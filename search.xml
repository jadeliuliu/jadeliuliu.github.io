<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go-channel</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-channel/</url>
    <content><![CDATA[<h3 id="1-channel简介"><a href="#1-channel简介" class="headerlink" title="1.channel简介"></a>1.channel简介</h3><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>它的操作符是箭头 <strong>&lt;-</strong> 。用来协程间传递数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    // 发送值v到Channel ch中</span><br><span class="line">v := &lt;-ch  // 从Channel ch中接收数据，并将数据赋值给v</span><br><span class="line">ch := make(chan int, 100)  //容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。</span><br><span class="line">如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</span><br><span class="line">close(ch)  //关闭channel</span><br></pre></td></tr></table></figure>

<p>无缓冲阻塞场景：1.没有协程在写却读   2.没有协程在读却写</p>
<p>有缓冲阻塞场景：1.缓冲中无数据却读  2.缓冲已满却写</p>
<p>无缓冲的channel，不管是入还是出，都会阻塞，所以在同一个goroutine中，不能同时对同一个无缓冲channel进行入和出操作；</p>
<p>带缓冲的channel，在队列满之前，不会阻塞；队列满之后，依然会阻塞。</p>
<h3 id="2-应用1：作为一个FIFO队列"><a href="#2-应用1：作为一个FIFO队列" class="headerlink" title="2.应用1：作为一个FIFO队列"></a>2.应用1：作为一个FIFO队列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//用channel实现队列，查看是否原子性</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ch))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(ch))</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++&#123;</span><br><span class="line">    	ch &lt;- i+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">30</span>)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">30</span>; j++&#123;</span><br><span class="line">		<span class="keyword">go</span> get(&amp;ch, &amp;wg, &amp;err)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:     <span class="comment">//失败返回</span></span><br><span class="line">	    fmt.Println(<span class="string">&quot;no number&quot;</span>)</span><br><span class="line">		*err = errors.New(<span class="string">&quot;channel has no data&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-应用2：实现类似sync-WaitGroup的同步"><a href="#3-应用2：实现类似sync-WaitGroup的同步" class="headerlink" title="3.应用2：实现类似sync.WaitGroup的同步"></a>3.应用2：实现类似sync.WaitGroup的同步</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//用sleep实现定时器</span></span><br><span class="line">	fmt.Println(time.Now())</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(time.Now())</span><br><span class="line">	<span class="comment">//用timer实现定时器</span></span><br><span class="line">	timer := time.NewTimer(time.Second)</span><br><span class="line">	fmt.Println(&lt;-timer.C)</span><br><span class="line">	<span class="comment">//用after实现定时器</span></span><br><span class="line">	fmt.Println(&lt;-time.After(time.Second))</span><br><span class="line">	<span class="comment">//周期定时</span></span><br><span class="line">	tiker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++&#123;</span><br><span class="line">			fmt.Println(&lt;-tiker.C)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;------------------&quot;</span>)</span><br><span class="line">	<span class="comment">//定时完成的操作写在协程里</span></span><br><span class="line">	ticker := time.NewTicker(time.Second * <span class="number">3</span>)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">//该channel完成同步，实现下面的协程执行完主线程才结束</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> x &lt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				x++</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, x)</span><br><span class="line">				fmt.Println(time.Now())</span><br><span class="line">				time.Sleep(time.Second * <span class="number">1</span>)  <span class="comment">//case里的操作不要超过定时时间，不然会不符合预期</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ticker.Stop()</span><br><span class="line">		ch &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//这里的channel 实现了一个 sync.WaitGroup的效果，主进程直接到&lt;-ch，无拥塞channel，里面没东西，直接拿是会阻塞的，直到里面有东西</span></span><br><span class="line"><span class="comment">//也就是上面协程里的10次定时都结束，往channel写一个东西，就终止阻塞，使程序结束</span></span><br><span class="line"><span class="comment">// ch := make(chan int)  和   ch := make(chan int， 1) 理解：</span></span><br><span class="line"><span class="comment">// 有1的缓冲channel，一个协程写入拿到这个数，其他再拿都拿不到，配合select，拿不到就走，那个协程执行完操作之后，再往里写个数，其他协程就可以拿了。</span></span><br><span class="line"><span class="comment">//其实不管是有缓冲还是无缓冲，单纯用都会阻塞，无非是有一个buffer</span></span><br><span class="line"><span class="comment">//但是，加上select，都可以实现不拥塞，直接过。</span></span><br></pre></td></tr></table></figure>

<h3 id="4-应用3：搭配select实现锁效果"><a href="#4-应用3：搭配select实现锁效果" class="headerlink" title="4.应用3：搭配select实现锁效果"></a>4.应用3：搭配select实现锁效果</h3><p>mutex实现的锁：拥塞的，一个获锁，其他需要一直等待，直到上一个操作释放，再执行操作</p>
<p>channel实现的锁：可以选择拥塞不拥塞，得不到可以直接放弃，也可以等待一段时间执行其他操作。</p>
<p>搭配select 实现的是io操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//实现初始化一台实例的锁，不同appid都可以更新map</span></span><br><span class="line"><span class="comment">//实现channle的拥塞锁</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> get_blockf(&amp;ch, &amp;wg, &amp;err)  <span class="comment">//一直拥塞</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> get_block(&amp;ch, &amp;wg, &amp;err)  <span class="comment">//拥塞2s</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line">		<span class="keyword">go</span> get_noblock(&amp;ch, &amp;wg, &amp;err)  <span class="comment">//无拥塞</span></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_blockf</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Block get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		*ch &lt;-x+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_block</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Block 2s get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		*ch &lt;-x+<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(time.Second *<span class="number">20</span>):  <span class="comment">//等待过程中一直尝试，尝试成功即从ch取数，超时还取不到执行下面操作</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;no number&quot;</span>)</span><br><span class="line">		*err = errors.New(<span class="string">&quot;channel has no data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_noblock</span><span class="params">(ch *<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup, err *error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x := &lt;- *ch:   <span class="comment">//如果可以读出，就读</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Block 2s get number: %d, channel size: %d\n&quot;</span>, x, <span class="built_in">len</span>(*ch))</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		*ch &lt;-x+<span class="number">1</span></span><br><span class="line">	<span class="keyword">default</span>:       <span class="comment">//等待过程中一直尝试，尝试成功即从ch取数，超时还取不到执行下面操作</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;no number&quot;</span>)</span><br><span class="line">		*err = errors.New(<span class="string">&quot;channel has no data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-mutex锁</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-mutex%E9%94%81/</url>
    <content><![CDATA[<h3 id="Go语言里的Mutex和RwMutex"><a href="#Go语言里的Mutex和RwMutex" class="headerlink" title="Go语言里的Mutex和RwMutex"></a>Go语言里的Mutex和RwMutex</h3><p>共享锁(S锁)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。（多读/单写）</p>
<p>排他锁(X锁)又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。（单读/单写）</p>
<p>go里的mutex（普通锁）：全局互斥锁特性(不支持同时读)—-读写操作一样待遇 （类似于：只能加X锁，读写都是X锁）<br>sync.RWMutex：读写锁，支持单写多读特性。—-读写操作不同待遇  （类似于：分两种Lock排他锁，RLock共享锁）</p>
<p>意思是：RWMutex是完全可以实现mutex的功能的，而RWMtex可以实现同时读。</p>
<ul>
<li>func (m *Mutex) Lock()<br>Lock⽅法锁住m，如果m已经加锁，则阻塞直到m解锁。</li>
<li>func (m *Mutex) Unlock()<br>Unlock⽅法解锁m，如果m未加锁会导致运⾏时错误。锁和线程无关，可以由不同的线程加锁和解锁。</li>
</ul>
<p>1.mutex无法实现分布式，多个请求怎么共享一个公共变量？</p>
<p>2.除非分布式请求，共享 sync.RWMutex 变量</p>
<h3 id="Mutex使用"><a href="#Mutex使用" class="headerlink" title="Mutex使用"></a>Mutex使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 共享变量</span><br><span class="line">var (</span><br><span class="line">	m  sync.Mutex</span><br><span class="line">	v1 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 修改共享变量</span><br><span class="line">// 在Lock()和Unlock()之间的代码部分是临界区</span><br><span class="line">func change(i int, m *sync.Mutex) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	v1 = v1 + 1</span><br><span class="line">	fmt.Printf(&quot;Write %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func read(i int, m *sync.Mutex) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	fmt.Printf(&quot;Read %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var numGR = 10</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; numGR; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			change(i, &amp;m)</span><br><span class="line">			read(i, &amp;m)     //读和写都不会同时进行</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RWMutex使用"><a href="#RWMutex使用" class="headerlink" title="RWMutex使用"></a>RWMutex使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 共享变量</span><br><span class="line">var (</span><br><span class="line">	m  sync.RWMutex</span><br><span class="line">	v1 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 修改共享变量</span><br><span class="line">// 在Lock()和Unlock()之间的代码部分是临界区</span><br><span class="line">func change(i int, m *sync.RWMutex) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	v1 = v1 + 1</span><br><span class="line">	fmt.Printf(&quot;Write %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func read(i int, m *sync.RWMutex) &#123;</span><br><span class="line">	m.RLock()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	v1 = v1 + 1</span><br><span class="line">	fmt.Printf(&quot;Read %dth time, v1:%d.\n&quot;, i, v1)</span><br><span class="line">	m.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var numGR = 10000</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; numGR; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">		//	change(i, &amp;m)</span><br><span class="line">			read(i, &amp;m)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：并发量不高的情况下，如100，发现用共享锁获得的数据是完全没重复的，像是互斥锁的效果。但是只是并发量不高，10000并发量，共享锁的效果就提现出来了。猜测：for循环间隔时间大于自增时间了？？盲猜</p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-函数结束协程结束吗</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E5%87%BD%E6%95%B0%E7%BB%93%E6%9D%9F%E5%8D%8F%E7%A8%8B%E7%BB%93%E6%9D%9F%E5%90%97/</url>
    <content><![CDATA[<h3 id="结论为先"><a href="#结论为先" class="headerlink" title="结论为先"></a>结论为先</h3><p> 在main或其他函数中开协程，主程序结束了，协程还继续执行吗?</p>
<p> 结论：main函数中的协程，如果main结束了，协程也会结束</p>
<pre><code>  其他函数里的协程，函数结束了，只要main没结束，协程就会执行。
</code></pre>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">	time.Sleep(time.Second*<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定时完成的操作写在协程里</span></span><br><span class="line">	ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">	<span class="comment">//ch := make(chan int)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> x &lt; <span class="number">10</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				x++</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ticker.Stop()</span><br><span class="line">		<span class="comment">//ch &lt;- 0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//&lt;- ch</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-实现一个队列queue</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97queue/</url>
    <content><![CDATA[<h2 id="go容器"><a href="#go容器" class="headerlink" title="go容器"></a>go容器</h2><p>*解引用  &amp;取地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//数组</span></span><br><span class="line">	<span class="comment">//var nums [5]int  //不初始化</span></span><br><span class="line">	<span class="keyword">var</span> nums = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++&#123;</span><br><span class="line">		fmt.Println(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切片slice</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> slice[]<span class="keyword">int</span>  <span class="comment">//切片不需要说明长度 ==nil为空</span></span><br><span class="line">    slice = <span class="built_in">append</span>(slice, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//可以不用make</span></span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">    <span class="keyword">var</span> slice1 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>) <span class="comment">//长度10，容量20</span></span><br><span class="line">	fmt.Println(slice1)  <span class="comment">//输出为10个0</span></span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> slice&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;slice[%d]=%d\t&quot;</span>, i, num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> slice2 = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="built_in">copy</span>(slice2, slice1)</span><br><span class="line">	fmt.Println(slice2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;---------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map</span></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>    <span class="comment">//声明，默认是nil</span></span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)  <span class="comment">//创建</span></span><br><span class="line">	<span class="comment">//或者一步到位： m := make(map[int]string)</span></span><br><span class="line">	m[<span class="number">1</span>] = <span class="string">&quot;two&quot;</span></span><br><span class="line">	m[<span class="number">1</span>] =<span class="string">&quot;one&quot;</span>  <span class="comment">//覆盖掉</span></span><br><span class="line">	m[<span class="number">2</span>] =<span class="string">&quot;two&quot;</span></span><br><span class="line">	m[<span class="number">3</span>] =<span class="string">&quot;three&quot;</span></span><br><span class="line">	value, ok :=m [<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(m,<span class="number">1</span>)  <span class="comment">//删除</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key:%d, value:%s\t&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list双向链表</span></span><br><span class="line">	li := list.New()  <span class="comment">//元素类型为接口类型，什么都能存</span></span><br><span class="line">	li.PushBack(<span class="number">1</span>)  <span class="comment">// 追加元素到末尾</span></span><br><span class="line">	li.PushBack(<span class="number">2</span>)</span><br><span class="line">	li.PushBack(<span class="number">3</span>)</span><br><span class="line">	zero := li.PushFront(<span class="number">0</span>)  <span class="comment">//添加元素在开头</span></span><br><span class="line">	li.InsertAfter(<span class="number">0.5</span>, zero)</span><br><span class="line">	<span class="keyword">for</span> e := li.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		fmt.Println(e.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个队列queue并加锁"><a href="#实现一个队列queue并加锁" class="headerlink" title="实现一个队列queue并加锁"></a>实现一个队列queue并加锁</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//切片实现固定长度队列，并加锁</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个结构体管理队列</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxSize <span class="keyword">int64</span></span><br><span class="line">	array []<span class="keyword">int64</span> <span class="comment">//数组=&gt;模拟队列</span></span><br><span class="line">	front  <span class="keyword">int64</span> <span class="comment">//表示指向队列列首</span></span><br><span class="line">	rear <span class="keyword">int64</span> <span class="comment">//表示指向队列的尾部</span></span><br><span class="line">	flag <span class="keyword">bool</span> <span class="comment">//表示队尾是否在对头后面</span></span><br><span class="line">	mut *sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现结构体初始化有默认值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">(max <span class="keyword">int64</span>)</span> <span class="title">Queue</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Queue&#123;</span><br><span class="line">		maxSize: max,</span><br><span class="line">		array: <span class="built_in">make</span>([]<span class="keyword">int64</span>, max),</span><br><span class="line">		front:   <span class="number">0</span>,</span><br><span class="line">		rear:    <span class="number">-1</span>,</span><br><span class="line">		flag: <span class="literal">true</span>,</span><br><span class="line">		mut: &amp;sync.Mutex&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">AddQueue</span><span class="params">(val <span class="keyword">int64</span>)</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line">	this.mut.Lock()</span><br><span class="line">	<span class="keyword">defer</span> this.mut.Unlock()</span><br><span class="line">	<span class="comment">//先判断队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> this.IsFull()&#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;queue full&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.rear++<span class="comment">//rear 后移</span></span><br><span class="line">	<span class="keyword">if</span> this.rear == this.maxSize&#123;</span><br><span class="line">		this.rear = <span class="number">0</span></span><br><span class="line">		this.flag = !this.flag</span><br><span class="line">	&#125;</span><br><span class="line">	this.array[this.rear] = val</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从队列中取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">GetQueue</span><span class="params">()</span> <span class="params">(val <span class="keyword">int64</span>, err error)</span></span>&#123;</span><br><span class="line">	this.mut.Lock()</span><br><span class="line">	<span class="keyword">defer</span> this.mut.Unlock()</span><br><span class="line">	<span class="comment">//先判断队列是否空</span></span><br><span class="line">	<span class="keyword">if</span> this.IsEmpty() &#123;<span class="comment">//队空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">&quot;queue empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	val = this.array[this.front]</span><br><span class="line">	this.front++</span><br><span class="line">	<span class="keyword">if</span> this.front == this.maxSize&#123;</span><br><span class="line">		this.front = <span class="number">0</span></span><br><span class="line">		this.flag = !this.flag</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (this.flag == <span class="literal">true</span> &amp;&amp; this.rear == this.front<span class="number">-1</span>) || (this.flag == <span class="literal">false</span> &amp;&amp; this.front == <span class="number">0</span> &amp;&amp; this.rear == this.maxSize<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (this.flag == <span class="literal">true</span> &amp;&amp; this.front == <span class="number">0</span> &amp;&amp; this.rear == this.maxSize<span class="number">-1</span>) || (this.flag == <span class="literal">false</span> &amp;&amp; this.rear == this.front<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求队列中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">QueueSize</span><span class="params">()</span> <span class="title">int64</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> this.flag == <span class="literal">false</span> &amp;&amp; this.front == <span class="number">0</span> &amp;&amp; this.rear == this.maxSize<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> this.flag == <span class="literal">true</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this.rear-this.front+<span class="number">1</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this.maxSize-(this.front-this.rear<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示队列,找到队首，然后到遍历到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span> <span class="title">ShowQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	size := this.QueueSize()</span><br><span class="line">	front := this.front</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int64</span>(<span class="number">1</span>) ; i &lt;= size; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,this.array[front])</span><br><span class="line">		front++</span><br><span class="line">		<span class="keyword">if</span> front == this.maxSize&#123;</span><br><span class="line">			front =<span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//先创建一个队列</span></span><br><span class="line">	max := <span class="keyword">int64</span>(<span class="number">50</span>)</span><br><span class="line">	queue := NewQueue(max)</span><br><span class="line">	queue.ShowQueue()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">50</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="number">50</span>; i++ &#123;</span><br><span class="line">		queue.AddQueue(<span class="keyword">int64</span>(i))</span><br><span class="line">	&#125;</span><br><span class="line">	queue.ShowQueue()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="number">50</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			out, err :=queue.GetQueue()</span><br><span class="line">			log.Println(err, queue.QueueSize(), <span class="string">&quot;out:&quot;</span>, out)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	queue.ShowQueue()</span><br><span class="line">	fmt.Println(queue.QueueSize())</span><br><span class="line">	fmt.Println(queue.GetQueue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-操作mysql数据库</title>
    <url>/2021/08/20/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="1-mysql原始命令"><a href="#1-mysql原始命令" class="headerlink" title="1.mysql原始命令"></a>1.mysql原始命令</h2><h3 id="a-登录"><a href="#a-登录" class="headerlink" title="a.登录"></a>a.登录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">登录：</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p密码  <span class="operator">/</span><span class="operator">/</span>连本机的</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span>, Host, Password <span class="keyword">FROM</span> mysql.user;  <span class="operator">/</span><span class="operator">/</span>查看用户</span><br><span class="line"></span><br><span class="line">添加新用户：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">修改密码：</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span><span class="operator">=</span>password(<span class="string">&#x27;1998&#x27;</span>);</span><br><span class="line">为用户授权：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许访问所有数据库下的所有表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定数据库下的指定表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> test.test <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>只拥有查询权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;  <span class="operator">/</span><span class="operator">/</span>刷新权限</span><br><span class="line"></span><br><span class="line">删除用户：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> liuxuan<span class="variable">@localhost</span>；</span><br><span class="line"></span><br><span class="line">连接远程数据库：</span><br><span class="line">MySQL 连接远程数据库（<span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span>），端口“<span class="number">3306</span>”，用户名为“root”，密码“<span class="number">123456</span>”</span><br><span class="line">mysql <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span> <span class="operator">-</span>P <span class="number">3306</span> <span class="operator">-</span>u root <span class="operator">-</span>p123456</span><br><span class="line">mysql <span class="operator">-</span>h ip <span class="operator">-</span>P 端口 <span class="operator">-</span>A <span class="operator">-</span>u name  <span class="operator">-</span>p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database name</span><br></pre></td></tr></table></figure>

<h3 id="b-建表"><a href="#b-建表" class="headerlink" title="b.建表"></a>b.建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `mytable`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `app_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;应用id&#x27;,</span><br><span class="line">   `time` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;时间&#x27;,</span><br><span class="line">   `date` DATE,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">   UNIQUE KEY `idx_app` (`app_id`) USING BTREE</span><br><span class="line">   KEY `idx_ip` (`machine_ip`) USING BTREE,</span><br><span class="line">   KEY `idx_app_machineid` (`app_id`,`machine_id`) USING BTREE</span><br><span class="line">)ENGINE=InnoDB DEFAULT COMMENT=&#x27;表名&#x27;;</span><br><span class="line"></span><br><span class="line">AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</span><br><span class="line">PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</span><br><span class="line">ENGINE 设置存储引擎，CHARSET 设置编码。</span><br><span class="line"></span><br><span class="line">表结构：desc name；</span><br><span class="line">建表语句：show create tablename；</span><br></pre></td></tr></table></figure>

<p>注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：comment</span><br><span class="line">create table test1 ( </span><br><span class="line">    field_name int comment &#x27;字段的注释&#x27; </span><br><span class="line">)comment=&#x27;表的注释&#x27;;</span><br><span class="line">修改表的注释：</span><br><span class="line">alter table test1 comment &#x27;修改后的表的注释&#x27;;</span><br><span class="line">修改字段的注释：</span><br><span class="line">alter table test1 modify column field_name int comment &#x27;修改后的字段注释&#x27;; </span><br><span class="line">查看表注释：</span><br><span class="line">show  create  table  test1; </span><br><span class="line">查看字段注释：</span><br><span class="line">show  full  columns  from  test1; </span><br></pre></td></tr></table></figure>

<p>索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唯一索引：</span><br><span class="line">UNIQUE KEY</span><br><span class="line">1  主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</span><br><span class="line">2  主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。</span><br><span class="line">3   唯一性索引列允许空值， 而主键列不允许为空值。</span><br><span class="line">4   主键可以被其他表引用为外键，而唯一索引不能。</span><br><span class="line">5   一个表最多只能创建一个主键，但是可以创建多个唯一索引。</span><br><span class="line">6   主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。</span><br><span class="line">7   在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。</span><br></pre></td></tr></table></figure>

<h3 id="c-添加一个字段"><a href="#c-添加一个字段" class="headerlink" title="c.添加一个字段"></a>c.添加一个字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tablename add `app_name` varchar(16) NOT NULL DEFAULT &#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="d-修改数据"><a href="#d-修改数据" class="headerlink" title="d.修改数据"></a>d.修改数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tablename set 字段=&#x27;修改的值&#x27; where 条件；</span><br><span class="line">多个字段中间加,</span><br></pre></td></tr></table></figure>

<h3 id="e-删除"><a href="#e-删除" class="headerlink" title="e.删除"></a>e.删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删库：drop database name;</span><br><span class="line">删表：drop table name；</span><br><span class="line"></span><br><span class="line">mysql删除一行：</span><br><span class="line">delete from 表 where 条件；</span><br></pre></td></tr></table></figure>

<h3 id="f-添加一行"><a href="#f-添加一行" class="headerlink" title="f.添加一行"></a>f.添加一行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tablename (app_id,machine_id,machine_ip,ctime,use_perc) values(?,?,?,?,?);   //对应字段加</span><br><span class="line"></span><br><span class="line">insert into 表名 values(int,&#x27;string&#x27;)(..);  //可一次性加多行，一行全部数都有</span><br><span class="line"></span><br><span class="line">insert into 表名 set 列名=&#x27;&#x27;, ...;</span><br></pre></td></tr></table></figure>

<h2 id="2-go操作数据库"><a href="#2-go操作数据库" class="headerlink" title="2.go操作数据库"></a>2.go操作数据库</h2><p>使用：database/sql包</p>
<p>mysql默认端口号3306</p>
<p>查看：mysql内，<code>show global variables like &#39;port&#39;; </code></p>
<p>查看mysql配置文件目录：</p>
<p><code>mysql --help|grep &#39;my.cnf&#39;</code></p>
<h3 id="a-创建连接池"><a href="#a-创建连接池" class="headerlink" title="a.创建连接池"></a>a.创建连接池</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建连接池</span><br><span class="line">func newPool() *sql.DB &#123;  //sql.DB 表示一个连接池</span><br><span class="line">	cfg := mysql.NewConfig()</span><br><span class="line">	cfg.User = &quot;name&quot;</span><br><span class="line">	cfg.Passwd = &quot;123456&quot;</span><br><span class="line">	cfg.Net = &quot;tcp&quot;</span><br><span class="line">	cfg.Addr = &quot;127.0.0.1:3306&quot;</span><br><span class="line">	cfg.DBName = &quot;mydb&quot;</span><br><span class="line">	dsn := cfg.FormatDSN()</span><br><span class="line"></span><br><span class="line">	db, err := sql.Open(&quot;mysql&quot;, dsn)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	if err := db.Ping(); err != nil &#123; //ping测试网络连通性及用户密码是否正确</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-query查询"><a href="#b-query查询" class="headerlink" title="b.query查询"></a>b.query查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func QueryUser(id int64) (*User, error) &#123;</span><br><span class="line">  var db = newPool()  //创建连接</span><br><span class="line">	rows, err := db.Query(&quot;select `id`, `name` from `users` where `id` = ?&quot;, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	defer rows.Close() // 注意这里，一定要关闭</span><br><span class="line">	user := User&#123;&#125;</span><br><span class="line">	for rows.Next() &#123;</span><br><span class="line">		if err := rows.Scan(&amp;user.ID, &amp;user.Name); err != nil &#123;</span><br><span class="line">			return nil, err</span><br><span class="line">		&#125;</span><br><span class="line">		break</span><br><span class="line">	&#125;</span><br><span class="line">	if err := rows.Err(); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;user, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接池对程序员是透明的，这里并不需要显式的从连接池里获取连接，而是通过连接池来执行查询语句。<br>Query 方法返回一个 *Rows 指针，代表结果集。</p>
<p>要注意的是 defer rows.Close() 如果忘了关闭，可能会造成连接泄露。</p>
<p>rows.Scan 方法有个方便的特性，如果id在数据库里是 varchar(50) 类型，我们传的参数&amp;user.ID指向int64，这依然可以工作，Scan 方法会执行自动转换。</p>
<h3 id="c-单行查询queryrow"><a href="#c-单行查询queryrow" class="headerlink" title="c.单行查询queryrow"></a>c.单行查询queryrow</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// QueryUser1 单行查询</span><br><span class="line">func QueryUser1(id int64) (*User, error) &#123;</span><br><span class="line">	row := pool.QueryRow(&quot;select `id`, `name` from `users` where `id` = ?&quot;, id)</span><br><span class="line">	user := User&#123;&#125;</span><br><span class="line">	if err := row.Scan(&amp;user.ID, &amp;user.Name); err != nil &#123;</span><br><span class="line">		if err == sql.ErrNoRows &#123;</span><br><span class="line">			return nil, nil  // 返回 (*User)(nil) 表示查询结果不错在</span><br><span class="line">		&#125;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;user, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-插入更新删除exec"><a href="#d-插入更新删除exec" class="headerlink" title="d.插入更新删除exec"></a>d.插入更新删除exec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// InsertUser 插入用户</span><br><span class="line">func InsertUser(name string) (int64, error) &#123;</span><br><span class="line">	res, err := pool.Exec(&quot;insert into `users` (`name`) values (?)&quot;, name)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return 0, err</span><br><span class="line">	&#125;</span><br><span class="line">	return res.LastInsertId()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// UpdateUser 更新用户</span><br><span class="line">func UpdateUser(id int64, name string) error &#123;</span><br><span class="line">	_, err := pool.Exec(&quot;update `users` set `name` = ? where `id` = ?&quot;, name, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// DeleteUser 删除用户</span><br><span class="line">func DeleteUser(id int64) error &#123;</span><br><span class="line">	_, err := pool.Exec(&quot;delete from `users` where `id` = ?&quot;, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="e-事务"><a href="#e-事务" class="headerlink" title="e.事务"></a>e.事务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// UpdateFooBar 更新</span><br><span class="line">func UpdateFooBar(id int64, x, y string) (err error) &#123;</span><br><span class="line">	tx, err := pool.Begin()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		switch &#123;</span><br><span class="line">		case err != nil:</span><br><span class="line">			tx.Rollback()</span><br><span class="line">		default:</span><br><span class="line">			err = tx.Commit()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	_, err = tx.Exec(&quot;update `foo` set `x` = ? where `id` = ?&quot;, x, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = tx.Exec(&quot;update `bar` set `y` = ? where `id` = ?&quot;, y, id)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-mysql加锁"><a href="#3-mysql加锁" class="headerlink" title="3.mysql加锁"></a>3.mysql加锁</h2><p>读锁全表锁(LOCK TABLE 表 READ)<br>读锁行锁(SELECT … LOCK IN SHARE MODE)<br>写锁全表锁(LOCK TABLE 表 WRITE)<br>写锁行锁(SELECT … FOR UPDATE)</p>
<p>锁总体可以分为乐观锁和悲观锁，简单说，乐观锁用版本号控制，悲观锁用锁控制。<br>乐观锁：核心原理是增加一个version的字段来控制。添加一个version字段，每个更新时where条件都加上它，并且也更新它UPDATE users SET name=”雪山飞猪”,version=version+1 WHERE id=3 AND version=0 UPDATE users SET name=”chenqionghe”,version=version+1 WHERE id=3 AND version=0。这就是最简单的CAS机制。<br>悲观锁：类似Go语言里的Mutex和RwMutex</p>
<p>共享锁(S锁)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p>
<p>排他锁(X锁)又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写锁表锁：</span><br><span class="line">加锁：lock table kiss_share_idproducer write;</span><br><span class="line">此时其他进程无法读也无法写。</span><br><span class="line">解锁：unlock table;</span><br><span class="line">--------------------------------</span><br><span class="line">写锁行锁：</span><br><span class="line">begin;</span><br><span class="line">加锁：select * from  kiss_share_idproducer where app_id=21 for update;</span><br><span class="line">其他再加锁，等待，直到占锁的commit；</span><br><span class="line">更新：update kiss_share_idproducer set mix_id=7 where app_id=21;</span><br><span class="line">解锁：commit;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读锁表锁：</span><br><span class="line">加锁：lock table kiss_share_idproducer read;</span><br><span class="line">此时其他进程可以读但无法写。</span><br><span class="line">解锁：unlock table;</span><br><span class="line">-------------------------------</span><br><span class="line">读锁行锁：</span><br><span class="line">加锁：select * from  kiss_share_idproducer where app_id=21 lock in share mode;</span><br><span class="line">其他再加锁，等待，直到占锁的commit；</span><br><span class="line">更新：update kiss_share_idproducer set mix_id=7 where app_id=21;</span><br><span class="line">解锁：commit;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>go的mysql操作：<a href="https://blog.csdn.net/embinux/article/details/84031620">https://blog.csdn.net/embinux/article/details/84031620</a></p>
<p>mysql加锁：<a href="https://blog.csdn.net/weixin_33838871/article/details/113566444">https://blog.csdn.net/weixin_33838871/article/details/113566444</a></p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-获取本机id</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip/</url>
    <content><![CDATA[<p>~~~<br>package main</p>
<p>import (<br>    “fmt”<br>    “net”<br>)</p>
<p>func main() {<br>    netInterfaces, err := net.Interfaces()<br>    if err != nil {<br>        fmt.Println(“net.Interfaces failed, err:”, err.Error())<br>    }<br>    for i := 0; i &lt; len(netInterfaces); i++ {<br>        if (netInterfaces[i].Flags &amp; net.FlagUp) != 0 {<br>            addrs, _ := netInterfaces[i].Addrs()</p>
<pre><code>        for _, address := range addrs &#123;
            if ipnet, ok := address.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() &#123;
                if ipnet.IP.To4() != nil &#123;
                    fmt.Println(ipnet.IP.String())
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记-go入门1.0</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-go%E5%85%A5%E9%97%A81.0/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言在多核并发上拥有原生的设计优势，兼顾性能和开发效率</span><br><span class="line">号称：Python的开发速度，C/C++的性能和安全</span><br><span class="line">php迁<span class="keyword">go</span>属于大的架构调整，从架构角度  个人认为<span class="keyword">go</span>符合，简单、合适的原则</span><br><span class="line"><span class="number">1</span>、架构设计的主要目的</span><br><span class="line">是为了解决软件系统复杂度带来的问题</span><br><span class="line"><span class="number">2</span>、系统复杂度的主要来源</span><br><span class="line">高性能、高可用、可扩展性、低成本、安全、规模</span><br><span class="line"><span class="number">3</span>、架构设计三原则</span><br><span class="line">合适原则、简单原则、演化原则</span><br><span class="line"></span><br><span class="line">菜鸟教程：https:<span class="comment">//www.runoob.com/go/go-tutorial.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>：开源、可靠高效、多核并发、编译型语言、<span class="number">2012</span>发布Go1稳定版本。</span><br><span class="line">特点：简洁、快读、安全、并行、有趣、开源、内存管理、数组安全、编译迅速</span><br><span class="line">适用：Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</span><br><span class="line">对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</span><br><span class="line"></span><br><span class="line">计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。</span><br><span class="line">除了OOP外，近年出现了一些小众的编程哲学，Go语言对这些思想亦有所吸收。例如，Go语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为代表的面向消息编程思想，支持goroutine和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go语言是一个非常现代化的语言，精小但非常强大。</span><br><span class="line">Go 语言最主要的特性：</span><br><span class="line">自动垃圾回收</span><br><span class="line">更丰富的内置类型</span><br><span class="line">函数多返回值</span><br><span class="line">错误处理</span><br><span class="line">匿名函数和闭包</span><br><span class="line">类型和接口</span><br><span class="line">并发编程</span><br><span class="line">反射</span><br><span class="line">语言交互性</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>安装 菜鸟方案</span><br><span class="line"><span class="number">1.</span>下载二进制安装包：https:<span class="comment">//golang.google.cn/dl/</span></span><br><span class="line">go1<span class="number">.16</span>.linux-amd64.tar.gz</span><br><span class="line">问题：.pkg和.tar.gz只是压缩方式的不同吗</span><br><span class="line"><span class="number">2.</span>解压安装包到目录</span><br><span class="line">tar -C /usr/local -xzf go1<span class="number">.4</span>.linux-amd64.tar.gz</span><br><span class="line"><span class="number">3.</span>添加PATH环境变量</span><br><span class="line">export PATH=$PATH:/usr/local/<span class="keyword">go</span>/bin</span><br><span class="line">MAC 系统下你可以使用 .pkg 结尾的安装包直接双击来完成安装，安装目录在 /usr/local/<span class="keyword">go</span>/ 下。</span><br><span class="line"></span><br><span class="line">问题：<span class="keyword">go</span>安装到哪？</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>安装 GDP2方案</span><br><span class="line"><span class="number">1.</span>配置环境变量</span><br><span class="line">建议把 <span class="keyword">go</span> 本身安装在 ~/sdk/ 目录下，如 ~/sdk/go1<span class="number">.16</span>。</span><br><span class="line">先设置环境变量（建议写入到 ~/.bash_profile 文件 ）？</span><br><span class="line">export GOBIN=$HOME/<span class="keyword">go</span>/bin  </span><br><span class="line">export PATH=$PATH:$GOBIN:$HOME/sdk/go1<span class="number">.16</span>/bin</span><br><span class="line">作用：</span><br><span class="line">后续使用 <span class="keyword">go</span> 命令安装的二进制程序都在 $HOME/<span class="keyword">go</span>/bin 目录里</span><br><span class="line">设置 $PATH以让 <span class="keyword">go</span> 和 使用 <span class="keyword">go</span> 安装的二进制程序能直接使用</span><br><span class="line"><span class="number">2.</span>安装：哪种方式安装？</span><br><span class="line">MAC直接安装：brew install <span class="keyword">go</span></span><br><span class="line">内网测试机deck环境安装：deck install <span class="keyword">go</span><span class="number">-1.16</span></span><br><span class="line">go1<span class="number">.13</span>开始的依赖管理工具Go Module</span><br><span class="line"></span><br><span class="line">问导师：直接安装pkg的，自动安装到一个目录，环境变量也不需要自己配了。然后学一下语法，可以在终端编译。装一下vscode。配一下Go module，镜像。</span><br><span class="line"></span><br><span class="line">brew是MacOS上的包管理工具，可以简化操作系统上软件的安装。</span><br><span class="line">brew是ruby开发的，需要确认ruby是否已安装，默认是已经安装的。</span><br><span class="line">which命令：查看安装路径</span><br><span class="line">安装brew：</span><br><span class="line">ruby -e <span class="string">&quot;$(curl -fsSL </span></span><br><span class="line"><span class="string">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span>  （没反应）</span><br><span class="line">另一条命令：</span><br><span class="line">/bin/zsh -c <span class="string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span></span><br><span class="line"></span><br><span class="line">（MAC安装和使用<span class="keyword">go</span>：https:<span class="comment">//www.jianshu.com/p/67dcf4e828e9）</span></span><br><span class="line">安装好了brew再<span class="keyword">go</span> version就有了。</span><br><span class="line"><span class="keyword">go</span> env 查看环境变量</span><br><span class="line">which <span class="keyword">go</span> 查看安装目录：/usr/local/<span class="keyword">go</span>/bin/<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span>的开发项目路径修改：  ？？</span><br><span class="line">export GOPATH=/Users/liuxuan14/work/go_project</span><br><span class="line"></span><br><span class="line">vim一个hello.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span> run hello.<span class="keyword">go</span> <span class="comment">//直接运行</span></span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">go</span> build hello.<span class="keyword">go</span> <span class="comment">//先编译</span></span><br><span class="line">./hello  <span class="comment">//运行编译文件 ./是运行的意思</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言结构：</span><br><span class="line"><span class="keyword">go</span>语言的基础组成：包声明、引入包、函数、变量、语句 &amp; 表达式、注释</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main  <span class="comment">//第一行，表明该文件属于main包，表示一个可独立执行的程序。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">//导包：fmt包实现格式化IO</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  <span class="comment">//init()函数？</span></span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">  <span class="comment">//在最后自动增加换行字符\n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：&#123;不能单独放在一行</span><br><span class="line"></span><br><span class="line">标识符（包括常量、变量、类型、函数名、结构字段等等）如果以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</span><br><span class="line"></span><br><span class="line">包结构，文件名与包名</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言基础语法：</span><br><span class="line">一行代表一个语句结束，无需；</span><br><span class="line">除非非要写在一行，用；人为区分</span><br><span class="line">标识符：第一个字符需要是字母或下划线不能是数字，不能是<span class="keyword">go</span>关键字，不能有运算符。</span><br><span class="line">字符串连接：fmt.Println(<span class="string">&quot;Google&quot;</span> + <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line"><span class="keyword">go</span>变量的申明必须使用空格隔开：</span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span>;</span><br><span class="line">fmt.</span><br><span class="line">Sprintf 格式化字符串并赋值给新串。</span><br><span class="line"><span class="keyword">var</span> stockcode=<span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> enddate=<span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line"><span class="keyword">var</span> url=<span class="string">&quot;Code=%d &amp; endDate=%s&quot;</span></span><br><span class="line"><span class="keyword">var</span> target_url=fmt.Sprintf(url,stockcode,enddate)</span><br><span class="line">fmt.Println(target_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>数据类型：</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span>=<span class="literal">true</span></span><br><span class="line">布尔型、数字类型、字符串类型、派生类型（指针、数组、结构化、channel、函数、切片、接口<span class="keyword">interface</span>、<span class="keyword">map</span>）</span><br><span class="line"><span class="keyword">uint8</span>（<span class="number">0</span><span class="number">-255</span>）<span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">int8</span>(<span class="number">-128</span><span class="number">-127</span>) </span><br><span class="line"><span class="keyword">float32</span>:<span class="number">32</span>位浮点数</span><br><span class="line"><span class="keyword">float64</span>：<span class="number">64</span>位浮点数</span><br><span class="line"><span class="keyword">complex64</span>：<span class="number">32</span>位实数和虚数</span><br><span class="line"><span class="keyword">byte</span> 类似<span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">rune</span> 类似<span class="keyword">int32</span></span><br><span class="line"><span class="keyword">uintptr</span> 无符号整型，用于存放一个指针。</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>变量：</span><br><span class="line"><span class="keyword">var</span> a,b <span class="keyword">type</span> <span class="comment">//一次定义两个变量</span></span><br><span class="line"><span class="keyword">var</span> b,c <span class="keyword">int</span>=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">fmt.Println(b,c)</span><br><span class="line">变量只声明但是不初始化，默认为零值。</span><br><span class="line">可以根据值自行判定变量类型。</span><br><span class="line">定义变量可省略<span class="keyword">var</span></span><br><span class="line">a:=<span class="number">1</span>  <span class="comment">//一定是需要定义新的变量，如果变量存在会编译错误。省略申明格式的写法只能在函数体中出现。</span></span><br><span class="line"><span class="keyword">var</span> a,b =<span class="number">1</span>,<span class="number">2</span> <span class="comment">//和python很像，不需要显示声明类型，自动判断。非全局变量</span></span><br><span class="line"><span class="keyword">var</span>（</span><br><span class="line">  a <span class="keyword">int</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">）  <span class="comment">//因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"></span><br><span class="line">值类型和引用类型</span><br><span class="line">值类型的变量的值存储在栈中。</span><br><span class="line">一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</span><br><span class="line">这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</span><br><span class="line">同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</span><br><span class="line">当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</span><br><span class="line">如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</span><br><span class="line"></span><br><span class="line"><span class="comment">//思考：在go中，引用类型中存放的是指针，指针相当于内存地址。用一个引用类型给另一个引用类型赋值，地址被赋值，地址一样，值变动，两个引用类型都指向这个修改后的内容。</span></span><br><span class="line"></span><br><span class="line">函数中如果你声明了一个局部变量却没有在相同的代码块中使用它，会编译错误。</span><br><span class="line">多个变量可以同时声明、初始化。</span><br><span class="line">_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>常量：</span><br><span class="line">常量是一个简单值的标识符，在程序运行时，不会被修改的量。</span><br><span class="line">常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</span><br><span class="line"><span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">常量还可用作枚举</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="literal">iota</span>：特殊常量，可以认为是一个可以被编译器修改的常量。</span><br><span class="line"><span class="literal">iota</span> 在 <span class="keyword">const</span>关键字出现时将被重置为 <span class="number">0</span>(<span class="keyword">const</span> 内部的第一行之前)，<span class="keyword">const</span> 中每新增一行常量声明将使 <span class="literal">iota</span> 计数一次(<span class="literal">iota</span> 可理解为 <span class="keyword">const</span> 语句块中的行索引)。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line">发现：下一行如果啥都没写的话，就跟上一行一样。</span><br><span class="line">左移&lt;&lt;n 相当于*（<span class="number">2</span>^n）</span><br><span class="line">fmt.Printf() 不会自动换行，需要\n</span><br><span class="line">fmt.Println() 会自动换行</span><br><span class="line">&amp;按位与</span><br><span class="line">|按位或</span><br><span class="line">^按位异或，不同为<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> 定义指针变量</span><br><span class="line">ptr=&amp;a  </span><br><span class="line">疑问：引用类型和指针类型？区别在哪</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">循环控制语句多一个：</span><br><span class="line"><span class="keyword">goto</span>语句：将控制转移到被标记的语句。</span><br><span class="line"><span class="built_in">len</span>()函数：返回该类型长度</span><br><span class="line">函数模板：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">多个返回值：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">指针和引用的理解：</span><br><span class="line">c++中：*解引用 &amp;取地址</span><br><span class="line"><span class="keyword">int</span> a,b,*p=&amp;a,&amp;r=a;<span class="comment">//正确</span></span><br><span class="line">r=<span class="number">3</span>;<span class="comment">//正确：等价于a=3</span></span><br><span class="line"><span class="keyword">int</span> &amp;rr;<span class="comment">//出错：引用必须初始化</span></span><br><span class="line">p=&amp;a;<span class="comment">//正确：p中存储a的地址，即p指向a</span></span><br><span class="line">*p=<span class="number">4</span>;<span class="comment">//正确：p中存的是a的地址，对a所对应的存储空间存入值4</span></span><br><span class="line">p=&amp;b<span class="comment">//正确：p可以多次赋值，p存储b的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>中：</span><br><span class="line">有的变量是引用类型，而不是叫变量的别名。指针可以赋值给引用类型，引用类型可以看做是对指针的封装。</span><br><span class="line">指针变量指向一个值的内存地址。</span><br><span class="line"><span class="keyword">go</span>语言中的值类型：</span><br><span class="line">　　<span class="keyword">int</span>、float、<span class="keyword">bool</span>、array、sturct等</span><br><span class="line">　　值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数</span><br><span class="line">　　声明一个值类型变量时，编译器会在栈中分配一个空间，空间里存储的就是该变量的值　　　　</span><br><span class="line"><span class="keyword">go</span>语言中的引用类型：</span><br><span class="line">　　slice，<span class="keyword">map</span>，channel，<span class="keyword">interface</span>，<span class="function"><span class="keyword">func</span>，<span class="title">string</span>等</span></span><br><span class="line">　　声明一个引用类型的变量，编译器会把实例的内存分配在堆上</span><br><span class="line">　　<span class="keyword">string</span>和其他语言一样，是引用类型，<span class="keyword">string</span>的底层实现<span class="keyword">struct</span> String &#123; <span class="keyword">byte</span>* str; intgo <span class="built_in">len</span>; &#125;; 但是因为<span class="keyword">string</span>不允许修改，每次操作<span class="keyword">string</span>只能生成新的对象，所以在看起来使用时像值类型。</span><br><span class="line">　　所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</span><br><span class="line">　　需要注意的是：引用类型在函数的内部可以对它的值进行修改，但是如果给形参重新赋值，重新赋值后的形参再怎么修改都不会影响外面的实参了</span><br><span class="line">　　<span class="literal">nil</span>可以赋值给引用类型（除<span class="keyword">string</span>外）、error类型和指针类型</span><br><span class="line"><span class="keyword">go</span>语言中的指针类型：</span><br><span class="line">　　一个指针变量指向了一个值的内存地址</span><br><span class="line"> 　 当一个指针被定义后没有分配到任何变量时，它的值为 <span class="literal">nil</span>。<span class="literal">nil</span> 指针也称为空指针</span><br><span class="line">　　一个指针变量通常缩写为 ptr</span><br><span class="line">　　其实引用类型可以看作对指针的封装</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PS.<span class="keyword">go</span>和C++中指针的区别：</span><br><span class="line">指针是用来指向任何一个变量的内存地址的类型变量，它所指向的变量的内存地址在 <span class="number">32</span> 和 <span class="number">64</span> 位机器上分别占用 <span class="number">4</span> 或者 <span class="number">8</span> 个字节，占用字节的大小与所指向的值的大小无关。</span><br><span class="line"><span class="number">1.</span>用法不同：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 一个整型变量a</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">string</span> = <span class="string">&quot;abcdefg&quot;</span> <span class="comment">// 一个字符串变量b</span></span><br><span class="line">    ptr:=&amp;b</span><br><span class="line">    <span class="comment">// 打印ptr的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ptr type: %T\n&quot;</span>, ptr)</span><br><span class="line">    <span class="comment">// 打印ptr的地址</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span>, ptr)</span><br><span class="line">    <span class="comment">//对指针进行取值</span></span><br><span class="line">    value：=*ptr</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p %p&quot;</span>, &amp;a, &amp;b) <span class="comment">// 分别输出a和b的地址</span></span><br><span class="line">&#125;</span><br><span class="line">--</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> a  = <span class="number">1</span>; <span class="comment">// 一个整型变量a</span></span><br><span class="line">    <span class="keyword">string</span> b  = <span class="string">&quot;abcdefg&quot;</span>; <span class="comment">// 一个字符串变量b</span></span><br><span class="line">    cout&lt;&lt; &amp;a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; &amp;b &lt;&lt;endl; <span class="comment">// 分别输出a和b的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>C++语言中可以直接对指针做算术运算（+、-、++、--），但是Golang中是不行的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用传递</span><br><span class="line">/* 定义交换值函数*/</span><br><span class="line">func swap(x *int, y *int) &#123;</span><br><span class="line">   var temp int</span><br><span class="line">   temp = *x    /* 保持 x 地址上的值 */</span><br><span class="line">   *x = *y      /* 将 y 值赋给 x */</span><br><span class="line">   *y = temp    /* 将 temp 值赋给 y */</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;a,&amp;b)</span><br><span class="line">和指针作为参数传递一模一样，一个更简洁的：</span><br><span class="line">func swap(x *int, y *int)&#123;</span><br><span class="line">    *x, *y = *y, *x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>函数用法：</span><br><span class="line"><span class="number">1.</span>可作为另一个函数的实参</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line">&#125;</span><br><span class="line">感觉像是在main函数中定义了一个函数，然后调用，不需要再main函数外定义。像是定义一个变量一样。</span><br><span class="line"><span class="number">2.</span>匿名函数，可作为闭包。</span><br><span class="line">内联在函数中，优越性在于可以直接使用函数内的变量，不必声明。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;  <span class="comment">//返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">像是给变量取别名，两次使用是独立的。</span><br><span class="line"><span class="number">3.</span>函数方法</span><br><span class="line">Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br><span class="line">--</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)</span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line">感觉把本来应该在函数名后面括号中的变量，也就是要传进去的变量放在了<span class="function"><span class="keyword">func</span>后的括号中。</span></span><br><span class="line">然后使用的时候像是使用c++中类的一个方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>变量作用域：</span><br><span class="line">Go 语言中变量可以在三个地方声明：</span><br><span class="line">函数内定义的变量称为局部变量（包括main函数）</span><br><span class="line">函数外定义的变量称为全局变量</span><br><span class="line">函数定义中的变量称为形式参数</span><br><span class="line">Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>数组</span><br><span class="line">val nums [<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line">val nums=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">nums:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">val nums=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">nums:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">3</span>&#125; <span class="comment">//只修改部分</span></span><br><span class="line">nums[<span class="number">0</span>]</span><br><span class="line">多维数组：</span><br><span class="line">nums:=[][]<span class="keyword">int</span>&#123;&#125;  <span class="comment">//创建</span></span><br><span class="line">row1:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">row2:=[]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">nums=<span class="built_in">append</span>(nums,row1) <span class="comment">//添加一行</span></span><br><span class="line">fmt.Println(nums[<span class="number">0</span>])  <span class="comment">//输出一行，有别于c++</span></span><br><span class="line">也可以直接输出二维数组nums</span><br><span class="line">初始化二维数组：</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   </span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   </span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,  </span><br><span class="line">&#125;  <span class="comment">//最后或者&#125;&#125;  也可以写在一行2</span></span><br><span class="line">作为函数参数传递：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言结构体</span><br><span class="line">结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</span><br><span class="line">结构体定义需要使用 <span class="keyword">type</span> 和 <span class="keyword">struct</span> 语句。<span class="keyword">struct</span> 语句定义一个新的数据类型，结构体中有一个或多个成员。<span class="keyword">type</span> 语句设定了结构体的名称。结构体的格式如下：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的结构体</span></span><br><span class="line">    fmt.Println(Books&#123;<span class="string">&quot;Go 语言&quot;</span>, <span class="string">&quot;www.runoob.com&quot;</span>, <span class="string">&quot;Go 语言教程&quot;</span>, <span class="number">6495407</span>&#125;)</span><br><span class="line">    <span class="comment">// 也可以使用 key =&gt; value 格式</span></span><br><span class="line">    fmt.Println(Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>, subject: <span class="string">&quot;Go 语言教程&quot;</span>, book_id: <span class="number">6495407</span>&#125;)</span><br><span class="line">    <span class="comment">// 忽略的字段为 0 或 空</span></span><br><span class="line">   fmt.Println(Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">定义结构体变量：</span><br><span class="line"><span class="keyword">var</span> BOOK1 Books</span><br><span class="line">访问结构体成员：</span><br><span class="line">BOOK1.title=<span class="string">&quot;go&quot;</span></span><br><span class="line">结构体作为函数参数：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title)</span><br><span class="line">&#125;</span><br><span class="line">调用函数：</span><br><span class="line"><span class="keyword">var</span> Book1 Books </span><br><span class="line">再访问结构体成员进行赋值</span><br><span class="line">printBook(Book1)</span><br><span class="line">结构体指针：</span><br><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br><span class="line">struct_pointer = &amp;Book1</span><br><span class="line">使用结构体指针访问结构体成员：</span><br><span class="line">struct_pointer.title</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言切片</span><br><span class="line">Go 语言切片是对数组的抽象。</span><br><span class="line">Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(<span class="string">&quot;动态数组&quot;</span>)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</span><br><span class="line">数组：</span><br><span class="line">val nums=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">nums:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">定义切片：</span><br><span class="line">可通过未指定大小的数组来定义切片：</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">或使用<span class="built_in">make</span>()函数来创建切片：</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line">s:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br><span class="line">容量<span class="built_in">cap</span>为可选参数</span><br><span class="line">定义+初始化切片：</span><br><span class="line">s:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s:=arr[:] <span class="comment">//arr为数组</span></span><br><span class="line">s:=arr[startIndex:endIndex]</span><br><span class="line">切片是可索引的，并且可以由 <span class="built_in">len</span>() 方法获取长度。</span><br><span class="line">切片提供了计算容量的方法 <span class="built_in">cap</span>() 可以测量切片最长可以达到多少。</span><br><span class="line">注：切片<span class="built_in">make</span>指定<span class="built_in">len</span>和<span class="built_in">cap</span>条件下，只定义没初始化的话，<span class="built_in">len</span>长度的数初始化为<span class="number">0</span>，而<span class="built_in">len</span>之外<span class="built_in">cap</span>之内还没有数。而只是定义的话，<span class="built_in">len</span>=<span class="number">0</span>，<span class="built_in">cap</span>=<span class="number">0</span></span><br><span class="line">一个切片未初始化之前（<span class="keyword">var</span> s[]<span class="keyword">int</span>）默认<span class="literal">nil</span>，长度为<span class="number">0</span></span><br><span class="line">切片可通过设置上下限来截取切片,左闭右开的</span><br><span class="line">s[<span class="number">0</span>:<span class="built_in">len</span>(s)] 全部</span><br><span class="line">s[<span class="number">1</span>:] 除了<span class="number">0</span></span><br><span class="line">如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</span><br><span class="line"><span class="built_in">append</span>()函数：增加切片内容：</span><br><span class="line"><span class="keyword">var</span> s[]<span class="keyword">int</span></span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="number">0</span>,<span class="number">1</span>)  可一次增加多个内容</span><br><span class="line">创建另一个切片</span><br><span class="line">s1:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(s),(<span class="built_in">cap</span>(s))*<span class="number">2</span>)</span><br><span class="line">拷贝s的内容到s1</span><br><span class="line"><span class="built_in">copy</span>(s1,s)</span><br><span class="line">疑问：<span class="keyword">go</span>语言中数组和切片的定义没有明确的区别？还是说[]中指定大小就是数组，[]中无数就是切片？</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言范围<span class="keyword">range</span>：</span><br><span class="line">Go 语言中 <span class="keyword">range</span> 关键字用于 <span class="keyword">for</span> 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(<span class="keyword">map</span>)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</span><br><span class="line"><span class="keyword">for</span> _,num:=<span class="keyword">range</span> nums&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,num:=<span class="keyword">range</span> nums&#123;&#125;</span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">    fmt.Println(i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</span><br><span class="line">Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</span><br><span class="line">可以使用内建函数 <span class="built_in">make</span> 也可以使用 <span class="keyword">map</span> 关键字来定义 Map:</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> <span class="comment">//声明变量，默认map是nil</span></span><br><span class="line">m=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>) <span class="comment">//如果不初始化，nil不能存放键值对</span></span><br><span class="line">或者：</span><br><span class="line">m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">1</span>]=<span class="string">&quot;liu&quot;</span> <span class="comment">//插入键值对</span></span><br><span class="line"><span class="keyword">for</span> i,s:=<span class="keyword">range</span> m&#123;  <span class="comment">//如果:前只有一个变量，那么就key</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;key:&quot;</span>,i,<span class="string">&quot;value:&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line">查看某个键i是不是存在值</span><br><span class="line">s,ok:=m[i]</span><br><span class="line"><span class="keyword">if</span>(ok)&#123;存在，是s&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;不存在&#125;</span><br><span class="line"><span class="built_in">delete</span>()删除元素：参数是原<span class="keyword">map</span>和要删除的key</span><br><span class="line"><span class="built_in">delete</span>(m,i)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言支持递归函数</span><br><span class="line"><span class="keyword">go</span>语言类型转换,<span class="keyword">go</span>不支持隐试转换类型</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span>=<span class="keyword">float32</span>(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>语言接口</span><br><span class="line">Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</span><br><span class="line">思考：有点类似C++的多态，在接口中定义一个方法，之后会给出不同的实现方式。向内传入的变量不同，方法的具体实现也不同。</span><br><span class="line">接口内的方法可以多个，传入的都是结构体变量？根据传入的结构体变量类型决定采用哪个方法。不同方法的输出可以不一样？每一种方法根据输入有很多种实现？</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;   <span class="comment">//实现error接口跟函数方法一样？</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone  <span class="comment">//定义接口变量</span></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)  <span class="comment">//为接口变量赋值，看方法的实现中要传入什么变量</span></span><br><span class="line">    phone.call()  <span class="comment">//跟函数方法一样的实现</span></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line">&#125;</span><br><span class="line">在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>错误处理</span><br><span class="line">Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</span><br><span class="line">error类型是一个接口类型，这是它的定义：</span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">我们可以在编码中通过实现 error 接口类型来生成错误信息。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">    dividee <span class="keyword">int</span></span><br><span class="line">    divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">            dData := DivideError&#123;</span><br><span class="line">                    dividee: varDividee,</span><br><span class="line">                    divider: varDivider,</span><br><span class="line">            &#125;   <span class="comment">//定义结构体</span></span><br><span class="line">            errorMsg = dData.Error()  <span class="comment">//使用方法</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当除数为零的时候会返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//条件语句</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Go 语言支持并发，我们只需要通过 <span class="keyword">go</span> 关键字来开启 goroutine 即可。</span><br><span class="line">goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</span><br><span class="line">Go 允许使用 <span class="keyword">go</span> 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">                time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">                fmt.Println(s)</span><br><span class="line">        &#125;   <span class="comment">//for循环语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">        say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;   </span><br><span class="line">输出的hello和world没有固定的先后顺序，因为它们是两个goroutine在执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">通道channel</span><br><span class="line">通道（channel）是用来传递数据的一个数据结构。</span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br><span class="line">创建通道：使用前必须要先创建</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">                sum += v</span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- sum <span class="comment">// 把 sum 发送到通道 c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">        <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">        x, y := &lt;-c, &lt;-c <span class="comment">// 从通道 c 中接收</span></span><br><span class="line">        fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line">思考：实现了一个数组分两部分，分别求和，把结果放入通道，从结果来看，通道像是一个栈？后进先出？不是，应该是由于goroutine没有先后顺序。感觉实际实现的是函数返回的问题，不加<span class="keyword">return</span>，把要返回的值放入通道中。这个用<span class="keyword">go</span>线程并行执行。</span><br><span class="line">疑问，如果函数有返回值，怎么用<span class="keyword">go</span>。</span><br><span class="line">默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。</span><br><span class="line">设置缓冲区：</span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)</span><br><span class="line">带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</span><br><span class="line">不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</span><br><span class="line">注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</span><br><span class="line">ch&lt;<span class="number">-1</span></span><br><span class="line">ch&lt;<span class="number">-2</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)  <span class="comment">//输出：1 2</span></span><br><span class="line"><span class="keyword">go</span>遍历通道和关闭通道：</span><br><span class="line">Go 通过 <span class="keyword">range</span> 关键字来实现遍历读取到的数据，类似于与数组或切片。</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line">如果通道接收不到数据后 ok 就为 <span class="literal">false</span>，这时通道就可以使用 <span class="built_in">close</span>() 函数来关闭。</span><br><span class="line">斐波那契数组：</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>环境配置问题：</span><br><span class="line">GOPATH 自己的<span class="keyword">go</span>语言工作目录，下有src存源码，bin存可执行文件，发布<span class="keyword">go</span> build时生成，pkg编译包，debug时生成的可执行文件，理解为中间文件。</span><br><span class="line">GOROOT是<span class="keyword">go</span>的安装目录</span><br><span class="line">要执行<span class="keyword">go</span>命令和<span class="keyword">go</span>工具，就必须将<span class="keyword">go</span>的可执行文件/usr/local/<span class="keyword">go</span>/bin添加到系统的PATH环境变量中。这样，无论在终端的任何路径，都可识别<span class="keyword">go</span>命令和<span class="keyword">go</span>相关工具。</span><br><span class="line">环境变量是为了告诉系统一个路径</span><br><span class="line">cd ~</span><br><span class="line">vim .bash_profile 中可配置环境变量</span><br><span class="line">source .bash_profile <span class="comment">//使配置生效</span></span><br><span class="line">GOBIN需要吗？</span><br><span class="line">export GOBIN=$GOPATH/bin</span><br><span class="line">事实证明 没有用</span><br><span class="line">export GOROOT=/usr/local/<span class="keyword">go</span></span><br><span class="line">export PATH=$PATH:$GOROOT/bin  <span class="comment">//已有，这个的作用要懂</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goland安装与激活：</span><br><span class="line">首先安装官方包，使用。</span><br><span class="line">下载压缩包得到jetbrains-agent-latest.zip</span><br><span class="line">打开IDE，将该zip拖入IDE窗口，激活即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">goland中左下角terminal可打开终端</span><br><span class="line">配置GOPATH，这一步非常重要，否则代码中的依赖包将无法识别。一般GOPATH都配置到项目名这一层</span><br><span class="line">配置教程：https:<span class="comment">//blog.csdn.net/zxy_666/article/details/80182688</span></span><br><span class="line">GOPATH是什么路径？？？</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">关于环境变量的理解：</span><br><span class="line">认为配置PATH是为了在终端的任何位置都可以识别<span class="keyword">go</span>命令和<span class="keyword">go</span>相关工具。</span><br><span class="line">配置GOPATH相当于是<span class="keyword">go</span>项目的一个工作目录。</span><br><span class="line">！！在终端中export配置是当前终端临时的，关闭无效？ 还是说goland的终端？</span><br><span class="line">所以在文件中配置。</span><br><span class="line">GOPATH 是 Go语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录。</span><br><span class="line">GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。</span><br><span class="line">在 GOPATH 指定的工作目录下，代码总是会保存在 $GOPATH/src 目录下。在工程经过 <span class="keyword">go</span> build、<span class="keyword">go</span> install 或 <span class="keyword">go</span> get 等指令后，会将产生的二进制可执行文件放在 $GOPATH/bin 目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。</span><br><span class="line">如果需要将整个源码添加到版本管理工具（Version Control System，VCS）中时，只需要添加 $GOPATH/src 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</span><br><span class="line"></span><br><span class="line">设置全局 GOPATH 的方法可能会导致当前项目错误引用了其他目录的 Go 源码文件从而造成编译输出错误的版本或编译报出一些无法理解的错误提示。</span><br><span class="line">因此，建议大家无论是使用命令行或者使用集成开发环境编译 Go 源码时，GOPATH 跟随项目设定。在 Jetbrains 公司的 GoLand 集成开发环境（IDE）中的 GOPATH 设置分为全局 GOPATH 和项目 GOPATH。</span><br><span class="line"></span><br><span class="line">Global GOPATH 代表全局 GOPATH，一般来源于系统环境变量中的 GOPATH；Project GOPATH 代表项目所使用的 GOPATH，该设置会被保存在工作目录的 .idea 目录下，不会被设置到环境变量的 GOPATH 中，但会在编译时使用到这个目录。建议在开发时只填写项目 GOPATH，每一个项目尽量只设置一个 GOPATH，不使用多个 GOPATH 和全局的 GOPATH。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遗留问题：</span><br><span class="line">gopath除了作为工作目录之外什么用处？</span><br><span class="line">编译为什么不会自动在bin目录下生成可执行文件？</span><br><span class="line">不设置gopath会怎样？</span><br><span class="line">gopath是为了什么？</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下vscode配置cpp环境</title>
    <url>/2021/08/23/myblog/cpp%E4%BF%AE%E7%82%BC/Mac%E4%B8%8Bvscode%E9%85%8D%E7%BD%AEcpp%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="1-安装vscode"><a href="#1-安装vscode" class="headerlink" title="1.安装vscode"></a>1.安装vscode</h3><h3 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2.插件安装"></a>2.插件安装</h3><p>安装“C/C++”、“C/C++ Clang Command Adapter”</p>
<h3 id="3-新建cpp文件"><a href="#3-新建cpp文件" class="headerlink" title="3.新建cpp文件"></a>3.新建cpp文件</h3><h3 id="4-配置1-c-cpp-properties-json"><a href="#4-配置1-c-cpp-properties-json" class="headerlink" title="4.配置1 c_cpp_properties.json"></a>4.配置1 c_cpp_properties.json</h3><p>按 <code>Command + Shift + P</code> 打开命令行面板，输入 <code>C/Cpp: Edit Configurations</code>命令<br>此时会在当前工作空间目录生成.vscode配置目录<br>同时在配置目录会生成一个c_cpp_properties.json文件</p>
<p>将要用到的库的路径添加到includePath数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Mac&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                        &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">                        &quot;/Library/Developer/CommandLineTools/usr/include/c++/v1&quot;,</span><br><span class="line">                        &quot;/usr/local/include&quot;,</span><br><span class="line">                        &quot;/Library/Developer/CommandLineTools/usr/include&quot;,</span><br><span class="line">                    ],</span><br><span class="line">            &quot;defines&quot;: [],</span><br><span class="line">            &quot;macFrameworkPath&quot;: [</span><br><span class="line">                &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++98&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;macos-clang-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-配置2-tasks-json"><a href="#5-配置2-tasks-json" class="headerlink" title="5.配置2 tasks.json"></a>5.配置2 tasks.json</h3><p>按 <code>Command + Shift + P</code> 打开命令行面板，输入 <code>tasks</code>，选择 <code>Tasks:Configure Task</code> 生成 <code>tasks.json</code> 配置文件，选择的模板为MSBuild</p>
<p>该文件其实就是一个命令行构建工具<br>把运行程序时在终端输入的命令和参数对于”command”和”args”的值<br>输入shift+command+b，便可构建成功，生成可执行文件a.out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">        &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">        &quot;tasks&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;label&quot;: &quot;c++&quot;,</span><br><span class="line">                &quot;command&quot;: &quot;clang++&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">                &quot;args&quot;: [</span><br><span class="line">                    &quot;main.cpp&quot;,</span><br><span class="line">                    &quot;-std=c++11&quot;,</span><br><span class="line">                    &quot;-g&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;presentation&quot;: &#123;</span><br><span class="line">                    &quot;echo&quot;: true,</span><br><span class="line">                    &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                    &quot;focus&quot;: false,</span><br><span class="line">                    &quot;panel&quot;: &quot;new&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="6-配置3-launch-json"><a href="#6-配置3-launch-json" class="headerlink" title="6.配置3 launch.json"></a>6.配置3 <strong>launch.json</strong></h3><p>如果需要对项目进行进行 <code>debug</code>，则需要先生成 <code>launch.json</code> 文件并对其做相应的配置</p>
<ul>
<li><p>按 <code>Command + Shift + D</code> 进入到运行界面</p>
</li>
<li><p>点击 <code>创建 launch.json 文件</code>，选择 <code>C++(GDB/LLDB)</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c/c++ Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/a.out&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;MIMode&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;:&quot;c++&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>![image-20210816193726334](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210816193726334.png)</p>
<h3 id="7-shift-command-b编译失败"><a href="#7-shift-command-b编译失败" class="headerlink" title="7.shift+command+b编译失败"></a>7.shift+command+b编译失败</h3><p>于VScode报错“终端将被任务重用，按任意键关闭”的解决方案：</p>
<p>原因是本地端口是被共享的，所以必须关闭一个进程才能执行另一个，只需要对 <code>tasks.json</code>文件做一些修改即可。</p>
<p>tasks.json里把”panel”=”shared”改成：”panel”=”new”</p>
<h3 id="8-如何运行？"><a href="#8-如何运行？" class="headerlink" title="8.如何运行？"></a>8.如何运行？</h3><p>输入shift+command+b，便可构建成功，生成可执行文件a.out</p>
<p>编译完成后，会在项目路径下生成 <code>main</code> 文件，使用 <code>./main</code> 即可执行</p>
<hr>
<p>出现错误，重新参考，理解三个配置文件</p>
<hr>
<p>在配置环境之前先检查一下机器上都安装了什么C++编译器，通过以下两条命令可以查看是否安装了g++/clang编译器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ --version</span><br><span class="line">clang++ --version</span><br></pre></td></tr></table></figure>

<p>然后安装两个插件</p>
<p>然后新建工程目录，在里面新建一个cpp文件命名为main.cpp。</p>
<p>然后点击侧边栏的Debug按钮，点击设置图标，便会提示你选择环境，这里就选择C++那一项。</p>
<p>此时VSCode会在你的工程目录下自动新建一个.vscode的文件夹，并新建了一个launch.json的文件，这里需要对生成的文件进行一些小改动。本人配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(lldb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/a.out&quot;,</span><br><span class="line">            //a.out 是需要运行的二进制文件可以改名</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;MIMode&quot;: &quot;lldb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后按快捷键⇧⌘B编译，此时会出现提示没有找到要运行的生成任务，所以接下来将进行生成任务的配置工作，VSCode提供了一些模版，有需要的可以自行选择，这里就选则Others。</p>
<p>此时.vscode目录下会出现一个task.json文件，对它进行改写。本人配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;hello world&quot;,  //描述</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;clang++&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">            </span><br><span class="line">                &quot;main.cpp&quot;  //文件名</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;:&quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                &quot;focus&quot;: false,</span><br><span class="line">                &quot;panel&quot;: &quot;new&quot;  //新建端口</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后再次按快捷键⇧⌘B就能够顺利编译了，编译完成后按F5执行，得到输出结果。</p>
<p>每次编译完成后，我们会发现目录下多了一个a.out文件，这个文件是Linux/Unix环境下编译器编译源代码并连接产生的可执行文件，在未指定的情况下其默认命名为a.out。那么如何通过修改配置文件来修改这个文件的命名呢？</p>
<p>方法很简单，在task.json中的args属性下填入<code>-o yourfilename.out</code></p>
<p>可以发现这里的command和args两个属性就相当于在命令行中执行了<code>clang++ -o yourfilename.out main.cpp</code>，所以如果还有其他的需求也可以对这里进行改写。最后不要忘记修改launch.json中的program属性，将.out的文件名修改为与task.json一致。便可以成功编译执行了。</p>
<hr>
<p>用了第二种之后，control+command+b 编译</p>
<p>再F5执行，不行，应该是branch文件配置的原因。</p>
<p>但是./\ app.out 可以运行。先这样。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/qq_43119354/article/details/89219180?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_43119354/article/details/89219180?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242</a></p>
]]></content>
      <categories>
        <category>cpp开发</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Geometry和Coordinate</title>
    <url>/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/</url>
    <content><![CDATA[<h3 id="LineString与Coordinate"><a href="#LineString与Coordinate" class="headerlink" title="LineString与Coordinate"></a>LineString与Coordinate</h3><p>Geometry对象转换为LineString对象，前面加(LineString)强转。</p>
<p><code>Coordinate coor = new Coordinate(lng, lat);</code><br>//lng、lat是Double类型经度纬度</p>
<p>LineString转换为Coordinate数组：<br><code>Coordinate[] coor = road.getCoordinates();</code></p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>com.vividsolutions.jts.geom下<br>Geometry可以是一系列的点组成的线。<br>数据库中查看需要加：select st_astext(geo) from table;</p>
<p>Geometry里的点：<br><code>Coordinate[] coordinates = geo.getCoordinates();</code></p>
<h3 id="GeometryUtils工具类"><a href="#GeometryUtils工具类" class="headerlink" title="GeometryUtils工具类"></a>GeometryUtils工具类</h3><p>GeometryUtils类属于mil.nga.giat.geowave.core.geotime包。</p>
<p><a href="https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html">https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html</a></p>
<h3 id="redisTemplate的GEO-API："><a href="#redisTemplate的GEO-API：" class="headerlink" title="redisTemplate的GEO API："></a>redisTemplate的GEO API：</h3><p><a href="https://blog.csdn.net/weixin_39274753/article/details/107783674">https://blog.csdn.net/weixin_39274753/article/details/107783674</a></p>
<h3 id="string和geometry的转换"><a href="#string和geometry的转换" class="headerlink" title="string和geometry的转换"></a>string和geometry的转换</h3><p>需要导入jts包。（vividsolution）</p>
<p>WKT，是一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换。它的二进制表示方式，亦即WKB(well-known binary)则胜于在传输和在数据库中存储相同的信息。该格式由开放地理空间联盟(OGC)制定。</p>
<p>WKT可以表示的几何对象包括：点，线，多边形，TIN（不规则三角网）及多面体。可以通过几何集合的方式来表示不同维度的几何对象。<br>几何物体的坐标可以是2D(x,y),3D(x,y,z),4D(x,y,z,m),加上一个属于线性参照系统的m值。<br>以下为几何WKT字串样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POINT(6 10)</span><br><span class="line">LINESTRING(3 4,10 50,20 25)</span><br><span class="line">POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))</span><br><span class="line">MULTIPOINT(3.5 5.6, 4.8 10.5)</span><br><span class="line">MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))</span><br><span class="line">MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))</span><br><span class="line">GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))</span><br><span class="line">POINT ZM (1 1 5 60)</span><br><span class="line">POINT M (1 1 80)</span><br><span class="line">POINT EMPTY</span><br><span class="line">MULTIPOLYGON EMPTY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void geoTest() throws ParseException, com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    //1.string类型转为geometry</span><br><span class="line">    //GeometryFactory工厂，参数一：数据精度 参数二空间参考系SRID</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line"></span><br><span class="line">    //熟知文本WKT阅读器，可以将WKT文本转换为Geometry对象</span><br><span class="line">    WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line"></span><br><span class="line">    //Geometry对象，包含Point、LineString、Polygon等子类</span><br><span class="line">    Geometry geometry = wktReader.read(&quot;POINT (113.53896635 22.36429837)&quot;);</span><br><span class="line">    System.out.println(&quot;geometry:&quot; + geometry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2.geometry对象转为string</span><br><span class="line">    //单纯的一个坐标点，单点可以创建Point，多点可以创建LineString、Polygon等</span><br><span class="line">    Coordinate coordinate = new Coordinate(113.53896635, 22.36429837);</span><br><span class="line">    Point point = geometryFactory.createPoint(coordinate);</span><br><span class="line"></span><br><span class="line">    Polygon polygon = geometryFactory.createPolygon(new Coordinate[]&#123;</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">    &#125;);</span><br><span class="line">    Geometry geometry1 = point;</span><br><span class="line">    Geometry geometry2 = polygon;</span><br><span class="line"></span><br><span class="line">    //WKT输出器，将Geometry对象写出为WKT文本</span><br><span class="line">    WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">    String pointString = wktWriter.write(point);</span><br><span class="line">    System.out.println(&quot;point string: &quot; + pointString);</span><br><span class="line">    String geoString = wktWriter.write(geometry1);</span><br><span class="line">    System.out.println(&quot;geo string: &quot; + geoString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>Java Geometry空间几何数据的处理应用：<a href="https://blog.csdn.net/An1090239782/article/details/123509504">https://blog.csdn.net/An1090239782/article/details/123509504</a></p>
<p>Geometry在数据库和Java中的应用：<a href="https://www.jianshu.com/p/76343e71d6f1">https://www.jianshu.com/p/76343e71d6f1</a></p>
<h3 id="两个geometry拼接"><a href="#两个geometry拼接" class="headerlink" title="两个geometry拼接"></a>两个geometry拼接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    WKTReader wktReader = new WKTReader();</span><br><span class="line">    Geometry geometry1 = wktReader.read(&quot;LineString(113.53896635 22.36429837, 113.53896645 22.36429847)&quot;);</span><br><span class="line">    Geometry geometry2 = wktReader.read(&quot;LineString(113.53896645 22.36429847, 113.53896655 22.36429857)&quot;);</span><br><span class="line">    Geometry geometry3 = geometry1.union(geometry2);</span><br><span class="line">    System.out.println(geometry3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：MULTILINESTRING ((113.53896635 22.36429837, 113.53896645 22.36429847), (113.53896645 22.36429847, 113.53896655 22.36429857))</p>
<h3 id="jts里的geometry的一些操作"><a href="#jts里的geometry的一些操作" class="headerlink" title="jts里的geometry的一些操作"></a>jts里的geometry的一些操作</h3><p>✅<code>org.locationtech.jts.geom.Geometry.isValid()</code></p>
<p>验证此Geometry是否在拓扑上有效。</p>
<p>✅<code>geo.buffer(distance)</code></p>
<p>buffer(double distance): 加buffer缓冲区<br>buffer(double distance, int quadrantSegments): 加buffer,边界样式</p>
<p>✅<code>geometry1.equals(geometry2)</code> 是否完全重叠</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void equalsGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">    WKTReader reader = new WKTReader( geometryFactory );</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.equals(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line"></span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(10 0, 0 0)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.equals(geometry2);//true</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅geometry1.crosses(geometry2) 是否交叉</p>
<p>得有交点。但交点不能是线的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void crossGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    //情景1</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    //情景2</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    //情景3</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(4 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b3 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b3);</span><br><span class="line">    //情景4</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(0 4, 3 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b4 = geometry1.crosses(geometry2);//true</span><br><span class="line">    System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅intersects ：两个对象是否空间相交（至少有一个点）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">boolean b2 = geometry1.intersects(geometry2);//true</span><br></pre></td></tr></table></figure>

<p>geometry的更多用法：<a href="https://blog.csdn.net/qiaobing1226/article/details/124467098">https://blog.csdn.net/qiaobing1226/article/details/124467098</a></p>
<p>常用的Geometry数据结构和GeometryFactory：<a href="https://www.jianshu.com/p/3add14bdee7b">https://www.jianshu.com/p/3add14bdee7b</a></p>
<p>jts使用：<a href="https://blog.csdn.net/weixin_40294332/article/details/124124361">https://blog.csdn.net/weixin_40294332/article/details/124124361</a><br><a href="https://blog.csdn.net/qiaobing1226/article/details/127204644">https://blog.csdn.net/qiaobing1226/article/details/127204644</a></p>
<h3 id="数据库相关的geo操作"><a href="#数据库相关的geo操作" class="headerlink" title="数据库相关的geo操作"></a>数据库相关的geo操作</h3><p>✅mysql空间数据有哪些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Geometry  空间数据	任意一种空间类型	</span><br><span class="line">Point	点	坐标值	POINT(104.00924 30.46872)</span><br><span class="line">LineString	线	线，由一系列点连接而成	LINESTRING(1 1,  1 1, 1 1)</span><br><span class="line">Polygon	多边形	由多条线组成	POLYGON((1 1, 2 2, 3 3,  4 4, 5 5))</span><br><span class="line">MultiPoint	点集合	集合类，包含多个点	MULTIPOINT(1 1, 2 2, 1 1)</span><br><span class="line">MultiLineString	线集合	集合类，包含多条线	MULTILINESTRING((1 1, 2 2), (1 1, 1 1))</span><br><span class="line">MultiPolygon	多边形集合	集合类，包含多个多边形	MULTIPOLYGON(((0 0, 1 0, 1 1, 0 1, 0 0)), ((1 1, 1 1, 1 1, 1 1, 1 1)))</span><br><span class="line">GeometryCollection	空间数据集合	集合类，可以包括多个点、线、多边形	GEOMETRYCOLLECTION(POINT(1 1), POINT(3 3), LINESTRING(1 1, 2 2))</span><br></pre></td></tr></table></figure>

<p>mysql中几何对象的表达格式：<br>WKT：（Well-known Text）可以通过文本来描述几何对象。<br>WKB（Well-known Binary）通过序列化的字节对象来描述几何对象（一般在数据库中使用）。</p>
<p>常用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ST_GEOMFROMTEXT</span><br><span class="line">用于将几何数据从可读的文本类型转换成内部存储的二进制类型。</span><br><span class="line">ST_ASTEXT</span><br><span class="line">将几何数据转换成可读的文本类型。</span><br><span class="line"></span><br><span class="line">st_union(g1, g2) 将g1和g2合并为一个集合类对象</span><br><span class="line">st_difference(g1, g2)  返回几何对象，该对象表示了几何值g1与g2的点集合差异</span><br><span class="line">st_intersection(g1,g2)  返回几何对象，该对象表示了几何值g1与g2的点集合交集</span><br><span class="line"></span><br><span class="line">st_contains(g1, g2)</span><br><span class="line">g1完全包含g2；返回0: g1未包含g2</span><br><span class="line"></span><br><span class="line">st_crosses(g1, g2), st_intersects(g1, g2)</span><br><span class="line">返回1: g1与g2相交；返回0:g1与g2未相交</span><br><span class="line"></span><br><span class="line">st_disjoint(g1, g2)</span><br><span class="line">是st_crosses的反函数</span><br><span class="line"></span><br><span class="line">st_within(g1, g2)</span><br><span class="line">g1在g2内则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<p>创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对表中的geometry类型的字段进行索引可以优化搜索，mysql中通过对geometry对象的mbr创建索引</span><br><span class="line">创建：</span><br><span class="line">create spatial index i_shape on `t_geo_test`(shape);</span><br><span class="line">删除：</span><br><span class="line">drop index i_shape on `t_geo_test`;</span><br><span class="line"></span><br><span class="line">目前mysql中支持的空间坐标系统没有gcj02,bd09等国内坐标系，</span><br><span class="line">默认使用wgs84地球坐标系，所以在创建几何对象时输入的坐标值尽量使用wgs84坐标，以避免误差。</span><br><span class="line"></span><br><span class="line">mysql中的计算距离，长度，面积等绝对数值的空间计算函数（area(), glength(), st_distance()）存在一定的误差，尽量不要使用。</span><br></pre></td></tr></table></figure>

<p>mysql的geometry相关的函数：<a href="https://jiuaidu.com/jianzhan/906169/">https://jiuaidu.com/jianzhan/906169/</a></p>
<p>✅创建表时带geometry字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`geo` geometry default null comment &#x27;坐标点&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists `geo_table`(</span><br><span class="line">    `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">    `geo` geometry default null comment &#x27;坐标点&#x27;,</span><br><span class="line">    PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COMMENT=&quot;geo&quot;;</span><br><span class="line"></span><br><span class="line">set @geo = st_geomfromtext(&quot;LineString(104.009241 30.468972,104.009229 30.468961)&quot;);</span><br><span class="line">insert into geo_table values(0, @geo);</span><br><span class="line">select st_astext(geo) from geo_table;</span><br></pre></td></tr></table></figure>

<p>✅Intersects相交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where Intersects(geome1, geo2);</span><br></pre></td></tr></table></figure>

<p>✅mysql根据经纬度计算距离</p>
<p>st_distance_sphere函数返回以米为单位.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select st_distance_sphere(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>st_distance返回的度<br>st_distance 计算的结果单位是度，需要乘111195（地球半径6371000*PI/180）是将值转化为米。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select st_distance(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>直接计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*,ROUND(</span><br><span class="line">6378.138 * 2 * ASIN(</span><br><span class="line">SQRT(</span><br><span class="line">POW( SIN(( 23.129163 * PI()/ 180-latitudes * PI()/ 180 )/ 2 ), 2 )+ COS( 23.129163 * PI()/ 180 )* COS( latitudes * PI()/ 180 )* POW( SIN(( 113.264435 * PI()/ 180-longitudes * PI()/ 180 )/ 2 ), 2 )))* 1000 </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="几个坐标系"><a href="#几个坐标系" class="headerlink" title="几个坐标系"></a>几个坐标系</h3><p>总的来说，坐标系可以分为两大类：地理坐标系（Geographic Coordinate System, GCS）和投影坐标系（Projected Coordinate System, PCS），地理坐标系进行地图投影后就变成了投影坐标系。例如我们常见的世界地图，使用的就是一种 墨卡托投影。</p>
<p>其中地理坐标系又可分为 参心坐标系 和 地心坐标系，常见的地心坐标系有WGS84、GCJ-02、BD-09、GCS2000。</p>
<p>✅WGS84（World Geodetic System 1984）</p>
<p>WGS84是为 GPS 全球定位系统建立的坐标系统，是世界上第一个统一的地心坐标系，因此也被称为大地坐标系、原始坐标系。一般通过GPS记录仪记录下来的经纬度，就是基于WGS84坐标系的数据。</p>
<p>✅GCJ-02（国家测量局02号标准）</p>
<p>GCJ-02 是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统，是在WGS84经纬度的基础上执行加密算法而成（为了数据安全和保密，通过地形图非线性保密处理算法（俗称火星加密）加密）。因为GPS得到的经纬度直接在 GCJ-02 坐标系下会定位到错误的地点，有种到了火星的感觉，因此在坊间也将 GCJ-02 戏称为火星坐标系。</p>
<p>国测局规定，国内出版的各种地图系统（包括电子形式），必须至少采用 GCJ-02 对地理位置进行首次加密的坐标系，高德和Google在国内都是使用 GCJ－02 坐标系，而百度使用的是在 GCJ-02 基础上再一次加密的 BD-09 坐标系。</p>
<p>举个例子，北京天安门中心的GPS经纬度是39°54’26.2”N，116°23’28.4”E，转化为度的单位就是39.907270, 116.391213（提示：小数部分 = 分 / 60 + 秒 / 3600）<br>将 GPS 坐标转换为 GCJ-02 坐标：116.397454,39.908671，才能在高德地图上找到正确的位置。<br>需要注意的是，如果切换到谷歌地图的卫星地图模式，它使用的是WGS84坐标系。</p>
<p>参考：<br>几种坐标系：<a href="https://www.jianshu.com/p/559029832a67">https://www.jianshu.com/p/559029832a67</a><br>地心坐标系和投影坐标系：<a href="https://zhuanlan.zhihu.com/p/62864791">https://zhuanlan.zhihu.com/p/62864791</a></p>
<p>三个坐标总结：WGS84是大地坐标系，这是一种国际通用的坐标，一般的终端设备，如果自己有定位功能，比如车载系统，他们发出的gps坐标就是原始坐标。我们在一些地图应用中使用的定位，比如打车软件，其他自带地图的软件，他们一般都是火星坐标系GCJ02，需要进行一个坐标转换。而百度地图相关的应用，基本都是使用的百度坐标，这个是在火星坐标基础上进行的再次加密，所以它还是与火星坐标有关系。</p>
<p>✅坐标转换</p>
<p>从WGS84坐标系不能直接转BD09，中间需要跨越一个GCJ02，反过来，需要将GCJ02或者BD09转为WGS84就是纠偏算法，相当于逆向解密。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">克拉索索夫斯基椭球系数:</span><br><span class="line">public static double pi = 3.1415926535897932384626;</span><br><span class="line">public static double a = 6378245.0;</span><br><span class="line">public static double ee = 0.00669342162296594323;</span><br><span class="line">经纬度偏移值：&#123;105,35&#125;。这个其实是中华人民共和国大地原点坐标。位置在中国陕西省咸阳市下的泾阳县。</span><br></pre></td></tr></table></figure>

<p>转换代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.geometry;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * wgs84 84年提出，大地坐标，也是原始坐标。</span><br><span class="line"> * gcj02 02年提出，火星坐标，经过加密算法。大多数非百度中国地图厂商基本都是使用的火星坐标：高德，腾讯，谷歌中国cn</span><br><span class="line"> * bd09  09年提出，百度坐标，经过火星坐标再次加密，相当于对大地坐标经过了二次加密。百度自己使用</span><br><span class="line"> * 一般的算法，没有直接bd09-&gt;wgs84或者wgs84-&gt;bd09，都需要借助wgs84-&gt;gcj02或者gcj02-&gt;wgs84算法推导。</span><br><span class="line"> */</span><br><span class="line">public class GpsTransfer &#123;</span><br><span class="line">    //π的定义</span><br><span class="line">    public static double pi = 3.1415926535897932384626;</span><br><span class="line">    //椭球长半径，依据克拉索索夫斯基椭球系数计算</span><br><span class="line">    public static double a = 6378245.0;</span><br><span class="line">    //第一偏心率的平方</span><br><span class="line">    public static double ee = 0.00669342162296594323;</span><br><span class="line"></span><br><span class="line">    public static double transformLat(double x, double y) &#123;</span><br><span class="line">        double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y</span><br><span class="line">                + 0.2 * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static double transformLon(double x, double y) &#123;</span><br><span class="line">        double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1</span><br><span class="line">                * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0</span><br><span class="line">                * pi)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断是否在中国范围之内</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean outOfChina(double lat, double lon) &#123;</span><br><span class="line">        if (lon &lt; 72.004 || lon &gt; 137.8347)</span><br><span class="line">            return true;</span><br><span class="line">        if (lat &lt; 0.8293 || lat &gt; 55.8271)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 把公式部分抽取出来</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps transform(double lat, double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return new Gps(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double dLat = transformLat(lon - 105.0, lat - 35.0);</span><br><span class="line">        double dLon = transformLon(lon - 105.0, lat - 35.0);</span><br><span class="line">        double radLat = lat / 180.0 * pi;</span><br><span class="line">        double magic = Math.sin(radLat);</span><br><span class="line">        magic = 1 - ee * magic * magic;</span><br><span class="line">        double sqrtMagic = Math.sqrt(magic);</span><br><span class="line">        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);</span><br><span class="line">        dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);</span><br><span class="line">        double mgLat = lat + dLat;</span><br><span class="line">        double mgLon = lon + dLon;</span><br><span class="line">        return new Gps(mgLat, mgLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * wgs84到gcj02转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps wgs84_To_Gcj02(double lat, double lon) &#123;</span><br><span class="line">        return transform(lat, lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 简单的gcj02到wgs84坐标类型转换，只做了一次迭代</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84(double lat, double lon) &#123;</span><br><span class="line">        Gps gps = transform(lat, lon);</span><br><span class="line">        double lontitude = lon * 2 - gps.lon;</span><br><span class="line">        double latitude = lat * 2 - gps.lat;</span><br><span class="line">        return new Gps(latitude, lontitude);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 稍微精确一点的gcj02到wgs84转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84_exact(double lat,double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return gcj02_To_Wgs84(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double initDelta = 0.01;</span><br><span class="line">        double threshold = 0.000001;</span><br><span class="line">        double dLat = initDelta;</span><br><span class="line">        double dLon = initDelta;</span><br><span class="line">        double mLat = lat - dLat;</span><br><span class="line">        double mLon = lon - dLon;</span><br><span class="line">        double pLat = lat + dLat;</span><br><span class="line">        double pLon = lon + dLon;</span><br><span class="line">        double wgsLat = 0;</span><br><span class="line">        double wgsLon = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            wgsLat = (mLat + pLat) / 2;</span><br><span class="line">            wgsLon = (mLon + pLon) / 2;</span><br><span class="line">            Gps tmp = wgs84_To_Gcj02(wgsLat, wgsLon);</span><br><span class="line">            dLat = tmp.lat - lat;</span><br><span class="line">            dLon = tmp.lon - lon;</span><br><span class="line">            if ((Math.abs(dLat) &lt; threshold) &amp;&amp; (Math.abs(dLon) &lt; threshold)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dLat &gt; 0) &#123; pLat = wgsLat; &#125; else &#123; mLat = wgsLat;&#125;</span><br><span class="line">            if (dLon &gt; 0) &#123; pLon = wgsLon; &#125; else &#123; mLon = wgsLon;&#125;</span><br><span class="line"></span><br><span class="line">            if (++i &gt; 1000) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Gps(wgsLat, wgsLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标是在火星坐标基础上做的二次加密</span><br><span class="line">     * @param gg_lat</span><br><span class="line">     * @param gg_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Bd09(double gg_lat, double gg_lon) &#123;</span><br><span class="line">        double x = gg_lon, y = gg_lat;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double bd_lon = z * Math.cos(theta) + 0.0065;</span><br><span class="line">        double bd_lat = z * Math.sin(theta) + 0.006;</span><br><span class="line">        return new Gps(bd_lat, bd_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标与火星坐标逆向转换</span><br><span class="line">     * @param bd_lat</span><br><span class="line">     * @param bd_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps bd09_To_Gcj02(double bd_lat, double bd_lon) &#123;</span><br><span class="line">        double x = bd_lon - 0.0065, y = bd_lat - 0.006;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double gg_lon = z * Math.cos(theta);</span><br><span class="line">        double gg_lat = z * Math.sin(theta);</span><br><span class="line">        return new Gps(gg_lat, gg_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Gps gps = new Gps(39.907270, 116.391213);</span><br><span class="line">        System.out.println(gps);//&#123;39.90727,116.391213&#125;</span><br><span class="line">        Gps gps2 = wgs84_To_Gcj02(gps.lat, gps.lon);</span><br><span class="line">        System.out.println(gps2);//&#123;39.90867122432153,116.39745410656687&#125;</span><br><span class="line">        Gps gps3 = gcj02_To_Wgs84(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps3);//&#123;39.907267736339556,116.3912105466475&#125;</span><br><span class="line">        Gps gps4 = gcj02_To_Wgs84_exact(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps4);//&#123;39.90727046748559,116.39121326184032&#125; 相对一次迭代是精确了，但是好像也不是完全还原</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gps&#123;</span><br><span class="line">    double lat,lon;</span><br><span class="line">    public Gps() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Gps(double lat,double lon)&#123;</span><br><span class="line">        this.lat = lat;</span><br><span class="line">        this.lon = lon;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;&#123;&quot;+lat+&quot;,&quot;+lon+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/feinifi/article/details/120547127">https://blog.csdn.net/feinifi/article/details/120547127</a></p>
<h3 id="mysql-java-redis三种地理位置算法"><a href="#mysql-java-redis三种地理位置算法" class="headerlink" title="mysql,java,redis三种地理位置算法"></a>mysql,java,redis三种地理位置算法</h3><p>获取附近信息，以用户当前位置为中心点，指定范围为半径，查询出在该圆圈内的所有信息。</p>
<h4 id="MySQL-基于st-distance函数"><a href="#MySQL-基于st-distance函数" class="headerlink" title="MySQL 基于st_distance函数"></a>MySQL 基于st_distance函数</h4><p>mysql 5.6.1 加入了空间数据支持功能，新增了st_*相关函数，可以非常方便的计算两个地理坐标点的距离。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	p.* </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		park_info.*,</span><br><span class="line">		st_distance (</span><br><span class="line">			point ( park_info.lng, park_info.lat ),</span><br><span class="line">		point ( 116.403694, 39.913828 ))* 111195 AS distance </span><br><span class="line">	FROM</span><br><span class="line">		park_info park_info </span><br><span class="line">	) p </span><br><span class="line">WHERE</span><br><span class="line">	p.distance &lt; 10000</span><br></pre></td></tr></table></figure>


<h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class DistanceUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 地球半径,单位 km</span><br><span class="line">     */</span><br><span class="line">    private static final double EARTH_RADIUS = 6378137;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据经纬度，计算两点间的距离</span><br><span class="line">     *</span><br><span class="line">     * @param longitude1 第一个点的经度</span><br><span class="line">     * @param latitude1  第一个点的纬度</span><br><span class="line">     * @param longitude2 第二个点的经度</span><br><span class="line">     * @param latitude2  第二个点的纬度</span><br><span class="line">     * @return 返回距离 单位米</span><br><span class="line">     */</span><br><span class="line">    public static double getDistance(double longitude1, double latitude1, double longitude2, double latitude2) &#123;</span><br><span class="line">        // 纬度</span><br><span class="line">        double lat1 = Math.toRadians(latitude1);</span><br><span class="line">        double lat2 = Math.toRadians(latitude2);</span><br><span class="line">        // 经度</span><br><span class="line">        double lng1 = Math.toRadians(longitude1);</span><br><span class="line">        double lng2 = Math.toRadians(longitude2);</span><br><span class="line">        // 纬度之差</span><br><span class="line">        double a = lat1 - lat2;</span><br><span class="line">        // 经度之差</span><br><span class="line">        double b = lng1 - lng2;</span><br><span class="line">        // 计算两点距离的公式</span><br><span class="line">        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +</span><br><span class="line">                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(b / 2), 2)));</span><br><span class="line">        // 弧长乘地球半径, 返回单位: 米</span><br><span class="line">        s =  s * EARTH_RADIUS;</span><br><span class="line">        return Math.round(s * 10000) / 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double distance = DistanceUtils.getDistance(109.49081, 36.596537, 111.128971, 37.524041);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance);</span><br><span class="line">        double distance1 = DistanceUtils.getDistance(109.500603,36.594125, 111.151761,37.52671);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key 停车场地理位置键</span><br><span class="line"> * @param lng 坐标</span><br><span class="line"> * @param lat 坐标</span><br><span class="line"> * @param t 停车场标示</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long addGeo(String key, Double lng, Double lat, T t) &#123;</span><br><span class="line">    RedisGeoCommands.GeoLocation&lt;T&gt; geoLocation = new RedisGeoCommands.GeoLocation&lt;&gt;(t, new Point(lng, lat));</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, geoLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量添加</span><br><span class="line"> * @param key</span><br><span class="line"> * @param list</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long batchAddGeo(String key, List&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt; list) &#123;</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> */</span><br><span class="line">public void removeGeo(String key, T... t) &#123;</span><br><span class="line">    redisTemplate.opsForGeo().remove(key, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取经纬度指定距离内的数据</span><br><span class="line"> *</span><br><span class="line"> * @param lng</span><br><span class="line"> * @param lat</span><br><span class="line"> * @param distance</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt;</span><br><span class="line">getCacheListByPointAndDistance(Double lng, Double lat, Double distance, String key) &#123;</span><br><span class="line">    Circle circle = new Circle(new Point(lng, lat), new Distance(distance, Metrics.KILOMETERS));</span><br><span class="line">    RedisGeoCommands.GeoRadiusCommandArgs args =</span><br><span class="line">            // includeCoordinates：返回结果包含坐标信息</span><br><span class="line">            // includeDistance：返回结果包含具中心坐标距离信息</span><br><span class="line">            // sortAscending：按照距离升序排序</span><br><span class="line">            // sortDescending：按照距离降序排序</span><br><span class="line">            // limit：返回结果数量限制</span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates()</span><br><span class="line">                    .sortAscending();</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt; content =</span><br><span class="line">            redisTemplate.opsForGeo().radius(key, circle, args).getContent();</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Elasticsearch-Geo"><a href="#Elasticsearch-Geo" class="headerlink" title="Elasticsearch Geo"></a>Elasticsearch Geo</h4><p>【toStudy】</p>
<p>转自：<a href="https://blog.csdn.net/m0_37923316/article/details/108978101">https://blog.csdn.net/m0_37923316/article/details/108978101</a></p>
<h3 id="点到线的最近线段"><a href="#点到线的最近线段" class="headerlink" title="点到线的最近线段"></a>点到线的最近线段</h3><p>使用JTSFactoryFinder 创建GeometryFactory，是在org.geotools.geometry.jts下的。</p>
<p>需要导入的包：gt-main、gt-metadata</p>
<p><code>GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory(null);</code></p>
<p>返回点到线段的最近线段，可能是垂线，不能垂直的话，是点到线段两端点的连线。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testNearest() throws ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    Coordinate coordinate = new Coordinate(1, 1);</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt = &quot;LINESTRING(0 0, 1 0, 2 0)&quot;;</span><br><span class="line">    LineString road = (LineString) reader.read(wkt);</span><br><span class="line">    Coordinate[] shadow = com.vividsolutions.jts.operation.distance.DistanceOp.nearestPoints(road,</span><br><span class="line">            geometryFactory.createPoint(coordinate));</span><br><span class="line">    System.out.println(Arrays.toString(shadow)); //[(1.0, 0.0, NaN), (1.0, 1.0, NaN)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="道格拉斯抽稀"><a href="#道格拉斯抽稀" class="headerlink" title="道格拉斯抽稀"></a>道格拉斯抽稀</h3><p>道格拉斯-普克算法（Douglas-Peuker算法）是我们常用的一种轨迹点的抽稀算法，抽稀出来的点可以尽可能的维持原先轨迹点的大体轮廓，剔除一些非必要的点。</p>
<p>道格拉斯-普克原理：<br>（1）在曲线首尾两点A，B之间连接一条直线AB，该直线为曲线的弦；<br>（2）得到曲线上离该直线段距离最大的点C，计算其与AB的距离d；<br>（3）比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则该直线段作为曲线的近似，该段曲线处理完毕。<br>（4）如果距离大于阈值，则用C将曲线分为两段AC和BC，并分别对两段取信进行1~3的处理。<br>（5）当所有曲线都处理完毕时，依次连接各个分割点形成的折线，即可以作为曲线的近似。</p>
<p>java使用方法：jts是一套用于处理几何要素拓扑关系的函数库，提供了基本二位平面线形图形运算算法实现。</p>
<p>mvn依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jts&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line">Geometry geometry1 = wktReader.read(&quot;lineString(0 0, 1 1, 2 0)&quot;);</span><br><span class="line">Geometry geometry2 = DouglasPeuckerSimplifier.simplify(geometry1, 0.9);</span><br><span class="line">WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">String res = wktWriter.write(geometry2);</span><br><span class="line">System.out.println(res);  //LINESTRING (0 0, 1 1, 2 0)</span><br></pre></td></tr></table></figure>

<p><code>Geometry simplify(Geometry geom, double distanceTolerance)</code>中的参数distanceTolerance是跟首尾点距离比(单纯平方间的距离，不是实际m的距离)。</p>
<p>自己实现道格拉斯抽稀(python)：<br><a href="https://www.jianshu.com/p/046bcaeb2cb6">https://www.jianshu.com/p/046bcaeb2cb6</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mac安装和配置java环境</title>
    <url>/2021/08/25/myblog/JAVA/MAC%E4%B8%8B%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="MAC下java环境安装"><a href="#MAC下java环境安装" class="headerlink" title="MAC下java环境安装"></a>MAC下java环境安装</h1><h2 id="1-下载jdk8并且安装"><a href="#1-下载jdk8并且安装" class="headerlink" title="1.下载jdk8并且安装"></a>1.下载jdk8并且安装</h2><p><code>java -version</code>看一下有没有安装</p>
<p>若没有，<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<h2 id="2-配置java环境"><a href="#2-配置java环境" class="headerlink" title="2.配置java环境"></a>2.配置java环境</h2><p>我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。</p>
<p>访达中，打开资源库，打开java，下面有jdk目录。</p>
<p><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home</code>  右键打开终端</p>
<p>终端运行：<code>sudo vim/etc/profile</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home&quot;</span><br><span class="line">export JAVA_HOME</span><br><span class="line">CLASS_PATH=&quot;$JAVA_HOME/lib&quot;</span><br><span class="line">PATH=&quot;.$PATH:$JAVA_HOME/bin&quot;</span><br></pre></td></tr></table></figure>

<p><code>source /etc/profile  //使配置生效</code></p>
<p><code>echo $JAVA_HOME //得到配置的路径，说明配置成功</code></p>
<h2 id="3-vim一个java程序"><a href="#3-vim一个java程序" class="headerlink" title="3.vim一个java程序"></a>3.vim一个java程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名需要跟java文件中的类名一致！</span><br><span class="line">public class helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javac helloworld.java   //生成.class字节码文件</span><br><span class="line">java helloworld    //运行</span><br></pre></td></tr></table></figure>

<h3 id="4-java-IDE"><a href="#4-java-IDE" class="headerlink" title="4.java IDE"></a>4.java IDE</h3><p>官网下载：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<p>下载破解包，保存在百度云中了。</p>
<p>安装IDEA，在注册页面，选择 Evaluate for free，点击 Evaluate 试用软件</p>
<p>将下载的破解文件夹中的 jetbrains-agent.jar 文件拖动到软件内，然后点击 Restart 重启软件</p>
<p>重启完成之后，如果弹出了激活方式，选择 Activation code，没有弹出则不用管，复制破解文件中的 Activation code，然后选择激活，重启软件</p>
<p>重启软件，在 Get Help 中点击 About ，可以查看激活情况</p>
<p><strong>不得行</strong></p>
<p>更新：<a href="https://www.jianshu.com/p/bbc7cd207a85">https://www.jianshu.com/p/bbc7cd207a85</a></p>
<h3 id="5-用idea的第一个java程序"><a href="#5-用idea的第一个java程序" class="headerlink" title="5.用idea的第一个java程序"></a>5.用idea的第一个java程序</h3><p>![image-20210823173916506](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210823173916506.png)</p>
<p>右键运行。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mac安装和配置maven</title>
    <url>/2021/08/25/myblog/JAVA/MAC%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEMaven/</url>
    <content><![CDATA[<h1 id="MAC安装和配置Maven"><a href="#MAC安装和配置Maven" class="headerlink" title="MAC安装和配置Maven"></a>MAC安装和配置Maven</h1><h2 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1.Maven简介"></a>1.Maven简介</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">背景：开发A项目，A项目中的一些功能依赖于B项目中的某些类，那么如何维系这种依赖关系？需要用哪个项目中的哪些类，也就是用别人写好了的功能代码，导入jar包即可。所以这里也如此，可以将B项目打成jar包，然后在A项目的Library下导入B的jar文件，这样，A项目就可以调用B项目中的某些类了。如果在开发过程中，发现B中的bug，则必须将B项目修改好，并重新将B打包并对A项目进行重编译操作</span><br></pre></td></tr></table></figure>

<p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具。</p>
<p>Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包。</p>
<p>由于Maven仓库中所有的JAR都有其自己的坐标，该坐标告诉Maven它的组ID，构件ID，版本，打包方式等等， 因此Maven项目可以方便的进行依赖版本管理。</p>
<h2 id="2-安装和配置Maven"><a href="#2-安装和配置Maven" class="headerlink" title="2.安装和配置Maven"></a>2.安装和配置Maven</h2><p>下载地址： <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>![image-20210824144100726](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824144100726.png)</p>
<p>我下载在了<code>/Library/ApacheMaven</code></p>
<p><code>vim ~/.bash_profile</code>  //配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export M=&quot;/Library/ApacheMaven&quot;  //根据自己放在哪个目录</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p><code>source ~/.bash_profile</code>     //使配置生效</p>
<p><code>mvn -v</code>   //查看版本</p>
<p>或者，可以直接<code>brew install maven</code></p>
<h3 id="下载远程仓库到本地"><a href="#下载远程仓库到本地" class="headerlink" title="下载远程仓库到本地"></a>下载远程仓库到本地</h3><p>maven 就像是一个大仓库，里面是很多的jar包，我们需要的时候就去里面拿，所以这就涉及到一个 ‘‘本地仓库’’（不能需要什么再去网上下载吧，速度有时候很慢的）,那么咱们就得先把这些jar包下载到咱们本地方便使用，<br>默认请况下，这个本地仓库会在/user/name/.m2下面（name 是你的用户名）。为了方便，把本地仓库改在Maven安装目录下。</p>
<p>打开安装目录下的conf目录下的<code>settings.xml</code><br>加入<code>&lt;localRepository&gt;/Library/ApacheMaven/repository &lt;/localRepository&gt;</code></p>
<p>输入<code>mvn help:system</code></p>
<p>![image-20210824175620786](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824175620786.png)</p>
<p>多了一个repository文件夹，这就是咱们从远程仓库下载到本地仓库的文件。</p>
<h2 id="3-创建Maven项目"><a href="#3-创建Maven项目" class="headerlink" title="3.创建Maven项目"></a>3.创建Maven项目</h2><h3 id="a-使用命令行创建Maven项目"><a href="#a-使用命令行创建Maven项目" class="headerlink" title="a.使用命令行创建Maven项目"></a>a.使用命令行创建Maven项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.xuanliu.helloword -DartifactId=helloworld -Dpackage=cn.cxuanliu.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mvn</code>:表示使用的是maven命令。</li>
<li><code>archetype:generate</code>:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。</li>
<li><code>-DgroupId</code>:标识项目的坐标元素之一，项目包名，可以是：域名的反写+项目名。</li>
<li><code>-DartifactId</code>:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。</li>
<li><code>-Dpackage</code>:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。</li>
<li><code>-Dversion</code>:指定版本号。此属性在命令行中可选</li>
<li><code>-DarchetypeArtifactId</code>:表示我们生成的工程结构为哪一种，这里的属性值为<code>maven-archetype-quickstart</code>表示生成工程目录结构为quickstart的结构。其值还可以为<code>maven-archetype-webapp</code>表示生成的工程目录结构为webapp的结构。</li>
</ul>
<p>![image-20210824155803431](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824155803431.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录解读：在maven项目的开发中，所有的源代码放在文件夹 /src/main/java/下, 所有的单元测试代码放入 /src/test/java/。</span><br><span class="line">pom.xml 描述了整个项目的信息</span><br></pre></td></tr></table></figure>

<h3 id="b-使用IDEA创建Maven项目"><a href="#b-使用IDEA创建Maven项目" class="headerlink" title="b.使用IDEA创建Maven项目"></a>b.使用IDEA创建Maven项目</h3><p><code>Create New Project</code>，选择<code>Maven</code>，勾选<code>Create from archetype</code></p>
<p><img src="https://img2018.cnblogs.com/blog/1068501/201809/1068501-20180914191722384-1695467171.png" alt="img"></p>
<p>写<code>Maven</code>的坐标，“groupId”，“artifactId”，以及“version”，其中groupId是公司域名的反写，而artifactId是项目名或模块名，version就是该项目或模块所对应的版本号。</p>
<p>![image-20210824174243856](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824174243856.png)</p>
<p>![image-20210824180029943](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824180029943.png)</p>
<p>maven会自动下载maven依赖，当所有的都自动完成后，创建的maven项目结构如下所示： </p>
<p>![image-20210824180441439](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210824180441439.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）在大多数情况下，把项目的主代码放到 src/main/java 目录下（遵循Maven约定），如果没有其他的配置，Maven在运行时将自动搜寻该目录下的主代码。</span><br><span class="line">（2）为了使项目的结构保持清晰，所以IDEA自动创建了 test 文件，将主代码和测试代码分别放到了独立的目录中。</span><br><span class="line">（3）pom.xml为Maven的核心配置文件，它的全称为（Project Object Model，项目对象模型），我们在使用Maven的时候也通常在这个pom .xml 中配置。</span><br></pre></td></tr></table></figure>

<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml:"></a>pom.xml:</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>    <span class="comment">&lt;!-- xml头，指定xml文档的版本信息和编码方式 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;project&gt;为所有pom.xml的根元素，声明了一些POM相关的命名空间及xsd元素，</span></span><br><span class="line"><span class="comment">  这些元素不是pom.xml中必须添加的，但是使用这些属性可以使第三方工具，</span></span><br><span class="line"><span class="comment">  如IDE中的xml编辑器帮助开发者快速编辑POM。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;modeVersion&gt; 指定了当前POM模板的版本 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liuxuan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="comment">&lt;!-- &lt;groupId&gt; 定义了该项目属于哪个项目组 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ideamaven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   <span class="comment">&lt;!-- &lt;&lt;artifactId&gt;定义了当前Maven项目在项目组的唯一一个ID,项目名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!--&lt;version&gt;定义了Hello Maven项目当前的版本号 1.0-SNAPSHOT 为IDEA默认的初始版本号 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>在没有实际的java代码时，我们就可以完整的创建一个Maven项目的pom.xml，这说明了Maven可以使项目对象模型最大程度的与代码相独立，这充分体现了解耦的原则和理念！为开发者节省了时间，大大缩短了项目开发周期。在项目开发到稳定期时，升级版本时，开发者可以不需要修改实际的 java 代码，而是只修改pom.xml，这一特点使Maven被广泛的使用。</p>
<h2 id="4-编写主代码"><a href="#4-编写主代码" class="headerlink" title="4.编写主代码"></a>4.编写主代码</h2><p><strong>项目主代码和测试代码不同，主代码会被打包到最终的构件中，而测试代码只在运行测试时用到，不会被打包。</strong></p>
<p><strong>在src/main/java中创建文件com/feiyu/web/helloworld/helloWorld.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello liuxuan&#x27;s Maven!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> hello().sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键运行。</p>
<p>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---pom.xml　　　　核心配置，项目根下</span><br><span class="line">---src</span><br><span class="line">　　---main　　　　　　</span><br><span class="line">　　　   ---java　　　　java源码目录</span><br><span class="line">　　     ---resources　  java配置文件目录</span><br><span class="line">　　---test</span><br><span class="line">　　　　　---java　　　　测试源码目录</span><br><span class="line">　　　　　---resources　  测试配置目录</span><br><span class="line">---target    输出目录</span><br></pre></td></tr></table></figure>

<h2 id="5-Maven仓库"><a href="#5-Maven仓库" class="headerlink" title="5.Maven仓库"></a>5.Maven仓库</h2><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p>
<p>Maven 仓库有三种类型：</p>
<ul>
<li>本地（local）</li>
<li>中央（central）</li>
<li>远程（remote）</li>
</ul>
<h3 id="a-本地仓库"><a href="#a-本地仓库" class="headerlink" title="a.本地仓库"></a>a.本地仓库</h3><p>第一次执行 maven 命令的时候才被创建。运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p>
<p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。</p>
<p>可以修改默认位置，改变settings.xml中的配置。<br><code>&lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;</code></p>
<h3 id="b-中央仓库"><a href="#b-中央仓库" class="headerlink" title="b.中央仓库"></a>b.中央仓库</h3><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p>
<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p>
<p>中央仓库的关键概念：</p>
<ul>
<li>这个仓库由 Maven 社区管理。</li>
<li>不需要配置。</li>
<li>需要通过网络才能访问。</li>
</ul>
<p>要浏览中央仓库的内容，maven 社区提供了一个 URL：<a href="http://search.maven.org/#browse%E3%80%82%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%EF%BC%8C%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%E3%80%82">http://search.maven.org/#browse。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</a></p>
<h3 id="c-远程仓库"><a href="#c-远程仓库" class="headerlink" title="c.远程仓库"></a>c.远程仓库</h3><p>中央仓库是一些常用的库？远程仓库是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>
<h3 id="d-Maven依赖搜索顺序"><a href="#d-Maven依赖搜索顺序" class="headerlink" title="d.Maven依赖搜索顺序"></a>d.Maven依赖搜索顺序</h3><ul>
<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ul>
<h3 id="e-更换Maven阿里云仓库"><a href="#e-更换Maven阿里云仓库" class="headerlink" title="e.更换Maven阿里云仓库"></a>e.更换Maven阿里云仓库</h3><p>Maven根目录下，conf文件夹下setting.xml文件，mirrors节点上修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：pom.xml文件里添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;  </span><br><span class="line">        &lt;repository&gt;  </span><br><span class="line">            &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">            &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">            &lt;releases&gt;  </span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;  </span><br><span class="line">            &lt;/releases&gt;  </span><br><span class="line">            &lt;snapshots&gt;  </span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;  </span><br><span class="line">            &lt;/snapshots&gt;  </span><br><span class="line">        &lt;/repository&gt;  </span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Maven命令"><a href="#6-Maven命令" class="headerlink" title="6.Maven命令"></a>6.Maven命令</h2><p><code>maven -version   Maven版本及控制信息</code></p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   构建java项目</code>   </p>
<p><code>mvn archetype:create  -DgroupId=   DartifactId=   -DarchetypeArtifactId=maven-archetype-webapp ls创建web项目</code></p>
<p><code>mvn compile     编译源代码</code>     </p>
<p><code>mvn test-compile    编译测试代码</code></p>
<p><code>mvn clean   打包前清理掉之前有过打包的文件夹target</code></p>
<p><code>mvn package  打包，package包括了编译、打包这两步</code>    </p>
<p>![image-20210825113016694](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210825113016694.png)</p>
<p><code>mvn install   将打包好的jar包部署到本地，放到本地仓库</code> </p>
<h2 id="7-运行jar包"><a href="#7-运行jar包" class="headerlink" title="7.运行jar包"></a>7.运行jar包</h2><p><code>java -jar ideamaven-1.0-SNAPSHOT.jar</code></p>
<p>问题：<code>ideamaven-1.0-SNAPSHOT.jar中没有主清单属性</code></p>
<p>解决：找不到<code>main</code>方法，需要在<code>pom.xml</code>配置<code>main</code>方法的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--  添加main方法   --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">      &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">      &lt;/goals&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;transformers&gt;</span><br><span class="line">          &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">            &lt;!-- 在这里指定入口类 --&gt;</span><br><span class="line">            &lt;mainClass&gt;com.liuxuan.hello&lt;/mainClass&gt;</span><br><span class="line">          &lt;/transformer&gt;</span><br><span class="line">        &lt;/transformers&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">  &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>mvn打包和jar包运行问题未解决。</p>
<p>问题：<code>Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project ideamaven: Compilation failure</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go">https://console.cloud.baidu-int.com/devops/icode/repos/baidu/netdisk/platform-idproducter/reviews/18480257/files/base...latest/service/create_service.go</a></p>
<p><a href="https://blog.csdn.net/wfy2695766757/article/details/81189291">https://blog.csdn.net/wfy2695766757/article/details/81189291</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis入门</title>
    <url>/2022/03/12/myblog/JAVA/Mybatis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>mybatis</strong></p>
<h3 id="⛽️第一课"><a href="#⛽️第一课" class="headerlink" title="⛽️第一课"></a>⛽️第一课</h3><p>✅开发步骤：</p>
<p>1.添加Mybatis的坐标、mysql的驱动（pom.xml中）</p>
<p>2.创建数据表、编写对应的实体类（操作实体从而间接操作表，查询表从而间接封装实体）</p>
<p>3.编写映射文件UserMapper.xml  主要描述sql文件（第一个点：namespace命名空间，第二个点：id和resultType，通过命名空间.id进行调用，resultType结果集，封装到指定的类型中）</p>
<p>4.编写核心文件sqlMapConfig.xml，配置mybatis核心内容的，配置数据源信息、加载映射文件（可能很多）。</p>
<p>5.编写测试类（1.获取核心配置文件 2.获得session工厂对象 3.获得session会话对象 4.执行操作 5.打印数据 6.释放资源）</p>
<p>mybatis映射文件： </p>
<p><img src="https://img-blog.csdnimg.cn/6779525e71d546109fea38a2120c0479.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="Pasted Graphic.tiff"></p>
<p>DTD约束头在写标签或者属性时能给提示。</p>
<p>✅什么是mybatis？</p>
<p>是apache的一个开源项目iBatis，2010年迁移到google code，改名为mybatis，2013年迁移到github。</p>
<p>Mybatis是一个实现了数据持久化的开源框架，简单理解就是对JDBC进行封装。</p>
<p>ORMapping：Object Relationship Mapping 对象关系映射</p>
<p>对象：面向对象</p>
<p>关系：关系型数据库</p>
<p>映射：java到mysql的映射，开发者以面向对象的思想来管理数据库。</p>
<p>✅mybatis优缺点</p>
<p>优点：</p>
<p>1⃣️与JDBC相比，减少50%代码量</p>
<p>2⃣️最简单的持久化框架，小巧简单</p>
<p>3⃣️灵活，不会对程序或数据库的现有设计强行加任何影响，sql写在xml中，从程序代码中彻底分离，解耦合，可重用。</p>
<p>4⃣️提供xml标签，支持编写动态sql语句。</p>
<p>5⃣️提供映射标签，支持对象的属性与数据库的ORM字段关系映射。</p>
<p>缺点：</p>
<p>1⃣️半自动的，sql语句编写工作量大</p>
<p>2⃣️依赖于数据库，数据库迁移性差。</p>
<p>✅Mybatis核心接口和类</p>
<p>java和Mybatis的连接者：sqlsession</p>
<p>SqlSessionFactoryBuilder接口 build()方法。得到SqlSessionFactory（工厂对象）。调用openSession()方法，获得SqlSession。</p>
<p>✅Mybatis的开发方式</p>
<p>1⃣️使用原生接口</p>
<p>2⃣️Mapper代理实现自定义接口</p>
<p>两种方法都是通过sqlsession的相关方法来完成的。</p>
<p>✅创建第一个mybatis项目</p>
<p>1⃣️新建一个maven项目</p>
<p>pom.xml文件：增加mybatis坐标org.mybatis. mysql驱动</p>
<p>❓pom.xml中加入依赖显红怎么办？</p>
<p>解决：首先删除.m文件夹下的repo文件夹，然后回到项目右键pom.xml，选maven，选reimport</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2⃣️新建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"> username <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> password <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>3⃣️新建数据表对应的实体类</p>
<p>这里用Lombok库，用来自动生成构造方法.类级别的 @Data 注释是由 Lombok 提供的，它告诉 Lombok 生成所有缺少的方法，以及接受所有final属性作为参数的构造函数。</p>
<p>加lombok依赖时，有错误，因为版本号的原因。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4⃣️创建mybatis配置文件 config.xml 文件名可自定义，建在resource文件夹中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置Mybatis运行环境 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 下面可以多个environment，但是上面选一个 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!-- 配置jdbc事务管理 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!--POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xuan&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jade&quot;</span>/&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>5⃣️使用原生接口的方式开发</p>
<p>（1）Mybatis框架需要开发者自定义sql语句，写在Mapper.xml文件中，实际开发中，会为每个实体类创建对应的Mapper.xml，定义管理该对象数据的SQL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace是mybatis加载配置文件时要找的路径（包+文件名的形式）。</span></span><br><span class="line"><span class="comment">  id是一会儿调用sql语句时要用的名字，自定义的.</span></span><br><span class="line"><span class="comment">  parameterType是要传入的参数,下面语句是从对象中取值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mybatis.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    insert into account(username, password, age) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在全局配置文件config.xml中注册AccountMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册AccountMapper.xml，加载映射文件，这里带后缀，所以用路径/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）调用mybatis的原生接口执行添加操作，写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.demo.mybatis.entity.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInsert</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//加载mybatis配置文件config.xml</span></span><br><span class="line">​    InputStream inputStream = TestInsert.class.getClassLoader().getResourceAsStream(<span class="string">&quot;config.xml&quot;</span>); <span class="comment">//变成一个流</span></span><br><span class="line">​    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">​    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); <span class="comment">//传入流</span></span><br><span class="line">​    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//然后就可以进行java和mysql的关联，结合namespace和id获取位置</span></span><br><span class="line">​    <span class="comment">//因为配置文件已经加载到环境中，因此可以通过下面找到</span></span><br><span class="line">​    String statement = <span class="string">&quot;com.demo.mybatis.mapper.AccountMapper.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//传参数需要对象，因此需要实例化一个对象</span></span><br><span class="line">​    Account account = <span class="keyword">new</span> Account(<span class="number">1L</span>, <span class="string">&quot;liu&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">12</span>);</span><br><span class="line">​    sqlSession.insert(statement, account);</span><br><span class="line">​    <span class="comment">//commit方法提交事务</span></span><br><span class="line">​    sqlSession.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>❓出现问题，明明已经有lombok，可是在对象实例化的时候还是有问题。</p>
<p>解决：添加插件：设置里找到plugins，搜索lombok plugin，安装，重启。勾选配置：setting–&gt;build,excecution,deployment–&gt;compiler–&gt;annotation processors勾选上 enable annotation processing。即可生效。</p>
<p>⚠️maven工程中不能直接读取resource以外的xml文件，得在pom里加一个配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>❓java.lang.ClassNotFoundException: Cannot find class: com.mysql.cj.jdbc</p>
<p>解决：<property name="driver" value="com.mysql.cj.jdbc.Driver"> 少写了Driver</property></p>
<p>🎉Success</p>
<h3 id="⛽️第二课"><a href="#⛽️第二课" class="headerlink" title="⛽️第二课"></a>⛽️第二课</h3><p>✅使用Mapper代理实现自定义接口</p>
<p>实际开发中推荐用这种。</p>
<p>Mapper是mybatis内部提供的组建，接口是开发者自己写，接口的实现类是由mybatis动态生成实现类，同时获取实现类的对象，可以直接用。</p>
<p>1⃣️自定义接口，定义相关的业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.mybatis.entity.Account;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(Account account)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2⃣️编写与接口相对应的Mapper.xml，定义接口方法对应的sql语句。</p>
<p>statement标签（如<code>&lt;insert&gt;</code>）可根据sql执行的业务选择insert、delete、update、select。</p>
<p>Mybatis会自动根据规则自动创建接口实现类的代理对象。</p>
<p>规则：</p>
<ol>
<li>Mapper.xml中namespace为接口的全类名。</li>
<li>Mapper.xml中statement的id为接口中对应的方法名。</li>
<li>Mapper.xml中statement的parameterType和接口中对应方法的参数类型一致。</li>
<li>Mapper.xml中statement的resultType和接口中对应的方法的返回值类型一致。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.demo.mybatis.repository.AccountRepository&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 映射 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 添加 修改 删除 三个操作在数据库返回的结果一定是int， 所以这里没有resultType属性 --&gt;</span></span><br><span class="line">​    insert into account(username, password, age) values(#&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    update account set username = #&#123;username&#125;, password = #&#123;password&#125;, age = #&#123;age&#125; where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">​    delete from account where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 不写集合类型，而写集合里的泛型类型 --&gt;</span></span><br><span class="line">​    select * from account</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line">​    select * from account where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3⃣️在config.xml中注册AccountRepository.xml</p>
<p><code>&lt;mappers&gt;</code></p>
<p>  <code>&lt;mapper resource=&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;&gt;&lt;/mapper&gt;</code></p>
<p>  <code>&lt;!-- 注册第二课中的AccountRepository.xml --&gt;</code></p>
<p>  <code>&lt;mapper resource=&quot;com/demo/mybatis/repository/AccountRepository.xml&quot;&gt;&lt;/mapper&gt;</code></p>
<p><code>&lt;/mappers&gt;</code></p>
<p>4⃣️测试</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">​    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置Mybatis运行环境 ,配置数据源信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 下面可以多个environment，但是上面选一个 --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!-- 配置jdbc事务管理 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">​      <span class="comment">&lt;!--POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xuan&quot;</span>/&gt;</span></span><br><span class="line">​        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jade&quot;</span>/&gt;</span></span><br><span class="line">​      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 注册AccountMapper.xml，加载映射文件，这里带后缀，所以用路径/ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/mapper/AccountMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">​    <span class="comment">&lt;!-- 注册第二课中的AccountRepository.xml --&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/demo/mybatis/repository/AccountRepository.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>🤔我对动态代理的理解：</p>
<p>自己只需要写一个类，框架为我动态代理实现接口的实现类，并且还给我实现类的对象，可以直接用。</p>
<p>可以看到第一种方法，确实比较复杂，需要自己写statement，但是说的自己写接口实现类？没有吧</p>
<h3 id="⛽️第三课"><a href="#⛽️第三课" class="headerlink" title="⛽️第三课"></a>⛽️第三课</h3><p>Mapper.xml解读</p>
<ol>
<li><p>statement标签，select、update、delete、insert分别对应查询、修改、删除、添加</p>
</li>
<li><p>parameterType：参数数据类型</p>
<p>A. 基本数据类型，通过id查询Account,  “long”</p>
<p>b. String类型，通过name查询Account，”java.lang.String”</p>
<p>C. 包装类，通过id查询Account。“java.lang.long”</p>
</li>
</ol>
<p>​     {用包装类的好处：基本数据类型接受不了null，null传进来报异常，业务中可能会有null，需要判断}</p>
<p>   D.多个参数，通过username和age查询account</p>
<p>​     ⚠️：如果返回结果可能多个，就得List。好像多个操作commit一次就行吧。</p>
<p>   e.java bean</p>
<p>​    update操作传入的account对象</p>
<ol>
<li><p>resultType结果类型</p>
<p>A. 基本数据类型</p>
<p>B. 包装类 java.lang.Integer</p>
<p>C. string类型，比如通过id查询username</p>
</li>
</ol>
<p>  ⚠️看到id有中断，这是因为之前程序有错异常了，没commit提交，但是id已经涨了。</p>
<p>   D. Java bean</p>
<p>​    findAll返回的account对象</p>
<h3 id="⛽️第四课"><a href="#⛽️第四课" class="headerlink" title="⛽️第四课"></a>⛽️第四课</h3><p>✅及联查询</p>
<p>1⃣️一对多，一个班对应多个学生</p>
<p>要查询id=1的学生的名字、班级</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> cid <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询语句： <code>select * from student s, classes c where s.id =1 and s.cid=c.id;</code></p>
<p>🤔首先建接口，再写xxxRepository.xml, 再把xml文件加载到config中。 测试代码中，用方法就好了。</p>
<p>🏁mybatis和java类怎么做到映射，mybatis不关注表和类的结构，关注的是结果集和类的映射。</p>
<p>从select查出来的结果集，到赋给resutl的结果的映射。从结果集里按顺序找result对的上的字段，赋给result。</p>
<p>应该给后面的取别名。这里关于班级的信息要赋给classes对象，需要建立映射，用resultMap。</p>
<p>注意映射的时候，是看这个查询结果集上面的字段。</p>
<p>这样就完成了，结果类 和 结果集的映射</p>
<p>2⃣️通过classes查students</p>
<p>通过班级id，查出整个classes类.</p>
<p>首先写接口，再写xml文件，xml文件中先写sql语句，完成映射，添加到config，测试。</p>
<p>⚠️注意结果集要用resultMap，要还是用resultType的话，相当于写的映射没有用到。</p>
<p>3⃣️多对多</p>
<p>比如说，客户和商品，这两个是多对多的关系。</p>
<p>customer表和goods表，中间需要建一个从表customer_goods，里面cid表示客户表的外键，gid表示商品表的外键。</p>
<p>customer类中，有一个goods集合</p>
<p>goods类中，有一个custimer集合</p>
<p>要做的是：根据customer的id，返回custimer类。</p>
<p><code>select c.id as cid, c.name as came, g.id as gid, g.name as gname from customer as c, goods as g， customer_goods as cg where c.id=1 and cg.cid = c.id and cg.gid = g.id;</code> </p>
<p>返回id=1的客人买的商品。</p>
<p>⚠️知识点；笛卡尔积，需要找这两张表的关联关系：第三张表.</p>
<p>根据一对多来建立多对多的映射就好了，不同之处在去sql语句中两张表建立关系的方式是通过第三张表了。</p>
<p>但是xml文件中构建映射要看的是sql语句返回结果集和接口方法要返回的返回类对象。</p>
<h3 id="⛽️第五课"><a href="#⛽️第五课" class="headerlink" title="⛽️第五课"></a>⛽️第五课</h3><p>✅逆向工程</p>
<p>对传统开发反向的一个方式。</p>
<p>Mybatis框架需要：实体类、自定义的Mapper接口、Mapper.xml。</p>
<p>传统的开发中，上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者自动创建这三个组件，减轻开发者的工作量，提高工作效率。</p>
<p>缺点：逆向工程只能执行一次，逆向工程根据数据表来建立实体类等，如果改了表结构，就需要重新执行一次逆向工程。</p>
<p>如果改了表结构，就需要删了已经存在的，重新执行。</p>
<p>====</p>
<p>如何使用：</p>
<p>Mybatis Generator，简称MBG，是一个专门为Mybatis框架开发者定制的代码生成器和自动生成Mybatis框架所需的实体类、Mapper接口、Mapper.xml，支持基本CRUD操作，但是一些相对复杂的sql需要开发者自己来完成。</p>
<p>1⃣️新建Maven工程，引入依赖</p>
<p>数据库建个表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line"> id int primary key auto_increment,</span><br><span class="line"> name varchar(11),</span><br><span class="line"> age int</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2⃣️创建MBG配置文件generatorConfig.xml</p>
<p> \1. jdbcConnection 配置数据库连接信息</p>
<p> \2. javaModelGenerator 配置javaBean的生成策略，要把创建的实体类放在哪个包里</p>
<p> \3. sqlMapGenerator 配置sql映射文件生成策略</p>
<p> \4. javaClientGenerator 配置Mapper接口</p>
<p> \5. table 配置目标数据表（tableName：表名，dominObjectName：JavaBean类名）</p>
<p>3⃣️创建Generator执行类</p>
<p>启动类main，里面没有业务逻辑，没理解反正是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.InvalidConfigurationException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.XMLParserException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">​    List&lt;String&gt;warings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">​    <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">​    String genCig = <span class="string">&quot;/generatorConfig.xml&quot;</span>; <span class="comment">// /就表示resource文件夹</span></span><br><span class="line">​    File configFile = <span class="keyword">new</span> File(Main.class.getResource(genCig).getFile()); <span class="comment">//获取运行时类，getResource(路径)，获取配置文件</span></span><br><span class="line"></span><br><span class="line">​    ConfigurationParser configurationParser = <span class="keyword">new</span> ConfigurationParser(warings);</span><br><span class="line">​    Configuration configuration = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      configuration = configurationParser.parseConfiguration(configFile);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (XMLParserException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">​    MyBatisGenerator myBatisGenerator = <span class="keyword">null</span>;</span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(configuration, callback, warings);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (InvalidConfigurationException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span> &#123;</span><br><span class="line">​      myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">​      throwables.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>IDEA抛出异常快捷键：</strong></p>
<p><strong>Mac</strong></p>
<p><strong>方式一（光标移到该代码行，option+Enter），可以异常外抛出，也可以try-catch：</strong></p>
<p><strong>方式二（光标移到该代码行，或者选中该行代码，option+command+T）：[使用关键字或控制语句，比如if…else, try…catch, for, synchronized等]</strong></p>
<p>4⃣️<strong>然后运行main方法，文件夹下什么都有了，而且根据数据库的表建立了实体类。</strong></p>
<h3 id="⛽️第六课"><a href="#⛽️第六课" class="headerlink" title="⛽️第六课"></a>⛽️<strong>第六课</strong></h3><p>✅<strong>延迟加载</strong></p>
<p><strong>什么是延迟加载？也叫懒加载、惰性加载</strong></p>
<p><strong>使用延迟加载可以提高程序的运行效率，针对于数据的持久层的操作。在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了java应用与数据库的交互次数。</strong></p>
<p><strong>比如说上面及联查询时，查询学生和班级，学生和班级在两张不同的表，如果当前的需求只需要获取学生的信息，那么查询学生单表即可，如果需要通过学生获取对应的班级信息，则必须查询两张表。</strong></p>
<p><strong>不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的工作就是延迟加载。</strong></p>
<p><strong>举例：student和classes的例子里，两个接口里都增加一个方法，各自重写xml里面对应新增方法的sql语句，select语句不联表查询了，各查各的，测试时，首先得到student的名字，如果够了，就不用查classes表了，如果不够，再根据student的cid获得classes相关信息。</strong></p>
<p><strong>因此要在配置文件里完成一个连接的操作来自动识别是否还需要查另一张表，在</strong>association中。</p>
<p>实践效果：根据学生id，查到学生完成信息，包括里面的Classes类。</p>
<p>实际上进行了两次sql查询，本身student接口方法调用查询一次，student配置文件中select标签又查一次。</p>
<p>通过配置config文件中setting可以打印sql执行过程。</p>
<p>但是，只拿name的话，还是执行两次sql。因此需要在config中开启延迟加载。</p>
<p>奇怪了，我开启了延迟加载，只获得student的name，还是查两次。</p>
<p>⚠️出现问题，Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath.</p>
<p>应该增加CGLIB依赖。</p>
<p>❓依赖闲红的时候，必须要删除.m2文件夹下的所有依赖，然后reimport吗？</p>
<h3 id="⛽️第七课"><a href="#⛽️第七课" class="headerlink" title="⛽️第七课"></a>⛽️第七课</h3><p>✅MyBatis缓存</p>
<p>什么事mybatis缓存？使用缓存可以减少Java应用与数据库的交互次数，从而提高程序的运行效率。比如查询出id=1的对象，第一次查询出之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。</p>
<p>Mybatis缓存分类：</p>
<ol>
<li><strong>一级缓存：SqlSession级别，默认开启，并且不能关闭。</strong></li>
</ol>
<p>  <strong>操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。</strong></p>
<p>  <strong>一级缓存的作用域是SqlSession范围的，当在同一个SqlSession中执行两次相同的SQL语句时，第一次执行完毕将结果保存到缓存中，第二次查询时直接从缓存中获取。</strong></p>
<p>  <strong>需要注意的是：如果SqlSession执行了DML操作（insert、update、delete），Mybatis必须将缓存清空，来保证数据的准确性。</strong></p>
<ol>
<li><strong>二级缓存：Mapper级别的，默认关闭，可以开启。</strong></li>
</ol>
<p>  <strong>使用二级缓存时，多个SqlSession使用同一个Mapper的sql语句操作数据库，得到的数据会存在二级缓存中，同样是使用HashMap进行数据存储，相比较一级缓存，二级缓存的范围更大，多个sqlsession可以共用二级缓存。二级缓存是跨sqlsession的。</strong></p>
<p>  <strong>二级缓存是多个sqlsession共享的，其作用域是mapper的同一个namespqce，不同的sqlsession两次执行相同的namespace下的sql语句，参数也相同，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。</strong></p>
<p>⚠️<strong>一级缓存是一个sqlsession一个缓存。二级缓存是一个mapper一个，多个sqlsession 可能是使用的同一mapper，也就是同一个namespace。二级缓存范围更大。</strong></p>
<p><strong>如何开启二级缓存：</strong></p>
<p><strong>config.xml中</strong></p>
<p><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p>
<p><strong>然后再对应的mapper.xml中，添加配置二级缓存</strong></p>
<p><code>&lt;cache&gt;&lt;/cache&gt;</code></p>
<p><strong>然后实体类实现序列化接口</strong></p>
<p><code>public class Classes implements Serializable</code></p>
<ol>
<li><strong>第三方二级缓存。需要在pom.xml里添加相关依赖</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>然后添加配置文件ehcache.xml 不用自己写，定义了一些二级缓存的设置</strong></p>
<p><strong>然后在config.xml中开启二级缓存</strong></p>
<p><strong>然后在mapper.xml中配置二级缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;</span><br><span class="line">  &lt;!-- 缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔 --&gt;</span><br><span class="line">  &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">  &lt;!-- 缓存自创建时间起至失效的时间间隔 --&gt;</span><br><span class="line">  &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">  &lt;!-- 缓存的回收策略 ,LRU移除近期使用最少--&gt;</span><br><span class="line">  &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这个缓存里实体类内不需要实现序列化接口</strong></p>
<h3 id="⛽️第八课-Mybatis动态sql"><a href="#⛽️第八课-Mybatis动态sql" class="headerlink" title="⛽️第八课 Mybatis动态sql"></a>⛽️<strong>第八课 Mybatis动态sql</strong></h3><p><strong>sql语句是动态创建的，只需要定一个大致的样式，它会根据具体的参数、具体的业务去动态生成不同的sql。</strong></p>
<p><strong>背景：业务比较复杂时，如果需要我们手动去拼接sql语句来完成操作，效率比较低而且容易出错。</strong></p>
<p>❓<strong>发现test类里，第一行的加载类一直是第一次用的，这合理吗？</strong></p>
<p><strong>用一个account对象查account对象，根据对象的四个参数对应放到sql语句中，如果传入的account的一个参数没设置，则传到sql语句那里，这个字段=null。一般就没结果。</strong></p>
<p><strong>动态sql：只需要写一个模版，让程序自动根据属性是否有值，来动态决定是否加这个条件。</strong></p>
<p><strong>其实就是一个if else的流程，判断如果为null，就忽略掉，使得有结果。</strong></p>
<p><strong>使用动态sql的作用：可简化代码的开发，减少开发者的工作量，程序可以自动根据业务参数来决定sal的组成。</strong></p>
<ul>
<li><strong>if标签</strong></li>
</ul>
<p><strong>～～～～～</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByAccount1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select * from account where</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">​    id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">​    and username = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">​    and password = #&#123;password&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">​    age = #&#123;age&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>但是，如果第一个参数不给，就会出错，因为直接and后面的，语法错误。</strong></p>
<p><strong>将if标签的语句，放在where标签里就可以了。</strong></p>
<p><strong>if标签可以自动根据表达式的结果来决定是否将对应的语句添加到sql中，如果条件不成立则不添加，如果条件成立则添加。</strong></p>
<p><strong>where标签可以自动判断是否要删除语句块中的and关键字，如果监测到where直接跟and拼接，则自动删除and，通常情况下 if 和 where结合使用。</strong></p>
<ul>
<li><strong>choose、when标签</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByAccount2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  select * from account</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;id !=0 &quot;</span>&gt;</span></span><br><span class="line">​        id = #&#123;id&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;username !=null &quot;</span>&gt;</span></span><br><span class="line">​        username = #&#123;username&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;password !=null &quot;</span>&gt;</span></span><br><span class="line">​        password = #&#123;password&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​      <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span> = <span class="string">&quot;age !=0 &quot;</span>&gt;</span></span><br><span class="line">​        age = #&#123;age&#125;</span><br><span class="line">​      <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>trim标签：trim标签中的prefix和suffix属性会被用于生成实际的sql语句，会和标签内部的语句进行拼接，如果语句前后出现了prefixOverrides或者suffixOverrides属性中指定的值，Mybatis框架会自动将其删除。</strong></li>
</ul>
<ul>
<li><strong>set标签：用于update操作，会自动根据参数来选择生成sql语句。</strong></li>
</ul>
<p><strong>update传入的对象，如果set属性只有一个，相当于其他属性不传值，变为了null或者0.</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.demo.mybatis.entity.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  update account</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != 0&quot;</span>&gt;</span></span><br><span class="line">​      id = #&#123;id&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">​      and username = #&#123;username&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span></span><br><span class="line">​      and password = #&#123;password&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != 0&quot;</span>&gt;</span></span><br><span class="line">​      age = #&#123;age&#125;</span><br><span class="line">​    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">   where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这是sql拼接吗？</strong></p>
<ul>
<li><strong>foreach标签</strong></li>
</ul>
<p><strong>foreach标签可以迭代生成一系列值，这个标签主要用于sql的in语句。</strong></p>
<p><code>private List&lt;Long&gt; ids;</code></p>
<p><code>List&lt;Long&gt; ids = new ArrayList&lt;Long&gt;();</code></p>
<p><strong>还得在实体类里建一个List吗？感觉不太便利。</strong></p>
<p><code>&lt;select id=&quot;findByIds&quot; param&gt;</code></p>
<h3 id="⛽️第九课-mybatis-通用Mapper"><a href="#⛽️第九课-mybatis-通用Mapper" class="headerlink" title="⛽️第九课 mybatis 通用Mapper"></a>⛽️<strong>第九课 mybatis 通用Mapper</strong></h3><p><strong>虽然有逆向工程MBG，能够自动生成代码，但是entity改变会牵一发而动全身。</strong></p>
<p>1⃣️<strong>建表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mapperdemo(</span><br><span class="line"> id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line"> username <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> password <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mapperdemo (username, password, age) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;liuxuan&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">23</span>),</span><br><span class="line">(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;kk&#x27;</span>, <span class="number">22</span>),</span><br><span class="line">(<span class="string">&#x27;aks&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>



<p>2⃣️新建java实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.mybatis.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//有参构造</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mapperdemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>~~~~</p>
<p>考虑到基本数据类型在Java类型中都有默认值，会导致mybatis在执行相关操作时很难判断当前字段是否为null。因此在mybatis环境下使用基本数据类型对应的包装类型。(上面的作废)</p>
<p>✅mapper注解重来：</p>
<p>参考链接：<a href="https://blog.csdn.net/jintingbo/article/details/80517053">https://blog.csdn.net/jintingbo/article/details/80517053</a></p>
<p>从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件</p>
<p>现在我们通过一个简易的maven项目去了解@Mapper注解的使用方式：</p>
<p>1⃣️建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line"> pwd <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (name, pwd) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;liuxuan&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;kk&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;aks&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>2⃣️实体类</p>
<p>操作之前，从github上clone下来的项目出现问题</p>
<p>1.文件左下角有个橙色的小时钟，出现橙色原因：没有添加到maven解决办法：找到项目的xml,如果最外层没有xml,找到模块里面对应的xml,右键选择Add as Maven project. 导入通过maven导入jar。就解决了了。</p>
<p>2.项目依赖是红的，去maven仓库<a href="https://mvnrepository.com/">Maven Repository: Search/Browse/Explore</a>下下来，放在.m2文件夹下。</p>
<p>3.没弄sdk，弄成jdk1.8</p>
<p>4.奇了怪了，这个项目里实体类用Lombok，依赖显红，懵逼了。</p>
<p>5.p空间显红的解决办法：file–&gt;settings…–&gt;languages &amp; frameworks–&gt;schemas and DTDs –&gt; 添加url</p>
<p>3⃣️加载配置文件时找不到bean</p>
<p>不知道啥原因了，应该是mybatis结合spring，这一点还没掌握。</p>
<p>总之，使用方面，不需要在mapper.xml里写sql语句？</p>
<p>测试类里直接调用dao接口里的方法即可？</p>
<p>！！！项目里还是有sql语句的，接口里用@mapper @param注解，只是传递参数。和之前学的，只是在接口里多了这俩注解。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Page分页</title>
    <url>/2022/11/05/myblog/JAVA/Page%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h2><p>新建一个子工程web-repository。</p>
<p>mybatis依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--web-repository</span><br><span class="line"> --src</span><br><span class="line">  --main</span><br><span class="line">   --java</span><br><span class="line">     --config</span><br><span class="line">       --SpringConfig.java</span><br><span class="line">     --domain</span><br><span class="line">       --StudentDO.java</span><br><span class="line">     --StudentDao.java</span><br><span class="line">   --resource</span><br><span class="line">     --mapper</span><br><span class="line">  --test</span><br></pre></td></tr></table></figure>

<p>✅spring配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要引入spring依赖。</p>
<p>spring配置：<a href="https://www.cnblogs.com/fengyupinglan/p/14517267.html">https://www.cnblogs.com/fengyupinglan/p/14517267.html</a></p>
<p>✅spring整合mybatis</p>
<p>首先，spring配置文件可以是xml文件在resource文件夹下，也可以是注解方式的java文件。先写一个spring配置文件，自动装配搞上去。还有mybatis的一些bean要配置上去。</p>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p>xml文件方式，spring-mybatis.xml<br>开启自动扫描和配置bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.配置阿里druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库基本信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.配置spring的数据源，声明事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.配置 mybatis，扫描mapper.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.1 配置 mybatis config --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2 配置扫描mybatis映射文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.类似于 jdbcTemplate 帮助类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描了所有的*Mapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mapper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.example.mysql&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>druid需要依赖包：druid<br>SqlSessionFactoryBean 需要依赖包：spring-jdbc<br>还需要 ibatis-common</p>
<p>dbconfig.properties:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">db.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">db.password=jade</span><br><span class="line">db.username=liuxuan</span><br><span class="line">db.maxActive=5</span><br><span class="line">db.initialSize=1</span><br></pre></td></tr></table></figure>

<p>mybatis配置文件，mybatis-config.xml<br>一些configuration setting</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//ybatis.org//DTD SQL Map Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;REUSE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml方式spring整合mybatis，mybatis配置项的意义：<br><a href="https://blog.csdn.net/qq_45797116/article/details/117105095">https://blog.csdn.net/qq_45797116/article/details/117105095</a></p>
<p>xml文件中如果想引入其他xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;.../...xml&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>注解方式，SpringConfig.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.mysql.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;org.example&quot;&#125;)</span><br><span class="line">@ImportResource(&quot;classpath:spring-mybatis.xml&quot;) //导入xml配置项</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，可以用@Import导入其他注解方式的配置文件，以及用@ImportResource导入xml方式的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(CDPlayerConfig.class)  </span><br><span class="line">@ImportResource(&quot;classpath:cons-injec.xml&quot;) //导入xml配置项</span><br></pre></td></tr></table></figure>

<p>注解方式倒入配置文件：<br><a href="https://blog.csdn.net/weixin_42107384/article/details/116475637">https://blog.csdn.net/weixin_42107384/article/details/116475637</a></p>
<p>纯注解方式的整合spring和mybatis配置：<br><a href="https://blog.csdn.net/weixin_44226181/article/details/127343597">https://blog.csdn.net/weixin_44226181/article/details/127343597</a></p>
<p>还有一个一行代码的基于注解整合的：<br><a href="https://www.pudn.com/news/62f1dcb95425817ffc22c172.html">https://www.pudn.com/news/62f1dcb95425817ffc22c172.html</a></p>
<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public class StudentDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectById() &#123;</span><br><span class="line"></span><br><span class="line">        // xml：</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper mapper = (UserMapper) context.getBean(&quot;userMapper&quot;);</span><br><span class="line"></span><br><span class="line">        // 注解：</span><br><span class="line">        ApplicationContext context =new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        StudentDao studentDao = (StudentDao) context.getBean(&quot;studentDao&quot;);</span><br><span class="line"></span><br><span class="line">        StudentDO studentDO = studentDao.selectById(1L);</span><br><span class="line">        System.out.println(studentDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试验证及xml中配置SqlSessionFactory的bean和扫描的bean：<br><a href="https://blog.csdn.net/qq_28082757/article/details/103488364">https://blog.csdn.net/qq_28082757/article/details/103488364</a></p>
<p>配置数据库连接池有几种方法，上面用的是ali的druid连接池，关于Druid连接池：<br><a href="https://www.cnblogs.com/chy18883701161/p/12594889.html">https://www.cnblogs.com/chy18883701161/p/12594889.html</a></p>
<p>注解方式配置JdbcConfig中 PlatformTransactionManager 是事务管理，在spring-jdbc包下。<br><a href="https://www.jianshu.com/p/903c01cb2a77">https://www.jianshu.com/p/903c01cb2a77</a></p>
<p>@Mapper注解，难道是spring-boot才能用的？<br>mybatis支持的映射方式有基于xml的mapper.xml文件、基于java的使用Mapper接口class。<br>从mybatis3.4.0开始加入了@Mapper注解，目的就是为了不再写mapper映射文件。<br><a href="https://blog.csdn.net/weixin_46369022/article/details/122755858">https://blog.csdn.net/weixin_46369022/article/details/122755858</a><br>需要依赖包：mybatis-spring-boot-starter</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>✅ @Value里的字段报红</p>
<p>原因：自动导入了lombok里的@Value，要用的是SpringFramework下的@Value。</p>
<p>✅ xml配置文件加载不到properties属性问题</p>
<p>原因：spring中没有成功加载相应的配置文件</p>
<p>解决：进入File-Project Struccture，进入Facets中进行配置，.在右边的spring目录下，找到对应的爆红问题所在配置文件，选择xml文件，点击修改符合（下图中的小铅笔），在跳出来的弹框中，选择添加（加号），然后选择Additioonal properties files。然后找到需要加载进spring中的配置文件，点击OK，添加成功。</p>
<p>来自：<a href="https://blog.csdn.net/zhaogot/article/details/103224088">https://blog.csdn.net/zhaogot/article/details/103224088</a></p>
<p>✅ xml配置文件中的问题：根元素 “beans” 必须匹配 DOCTYPE 根 “null”</p>
<p>在<code>&lt;beans&gt;</code>标签那里报出来。</p>
<p>原因：mybatis在扫描Mapper.xml文件时，扫描到非mapper文件。比如本次报错扫描到了自己。spring.xml的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>当然不会有DOCTYPE了。<br>所以当Mybatis扫描到了Spring.xml这个非Mapper.xml文件时，自然找不到DOCTYPE，所以会有“DOCTYPE 根 “null””这个错误。</p>
<p>粗心：应该扫的是mybatis-config.xml文件，结构写成了自己。</p>
<p>来自：<a href="https://www.codeleading.com/article/7746743165/">https://www.codeleading.com/article/7746743165/</a></p>
<p>✅ org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</p>
<p>原因：mapper接口和xml文件没匹配上，有可能是文件名方法名没匹配上，这里是在配置文件里没加扫描接口，加了就好了。</p>
<p><a href="https://blog.csdn.net/weixin_43570367/article/details/103147854">https://blog.csdn.net/weixin_43570367/article/details/103147854</a></p>
<p>✅ properties文件 java.lang.NumberFormatException</p>
<p>明明是数字类型，但是说我从String转为int发生异常。</p>
<p>需要在xml配置文件中加载properties配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">ignore-unresolvable</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">location</span>=<span class="string">&#x27;classpath:dbconfig.properties&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring加载properties文件的几种方式：<br><a href="https://blog.csdn.net/chuige2013/article/details/121759088">https://blog.csdn.net/chuige2013/article/details/121759088</a></p>
<p>✅ java.sql.SQLException: com.mysql.cj.jdbc.Driver</p>
<p>mysql连接驱动依赖的版本不匹配问题，一般出现在使用低版本连接驱动连接高版本mysql情况下，解决方法是在maven中央仓库中下载高版本的mysql连接驱动.</p>
<p>mysql-connector-java 换8.0.21的包，自动引入没成功，手动下载装到.m2的。</p>
<p>✅ init datasource error, url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8</p>
<p>db.url换成：<code>jdbc:mysql://localhost:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</code></p>
<p>✅ Table ‘mysql.student’ doesn’t exist</p>
<p>上面mysql换成库名。</p>
<p>😄终于成功了，不容易。</p>
<h2 id="com-github-pagehelper"><a href="#com-github-pagehelper" class="headerlink" title="com.github.pagehelper"></a>com.github.pagehelper</h2><p>背景：使用Pige时，从数据库中获取到list之后，removeIf筛选，但是分页得到的效果不对，条目总数total是从数据库得到的list size。</p>
<p>原因：Page与Mybatis强耦合，不是先从数据库获取再分页，而是先获取某页要获取的条目，耦合到sql中查询。</p>
<p>难道只能是spring-boot用的？ pagehelper-spring-boot-starter 依赖包中。</p>
<p>PageHelper分页：<a href="https://blog.csdn.net/weixin_43958747/article/details/103822761">https://blog.csdn.net/weixin_43958747/article/details/103822761</a></p>
<p>其中有个参数为CallBack接口。</p>
<p>⚠️使用中的一个case：<br>Pageed中的list的元素得和数据库dao返回的数据结构一样，得是DO。获取了Paged之后再转为vo，因为分页Page和mybatis是强耦合的。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat入门教程</title>
    <url>/2022/03/12/myblog/JAVA/Tomcat%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a><strong>tomcat</strong></h3><p>为什么有tomcat？</p>
<p>一个项目：客户端+后端+数据库。</p>
<p>如何访问到服务？需要在web应用服务器里进行部署。</p>
<p>tomcat就是一个web应用服务器，就是一个服务，里面放java程序。</p>
<p>web应用服务器：tomcat、Jboos、Weblogic、Jetty。</p>
<p>有了tomcat可以实现两个电脑之间的互相访问，前提是在一个局域网里。</p>
<h3 id="1⃣️安装tomcat。"><a href="#1⃣️安装tomcat。" class="headerlink" title="1⃣️安装tomcat。"></a>1⃣️安装tomcat。</h3><p>apache出的，进入官网，选择tomcat9，下载压缩文件tar.gz</p>
<p>解压缩，放library里。</p>
<p>bin：存放各个平台下启动和停止tomcat服务的脚本文件。bat是windows系统下的脚本文件，sh是mac和linux的。</p>
<p>conf：存放各种tomcat服务器的配置文件，可以配置端口，server.xml。</p>
<p>lib：存放tomcat服务器需要的jar包。</p>
<p>logs：存放tomcat服务运行的日志。</p>
<p>temp：tomcat运行时的临时文件，文件上传下载io流的时候用，大文件放在java虚拟机内存里占用资源大，先放在temp文件夹里。</p>
<p>webapps：存放允许客户端访问的资源（java程序）。</p>
<p>work：存放tomcat将jsp转换之后的servlet文件。</p>
<h3 id="2⃣️idea集成tomcat"><a href="#2⃣️idea集成tomcat" class="headerlink" title="2⃣️idea集成tomcat"></a>2⃣️idea集成tomcat</h3><p>create new project –&gt; java enterprise –&gt; web application –&gt; 完成</p>
<p>index.jsp：写html的</p>
<p>web.xml：配置应用的</p>
<p>添加tomcat配置：右上角add configuration，点加号，tomcal，选local，配一个本地的tomcat，设置，写名字，选tomcat路径（主要就用tomcat的两个jar包：jsp、servlet）。相当于是把idea和tomcat映射起来了。设置url：默认浏览器，after launch是启动后自动打开浏览器，url是访问路径，访问到tomcat服务。然后选deployment添加java工程，点加号，选artifact，自动加进来了。相当于是把java工程放在test里了。然后apply，ok。</p>
<p>点右上角虫子图标。自动跳出来页面。关掉idea，就没了。</p>
<p>url由三部分组成：ip:port/application name</p>
<p>可以改应用的名字，在右上角edit application，选deployment，下面context改名字。重启就可以了。</p>
<p>也可以没有名字，只是一个/。</p>
<h3 id="3⃣️打包在tomcat运行"><a href="#3⃣️打包在tomcat运行" class="headerlink" title="3⃣️打包在tomcat运行"></a>3⃣️打包在tomcat运行</h3><p>1.首先基于maven进行打包，将war包复制到某个路径（不改配置的话放在webapps文件夹下）<br>2.对于放在其他文件夹的war包，在tomcat包下的conf文件夹下的server.xml文件增加配置（war包路径启动）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Host&gt; 标签下</span><br><span class="line">&lt;Context docBase=&quot;/Users/liuxuan/MyProject/java/log-maven-package.war&quot; </span><br><span class="line">        path=&quot;/log&quot; </span><br><span class="line">        reloadable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>path:指定访问该Web应用的URL入口<br>docBase:指定Web应用的文件路径，可以给定绝对路径，也可以给定相对于<code>&lt;Host&gt;</code>的appBase属性的相对路径，如果Web应用采用开放目录结构，则指定Web应用的 根目录，如果Web应用是个war文件，则指定war文件的路径。<br>reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。<br>Tomcat本身设置了Reloadable的属性，故Tomcat在检测到class文件发生变化之后，对WebApp的应用进行了重新加载：先卸载，再重新加载。<br>在开发阶段将reloadable属性设为true，有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议在Web应用的发存阶段将reloadable设为false。</p>
</blockquote>
<p>3.启动tomcat，之前配置过环境变量，所以不用区tomcat的bin目录下启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动：startup.sh</span><br><span class="line">关闭：shutdown.sh</span><br><span class="line">查看运行状态：ps -ef|grep tomcat</span><br><span class="line">查看启动日志：</span><br><span class="line">cd /usr/local/tomcat/apache-tomcat-8.5.51/logs/</span><br><span class="line">tail -200f catalina.out</span><br></pre></td></tr></table></figure>
<p>4.访问：<a href="http://localhost:8080/log/">http://localhost:8080/log/</a><br>5.外网如何访问：<a href="https://blog.csdn.net/weixin_30596023/article/details/98539676">https://blog.csdn.net/weixin_30596023/article/details/98539676</a><br>6.如何在服务器上部署：<a href="https://blog.csdn.net/qq_53324833/article/details/123802881">https://blog.csdn.net/qq_53324833/article/details/123802881</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson</title>
    <url>/2022/04/30/myblog/JAVA/fastjson/</url>
    <content><![CDATA[<p>fastjson是阿里出品的处理JSON字符串的Java类库，可以对JSON字符串、JSON对象、Java对象进行互相转换。需要导入fastjson包。</p>
<h3 id="String、JSONObject、Object转换"><a href="#String、JSONObject、Object转换" class="headerlink" title="String、JSONObject、Object转换"></a>String、JSONObject、Object转换</h3><p>一、字符串转成JSON对象/数组<br>字符串转成JSON对象<br>JSON.parseObject(String text)<br>JSON.parse(String text)</p>
<p>字符串转成JSON数组<br>JSON.parseArray(String text)<br>JSON.parse(String text)</p>
<p>二、字符串转成Java对象/列表<br>字符串转成Java对象<br>JSON.parseObject(String text, Class<T> clazz)</T></p>
<p>字符串转成Java对象列表<br>JSON.parseArray(String text, Class<T> clazz)</T></p>
<p>三、Java对象/列表转成JSON对象/数组<br>Java对象转成JSON对象<br>JSONObject.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>Java对象列表转成JSON数组<br>JSONArray.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>四、JSON对象/数组转成Java对象/列表<br>JSON对象转成Java对象<br>JSON.toJavaObject(JSON json, Class<T> clazz)<br>jsonObject.toJavaObject(JSON json) (非静态方法)</T></p>
<p>JSON数组转成Java对象列表<br>jsonArray.toJavaList(Class<T> clazz) (非静态方法)</T></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class FastJSONLearning &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    String jsonObjectStr = &quot;&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;&quot;;</span><br><span class="line">    String jsonArrayStr = &quot;[&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;,&#123;\&quot;prop\&quot;:\&quot;explain\&quot;,\&quot;label\&quot;:\&quot;中文释义\&quot;,\&quot;required\&quot;:true&#125;]&quot;;</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON对象/数组</span><br><span class="line">    // 字符串转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject1 = JSON.parseObject(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject2 = (JSONObject) JSON.parse(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray1 = JSON.parseArray(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray2 = (JSONArray) JSON.parse(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象/列表</span><br><span class="line">    // 字符串转成Java对象</span><br><span class="line">    Dict dict = JSON.parseObject(jsonObjectStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象: &quot; + dict.toString());</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList = JSON.parseArray(jsonArrayStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象列表: &quot; + dictList.toString());</span><br><span class="line"> </span><br><span class="line">    // Java对象/列表转成JSON对象/数组</span><br><span class="line">    // Java对象转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject3 = (JSONObject) JSONObject.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject4 = (JSONObject) JSON.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // Java对象列表转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray3 = (JSONArray) JSONArray.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray4 = (JSONArray) JSON.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // JSON对象/数组转成Java对象/列表</span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法1</span><br><span class="line">    Dict dict1 = JSON.toJavaObject(jsonObject1, Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict1);</span><br><span class="line"> </span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法2</span><br><span class="line">    Dict dict2 = jsonObject1.toJavaObject(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict2);</span><br><span class="line"> </span><br><span class="line">    // JSON数组转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList1 = jsonArray1.toJavaList(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON数组转成Java对象列表: &quot; + dictList1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/lasdaybg/p/15144350.html">https://www.cnblogs.com/lasdaybg/p/15144350.html</a></p>
<h3 id="json文件中获取"><a href="#json文件中获取" class="headerlink" title="json文件中获取"></a>json文件中获取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JsonTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void TestJ()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File jsonFile = ResourceUtils.getFile(&quot;classpath:hello.json&quot;);</span><br><span class="line">            String s = FileUtils.readFileToString(jsonFile);</span><br><span class="line">            System.out.println(&quot;s:&quot;+s);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;error:&quot;+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileUtils 需要导包：commons-io。<br>classpath表示项目中的resource文件夹。</p>
<h3 id="JSONObject、JSONArray"><a href="#JSONObject、JSONArray" class="headerlink" title="JSONObject、JSONArray"></a>JSONObject、JSONArray</h3><p>也是fastjson下的</p>
<p>JSON是互联网开发过程中应用最广泛的一种数据类型，不管是后端API接口中，还是在前端都能得到广泛应用。JSON 就是一种轻量级的数据交换格式，被广泛应用于 WEB 应用程序开发</p>
<p>在线解析：<a href="https://c.runoob.com/front-end/53/">https://c.runoob.com/front-end/53/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;area&quot;: &quot;山东菏泽&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;马马马马马百万&quot;,</span><br><span class="line">  &quot;age&quot;: [1,2,3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON、JSON对象、JSON数组区别<br>JSON 呢只是一种宏观上的叫法，可以理解为是一种数据结构，就像 xml 结构一样，是一种规约性内容；而 JSON 对象则是对 JSON 的具体体现；JSON 数组则是将多个 JSON 对象进行存储的一个集合，可以想象成 Java 中的 List 和 Object 的关系</p>
<h4 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h4><p>JSONObject 是根据 JSON 形式在 Java 中存在的对象映射<br>各大 JSON 类库的 JSONObject 内部实现也是不太一样的。<br>例如fastjson：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JSONObject extends JSON implements Map&lt;String, Object&gt;, Cloneable, Serializable, InvocationHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line">对 HashMap 的一层封装，并提供了一些个性化方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">json.put(&quot;key1&quot;,&quot;11&quot;);</span><br><span class="line">System.out.println(json.getInteger(&quot;key1&quot;));</span><br><span class="line">System.out.println(json.getString(&quot;key&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="JSONArray"><a href="#JSONArray" class="headerlink" title="JSONArray"></a>JSONArray</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JSONArray extends JSON implements List&lt;Object&gt;, Cloneable, RandomAccess, Serializable &#123;</span><br><span class="line">&#125;</span><br><span class="line">一个 List 中 套了个 Map 类结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">JSONObject drug = new JSONObject();</span><br><span class="line">drug.put(&quot;drugName&quot;, &quot;盐酸丁卡因注射液&quot;);</span><br><span class="line">JSONArray array = new JSONArray();</span><br><span class="line">array.add(person);</span><br><span class="line">array.add(drug);</span><br></pre></td></tr></table></figure>

<h4 id="各种转换"><a href="#各种转换" class="headerlink" title="各种转换"></a>各种转换</h4><p>普通对象、json字符串、jsonObject</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将对象转换为json字符串</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">String jsonStr = JSON.toJSONString(person);</span><br><span class="line">将json字符串转换为JSONObject对象</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonStr);</span><br><span class="line">将JSONObject 转换为对象</span><br><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">person.put(&quot;age&quot;, 25);</span><br><span class="line">Student stuObj = JSON.toJavaObject(person, Student.class);</span><br></pre></td></tr></table></figure>

<h3 id="一个对象转换为另一个对象"><a href="#一个对象转换为另一个对象" class="headerlink" title="一个对象转换为另一个对象"></a>一个对象转换为另一个对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B = JSON.parseObject(JSON.toString(a), b.class)</span><br></pre></td></tr></table></figure>


<h3 id="getJSONObject、getJSONArray"><a href="#getJSONObject、getJSONArray" class="headerlink" title="getJSONObject、getJSONArray"></a>getJSONObject、getJSONArray</h3><p>Fastjson中getJSONObject()与getJSONArray()，用于获取JSONObject里的JSONObject、JSONArray()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;    &quot;package&quot;: &#123;</span><br><span class="line">        &quot;List1&quot;: &#123;</span><br><span class="line">            &quot;errorCode&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;errorMsg&quot;: &quot;Success&quot;,</span><br><span class="line">            &quot;receiverTradeNum&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;List2&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;medicalNum&quot;: &quot;15XXXXXX&quot;,</span><br><span class="line">                &quot;queryDate&quot;: &quot;YYYYMMDD&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;XXX&quot;,</span><br><span class="line">                &quot;authorizationNum&quot;: &quot;xxxxx&quot;,</span><br><span class="line">                &quot;pageNum&quot;: &quot;1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = JSON.parseObject(jsonStr);</span><br><span class="line">JSONObject package = jsonObj.getJSONObject(&quot;package&quot;);     // 定位到package json对象</span><br><span class="line">JSONArray list = package.getJSONArray(&quot;List2&quot;);   //采用getJSONArray方法， 定位到json集合</span><br></pre></td></tr></table></figure>


<h3 id="XStream"><a href="#XStream" class="headerlink" title="XStream"></a>XStream</h3><p>XStream是Java类库，用来将对象序列化成XML（JSON）或反序列化为对象。<br>也就是说，使用XStream，我们可以把Java对象转换成XML，也可以将XML转换为Java对象。</p>
<p>依赖：<br>XStream的必导JAR包：<br>核心JAR包：xstream-1.4.7.jar；<br>必须依赖包：xpp3_min-1.1.4c.jar（XML Pull Parser，一款速度很快的XML解析器）。</p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XStream xStream = new XStream();</span><br><span class="line">xStream.alias(&quot;china&quot;, List.class);   //标签类换成指定字符</span><br><span class="line">xStream.alias(&quot;province&quot;, Province.class);</span><br><span class="line">xStream.alias(&quot;city&quot;, City.class);</span><br><span class="line"></span><br><span class="line">xStream.useAttributeFor(Province.class, &quot;name&quot;); //子元素编程熟悉</span><br><span class="line">xStream.addImplicitCollection(Province.class, &quot;cities&quot;);  //去掉cities标签</span><br><span class="line"></span><br><span class="line">String string = xStream.toXML(proList);</span><br><span class="line">System.out.println(string);</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://blog.csdn.net/u014565127/article/details/104419528">https://blog.csdn.net/u014565127/article/details/104419528</a></p>
<p><strong>高并发情况下的性能问题</strong></p>
<p>项目中使用了XStream进行XML序列化、反序列化的方案，完成服务之间的接口报文Object与Xmlg格式之间的转化。</p>
<p>当线上业务量并不大的情况下，一切正常；但是发现当业务量突然加大的情况下，突然发现，线上服务器出现CPU居高不下，服务接口调用速度越来越慢，研究JVM日志分析，发现出现很多的RUNNABLE问题。</p>
<p>问题原因：XStream在new的时候会创建CompositeClassLoader（初始类加载器），并且不断new会不断创建，导致ygc需要扫描的内容越来越多，最终导致接口调用性能下降。</p>
<p>XStream是线程安全的，不需要重复初始化xstream对象，每一种类型实例化一个对象即可，而正是由于开发人员错误地在每次处理时都实例化一个新的xstream对象，才导致了该问题。</p>
<p>解决：单列模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原来：</span><br><span class="line">XStream xstream = XStreamInitializer.getInstance();</span><br><span class="line">xstream.processAnnotations(this.getClass());</span><br><span class="line">xstream.aliasSystemAttribute(null, &quot;class&quot;);</span><br><span class="line">return xstream.toXML(this);</span><br><span class="line"></span><br><span class="line">现在：</span><br><span class="line">实现单列：</span><br><span class="line">public class XmlHandler&#123;</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentHashMap xStream = new ConcurrentHashMap&lt;String, XStream&gt;();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     * @param objName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static XStream getXStream(Class&lt;?&gt; objName) &#123;</span><br><span class="line">        String key = objName.getName();</span><br><span class="line">        if (xStream.get(key) == null)</span><br><span class="line">            xStream.put(key, new XStream());</span><br><span class="line">        return (XStream) xStream.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">序列化：</span><br><span class="line">XStream xstream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xstream.processAnnotations(Dog.class);</span><br><span class="line">String xml = xstream.toXML(dog);</span><br><span class="line"></span><br><span class="line">反序列化：</span><br><span class="line">XStream xStream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xStream.processAnnotations(Dog.class);</span><br><span class="line">Dog dog = (Dog) xStream.fromXML(xml);</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://blog.csdn.net/weixin_43767602/article/details/114824028">https://blog.csdn.net/weixin_43767602/article/details/114824028</a></p>
<h3 id="JSON与XML转化"><a href="#JSON与XML转化" class="headerlink" title="JSON与XML转化"></a>JSON与XML转化</h3><p>详见：<a href="https://blog.csdn.net/CDWLX/article/details/119038509">https://blog.csdn.net/CDWLX/article/details/119038509</a><br><a href="https://blog.csdn.net/baidu_37366055/article/details/110468129">https://blog.csdn.net/baidu_37366055/article/details/110468129</a></p>
<p>xml转json：用 org.jdom，用 dom 提取节点 转成map<br>json转xml： com.alibaba.fastjson.JSONObject</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.16.graal&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import org.dom4j.io.OutputFormat;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line">import org.dom4j.io.XMLWriter;</span><br><span class="line">import org.jdom.Document;</span><br><span class="line">import org.jdom.Element;</span><br><span class="line">import org.jdom.JDOMException;</span><br><span class="line">import org.jdom.input.SAXBuilder;</span><br><span class="line">import org.xml.sax.InputSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class JsonXML &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //请注意使用正常的xml</span><br><span class="line">        //xml-&gt;json</span><br><span class="line">//      String jsonStr = xmlToJson(&quot;D:\\NewFile.xml&quot;, null);</span><br><span class="line">//      System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line">        //json-&gt;xml</span><br><span class="line">        String xmlstr = jsonToXml(&quot;&#123;\&quot;b_content\&quot;:&#123;\&quot;sdata\&quot;:\&quot;Ps/DPJnZZPN6QQJQodY3+hK6PWCF3/2oi3DJPnFEXgKDrXX5rHT7q/I0nQPAruuBbQRfErnenQNvPpbf/lXl690qtye0/ZEuDs0ByFdFAGffQalB+Ij3lLUMDPz=\&quot;,\&quot;userobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;ma000\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;法人用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;10\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市天河区天河北路XXX号\&quot;,\&quot;legal_code=440***********033\&quot;,\&quot;ent_type=-1\&quot;,\&quot;link_person_code=350************14\&quot;,\&quot;origin=gdbs\&quot;,\&quot;card_type_two_num=-1\&quot;,\&quot;cert_ca=-1\&quot;,\&quot;accout_type=2\&quot;,\&quot;account_uid=2\&quot;,\&quot;comm_code=-1\&quot;,\&quot;unit_type=-1\&quot;,\&quot;legal_id_type=10\&quot;,\&quot;landline=-1\&quot;,\&quot;tax_code=-1\&quot;,\&quot;cert_notafter=-1\&quot;,\&quot;card_type_one_num=-1\&quot;,\&quot;local_user=-1\&quot;,\&quot;legal_person=郑**\&quot;,\&quot;link_person_type=10\&quot;,\&quot;card_type_three=-1\&quot;,\&quot;card_type_two=-1\&quot;,\&quot;card_type_three_num=-1\&quot;,\&quot;cert_data=-1\&quot;,\&quot;area=guangzhou\&quot;,\&quot;uversion=3.0\&quot;,\&quot;cert_notbefore=-1\&quot;,\&quot;card_type_one=-1\&quot;,\&quot;user_typeext=2\&quot;],\&quot;idcardnumber\&quot;:\&quot;11***************23\&quot;,\&quot;useridcode\&quot;:\&quot;38c97fa1ee2e43d4a664cffc4554cde4\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;pareobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;mayintao\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;单位用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;50\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市东山区\&quot;,\&quot;legal_id_type=-1\&quot;,\&quot;link_person_type=-1\&quot;,\&quot;legal_code=-1\&quot;,\&quot;origin=gdbs\&quot;,\&quot;tax_code=-1\&quot;,\&quot;legal_person=-1\&quot;,\&quot;area=shenzhen\&quot;,\&quot;link_person_code=-1\&quot;,\&quot;user_typeext=2\&quot;,\&quot;uversion=1.0\&quot;],\&quot;idcardnumber\&quot;:\&quot;456787654\&quot;,\&quot;useridcode\&quot;:\&quot;75c91fagrr2e67d4a169cfmc8735ctrf\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;user_creditable_level\&quot;:&#123;\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account_way_list\&quot;:[&#123;\&quot;auth_time\&quot;:\&quot;2018-02-28 16:45:26\&quot;,\&quot;uniqueid\&quot;:\&quot;***86f93fb61***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;2088******653\&quot;,\&quot;identity_level\&quot;:\&quot;L2\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;YSS\&quot;&#125;,&#123;\&quot;auth_time\&quot;:null,\&quot;uniqueid\&quot;:\&quot;***764486f93fb61212***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L0\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;IDV\&quot;&#125;,&#123;\&quot;auth_time\&quot;:\&quot;2018-02-13 17:12:31\&quot;,\&quot;uniqueid\&quot;:\&quot;*****764486f93fb612122*****\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L3\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;GW\&quot;&#125;],\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;&#125;,\&quot;time_stamp\&quot;:\&quot;20200821\&quot;,\&quot;version \&quot;:\&quot;v1\&quot;,\&quot;sign\&quot;:\&quot;rxf0MFT7eQqYgYKWtgzNBi6mhS2tbqkPgI \&quot;&#125;&quot;);</span><br><span class="line">        System.out.println(xmlstr);</span><br><span class="line">        createXMLFile(formatXML(xmlstr), &quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * xml转json字符串 注意:路径和字符串二传一另外一个传null&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToJson &lt;br&gt;</span><br><span class="line">     * @param xmlPath xml路径(和字符串二传一,两样都传优先使用路径)</span><br><span class="line">     * @param xmlStr xml字符串(和路径二传一,两样都传优先使用路径)</span><br><span class="line">     * @return String</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws JDOMException</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static String xmlToJson(String xmlPath,String xmlStr)&#123;</span><br><span class="line">        SAXBuilder sbder = new SAXBuilder();</span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        Document document;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(xmlPath!=null)&#123;</span><br><span class="line">                //路径</span><br><span class="line">                document = sbder.build(new File(xmlPath));</span><br><span class="line">            &#125;else if(xmlStr!=null)&#123;</span><br><span class="line">                //xml字符</span><br><span class="line">                StringReader reader = new StringReader(xmlStr);</span><br><span class="line">                InputSource ins = new InputSource(reader);</span><br><span class="line">                document = sbder.build(ins);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return &quot;&#123;&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取根节点</span><br><span class="line">            Element el =  document.getRootElement();</span><br><span class="line">            List&lt;Element&gt; eList =  el.getChildren();</span><br><span class="line">            Map&lt;String, Object&gt; rootMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            //得到递归组装的map</span><br><span class="line">            rootMap = xmlToMap(eList,rootMap);</span><br><span class="line">            map.put(el.getName(), rootMap);</span><br><span class="line">            //将map转换为json 返回</span><br><span class="line">            return JSON.toJSONString(map);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转xml&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXml &lt;br&gt;</span><br><span class="line">     * @param json</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXml(String json)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            StringBuffer buffer = new StringBuffer();</span><br><span class="line">            buffer.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);</span><br><span class="line">            buffer.append(&quot;&lt;base&gt;&quot;);</span><br><span class="line">            JSONObject jObj = JSON.parseObject(json);</span><br><span class="line">            jsonToXmlstr(jObj,buffer);</span><br><span class="line">            buffer.append(&quot;&lt;/base&gt;&quot;);</span><br><span class="line">            return buffer.toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转str&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXmlstr &lt;br&gt;</span><br><span class="line">     * @param jObj</span><br><span class="line">     * @param buffer</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXmlstr(JSONObject jObj,StringBuffer buffer )&#123;</span><br><span class="line">        Set&lt;Entry&lt;String, Object&gt;&gt;  se = jObj.entrySet();</span><br><span class="line">        for( Iterator&lt;Entry&lt;String, Object&gt;&gt;   it = se.iterator();  it.hasNext(); )</span><br><span class="line">        &#123;</span><br><span class="line">            Entry&lt;String, Object&gt; en = it.next();</span><br><span class="line">            if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONObject&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                JSONObject jo = jObj.getJSONObject(en.getKey());</span><br><span class="line">                jsonToXmlstr(jo,buffer);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONArray&quot;))&#123;</span><br><span class="line">                if (en.getKey().equals(&quot;extproperties&quot;)) &#123;</span><br><span class="line">                    JSONArray ja = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    Iterator&lt;Object&gt; it1 = ja.iterator();</span><br><span class="line">                    List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">                    while (it1.hasNext()) &#123;</span><br><span class="line">                        String ob = (String) it1.next();</span><br><span class="line">                        System.out.println(ob);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    JSONArray jarray = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    for (int i = 0; i &lt; jarray.size(); i++) &#123;</span><br><span class="line">                        buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                        JSONObject jsonobject =  jarray.getJSONObject(i);</span><br><span class="line">                        jsonToXmlstr(jsonobject,buffer);</span><br><span class="line">                        buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;java.lang.String&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+en.getValue());</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+&quot;&quot;);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 节点转map&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToMap &lt;br&gt;</span><br><span class="line">     * @param eList</span><br><span class="line">     * @param map</span><br><span class="line">     * @return Map&lt;String,Object&gt;</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static Map&lt;String, Object&gt; xmlToMap(List&lt;Element&gt; eList,Map&lt;String, Object&gt; map)&#123;</span><br><span class="line">        for (Element e : eList) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; eMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            List&lt;Element&gt; elementList = e.getChildren();</span><br><span class="line">            if(elementList!=null&amp;&amp;elementList.size()&gt;0)&#123;</span><br><span class="line">                eMap = xmlToMap(elementList,eMap);</span><br><span class="line">                Object obj = map.get(e.getName());</span><br><span class="line">                if(obj!=null)&#123;</span><br><span class="line">                    List&lt;Object&gt; olist = new ArrayList&lt;Object&gt;();</span><br><span class="line">                    if(obj.getClass().getName().equals(&quot;java.util.HashMap&quot;))&#123;</span><br><span class="line">                        olist.add(obj);</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line"></span><br><span class="line">                    &#125;else if(obj.getClass().getName().equals(&quot;java.util.ArrayList&quot;))&#123;</span><br><span class="line">                        olist = (List&lt;Object&gt;)obj;</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(e.getName(), olist);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map.put(e.getName(), eMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(e.getName(), e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将已经格式化的xml字符串写入xml文件</span><br><span class="line">     * @param xmlStr</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean createXMLFile(String xmlStr,String xmlName)&#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            XMLWriter output = null;</span><br><span class="line">            //OutputFormat   format   =   OutputFormat.createPrettyPrint();</span><br><span class="line">            //format.setSuppressDeclaration(true);</span><br><span class="line">            // format.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为GBK，则应当用FileWriter来构建xml文件，否则会出现中文连码问题</span><br><span class="line">                /*outpt = new XMLWriter(</span><br><span class="line">                        new FileWriter(</span><br><span class="line">                                new File(&quot;D:/myeclipse/Workspaces/fusionChartsDemoTest/WebRoot/xml/&quot;+xmlName+&quot;.xml&quot;)) ,</span><br><span class="line">                                    format);</span><br><span class="line">                  */</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为utf-8，则应当用FileOutputStream来构建xml文件，否则还是会出现问题</span><br><span class="line">            output = new XMLWriter(</span><br><span class="line">                    new FileOutputStream(</span><br><span class="line">                            new File(&quot;D:/&quot;+xmlName+&quot;.xml&quot;)));</span><br><span class="line">            output.setEscapeText(false);</span><br><span class="line">            output.write( xmlStr );</span><br><span class="line">            output.close();</span><br><span class="line">            return flag = true;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  String formatXML(String str) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        SAXReader reader=new SAXReader();</span><br><span class="line"></span><br><span class="line">        //创建一个串的字符输入流</span><br><span class="line">        StringReader in=new StringReader(str);</span><br><span class="line">        org.dom4j.Document doc=reader.read(in);</span><br><span class="line">        // 创建输出格式</span><br><span class="line">        OutputFormat formater=OutputFormat.createPrettyPrint();</span><br><span class="line">        //去掉xml文件的版本信息</span><br><span class="line">        //formater.setSuppressDeclaration(true);</span><br><span class="line">        //设置xml的输出编码</span><br><span class="line">        formater.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        //创建输出(目标)</span><br><span class="line">        StringWriter out=new StringWriter();</span><br><span class="line">        //创建输出流</span><br><span class="line">        XMLWriter writer=new XMLWriter(out,formater);</span><br><span class="line">        //输出格式化的串到目标中，执行后。格式化后的串保存在out中。</span><br><span class="line">        writer.write(doc);</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line"></span><br><span class="line">        // System.out.println(out.toString());</span><br><span class="line"></span><br><span class="line">        //返回我们格式化后的结果</span><br><span class="line">        return out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java的junit与mock测试</title>
    <url>/2022/04/14/myblog/JAVA/java%20junit%E4%B8%8Emock%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>单元测试(Unit test)：<br>单元测试关注单一的类. 它们存在的目的是检查这个类中的代码是否按照期望正确运行.<br>特征：快速、独立、可重复、自检查（不加main不打日志）<br>核心价值：缩短反馈周期，降低缺陷修复成本，理解代码意图</p>
<p>集成测试(Integration test)<br>顾名思义, 集成测试是检查开发的模块和其他模块整合时是否正常工作.<br>虽然集成测试的代码影响范围比单元测试要广, 但是集成测试和单元测试一样, 也是针对于开发者而言的.<br>集成测试是对外部系统（数据库、消息队列等）有依赖的测试。</p>
<p>端到端测试(End-to-End test)<br>端到端测试是将整个系统作为一个整体, 然后从用户的角度进行测试的.<br>端到端测试的目的是测试系统在实际使用的是否正常的, 因此通常来说是不需要测试替身的(Test Double)</p>
<h2 id="1-Junit单元测试"><a href="#1-Junit单元测试" class="headerlink" title="1.Junit单元测试"></a>1.Junit单元测试</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单元测试的目的: 测试当前所写的代码是否是正确的, 例如输入一组数据, 会输出期望的数据; 输入错误数据, 会产生错误异常等.</p>
<p>在单元测试中, 我们需要保证被测系统是独立的(SUT 没有任何的 DOC), 即当被测系统通过测试时, 那么它在任何环境下都是能够正常工作的. 编写单元测试时, 仅仅需要关注单个类就可以了. 而不需要关注例如数据库服务, Web 服务等组件.</p>
<p>【SUT】被测系统(System under test, SUT) 被测系统。根据测试类型的不同, SUT 指代的内容也不同, 例如 SUT 可以是一个类甚至是一整个系统.</p>
<p>【DOC】被测系统所依赖的组件, 例如进程 UserService 的单元测试时, UserService 会依赖 UserDao, 因此 UserDao 就是 DOC</p>
<p>【Test Double】测试替身<br>一个实际的系统会依赖多个外部对象, 但是在进行单元测试时, 我们会用一些功能较为简单的并且其行为和实际对象类似的假对象来作为 SUT 的依赖对象, 以此来降低单元测试的复杂性和可实现性. 在这里, 这些假对象就被称为 测试替身(Test Double).</p>
<p>测试替身有以下五种：</p>
<p>1.Test stub, 为 SUT 提供数据的假对象。stub 类有时候还会记录调用的一些信息。</p>
<p>2.Fake object，实现了简单功能的一个假对象. Fake object 和 Test stub 的主要区别就是 Test stub 侧重于用于提供数据的假对象, 而 Fake object 没有这层含义，使用 Fake object 的最主要的原因就是在测试时某些组件不可用或运行速度太慢, 因而使用 Fake object 来代替它们.<br>譬如说，它存在内存中而不是真正的数据库中。</p>
<p>3.Mock object<br>是指类或者接口的模拟实现，你可以自定义这个对象中某个方法的输出结果。<br>实际上, Mock object 是 Test stub 或 Fake object 一种, 但是 Mock object 有 Test stub/Fake object 没有的特性, Mock object 可以很灵活地配置所调用的方法所产生的行为, 并且它可以追踪方法调用, 例如一个 Mock Object 方法调用时传递了哪些参数, 方法调用了几次等.</p>
<p>4.Dummy object: 在测试中并不使用的, 但是为了测试代码能够正常编译/运行而添加的对象. 例如我们调用一个 Test Double 对象的一个方法, 这个方法需要传递几个参数, 但是其中某个参数无论是什么值都不会影响测试的结果, 那么这个参数就是一个 Dummy object.<br>Dummy object 可以是一个空引用, 一个空对象或者是一个常量等.<br>简单的说, Dummy object 就是那些没有使用到的, 仅仅是为了填充参数列表的对象.</p>
<p>5.Test Spy<br>可以包装一个真实的 Java 对象, 并返回一个包装后的新对象. 若没有特别配置的话, 对这个新对象的所有方法调用, 都会委派给实际的 Java 对象.</p>
<p>mock 和 spy 的区别是: mock 是无中生有地生出一个<strong>完全虚拟的对象</strong>, 它的所有方法都是虚拟的; 而 spy 是在现有类的基础上包装了一个对象, 即如果我们没有重写 spy 的方法, 那么这些方法的实现其实都是调用的被包装的对象的方法.</p>
<p>【test fixture】测试的先决条件，<br>@Before 在每个测试方法运行前都会被调用, @After 在每个测试方法运行后都会被调用.<br>因为 @Before 和 @After 会在每个测试方法前后都会被调用, 而有时我们仅仅需要在测试前进行一次初始化, 这样的情况下, 可以使用@BeforeClass 和@AfterClass 注解.</p>
<p>【test case】测试用例<br>在 JUnit 3中, 测试方法都必须以 test 为前缀, 且必须是 public void 的, JUnit 4之后, 就没有这个限制了, 只要在每个测试方法标注 @Test 注解, 方法签名可以是任意的.</p>
<p>【测试套件】通过 TestSuit 对象将多个测试用例组装成一个测试套件, 测试套件批量运行.<br>通过@RunWith 和@SuteClass 两个注解, 我们可以创建一个测试套件. 通过@RunWith 指定一个特殊的运行器, 并通过@SuiteClasses 注解, 将需要进行测试的类列表作为参数传入.</p>
<h3 id="Junit4注解"><a href="#Junit4注解" class="headerlink" title="Junit4注解"></a>Junit4注解</h3><p>@Test (expected = Exception.class) 表示预期会抛出Exception.class 的异常</p>
<p>@Ignore 含义是“某些方法尚未完成，暂不参与此次测试”。这样的话测试结果就会提示你有几个测试被忽略，而不是失败。一旦你完成了相应函数，只需要把@Ignore注解删去，就可以进行正常的测试。</p>
<p>@Test(timeout=100) 表示预期方法执行不会超过 100 毫秒，控制死循环</p>
<p>@Before 表示该方法在每一个测试方法之前运行，可以使用该方法进行初始化之类的操作</p>
<p>@After 表示该方法在每一个测试方法之后运行，可以使用该方法进行释放资源，回收内存之类的操</p>
<p>@BeforeClass 表示该方法只执行一次，并且在所有方法之前执行。一般可以使用该方法进行数据库连接操作，注意该注解运用在静态方法。</p>
<p>@AfterClass 表示该方法只执行一次，并且在所有方法之后执行。一般可以使用该方法进行数据库连接关闭操作，注意该注解运用在静态方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.junit.runner.RunWith;  </span><br><span class="line">import org.junit.runners.Suite;  </span><br><span class="line">import org.junit.runners.Suite.SuiteClasses;  </span><br><span class="line">  </span><br><span class="line">@RunWith( Suite.class )  </span><br><span class="line">@SuiteClasses( &#123; JUnitTest1.class, JUnitTest2.class &#125; )  </span><br><span class="line">public class AllTests &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个测试类, 可以合并成一个测试套件进行测试, 运行一个 Test Suite, 那么就会运行在这个 Test Suite 中的所用的测试.<br>在这个例子中, 我们定义了一个 Test Suite, 这个 Test Suite 包含了两个测试类: JUnitTest1 和 JUnitTest2, 因此运行 这个 Test Suite 时, 就会自动运行这两个测试类了.</p>
<p>*在类名上按下command+shift+t，就可以生成对应测试类。</p>
<p>来源：<a href="https://segmentfault.com/a/1190000006731125">https://segmentfault.com/a/1190000006731125</a></p>
<h2 id="2-Mockito中-Mock与-InjectMock"><a href="#2-Mockito中-Mock与-InjectMock" class="headerlink" title="2.Mockito中@Mock与@InjectMock"></a>2.Mockito中@Mock与@InjectMock</h2><p>Mockito 是一个流行 mock 框架，可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象。<br>Mockito是java单元测试中，最常用的mck工具之一，提供了诸多打桩方法和注解。其中有两个比较常用的注解，@Mock和@InjectMock，名字和在代码中使用 的位置都很像。但是是在功能上无任何可类比性的完全不同的东西。<br>程序员通常创造模拟对象来测试其他对象的行为，很类似汽车设计者使用碰撞测试假人来模拟车辆碰撞中人的动态行为。</p>
<p>为什么使用mock？<br>在单元测试中，模拟对象可以模拟复杂的、真实的（非模拟）对象的行为， 如果真实的对象无法放入单元测试中，使用模拟对象就很有帮助。</p>
<p>单元测试的思路是在不涉及依赖关系的情况下测试代码（隔离性），所以测试代码与其他类或者系统的关系应该尽量被消除。一个可行的消除方法是替换掉依赖类（测试替换），也就是说我们可以使用替身来替换掉真正的依赖对象。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@Mock：<br>在Mockito中用于创建mock对象，使用方法如下：<br><code>@Mock</code><br><code>private ClassName mockedObject；</code></p>
<p>上面代码创建了一个名为mockedObject，类型为ClassName的mock对象，该对象所有的方法被置空，根据测试代码逻辑的需要使用.</p>
<hr>
<p>@InjectMock：<br>创建一个实例，简单的说是这个Mock可以调用真实代码的方法，其余用@Mock（或@Spy）注解创建的mock将被注入到用该实例中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(MockitoJUnitRunner.class)  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    @InjectMocks  </span><br><span class="line">    private SomeHandler someHandler;  </span><br><span class="line">  </span><br><span class="line">    @Mock  </span><br><span class="line">    private OneDependency oneDependency; // 此mock将被注入到someHandler  </span><br><span class="line"></span><br><span class="line">    // ...   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这段代码中，@InjectMock下面声明了一个待测试的对象，@Mock定义的mock对象将会被注入到这个待测试的对象中。</p>
<hr>
<p>🤔 @Mock创建创建mock对象之后，在对具体的方法打桩之前，mock对象的所有属性和方法全被置空（0或者null），所以，对应的方法是不运行的。<br>*mock对象创建之后，被测试类中的该对象的方法就都不执行了。</p>
<p>🤔 @Spy可以创建的对象的所有成员方法都会按照原方法的逻辑执行，直到被打桩返回某个具体的值。</p>
<p>来源：<a href="https://www.cnblogs.com/langren1992/p/9681600.html">https://www.cnblogs.com/langren1992/p/9681600.html</a></p>
<h3 id="mock使用"><a href="#mock使用" class="headerlink" title="mock使用"></a>mock使用</h3><p>maven注入依赖。</p>
<p>如果你使用注解，那么必须要实例化 mock 对象。Mockito 在遇到使用注解的字段的时候必须使用@RunWith(MockitoJUnitRunner.class) 或 MockitoAnnotations.initMocks(this)进行mocks的初始化和注入。<br>(可以写一个init函数，加@Before注解)</p>
<h4 id="配置mock"><a href="#配置mock" class="headerlink" title="配置mock"></a>配置mock</h4><p>when(…​.).thenReturn(…​.)可以被用来定义当条件满足时函数的返回值，当多次调用函数的时候，Mockito 会根据你定义的先后顺序来返回返回值（多次调用）。Mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将anyString 或者 anyInt作为输入参数，然后定义其特定的放回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test1()  &#123;</span><br><span class="line">        //  创建 mock</span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line"></span><br><span class="line">        // 自定义 getUniqueId() 的返回值</span><br><span class="line">        when(test.getUniqueId(Mockito.anyLong())).thenReturn(43);</span><br><span class="line"></span><br><span class="line">        // 在测试中使用mock对象</span><br><span class="line">        assertEquals(test.getUniqueId(), 43);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回多个值</span><br><span class="line">@Test</span><br><span class="line">public void testMoreThanOneReturnValue()  &#123;</span><br><span class="line">        Iterator i= mock(Iterator.class);</span><br><span class="line">        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);</span><br><span class="line">        String result=i.next()+&quot; &quot;+i.next();</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(&quot;Mockito rocks&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何根据输入来返回值</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);</span><br><span class="line">        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(1,c.compareTo(&quot;Mockito&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何让返回值不依赖于输入</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueInDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(anyInt())).thenReturn(-1);</span><br><span class="line">        // 断言</span><br><span class="line">        assertEquals(-1 ,c.compareTo(9));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据参数类型来返回值</span><br><span class="line">@Test</span><br><span class="line">public void testReturnValueInDependentOnMethodParameter()  &#123;</span><br><span class="line">        Comparable c= mock(Comparable.class);</span><br><span class="line">        when(c.compareTo(isA(Todo.class))).thenReturn(0);</span><br><span class="line">        // 断言</span><br><span class="line">        Todo todo = new Todo(5);</span><br><span class="line">        assertEquals(todo ,c.compareTo(new Todo(1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="无返回值的方法"><a href="#无返回值的方法" class="headerlink" title="无返回值的方法"></a>无返回值的方法</h4><p>mokito中，对无返回的函数什么都不做<br>Mokito.doNothing().when(对象).函数();</p>
<p>对于无返回值的函数，我们可以使用doReturn(…​).when(…​).methodCall来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用doThrow 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">// 下面测试用例描述了如何使用doThrow()方法</span><br><span class="line"></span><br><span class="line">@Test(expected=IOException.class)</span><br><span class="line">public void testForIOException() &#123;</span><br><span class="line">        // 创建并配置 mock 对象</span><br><span class="line">        OutputStream mockStream = mock(OutputStream.class);</span><br><span class="line">        doThrow(new IOException()).when(mockStream).close();</span><br><span class="line"></span><br><span class="line">        // 使用 mock</span><br><span class="line">        OutputStreamWriter streamWriter= new OutputStreamWriter(mockStream);</span><br><span class="line">        streamWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证是否调用"><a href="#验证是否调用" class="headerlink" title="验证是否调用"></a>验证是否调用</h4><p>验证 query 方法是否被 MyDatabase 的 mock 对象调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">public class MockitoTest  &#123;</span><br><span class="line"></span><br><span class="line">        @Mock</span><br><span class="line">        MyDatabase databaseMock; (1)</span><br><span class="line"></span><br><span class="line">        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); (2)</span><br><span class="line"></span><br><span class="line">        @Test</span><br><span class="line">        public void testQuery()  &#123;</span><br><span class="line">                ClassToTest t  = new ClassToTest(databaseMock); (3)</span><br><span class="line">                boolean check = t.query(&quot;* from t&quot;); (4)</span><br><span class="line">                assertTrue(check); (5)</span><br><span class="line">                verify(databaseMock).query(&quot;* from t&quot;); (6)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testVerify()  &#123;</span><br><span class="line">        // 创建并配置 mock 对象</span><br><span class="line">        MyClass test = Mockito.mock(MyClass.class);</span><br><span class="line">        when(test.getUniqueId()).thenReturn(43);</span><br><span class="line"></span><br><span class="line">        // 调用mock对象里面的方法并传入参数为12</span><br><span class="line">        test.testing(12);</span><br><span class="line">        test.getUniqueId();</span><br><span class="line">        test.getUniqueId();</span><br><span class="line"></span><br><span class="line">        // 查看在传入参数为12的时候方法是否被调用</span><br><span class="line">        verify(test).testing(Matchers.eq(12));</span><br><span class="line"></span><br><span class="line">        // 方法是否被调用两次</span><br><span class="line">        verify(test, times(2)).getUniqueId();</span><br><span class="line"></span><br><span class="line">        // 其他用来验证函数是否被调用的方法</span><br><span class="line">        verify(mock, never()).someMethod(&quot;never called&quot;);</span><br><span class="line">        verify(mock, atLeastOnce()).someMethod(&quot;called at least once&quot;);</span><br><span class="line">        verify(mock, atLeast(2)).someMethod(&quot;called at least twice&quot;);</span><br><span class="line">        verify(mock, times(5)).someMethod(&quot;called five times&quot;);</span><br><span class="line">        verify(mock, atMost(3)).someMethod(&quot;called at most 3 times&quot;);</span><br><span class="line">&#125;</span><br><span class="line">前面都加个Mockito.</span><br></pre></td></tr></table></figure>

<h3 id="spy使用"><a href="#spy使用" class="headerlink" title="spy使用"></a>spy使用</h3><p>@Spy或者spy()方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 stub），否则都会真正的调用对象里面的每一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line">// Lets mock a LinkedList</span><br><span class="line">List list = new LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line">// 可用 doReturn() 来打桩</span><br><span class="line">doReturn(&quot;foo&quot;).when(spy).get(0);</span><br><span class="line"></span><br><span class="line">// 下面代码不生效</span><br><span class="line">// 真正的方法会被调用</span><br><span class="line">// 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空</span><br><span class="line">when(spy.get(0)).thenReturn(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.jianshu.com/p/f6e3ab9719b9">https://www.jianshu.com/p/f6e3ab9719b9</a><br><a href="https://www.jianshu.com/p/7b67806b74f6">https://www.jianshu.com/p/7b67806b74f6</a></p>
<h2 id="PowerMockRunner-和-MockitoJUnitRunner"><a href="#PowerMockRunner-和-MockitoJUnitRunner" class="headerlink" title="PowerMockRunner 和 MockitoJUnitRunner"></a>PowerMockRunner 和 MockitoJUnitRunner</h2><p>关于打桩：<br><a href="https://blog.csdn.net/moshowgame/article/details/100983711">https://blog.csdn.net/moshowgame/article/details/100983711</a></p>
<h2 id="when-thenReturn-和-doReturn-when-区别"><a href="#when-thenReturn-和-doReturn-when-区别" class="headerlink" title="when().thenReturn() 和 doReturn().when() 区别"></a>when().thenReturn() 和 doReturn().when() 区别</h2><p>使用@Mock时可以相互替换，但是@Spy时，它们的调用结果不同。<br>1.when().thenReturn() 会调用真实的方法，容易抛出异常<br>2.doReturn().when() 不会调用真实方法</p>
<h2 id="PowerMockito"><a href="#PowerMockito" class="headerlink" title="PowerMockito"></a>PowerMockito</h2><p>PowerMock扩展了EasyMock和Mockito框架，增加了对static和final方法mock支持等功能.<br>PowerMock有两个重要的注解：<br> @RunWith(PowerMockRunner.class)<br> @prepareForTest({MyObject.class})<br> @PrepareForTest注解和@RunWith注解是结合使用的，不要单独使用@PrepareForTest，否则不起作用。当使用PowerMock去mock静态，final或者私有方法时，需要加上这两个注解。<br>————————————————<br><a href="https://blog.csdn.net/KeeYang108/article/details/79891588">https://blog.csdn.net/KeeYang108/article/details/79891588</a></p>
<h2 id="Mock测试踩坑"><a href="#Mock测试踩坑" class="headerlink" title="Mock测试踩坑"></a>Mock测试踩坑</h2><p>今天写了一个control层的mock单元测试，因为要调service层（实现类）的方法，就把service接口做了一个mock，测试时候一直包空指针异常。<br>mock service实现类之后，正常。</p>
<p>更新：今天@Mock的接口也是可以的，奇怪了：<br>mock接口出现空指针异常的case：是service（.之前的）是实现类，@Autowired的也是实现类，所以mock接口没用？<br>而今天mock接口，被测试类中.之前的是接口，@Autowired的也是接口，所以没毛病。</p>
<p>加@RunWith(PowerMockRunner.class)<br>要测试的类加@InjectMocks</p>
<p>1.service实现类不加mock，到指定方法会报空指针异常，service对象为空<br>2.如果service方法无返回，可以不打桩，如果有返回，最好打个桩。<br>3.有返回的打了桩，可以根据不同的输入，返回不同的结果。有返回如果不打桩，相当于返回的是null，返回如果被后面用到，容易报空指针异常。</p>
<h2 id="Mock测试踩坑空指针异常"><a href="#Mock测试踩坑空指针异常" class="headerlink" title="Mock测试踩坑空指针异常"></a>Mock测试踩坑空指针异常</h2><p>mock测试的被测试类（@InjectMock）中的属性一般为null，所以什么都不加就在被测试类中调用属性对象的方法时，报空指针异常，因为属性对象是null。<br>将属性对象在Test中添加@Mock为mock对象，直接忽略属性对象方法，不进入执行。<br>将属性对象在Test中添加@Spy为spy对象，会进入该方法中，但是只限于一层，再进入就不行了，还是会报空指针异常。</p>
<hr>
<h2 id="单元测试框架和步骤"><a href="#单元测试框架和步骤" class="headerlink" title="单元测试框架和步骤"></a>单元测试框架和步骤</h2><p>Jnit：一个java语言的单元测试框架，编写和运行可重复的自动化测试。</p>
<p>Mockito：单元测试模拟框架，采用模拟技术，模拟应用中依赖的复杂对象，把测试对象和依赖对象隔离开。</p>
<p>PowerMock：在Mockito的基础上作出扩展。</p>
<p>单元测试步骤：定义对象 - 模拟方法 - 调用方法 - 验证方法 （第二步和第四步是有外部依赖时需要mock使用的）</p>
<p>1、定义测试对象（new/Mockito.spy/@Spy/@InjectMocks）<br>2、模拟依赖对象（直接构建对象/Json反序列化对象/@Mock/@Spy）<br>3、注入依赖对象（set/Whitebox/@Mock）<br>4、模拟依赖方法<br>5、调用被测方法（分为构造方法、普通方法、静态方法）（都分为有权限和无权限）（有权限直接调用，无权限用：<code>Whitebox.invokeMethod(userService, &quot;isUser&quot;, uid)</code>）<br>6、验证依赖方法（Mockito.verify(…)）（用ArgumentCaptor/@Captor捕获参数）<br>7、验证数据对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//验证对象为空</span><br><span class="line">Assert.assertNull(&quot;必须为空！&quot;, uid);</span><br><span class="line">//验证对象非空</span><br><span class="line">Assert.assertNotNull(&quot;不能为空！&quot;, uid);</span><br><span class="line">//验证为真</span><br><span class="line">Assert.assertTrue(&quot;返回必须为真&quot;, isSuper);</span><br><span class="line">//验证为假</span><br><span class="line">Assert.assertFalse(&quot;返回必须为假&quot;, isSuper);</span><br><span class="line">//验证数据对象是否一致</span><br><span class="line">Assert.assertSame(&quot;用户必须一致&quot;, exceptId, uid);</span><br><span class="line">//验证数据对象是否一致</span><br><span class="line">Assert.assertNotSame(&quot;用户不能一致&quot;, exceptId, uid);</span><br><span class="line">//验证简单数据对象</span><br><span class="line">Assert.assertNotEquals(&quot;用户名称不一致&quot;, &quot;admin&quot;, user)</span><br><span class="line">//验证简单数组或集合对象</span><br><span class="line">Assert.assertArrayEquals</span><br><span class="line">//对于复杂数据，可以先序列化为json字符串，然后Assert.assertEquals</span><br></pre></td></tr></table></figure>
<p>验证跑出异常：可以用@Test(expected=ExampleException.class)，但是一旦内部方法抛出异常，整个方法就返回，后面的验证没法执行。@Rule注解实现。推荐使用Assert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExampleException e = Assert.assertThrows(&quot;异常类型不一致&quot;, ExampleException.class, ()-&gt;userService.getUser(uid));</span><br><span class="line">Assert.assertEquals(&quot;异常消息不一致&quot;, exceptString, e.getMessage());</span><br></pre></td></tr></table></figure>
<p>8、验证依赖对象（一般不用）<br><code>Mockito.verifyNotInteractions</code></p>
<p>✅Mockito的any相关的参数匹配方法不支持可空参数和空参数，应该用nullable方法。<br>✅采用Mockito的参数匹配方法时，其他参数不能直接用常量或变量，应该用Mockito的eq方法。</p>
<h2 id="Mock静态方法"><a href="#Mock静态方法" class="headerlink" title="Mock静态方法"></a>Mock静态方法</h2><p>通过PowerMockito.mockStatic() 对静态方法进行mock。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.junit.jupiter.api.Assertions;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.powermock.api.mockito.PowerMockito;</span><br><span class="line">import org.powermock.core.classloader.annotations.PowerMockIgnore;</span><br><span class="line">import org.powermock.core.classloader.annotations.PrepareForTest;</span><br><span class="line">import org.powermock.modules.junit4.PowerMockRunner;</span><br><span class="line"> </span><br><span class="line">@RunWith(PowerMockRunner.class)</span><br><span class="line">@PrepareForTest(StringUtils.class)  //多个静态方法的话&#123;1,2&#125;</span><br><span class="line">//@PowerMockIgnore(&quot;javax.crypto.*&quot;)</span><br><span class="line">public class MyTest &#123;</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //模拟依赖方法</span><br><span class="line">        PowerMockito.mockStatic(StringUtils.class);</span><br><span class="line">        PowerMockito.when(StringUtils.isEmpty(&quot;empty&quot;)).thenReturn(true);</span><br><span class="line">        Assertions.assertTrue(StringUtils.isEmpty(&quot;empty&quot;));</span><br><span class="line">        //验证依赖方法被调用</span><br><span class="line">        PowerMockito.verifyStatic(StringUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/q2878948/article/details/124862699">https://blog.csdn.net/q2878948/article/details/124862699</a><br><a href="https://blog.csdn.net/qq_34497300/article/details/119774225">https://blog.csdn.net/qq_34497300/article/details/119774225</a></p>
<h2 id="Mock私有方法"><a href="#Mock私有方法" class="headerlink" title="Mock私有方法"></a>Mock私有方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先@RunWith(PowerMockRunner.class)</span><br><span class="line">把私有方法所在类放在@PrepareForTest()中</span><br><span class="line">//模拟私有依赖方法</span><br><span class="line">PowerMockito.doReturn(true).when(MyService.class, &quot;myFunc&quot;, myParam);</span><br><span class="line">PowerMockito.when(MyService.class, &quot;myFunc&quot;, myParam).thenReturn(true);</span><br><span class="line">//验证私有方法调用</span><br><span class="line">PowerMockito.verifyPrivate(myClass, times(1)).invoke(&quot;myfunc&quot;, any(List.class))</span><br></pre></td></tr></table></figure>

<p>⚠️想mock被验证类(@InjectMock)的私有方法是不行的。只能mock注入类的私有方法。</p>
<h2 id="Mock被测试类的其他public方法"><a href="#Mock被测试类的其他public方法" class="headerlink" title="Mock被测试类的其他public方法"></a>Mock被测试类的其他public方法</h2><p>直接用Mockito.when是不行，会报空指针。</p>
<p>还没搞出来。</p>
<p>Java中使用PowerMockito mock static方法/new对象/mock对象的public或private方法的简单示例：<br><a href="https://www.cnblogs.com/epic358/p/16559549.html">https://www.cnblogs.com/epic358/p/16559549.html</a></p>
<h2 id="Mock测试修改方法的入参"><a href="#Mock测试修改方法的入参" class="headerlink" title="Mock测试修改方法的入参"></a>Mock测试修改方法的入参</h2><p>如果方法有返回值，直接使用Mockito.when().thenReturn()的方式Mock即可，但是对于没有返回值的方法，但是在方法内部却对方法的入参做了一些逻辑的方法，就不能再用这种方式，应该用另外一个Mock方法，即doNothing。</p>
<p>Mock的时候，首先匹配参数，然后在ArgumentMatcher中修改参数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mock方式修改方法入参</span><br><span class="line">doNothing().when(userService).service(any(), argThat(new ArgumentMatcher&lt;UserResponse&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(UserResponse response) &#123;</span><br><span class="line">        ImportInfo importInfo = new ImportInfo();</span><br><span class="line">        importInfo.setStatus(&quot;APPROVING&quot;);</span><br><span class="line">        // 修改入参的属性</span><br><span class="line">        response.setImportInfo(importInfo);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line">Request request = new Request();</span><br><span class="line">Response response = new Response();</span><br><span class="line">// 这个是我们要验证的主方法</span><br><span class="line">handler.handle(request, response);</span><br></pre></td></tr></table></figure>

<p><a href="https://www.wxxblog.com/article/5">https://www.wxxblog.com/article/5</a></p>
<h2 id="单元测试风格"><a href="#单元测试风格" class="headerlink" title="单元测试风格"></a>单元测试风格</h2><p>单元测试的意义在于验证业务代码，高覆盖率+可读性 = 高价值。高覆盖率包括对代码的覆盖，也包括对测试用例的覆盖。</p>
<p>一个方法要测试多种测试场景的话，就写多个mock方法，一个单侧方法只针对一个行为。但是看，有些公共的mock打桩可以提取出来，写成一个公共的私有方法，或者写一个init方法，用@Before注解修饰，在运行测试方法时就提前打桩。</p>
<p>推荐的风格：<br>1.一个测试方法仅调用一次被测方法<br>2.至少一个正例的测试用例<br>3，提取公共的mock插桩<br>4.异常流的测试中，只引入一种异常的mock重写<br>5.加注释：测试什么场景，期望什么结果</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、Mockito.anyString 什么的，不能和实际的参数一起作为一个方法的输入。<br>会报错：InvalidUseOfMatchersException。</p>
<p>2、接口的单元测试类，一般是一个实现类就一个单元测试类。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java web相关</title>
    <url>/2022/09/11/myblog/JAVA/java%20web/</url>
    <content><![CDATA[<h2 id="网页502"><a href="#网页502" class="headerlink" title="网页502"></a>网页502</h2><p>502 Bad Gateway是指错误网关，无效网关；在互联网中表示一种网络错误。表现在WEB浏览器中给出的页面反馈。</p>
<p>服务端代码下掉，重新部署的间隙，访问接口会502.</p>
<h2 id="504错误"><a href="#504错误" class="headerlink" title="504错误"></a>504错误</h2><p>504错误代表网关超时 （Gateway timeout），是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>接口504超时，是服务端这边超时断开请求了，需要看一下nginx配置。如果是tomcat，看一下conf中配置的请求超时时间。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="✅nginx是什么？"><a href="#✅nginx是什么？" class="headerlink" title="✅nginx是什么？"></a>✅nginx是什么？</h3><blockquote>
<p>Nginx是十分轻量级的HTTP服务器。Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。</p>
<p>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。<br>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p>
</blockquote>
<p>nginx是服务器，代理服务器，负载均衡，反向代理，服务器架构。</p>
<p>Nginx凭借其稳定性、低资源消耗、简单配置和丰富的功能，从十多年前名不见经传的Web服务器软件，发展到如今能够跟Apache匹敌的地位。</p>
<p>1、作为Web服务器，Nginx处理静态文件、索引文件，自动索引的效率非常高</p>
<p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p>
<p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡</p>
<p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p>
<p>5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p>
<p>6、在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行<br>————————————————<br>解读nginx：<br>原文链接：<a href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅什么是代理服务器？"><a href="#✅什么是代理服务器？" class="headerlink" title="✅什么是代理服务器？"></a>✅什么是代理服务器？</h3><p>代理服务器是介于客户端和Web服务器之间的另一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页，而是通过向代理服务器发送请求，信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<p><img src="https://img-blog.csdnimg.cn/865dde1f883d4cd6a0ec00a61bc960c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5bCx5Z2Q6L-Z55yL55yL,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br>HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h3 id="✅什么是正反向代理"><a href="#✅什么是正反向代理" class="headerlink" title="✅什么是正反向代理"></a>✅什么是正反向代理</h3><p>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端，客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理代理的对象是客户端，正向代理中，proxy和client同属一个LAN，对server透明 （客户端服务端多对一？）</p>
<p>反向代理服务器：在服务器端接收客户端的请求，然后把请求分发给具体的服务器进行处理，然后再将服务器的响应结果反馈给客户端。Nginx就是其中的一种反向代理服务器软件。</p>
<p>反向代理代理的对象是服务端，反向代理中，proxy和server同属一个LAN，对client透明  （客户端服务端多对多）</p>
<p>正向代理客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。<br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向哪个原始服务器转交请求，并将获得的内容返回给客户端。<br>————————————————<br>解读nginx：<br>原文链接：<a href="https://blog.csdn.net/weixin_60274825/article/details/122101640">https://blog.csdn.net/weixin_60274825/article/details/122101640</a></p>
<h3 id="✅nginx与tomcat什么关系"><a href="#✅nginx与tomcat什么关系" class="headerlink" title="✅nginx与tomcat什么关系"></a>✅nginx与tomcat什么关系</h3><p>nginx是上面做web代理服务器的，而tomcat是上面做真正web服务器的。</p>
<p>nginx常用做静态内容服务和代理服务器，直面外来请求转发给后面的应用服务（tomcat，django什么的），tomcat更多用来做做一个应用容器，让java web app跑在里面的东西，对应同级别的有jboss,jetty等东西。</p>
<p>但是事无绝对，nginx也可以通过模块开发来提供应用功能，tomcat也可以直接提供http服务，通常用在内网和不需要流控等小型服务的场景。</p>
<p>严格的来说，Apache/Nginx 应该叫做「HTTP Server」；而 Tomcat 则是一个「Application Server」，或者更准确的来说，是一个「Servlet/JSP」应用的容器（Ruby/Python 等其他语言开发的应用也无法直接运行在 Tomcat 上）。</p>
<p>一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，也可以将处理过的内容通过 HTTP Server 分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端。</p>
<p>而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_44517990/article/details/100712182">https://blog.csdn.net/weixin_44517990/article/details/100712182</a></p>
<h3 id="✅-springboot内置tomcat-和-tomcat"><a href="#✅-springboot内置tomcat-和-tomcat" class="headerlink" title="✅ springboot内置tomcat 和 tomcat"></a>✅ springboot内置tomcat 和 tomcat</h3><p>1.内置的tomcat没有tomcat的主页页面<a href="http://localhost:9999/%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E7%94%A8%E7%9A%84%E5%A4%96%E7%BD%AE%E7%9A%84tomcat%E6%98%AF%E6%9C%89%E7%9A%84">http://localhost:9999/，而我们平时用的外置的tomcat是有的</a></p>
<p>2.内置的tomcat可以用main跑项目，而如果要用外置的tomcat就需要把项目打成war包，然后拷贝到webapp下进行运行</p>
<p>Tomcat：<br>Tomcat是一个Web应用服务器，也是Servlet容器。它的作用是，解析客户端client发起的request，并组装出HttpRequest、创建HttpResponse，将二者交于内部的HttpServlet处理和填充</p>
<p>Tomcat映射处理请求的Servlet是通过web.xml做的。</p>
<p>SpringMVC使用一个DispatcherServlet来接收所有的请求，并把它们分发到不同的controller中来做进一步处理。</p>
<p>SpringMVC = Spring + Web框架，Spring这部分主要是AOP/IOC容器。</p>
<p>SpringBoot是Spring的扩展，简化了Spring的配置，通过starter的方式简化了常用组件依赖的引入，使其更加易用。</p>
<p>SpringBoot内置了tomcat。</p>
<h3 id="✅tomcat和spring-mvc"><a href="#✅tomcat和spring-mvc" class="headerlink" title="✅tomcat和spring mvc"></a>✅tomcat和spring mvc</h3><p>tomcat既是Http服务器（不用代理的话，其实是应用服务器），Http服务器与Servlet容器的功能界限是：可以把HTTP服务器想象成前台的接待，负责网络通信和解析请求，Servlet容器是业务部门，负责处理业务请求。</p>
<p>Tomcat和Servlet作为Web服务器和Servlet容器的结合，可以接受网络http请求解析为Servlet规范的请求对象和响应对象。比如，HttpServletRequest对象是Tomcat提供的，Servlet是规范，Tomcat是实现规范的Servlet容器。tomcat监听了端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理;然后调用那个servlet的service方法，service方法返回一个response对象;<br>tomcat再把这个response返回给客户端。</p>
<p>SpringMVC是处理Servlet请求的应用，其中DispatcherServlet实现了Servlet接口，Tomcat负责加载和调用DispatcherServlet。同时，DispatcherServlet有自己的容器（SpringMVC）容器，这个容器负责管理SpringMVC相关的bean，比如Controler和ViewResolver等。同时，Spring中还有其他的Bean比如Service和DAO等，这些由全局的Spring IOC容器管理，因此，Spring有两个IOC容器。</p>
<p>如果只是使用spring(不包含springmvc)，那么是tomcat容器解析xml文件，通过反射实例化对应的类，根据这些servlet规范实现类，触发对应的代码处理逻辑，这个时候tomcat负责http报文的解析和servlet调度的工作。</p>
<p>如果使用spring mvc，那么tomcat只是解析http报文，然后将其转发给dispatchsetvlet，然后由springmvc根据其配置，实例对应的类，执行对应的逻辑，然后返回结果给dispatchservlet，最后由它转发给tomcat,由tomcat负责构建http报文数据。</p>
<p>DispatcherServlet：是Spring MVC中的一个类，实现了Servlet接口。所以部署在Tomcat中的Spring项目，对Tomcat来说，都是一个servlet。</p>
<p>————————————————<br>spring mvc还需要tomcat吗？<br>版权声明：本文为CSDN博主「黄泥川水猴子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_40277163/article/details/124730530">https://blog.csdn.net/qq_40277163/article/details/124730530</a></p>
<h3 id="✅nginx与域名解析DNS什么关系"><a href="#✅nginx与域名解析DNS什么关系" class="headerlink" title="✅nginx与域名解析DNS什么关系"></a>✅nginx与域名解析DNS什么关系</h3><p>首先，nginx是web服务器和反向代理服务器。 dns是域名解析服务器。nginx不带dns。</p>
<p>作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。访问域名，dns帮忙解析到ip，然后访问这个地址的资源呈现给你。hosts和nginx在后面用到。</p>
<p>hosts文件：<br>hosts文件是个本地域名解析文件，不管你是windwos还是linux，那都是有的，他里面的有效内容，就是一个个的ip和域名映射关系。<br>windows一般在：C:/Windows/System32/drivers/etc/hosts<br>Linux的hosts文件路径一般：/etc/hosts<br>比如：127.0.0.1 localhost<br>这个文件其实也是配置了ip和域名之间的映射关系的数据库，本地要是有这个文件，就优先用这个文件中的配置去解析，如果没有，那就通过dns解析。<br>注意：hosts文件只能配置ip和域名的映射关系，但是不能配置端口号，默认访问80端口</p>
<p>因为要解决端口问题，这里就得使用反向代理软件nginx，nginx中的每个server就是一个反向代理配置，可以有多个server。</p>
<p>理解：<em><strong>客户端请求 - dns解析域名 - 解析到nginx服务器的ip - nginx代理到tomcat服务器+端口 - tomcat将请求给servlet - servlet的service处理请求。</strong></em></p>
<h3 id="✅nginx与CDN内容分发网络什么关系"><a href="#✅nginx与CDN内容分发网络什么关系" class="headerlink" title="✅nginx与CDN内容分发网络什么关系"></a>✅nginx与CDN内容分发网络什么关系</h3><p>cdn是网络，nginx是服务器也是负载均衡。</p>
<p>cdn：<br>1、CDN的全称是Content Delivery Network，即内容分发网络。<br>2、其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br>3、通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>4、其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度**。<br>5、内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p>
<p>cdn的工作原理：<br>CDN这个技术其实说起来并不复杂，最初的核心理念，就是将内容缓存在终端用户附近。</p>
<p>内容源不是远么？那么，我们就在靠近用户的地方，建一个缓存服务器，把远端的内容，复制一份，放在这里，不就OK了？</p>
<p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）</p>
<p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p>
<p><img src="https://img-blog.csdnimg.cn/20210629132506469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDA5MTQz,size_16,color_FFFFFF,t_70"></p>
<p>借用阿里云官网的例子，来简单介绍CDN的工作原理。</p>
<p>假设通过CDN加速的域名为 <a href="http://www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：">www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</a></p>
<p>1、当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先向ldns(本地dns)发起域名解析请求./">www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</a></p>
<p>2、LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直接返回给终端用户;如果没有,则向授权dns查询./">www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</a></p>
<p>3、当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a> <a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></p>
<p>4、域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</p>
<p>5、LDNS获取DNS返回的解析IP地址。</p>
<p>6、用户获取解析IP地址。</p>
<p>7、用户向获取的IP地址发起对该资源的访问请求。</p>
<p>8、如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</p>
<p>9、如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</p>
<p>所以：<br>（1）CDN的加速资源是跟域名绑定的。<br>（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<hr>
<p>nginx负载均衡：负载均衡实际上就是将大量请求进行分布式处理的策略</p>
<p>Nginx 作为一个基于 C 实现的高性能 Web 服务器，可以通过系列算法解决上述的负载均衡问题。并且由于它具有高并发、高可靠性、高扩展性、开源等特点，成为开发人员常用的反向代理工具</p>
<p>1、正向代理</p>
<p>正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网。</p>
<p>假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a href="https://www.google.com/%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%AE%83%E6%89%BE%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%BF%E9%97%AE%E5%88%B0">https://www.google.com/，但由于条件限制，它找来了一个能够访问到</a> Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。<br>（客户端 - 正向代理 - 服务器）</p>
<p>2、反向代理</p>
<p>随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证<br>（一堆客户端 - 反向代理 - 一堆服务器）</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>3、负载均衡常用算法</p>
<p>轮询 （round-robin）<br>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。特点：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。</p>
<p>加权轮询<br>为了避免普通轮询带来的弊端，加权轮询应运而生。在加权轮询中，每个服务器会有各自的 weight。一般情况下，weight 的值越大意味着该服务器的性能越好，可以承载更多的请求。该算法中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。</p>
<p>IP 哈希（IP hash）<br>ip_hash 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。特点：该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。</p>
<p>所以：<br>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p>
<p>————————————————<br>好文章：从对CDN的理解到Nginx负载均衡<br>原文链接：<a href="https://blog.csdn.net/qq_40409143/article/details/118330238">https://blog.csdn.net/qq_40409143/article/details/118330238</a></p>
<h3 id="✅nginx与RPC远程过程调用什么关系？"><a href="#✅nginx与RPC远程过程调用什么关系？" class="headerlink" title="✅nginx与RPC远程过程调用什么关系？"></a>✅nginx与RPC远程过程调用什么关系？</h3><p>RPC是远程过程调用，是一种计算机通信思想。</p>
<p>nginx是代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。</p>
<p>Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>讲RPC、RPC与nginx、RPC与HTTP间的关系的好文章：<br><a href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a></p>
<h3 id="✅与gateway有什么关系？"><a href="#✅与gateway有什么关系？" class="headerlink" title="✅与gateway有什么关系？"></a>✅与gateway有什么关系？</h3><p>网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy53YW5kb3VpcC5jb20vY3Jhd2xlci9hcnRpY2xlLzIwMTk4MS9hYTVmNTVkNjVkMTUxYjUxYzJiOGRhZTAyNTNmN2NmMQ?x-oss-process=image/format,png"></p>
<p>1、nginx也可以做网关，是用户访问的总入口，也就是前端页面的容器，流量网关。</p>
<p>流量网关是定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关。<br>流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。</p>
<p>2、gateway的定义是针对每一个业务微服务来得，属于业务网关。是介于nignx以及业务应用之间的中间层，主要负责将请求路由到不同的微服务中以及对请求的合法性进行校验。</p>
<p>业务网关针对具体的业务需要提供特定的流控策略、缓存策略、鉴权认证策略等等。<br>业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。 有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。</p>
<hr>
<p>网关可以看做系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。</p>
<p>1、nginx是用户到 前端工程 的网关，对外网关<br>nginx是用C语言写的<br>nginx做网关，更多的是做总流量入口，反向代理，负载均衡等，还可以用来做web服务器。<br>Nginx在其中扮演的角色是什么？<br>反向代理<br>负载均衡</p>
<p>2、gateway 是前端工程 到 后台服务器之间的一个 对内网关<br>gateway是java语言的一个框架，可以在框架上进行代码的扩展与控制，例如：安全控制，统一异常处理，XXS,SQL注入等；权限控制，黑白名单，性能监控，日志打印等<br>gateway的主要功能有，路由，断言，过滤器，利用它的这些特性，可以做流控。<br>SpringGateway在其中扮演的角色是什么？<br>统一鉴权</p>
<p>nginx与gateway：<a href="https://blog.csdn.net/yangbindxj/article/details/125040773">https://blog.csdn.net/yangbindxj/article/details/125040773</a></p>
<hr>
<p>网关服务的端口号默认是80或者443.<br>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。<br>Nginx实现负载均衡的原理属于服务器端负载均衡器。<br>Gateway实现负载均衡原理采用本地负载均衡器的形式。</p>
<h3 id="✅nginx与统一接入有什么关系？"><a href="#✅nginx与统一接入有什么关系？" class="headerlink" title="✅nginx与统一接入有什么关系？"></a>✅nginx与统一接入有什么关系？</h3><p>统一接入层是：指的是设置专属一层，统一接入所有流量，包括 PC 流量、无线流量、IoT 流量。在应用层之上的一层。</p>
<p>如果没有统一接入层，之前的业务方，例如购物车、商品等都要自己维护一个网关，这就涉及到维护成本和机器成本。例如卸载 HTTPS，如果所有业务方都要申请证书，那造成的应用成本是非常高的。可如果将所有功能全放在这一层进行，好处非常明显：一方面是机器集中管理节省成本；另外一方面，如果遇到新的瓶颈可以在统一接入层集中优化，如请求响应 Body 统一在这一层进行压缩减少带宽消耗，压缩会消耗 CPU，可以在这一层通过硬件加速的方式集中优化等。</p>
<p>阿里统一接入层：<a href="https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/96510277?hmsr=toutiao.io</a></p>
<p>统一接入层方案：<a href="https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html">https://www.cnblogs.com/Leo_wl/archive/2012/10/17/2728541.html</a></p>
<p>统一接入层是网关中最前端的服务，统一接入到集群中。<br>所以，统一接入层应该是在web代理服务器nginx前的。</p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><h3 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h3><p>Main 位于 nginx.conf 配置文件的最高层；<br>Main 层下可以有 Event、HTTP 层；<br>Http 层下面允许有多个 Server 层，用于对不同的网站做不同的配置；<br>Server 层下面允许有多个 Location，用于对不同的路径进行不同模块的配置。</p>
<p>1、main（最上面）<br>全局配置部分用来配置对整个 server 都有效的参数。主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等<br>全局Main配置<br>user nginx;<br>worker_processes 1; #设置值和CPU核心数一致</p>
<p>error_log /var/log/nginx/error.log warn; #日志位置和日志级别<br>pid       /var/run/nginx.pid;</p>
<p>2.event<br>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。<br>Event配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、http<br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。<br>http配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">  access_log /var/log/nginx/access.log main;</span><br><span class="line">  sendfile       on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、server<br>Server 块也被叫做“虚拟主机”部分，它描述的是一组根据不同 server_name 指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 http 部分。最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。一个 server 块可以配置多个 location 块。<br>server配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  error_page   500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx配置结构：<a href="https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1729793004418584302&amp;wfr=spider&amp;for=pc</a></p>
<p>菜鸟nginx配置：<a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></p>
<p>nginx配置详细介绍：<a href="https://blog.51cto.com/u_12218973/2457715">https://blog.51cto.com/u_12218973/2457715</a></p>
<h3 id="nginx超时配置"><a href="#nginx超时配置" class="headerlink" title="nginx超时配置"></a>nginx超时配置</h3><p>Nginx主要有四类超时设置：客户端超时设置、DNS解析超时设置、代理超时设置，如果使用ngx_lua，则还有lua相关的超时设置。</p>
<p>1、客户端超时</p>
<p>客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。通过客户端超时设置避免客户端恶意或者网络状况不佳造成连接长期占用，影响服务端的可处理的能力。</p>
<p><strong>client_header_timeout time</strong>：设置读取客户端请求头超时时间，默认为60s，如果在此超时时间内客户端没有发送完请求头，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>client_body_timeout time</strong>：设置读取客户端内容体超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是发送整个请求体的超时时间，如果在此超时时间内客户端没有发送任何请求体，则响应408（RequestTime-out）状态码给客户端。</p>
<p><strong>send_timeout time</strong>：设置发送响应到客户端的超时时间，默认为60s，此超时时间指的也是两次成功写操作间隔时间，而不是发送整个响应的超时时间。如果在此超时时间内客户端没有接收任何响应，则Nginx关闭此连接。</p>
<p>**keepalive_timeout timeout [header_timeout]**：设置HTTP长连接超时时间，其中，第一个参数timeout是告诉Nginx长连接超时时间是多少，默认为75s。第二个参数header_timeout是用于设置响应头“Keep-Alive: timeout=time”，即告知客户端长连接超时时间。如果timeout设置为0，则表示禁用长连接。</p>
<p>2、DNS解析超时</p>
<p><strong>resolver_timeout 30s</strong>：设置DNS解析超时时间，默认为30s</p>
<p>3、代理超时</p>
<p>主要有三组配置：网络连接/读/写超时设置、失败重试机制设置、upstream存活超时设置</p>
<p><strong>proxy_connect_timeout time</strong>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</p>
<p><strong>proxy_read_timeout time</strong>：设置从后端/上游服务器读取响应的超时时间，默认为60s，此超时时间指的是两次成功读操作间隔时间，而不是读取整个响应体的超时时间，如果在此超时时间内上游服务器没有发送任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_send_timeout time</strong>：设置往后端/上游服务器发送请求的超时时间，默认为60s，此超时时间指的是两次成功写操作间隔时间，而不是发送整个请求的超时时间，如果在此超时时间内上游服务器没有接收任何响应，则Nginx关闭此连接。</p>
<p><strong>proxy_next_upstream_tries number</strong>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</p>
<p><strong>proxy_next_upstream_timeout time</strong>：设置重试最大超时时间，默认0表示不限制。</p>
<p>Nginx超时配置：<a href="https://blog.csdn.net/xiao__jia__jia/article/details/124075274">https://blog.csdn.net/xiao__jia__jia/article/details/124075274</a></p>
<h2 id="PoolingHttpClientConnectionManager"><a href="#PoolingHttpClientConnectionManager" class="headerlink" title="PoolingHttpClientConnectionManager"></a>PoolingHttpClientConnectionManager</h2><p>HttpClien高并发请求连接池 - PoolingHttpClientConnectionManager</p>
<p>连接池：<br>连接池技术作为创建和管理连接的缓冲池技术，目前已广泛用于诸如数据库连接等长连接的维护和管理中，能够有效减少系统的响应时间，节省服务器资源开销。其优势主要有两个：其一是减少创建连接的资源开销，其二是资源的访问控制。连接池管理的对象是长连接。</p>
<p>PoolingHttpClientConnectionManager是通过租用连接和收回链接的方式来实现的。解决了http请求的多线程问题。</p>
<p>依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>实现http连接池：<a href="https://blog.csdn.net/qq_34484062/article/details/109470135">https://blog.csdn.net/qq_34484062/article/details/109470135</a></p>
<h2 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h2><p>远程过程调用（Remote Procedure Call，缩写为 RPC）允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。</p>
<p>远程过程调用是一个分布式计算的客户端-服务器（Client/Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p>
<p>为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。<br>有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。</p>
<p>服务的调用过程为：<br>1、client调用client stub，这是一次本地过程调用<br>2、client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling<br>3、client所在的系统将消息发送给server<br>4、server的的系统将收到的包传给server stub<br>5、server stub解包得到参数。 解包也被称作 unmarshalling<br>6、最后server stub调用服务过程. 返回结果按照相反的步骤传给client</p>
<hr>
<p>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存。</p>
<p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。<strong>HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</strong></p>
<p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们<strong>这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术</strong>。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p>
<p>例如数据库：<br>子系统和数据库之间的交互也是通过 RPC 进行的，只不过这里是三个子系统之间复杂的组合消息交互罢了。如果再深入进去，你会发现，这里的数据库不是那种单机数据库，而是具备主从复制功能的数据库，比如 MySQL。在互联网企业里一般都会使用这种主从读写分离的数据库。一个业务子系统将数据写往主库，主库再将数据同步到从库，然后另一个业务子系统又从从库里将数据取出来。这时又可以进一步将它们看成是四个子系统之间进行的更加复杂的 RPC 数据交互。</p>
<hr>
<p>一些分布式场景中RPC的使用：（广义上的RPC）</p>
<p>✅nginx<br>Ngnix 是互联网企业使用最为广泛的代理服务器。它可以为后端分布式服务提供负载均衡的功能，它可以将后端多个服务地址聚合为单个地址来对外提供服务。Nginx 和后端服务之间的交互在本质上也可以理解为 RPC 数据交互。也许你会争辩说 Nginx 和后端服务之间使用的是 HTTP 协议，走的是短连接，严格上不能算是 RPC 调用。不过 Nginx 和后端服务之间还可以走其它的协议，比如 uwsgi 协议、fastcgi 协议等，这两个协议都是采用了比 HTTP 协议更加节省流量的二进制协议。</p>
<p>✅Hadoop<br>在大数据技术领域，RPC 也占据了非常重要的地位。大数据领域广泛应用了非常多的分布式技术，分布式意味着节点的物理隔离，隔离意味着需要通信，通信意味着 RPC 的存在。大数据需要通信的量比业务系统更加庞大，所以在数据通信优化上做的更深。比如最常见的 Hadoop 文件系统 hdfs，一般包括一个 NameNode 和多个 DataNode，NameNode 和 DataNode 之间就是通过一种称为 Hadoop RPC 的二进制协议进行通讯。</p>
<p>✅TensorFlow<br>在人工智能领域，RPC 也很重要，著名的 TensorFlow 框架如果需要处理上亿的数据，就需要依靠分布式计算力，需要集群化，当多个分布式节点需要集体智慧时，就必须引入 RPC 技术进行通讯。Tensorflow Cluster 的 RPC 通讯框架使用了 Google 内部自研的 gRPC 框架。</p>
<p>转自：<a href="https://www.kancloud.cn/machh03/server/2096716">https://www.kancloud.cn/machh03/server/2096716</a><br>里面还有实现rpc</p>
<h2 id="理解http和rpc"><a href="#理解http和rpc" class="headerlink" title="理解http和rpc"></a>理解http和rpc</h2><p>HTTP1.0 协议时，HTTP 调用还只能是短链接调用，一个请求来回之后连接就会关闭。HTTP1.1 在 HTTP1.0 协议的基础上进行了改进，引入了 KeepAlive 特性可以保持 HTTP 连接长时间不断开，以便在同一个连接之上进行多次连续的请求，进一步拉近了 HTTP 和 RPC 之间的距离。</p>
<p>当 HTTP 协议进化到 2.0 之后，Google 开源了一个建立在 HTTP2.0 协议之上的通信框架直接取名为 gRPC，也就是 Google RPC，这时 HTTP 和 RPC 之间已经没有非常明显的界限了。</p>
<p>HTTP 与 RPC 的关系就好比普通话与方言的关系。要进行跨企业服务调用时，往往都是通过 HTTP API，也就是普通话，虽然效率不高，但是通用，没有太多沟通的学习成本。但是在企业内部还是 RPC 更加高效，同一个企业公用一套方言进行高效率的交流，要比通用的 HTTP 协议来交流更加节省资源。整个中国有非常多的方言，正如有很多的企业内部服务各有自己的一套交互协议一样。好比开源 RPC 协议中 Protobuf 和 Thrift 一样，它们两应该是 RPC 协议中使用最为广泛的两个。</p>
<p>rpc基于什么实现网络传输？<br>1.rpc可以基于tcp直接开发自己的协议，这个是可以保持长连接的，tcp的传输效率高，并且可以一直维持链接</p>
<p>2.自定义协议可以优化数据的传输，例如更大的压缩比。分布式系统中非常有用。</p>
<p>3.http协议1.x一般情况下一个来回就关闭连接，虽然提供了keep-alive可以保持长连接，但是依然不方便，所以就出现了http2.0， http2.0基本上可以当做tcp协议使用了。所以grpc就会使用http2.0开发。</p>
<h2 id="rest和restful"><a href="#rest和restful" class="headerlink" title="rest和restful"></a>rest和restful</h2><p>REST，英文全称Representational State Transfer（表述性状态转移），是一组架构约束条件和原则（注意，REST是设计风格而不是标准）。满足这些约束条件和原则的应用程序或设计就是RESTful。可以降低开发的复杂性，提高系统的可伸缩性。体现在Web开发中就是通过HTTP方法中的POST、DELETE、PUT、GET来对资源进行操作。</p>
<p>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE，还可能包括 HEADER 和 OPTIONS。</p>
<p>Representation（表现层）<br>资源的信息载体形式。它可以是文本、XML、JSON或者是一个二进制文件。它的表现形式应该在HTTP请求的头信息中用Accept和Content-Type字段指定描述。</p>
<p>State Transfer（状态转移）<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转移”。</p>
<p>在 HTTP 中，我们一般通过四种 HTTP 动词来对应资源的变化：<br>POST（新建资源，也可用于更新资源）<br>DELETE（删除资源）<br>PUT（更新资源）<br>GET（获取资源）</p>
<p>REST架构原则：<br>对网络上所有资源都有一个资源标识符<br>对资源的操作不会改变标识符<br>同一资源有多种表现形式，如XML、JSON…<br>所有操作都是无状态的（Stateless）</p>
<p>RESTful，是一种网络应用程序的设计风格和开发方式。RESTful可以通过一套统一的接口为Web，iOS和Android提供服务。比如微博开放平台，微信开放平台等，它们不需要有显式的前端，只需要一套提供服务的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在使用RESTful风格之前，我们通常是这样操作用户数据:</span><br><span class="line">//创建用户信息</span><br><span class="line">http://localhost:8080/user/createUser</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">http://localhost:8080/user/deleteUser/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">http://localhost:8080/user/updateUser/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">http://localhost:8080/user/getUsers</span><br><span class="line"></span><br><span class="line">使用RESTful风格之后:</span><br><span class="line">//创建用户信息</span><br><span class="line">POST http://localhost:8080/user</span><br><span class="line">//删除id为1的用户信息</span><br><span class="line">DELETE http://localhost:8080/user/1</span><br><span class="line">//修改id为2的用户信息</span><br><span class="line">PUT http://localhost:8080/user/2</span><br><span class="line">//获取所有用户信息</span><br><span class="line">GET http://localhost:8080/user获取所有用户信息</span><br><span class="line">通过约定不同的HTTP方法来实现不同的业务，有一个更加直观的了解。</span><br><span class="line">1、看URL就知道要操作什么</span><br><span class="line">2、看HTTP方法就知道要如何操作</span><br><span class="line">3、看HTTP状态码就知道返回结果如何</span><br></pre></td></tr></table></figure>

<p>参考：<br>rest与restful：<br><a href="https://blog.csdn.net/weixin_44316527/article/details/106276655">https://blog.csdn.net/weixin_44316527/article/details/106276655</a></p>
<hr>
<p>rpc与restful：</p>
<p>RPC（Remote Procedure Call Protocol）就是远程调用。最简单的想法，应该就是把HTTP协议当做RPC来用。比如我们把网址作为一个借口，传入的参数作为函数参数，response的数据作为返回信息。这其实就是一个调用。</p>
<p>RESTful和RPC最大的区别应该就是面向对象了。<br>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ；<br>REST：所谓的 Representational state transfer ，是面向资源的；<br>除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的。<br>很多人只知道GET和POST，因为现在最常用的就是GET和POST了。虽说这应该是违背了HTTP设计的初衷。</p>
<p>序列化协议的区别：<br>接口调用通常包含两个部分，序列化和通信协议。<br>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。<br>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<p>什么时候用？<br>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的HTTP接口，一个RPC的调用性能更高。从性能角度看，由于HTTP本身提供了丰富的状态功能与扩展功能，但也正由于HTTP提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而RPC服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p>
<p>转自：<br><a href="https://developer.aliyun.com/article/53677">https://developer.aliyun.com/article/53677</a></p>
<hr>
<p>restful和http：</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<hr>
<p>总结：rpc、http、rest</p>
<p>rpc是一种协议还是，还是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想？更是后者<br>rpc包含：服务发现、负载、容器、网络传输、序列化等组件。<br>rpc指明了程序如何进行网络传输和序列化。</p>
<p>关于rpc和http的比较：<br>rpc的网络传输是如何实现的，rpc是连接，http是短连接。<br>http是一种rpc（广义上），还是rpc可以基于http实现？<br>RPC可以基于TCP协议也可以基于HTTP协议。<br>HTTP需要携带的信息更多，低效，RPC仅传输与业务相关的数据，传输数据更小，性能更高</p>
<p>关于rpc和restful的比较：<br>rpc面向方法，restful面向资源。<br>日常写的接口，更多基于rpc面向方法的，虽然有的是rpc接口，有的是http接口。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常规</title>
    <url>/2022/04/30/myblog/JAVA/java/</url>
    <content><![CDATA[<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>1、sql（dao层）返回的，尽量不要用VO，而使用DO。除非联表查询？dao层查出来的do需要加其他表的一两个字段，可以在原表do的基础上继承封装一下，如果要传入，可以直接输入子类，dao层处理时会自动解析为父类。</p>
<p>2、service里面不要调不想干的dao层方法，而是调dao所在service的方法。</p>
<p>3、继承自同一抽象类的类方法，需要对同一返回处理，并且是串行的，可以输入中用context。</p>
<p>4、main方法是静态方法，同一个类内的方法得加static，不然就是成员方法，成员方法无法在静态方法中调用。</p>
<p>5、运行时异常比如NPE，在方法里throw，不需要在方法上throw了，并且里面方法抛出的异常，可以在外面方法可以catch到。</p>
<p>6、写service什么时候写成类，什么时候写成接口？ 如果对外的话就写接口，如果内部代码用，就service类就行。</p>
<p>7、null不能用来做比较，会报NPE，例如：1 == null，不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer s1 = null;</span><br><span class="line">if(s1 == 1) System.out.println(&quot;不对&quot;);  //报NPE</span><br><span class="line">Integer s1 = 3;</span><br><span class="line">if(null == s1) System.out.println(&quot;对&quot;); //对的</span><br><span class="line">String s1 = null;</span><br><span class="line">if(s1 == &quot;a&quot;) System.out.println(&quot;对&quot;); //String不会NPE</span><br></pre></td></tr></table></figure>

<p>8、如果类报红，没有引用到，尝试更新下仓库：点idea右边maven，点左上角更新圈，更新一下。如果还不行，看一下maven的setting文件对不对。</p>
<p>9、if、while、for关键词的后面和括号之间要有空格，HashMap&lt;Integer, Integer&gt;和变量名之间要有空格。<br>方法名后面到入参的括号不需要空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public voif func(Integer i) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、不要在代码中，特别是主线程中随便Thread.sleep，这样会阻塞住线程。</p>
<p>11、方法返回如果是包装类型Double等，如果用double接，是接不住null的，会报空指针异常。</p>
<p>12、boolean这种类型，如果是一个对象的参数，初始化对象时，会给一个默认值false，但是单独初始化boolean类型，需要给值，不能boolean b;</p>
<p>13、配置可以写在一个接口里 XXXInstance，可以这么取名，直接加类型就行，不用public static。调用的时候就 XXXInstance.SSS。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>private：仅限类本身可见<br>default：类内部、包访问权限<br>protected：类内部、同一个包、子类中访问<br>public：类内部、同一个包、子类、任意位置都能访问</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>✅java: Compilation failed:</p>
<p>报错原因：<br>项目中Java版本不一致，可以查看项目中的jdk配置.<br>1、查看项目的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt;Project </p>
<p>2、查看工程的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt; Modules -&gt; （需要修改的工程名称） -&gt; Sources -&gt;</p>
<p>3、查看idea中Java配置<br>compile 的 java compile中。</p>
<p>✅空指针NPE</p>
<p>空指针(Null Pointer Exception，NPE)<br>空指针异常属于运行时的异常。当Java尝试去调用真实对象上的任何方法时，如果在运行时中，该对象调用的是空引用(Null Reference)，那么就会抛出异常。<br>由于种种原因，开发人员时常会忘记初始化对象和验证对象。这往往是导致空指针异常的根源。<br>例如：对一个为null的对象调用get/set方法，就会NPE。</p>
<p>🤔Optional避免空指针<br>java.util.Optional 是java8中引进的一个新的类，它可以对可能缺失的值进行建模，而不是直接将null赋值给变量。</p>
<p>java引入空指针的危害：<br>1、它是很多问题的错误之源，它是目前开发中最典型的异常。<br>2、它会使代码膨胀，它会使我们的代码充满了深度嵌套的null检查，代码的可读性下降。<br>3、它自身是毫无意义的，null自身没有任何的语义，它表示以一种错误的方式对缺失变量的值建模。<br>4、它破坏了java的哲学，java一直避免引入指针的存在，而唯一的例外就是null指针。<br>5、它破坏了java的类型，null不属于任何类型，这也意味着它可以被赋值给任意引用类型的变量，我们将无法获取这个null值最初的类型是什么。<br>而Optional的出现可以让我们最大程度上规避上述问题。</p>
<p>Optional的使用：<a href="https://blog.csdn.net/aaaPostcard/article/details/123596787">https://blog.csdn.net/aaaPostcard/article/details/123596787</a><br>（感觉只能避免对自己定义的domain产生空指针异常，无法避免从数据库中获取到null，然后操作造成NPE。）</p>
<p>✅ IllegalStateException:Failed to load ApplicationContext</p>
<p>加载类出问题，往下看是哪个类没加载，获取bean出现问题，看是不是当作对象调用了，但是没加@Service。</p>
<p>✅ for循环内通过new来修改引用变量导致的问题</p>
<p>for循环中声明的变量是局部变量，List中存着对象的引用变量，也就是对象在堆中的地址。for循环中通过set方法来改变堆中的变量，没问题，引用变量并不会改变。</p>
<p>但是，for循环中通过new一个新对象来赋值给局部变量，新对象是在堆中创建了，对象地址赋给局部变量，但是List中的值并没有改变。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test10() &#123;</span><br><span class="line">    A a = new A(&quot;lll&quot;);</span><br><span class="line">    List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">    List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">    list2.addAll(list1);</span><br><span class="line">    System.out.println(list2); //[A(name=lll)]</span><br><span class="line">    a.setName(&quot;www&quot;);</span><br><span class="line">    System.out.println(list1); //[A(name=www)]</span><br><span class="line">    System.out.println(list2); //[A(name=www)]</span><br><span class="line"></span><br><span class="line">    for (A u : list2) &#123;</span><br><span class="line">        u.setName(&quot;bbb&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1642360923</span><br><span class="line">        A u1 = new A(&quot;aaa&quot;);</span><br><span class="line">        u = u1;</span><br><span class="line">        u.setName(&quot;aaa&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1343441044</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list2); //[A(name=bbb)]</span><br><span class="line">    System.out.println(list2.get(0).hashCode()); //1642360923</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">class A &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Void-与-void-与-null"><a href="#Void-与-void-与-null" class="headerlink" title="Void 与 void 与 null"></a>Void 与 void 与 null</h3><p>void 是一种基本数据类型。而 Void 是 void 封装类型。<br>Void 之于 void 类似于 Integer 之于 int。但并非如此，Void 比较特别：<br>它不可实例化<br>它没有内置的类型实例，也没有可用的字面值。</p>
<p>声明一个 Void 变量通常是没有什么意义的，因为没有可为其赋值的实例。Void 变量唯一能持有的是 null。Void 一个可用的地方是反射判断方法的返回值时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(m.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">	// 处理返回值为 void 的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也不是必需使用Void.TYPE，也可以用void.class。<br>总结来说，几乎很少会用到 Void 。</p>
<p>null是所有引用类型的默认值，但是要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。</p>
<p>访问一个类里的方法，如果用null赋予的对象访问普通方法，会NullPointerException，而访问static方法，没事，因为访问静态方法不需要实例对象。因此，静态方法的访问，不建议用实例调用，用类调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main m = (Main) null;</span><br><span class="line">System.out.println(m instanceof Main); //返回false</span><br><span class="line">System.out.println(m.getClass()); //空指针</span><br></pre></td></tr></table></figure>

<p>void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        return; //返回void，return可写可不写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void do2() &#123;</span><br><span class="line">        return null; //此处必须返回null 返回其余类型都不好使</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Void.class); //class java.lang.Void</span><br><span class="line">        System.out.println(void.class); //void</span><br><span class="line">        //类似于下面的</span><br><span class="line">        System.out.println(Integer.class); //class java.lang.Integer</span><br><span class="line">        System.out.println(int.class); //int</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void我们到底有什么用呢？其实在泛型出现之前，Void一般用于反射之中。判断方法返回是否为void。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">  public void print(String v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    for(Method method : Test.class.getMethods()) &#123;</span><br><span class="line">      //判断返回值类型 用到了Void类</span><br><span class="line">      if(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有有的时候，并不需要返回值的抽像性设计，比如下面设计的分布式锁：RedisLock.</p>
<p>更多用法：<a href="https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0">https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0</a></p>
<h3 id="Java中包装类型和基本类型的使用场景"><a href="#Java中包装类型和基本类型的使用场景" class="headerlink" title="Java中包装类型和基本类型的使用场景"></a>Java中包装类型和基本类型的使用场景</h3><p>最简单的理解，基本类型有默认值，而包装类型初始为null。然后再根据这两个特性进行分业务使用，在阿里巴巴的规范里所有的POJO类必须使用包装类型，而在本地变量推荐使用基本类型。定义方法的输入输出参数用包装类型。List里用包装类型(,因为List中的泛型必须是引用类型。)，for循环里用包装类型。</p>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>1、整数：包括int、short、byte、long初始值为0。<br>2、浮点型：float、double初始值为0.0<br>3、字符：char初始值为空格，即’’ “，如果输出，在Console上是看不到效果的。<br>4、布尔：boolean初始值为false </p>
<p>基本类型的包装类<br>Integer 、Long、Short、Byte、Character、Double、Float、Boolean、BigInteger、BigDecimal<br>其中BigInteger、BigDecimal没有相对应的基本类型，主要应用于高精度的运算，BigInteger 支持任意精度的整数，<br>BigDecimal支持任意精度带小数点的运算。</p>
<p>基本类型与包装类型的异同：<br>1、在Java中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型则需new关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值，保存在堆栈中能高效的存取；封装类型需要通过引用指向实例，具体的实例保存在堆中；<br>4、初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。<br>6、什么时候该用包装类，什么时候该用基本类型，看基本的业务来定：这个字段允不允许null值，如果允许，则必然要用封装类；否则，基本类型就可以了。如果用到比如泛型和反射调用函数，就需要用包装类！ </p>
<p>转自 <a href="http://t.zoukankan.com/east7-p-9887722.html">http://t.zoukankan.com/east7-p-9887722.html</a></p>
<h4 id="parseDouble-和valueOf-方法，类型转换"><a href="#parseDouble-和valueOf-方法，类型转换" class="headerlink" title="parseDouble()和valueOf()方法，类型转换"></a>parseDouble()和valueOf()方法，类型转换</h4><p>✅Double类parseDouble()和valueOf()方法的区别（String转Double）</p>
<p>1、Double.parseDouble(java.lang.String)的参数只能是String。Double.valueOf()的参数类型可以是浮点型或者是字符串均可。</p>
<p>2、Double.parseDouble(java.lang.String)把数字类型的字符串转换成double类型，返回是double类型。入参是String。<br>Double.valueOf()方把数字类型的字符串转换成Double类型，返回是Double类型。入参是String或double。</p>
<p>这两个方法里面都不能是Object类型，得先o.toString转为String，再变Double。注意空指针。</p>
<p>✅Double转String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = Double.toString(1.1);  //里面可以是double也可以是Double,为null会NPE</span><br><span class="line"></span><br><span class="line">Double d = 1.1;</span><br><span class="line">String s1 = d.toString();  //Object的toString方法double类型不能用,d为null会NPE</span><br><span class="line"></span><br><span class="line">double d1 = 1.2;</span><br><span class="line">String s1 = String.valueOf(d);  //里面可以是double也可以是Double,可以是null，nul的话输出“null”</span><br></pre></td></tr></table></figure>

<p>✅强制类型转换<br>首先，每个包装类型都有一个valueOf方法，用来把其他类型转换为自己类型。例如：Double d = Double.valueOf(“1”);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    System.out.println((double) 1 / 1000); //输出0.001</span><br><span class="line">    System.out.println((double) (1 / 1000)); //输出0.0</span><br><span class="line">    Integer integer = 1;</span><br><span class="line">    System.out.println((double) integer / 1000); //输出0.001</span><br><span class="line"></span><br><span class="line">    //向上取整</span><br><span class="line">    double d = Math.ceil(2.3);</span><br><span class="line">    Integer i = (int) d;</span><br><span class="line">    System.out.println(i); //输出3</span><br><span class="line"></span><br><span class="line">    int x = 1, y = 2;</span><br><span class="line">    double z = x / y; //waring:&#x27;x / y&#x27;: integer division in floating-point context （意思是说这是浮点数的除法）</span><br><span class="line">    System.out.println(z);  //0.0</span><br><span class="line">    double w = 1.0 * x / y;</span><br><span class="line">    System.out.println(w);  //0.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="String-valueOf-1L-和-l-toString"><a href="#String-valueOf-1L-和-l-toString" class="headerlink" title="String.valueOf(1L)和 l.toString"></a>String.valueOf(1L)和 l.toString</h4><p>String.valueOf 入参是Object。<br>String.valueOf 如果传入null，返回是“null”字符串，而不是空null。<br>null.toString() 会报空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Long l = new Long(1L);</span><br><span class="line">String s1 = String.valueOf(l);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">String s2 = l.toString();</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">l = null;</span><br><span class="line">String s3 = String.valueOf(l);</span><br><span class="line">System.out.println(s3);  //null</span><br><span class="line">String s4 = l.toString(); //NullPointerException</span><br><span class="line">System.out.println(s4);</span><br></pre></td></tr></table></figure>

<h4 id="判断小数精确度"><a href="#判断小数精确度" class="headerlink" title="判断小数精确度"></a>判断小数精确度</h4><p>实现思路：用String的split方法，得到小数点后的String，再看大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (&quot;1231312.12&quot;.split(&quot;\\.&quot;)[1].length()==2) &#123;</span><br><span class="line">    System.out.println(&quot;是两位小数&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较两个double的大小"><a href="#比较两个double的大小" class="headerlink" title="比较两个double的大小"></a>比较两个double的大小</h4><p>1.用bigdecimal，传入string类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal bdL = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">BigDecimal bdR = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">if (bdL.compareTo(bdR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (bdL.compareTo(bdR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>2.使用Double</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Double dL = 1.33;</span><br><span class="line">Double dR = 1.33;</span><br><span class="line">if (dL.compareTo(dR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (dL.compareTo(dR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>3.在误差范围内允许相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 两实数的差在允许的范围内认为相等既可认为是相等的</span><br><span class="line">Double num1 = 1.222;</span><br><span class="line">Double num2 = 1.222;</span><br><span class="line">if (num1 - num2 &gt; 0.000001)</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br><span class="line">else if (num1 - num2 &lt; -0.0000001)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br></pre></td></tr></table></figure>

<p>4.转换成字符串</p>
<p>可以将double数据转换成string然后借助string的compareTo方法来间接实现比较两个double数据是否相等。注意这种方法只适用于比较精度相同的数据，并且是只能用于比较正数的大小，负数比较结果异常，不过可以用于比较两数是否相等，此时正负数对结果没有影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String strL = String.valueOf(num1);</span><br><span class="line">String strR = String.valueOf(num2);</span><br><span class="line">if (strL.compareTo(strR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (strL.compareTo(strR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>5.使用doubleToLongBits()方法</p>
<p>使用sun提供的Double.doubleToLongBits()方法，该方法可以将double转换成long型数据，从而可以使double按照long的方法（&lt;, &gt;, ==）判断是否大小和是否相等，但是，这种办法还是只能用于比较正数，负数结果异常，比较两数相等与否是没有问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用使用sun提供的Double.doubleToLongBits()方法</span><br><span class="line">long lL = Double.doubleToRawLongBits(num1);</span><br><span class="line">long lR = Double.doubleToRawLongBits(num2);</span><br><span class="line">System.out.println(lL + &quot;:&quot; + lR);</span><br><span class="line">if (lL &lt; lR)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (lL == lR)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/qq_49217297/article/details/124969742">https://blog.csdn.net/qq_49217297/article/details/124969742</a></p>
<h4 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h4><p>1、使用java.math.BigDecimal，四舍五入的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Double value = 1.2355;</span><br><span class="line">BigDecimal bd = new BigDecimal(value);</span><br><span class="line">bd = bd.setScale(2, RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(bd.toString());</span><br><span class="line">System.out.println(bd.doubleValue());</span><br></pre></td></tr></table></figure>

<p>2、使用DecimalFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DecimalFormat df = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(df.format(value));</span><br></pre></td></tr></table></figure>

<p>3、使用NumberFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">//如果不这么做，那么当value的值是100.00的时候返回100</span><br><span class="line">nf.setMaximumFractionDigits(2);</span><br><span class="line">nf.setMinimumFractionDigits(2);</span><br><span class="line">nf.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">//如果想输出的格式用逗号隔开，可以设置成true</span><br><span class="line">nf.setGroupingUsed(false);</span><br><span class="line">System.out.println(nf.format(value));</span><br></pre></td></tr></table></figure>

<p>4、使用java.util.Formatter,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = new Formatter().format(&quot;%.2f&quot;, value).toString();</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>5、使用String.format来实现，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, value));</span><br></pre></td></tr></table></figure>

<p>六、通过运算，不是四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long l =(long)(value*100) ;</span><br><span class="line">double d = l/100D;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<p>Java保留两位小数的几种写法总结：<br><a href="https://cloud.tencent.com/developer/article/2155412">https://cloud.tencent.com/developer/article/2155412</a></p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>使用场景：比较精确的数字的加减法、小数的四舍五入</p>
<p>首先，浮点数为什么不准确？<br>码农在程序里写的10进制小数，计算机内部无法用二进制的小数来精确的表达。<br>对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n）</p>
<p>试一试如何表达十进制的 0.2 吧。</p>
<p>0.01 = 1/4 = 0.25 ,太大</p>
<p>0.001 =1/8 = 0.125 , 又太小</p>
<p>0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了</p>
<p>0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了</p>
<p>0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大</p>
<p>0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错</p>
<p>0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875<br>已经很逼近了， 就这样吧。</p>
<p>这就是用二进制小数没法精确表达10进制小数的含义。<br>根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值</p>
<p>《Effective Java》在第48条推荐“使用BigDecimal来做精确运算”。</p>
<hr>
<p>float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场啦。</p>
<p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。</p>
<hr>
<h4 id="✅BigDecimal构造方法："><a href="#✅BigDecimal构造方法：" class="headerlink" title="✅BigDecimal构造方法："></a>✅BigDecimal构造方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BigDecimal(double val)    将double表示形式转换为BigDecimal *不建议使用</span><br><span class="line">public BigDecimal(int val)　　将int表示形式转换成BigDecimal</span><br><span class="line">public BigDecimal(long)    创建一个具有参数所指定长整数值的对象。 </span><br><span class="line">public BigDecimal(String val)　　将String表示形式转换成BigDecimal *推荐使用</span><br></pre></td></tr></table></figure>
<p>⚠️BigDecimal 不像Double一样可以直接=1.1。 BigDecimal需要new个对象，或者：BigDecimal.ZERO 表示0.0。</p>
<p>为什么不推荐使用Double入参？<br>BigDecimal bDouble = new BigDecimal(2.3);<br>最终输出的数是：2.29999999….</p>
<p>为什么会出现这种情况呢？</p>
<p>JDK的描述：<br>1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p>
<p>2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。</p>
<p>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal bDouble1 = BigDecimal.valueOf(2.3); //方法不能传null</span><br><span class="line">BigDecimal bDouble2 = new BigDecimal(Double.toString(2.3));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅BigDecimal用法："><a href="#✅BigDecimal用法：" class="headerlink" title="✅BigDecimal用法："></a>✅BigDecimal用法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a + b =&quot; + a.add(b));</span><br><span class="line">        System.out.println(&quot;a - b =&quot; + a.subtract(b));</span><br><span class="line">        System.out.println(&quot;a * b =&quot; + a.multiply(b));</span><br><span class="line">        System.out.println(&quot;a / b =&quot; + a.divide(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>👋BigDecimal除法可能出现不能整除的情况，比如 4.5/1.3，这时会报错java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p>
<p>其实divide方法有可以传三个参数</p>
<p><code>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) </code><br>第一参数表示除数， 第二个参数表示小数点后保留位数，<br>第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROUND_CEILING    //向正无穷方向舍入</span><br><span class="line">ROUND_DOWN    //向零方向舍入</span><br><span class="line">ROUND_FLOOR    //向负无穷方向舍入</span><br><span class="line">ROUND_HALF_DOWN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5</span><br><span class="line">ROUND_HALF_EVEN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><span class="line">ROUND_HALF_UP    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6</span><br><span class="line">ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式</span><br><span class="line">ROUND_UP    //向远离0的方向舍入</span><br><span class="line"></span><br><span class="line">四舍五入采用 ROUND_HALF_UP</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(&quot;1000&quot;);  </span><br><span class="line">BigDecimal b2 = new BigDecimal(&quot;100&quot;);  </span><br><span class="line">System.out.println(b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP).toString());</span><br><span class="line">输出：</span><br><span class="line">10.00,结果返回一个BigDecimal</span><br></pre></td></tr></table></figure>


<p>对BigDecimal进行截断和四舍五入可用setScale方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5635&quot;);</span><br><span class="line"></span><br><span class="line">        a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入</span><br><span class="line">        a = a.setScale(3, BigDecimal.ROUND_HALF_UP);    //这个也行</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Double d = a.doubleValue();  //转为double/Double类型</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal都是不主动变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line">        a.add(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);  //输出4.5. 加减乘除方法会返回一个新的BigDecimal对象，原来的a不变</span><br><span class="line">        a = a.add(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/YangJavaer/p/6056394.html">https://www.cnblogs.com/YangJavaer/p/6056394.html</a></p>
<hr>
<h4 id="✅BigDecimal比较"><a href="#✅BigDecimal比较" class="headerlink" title="✅BigDecimal比较"></a>✅BigDecimal比较</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int flag = bigdemical.compareTo(bigdemical1)。</span><br><span class="line"></span><br><span class="line">flag = -1，表示bigdemical小于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =0，表示bigdemical等于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =1，表示bigdemical大于bigdemical1。</span><br><span class="line"></span><br><span class="line">实际中直接跟0比较就可以了，别跟-1或者1比较。</span><br></pre></td></tr></table></figure>

<p>BigDecimal的equals方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal a=BigDecimal.valueOf(1.0);</span><br><span class="line">BigDecimal b=BigDecimal.valueOf(1.000);</span><br><span class="line">System.out.println(a.equals(b));  //true</span><br><span class="line"></span><br><span class="line">BigDecimal c = new BigDecimal(&quot;10.00&quot;);</span><br><span class="line">BigDecimal d = new BigDecimal(&quot;10&quot;);</span><br><span class="line">BigDecimal e = new BigDecimal(10.00);</span><br><span class="line">System.out.println(c.equals(d));  //false</span><br><span class="line">System.out.println(c.equals(e));  //false</span><br><span class="line">// equals是比较内容，“1.0”和“1.000”不一样.</span><br><span class="line"></span><br><span class="line">//toPlainString再equals</span><br><span class="line">System.out.println(c.toPlainString().equals(d.toPlainString())); //false</span><br><span class="line">System.out.println(c.toPlainString().equals(e.toPlainString())); //false</span><br><span class="line"></span><br><span class="line">//longValue方式</span><br><span class="line">System.out.println(c.longValue() == d.longValue()); //true</span><br><span class="line">System.out.println(c.longValue() == e.longValue()); //true</span><br><span class="line"></span><br><span class="line">//compareTo</span><br><span class="line">System.out.println(c.compareTo(d) == 0); //true</span><br><span class="line">System.out.println(c.compareTo(e) == 0); //true</span><br><span class="line"></span><br><span class="line">BigDecimal f = new BigDecimal(&quot;10.100001&quot;);</span><br><span class="line">BigDecimal g = new BigDecimal(10.100001);</span><br><span class="line">System.out.println(f.compareTo(g) == 0); //false</span><br><span class="line">// 这是因为本身Double传参的构造就不准，看上面</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.iteye.com/blog/bijian1013-2366549">https://www.iteye.com/blog/bijian1013-2366549</a></p>
<hr>
<h4 id="✅mysql的decimal"><a href="#✅mysql的decimal" class="headerlink" title="✅mysql的decimal"></a>✅mysql的decimal</h4><p>decimal:数字型，不存在精度损失，常用于银行帐目计算</p>
<p><code>distance decimal(10,1) not null default 0.0 comment &#39;距离&#39;</code></p>
<p>decimal(P,m)<br>P的取值范围是1–65，表示整数位数<br>M的取值是0–30.表示小数位<br>精度M最大为30，表示有30位小数。<br>decimal整数和小数位均不写 默认为decimal(10,0)<br>若小数位不写默认的小数位为0。</p>
<p>decimal(22,6）表示整数位16个小数位6个。</p>
<p>decimal 还可以存储超过bigint的整数位，最大存储65位的整数类型。<br>还可以存储对应位数的负数</p>
<p>例：decimal(2,1)，此时，插入数据“12.3”、“12”等会出现“数据溢出错误”的异常；插入“1.23”或“1.2345…”会自动四舍五入成“1.2”；插入“2”会自动补成“2.0”，以确保2位的有效长度，其中包含1位小数。<br>当用 int类型会有溢出时，可以用 decimal 类型进行处理，把结果可以用 convert 或是 cast 进行转换。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/chenpp666/article/details/124372731">https://blog.csdn.net/chenpp666/article/details/124372731</a></p>
<h3 id="java位运算"><a href="#java位运算" class="headerlink" title="java位运算"></a>java位运算</h3><p>1、左移( &lt;&lt; )  向左移动，低位补0<br>2、右移( &gt;&gt; )  向右移动，高位补0<br>3、无符号右移( &gt;&gt;&gt; )   正数右移，高位补0，负数右移，高位补1，当负数使用无符号右移时，用0进行补位(自然而然的，就由负数变成了正数了)<br>4、与( &amp; )  都为1，结果为1，否则为0<br>5、或( | )  一个是1，结果为1，否则为0<br>6、异或( ^ )  两个相反，结果为1，否则为0<br>7、非( ~ ) 一元操作符   取相反。</p>
<h3 id="Autowired接口还是现实类？"><a href="#Autowired接口还是现实类？" class="headerlink" title="Autowired接口还是现实类？"></a>Autowired接口还是现实类？</h3><p>答案：接口好</p>
<p>当实现类唯一时，表面上注入接口，其实注入实现类<br>当实现类多个时，通过@Service(“menuService1”)指定实现类</p>
<p>解析：<br>这个其实是创建了实现类的对象但引用了接口类型，<br>即 “InjectionDao injectionDao = new InjectionDaoImpl ()”, 是 Java 多态性（向上转型）的一种应用。<br>在实现类处加 @Repository 注解，意思就是 new InjectionDaoImpl (),</p>
<p>而在 InjectionServiceImpl 中定义属性 InjectionDAO injectionDAO 就是将 new 出来的这个 InjectionDaoImpl 对象向上转型为 InjectionDao 类型。</p>
<p>注意：<br>若一个接口被多个实现类，实现的时候，@Autowired，Spring 会按 byType 的方式寻找接口的实现类，将其注入。存在多个实现类，应该指定名字，可以通过 byName 注入的方式。可以使用 @Resource 或 @Qualifier 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实现类1</span><br><span class="line">@Service(&quot;menuService1&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line">//实现类2</span><br><span class="line">@Service(&quot;menuService2&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService1实现类</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService1&quot;)</span><br><span class="line">private IMenuService menuService;</span><br><span class="line"></span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService2实现类  </span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService2&quot;)</span><br><span class="line">private IMenuService menuService;</span><br></pre></td></tr></table></figure>

<p>链接：<a href="https://blog.csdn.net/huangkechen/article/details/122475824">https://blog.csdn.net/huangkechen/article/details/122475824</a></p>
<p>总结：就是Java 多态性（向上转型）的一种应用，但是这样做的好处并没有说。<br>规矩：注入实现类时用@Resource（@Autowired应该也可以），接口单个实现类用@Autowired（@Resource应该也可以），接口多个实现类用@Autowired + @Qualifier(value=””) 或 @Resource(name=””)。</p>
<h3 id="Collection、Collections、CollectionUtils"><a href="#Collection、Collections、CollectionUtils" class="headerlink" title="Collection、Collections、CollectionUtils"></a>Collection、Collections、CollectionUtils</h3><p>Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection（单例集合  ） </span><br><span class="line">├-List（有序，可重复 ）  </span><br><span class="line">│  ├-LinkedList（查询速度慢，增删快）   </span><br><span class="line">│  ├-ArrayList（查询速度快，增删慢）  </span><br><span class="line">│  └-Vector（线程安全的，操作效率低 ）  </span><br><span class="line">│　    └-Stack   </span><br><span class="line">└-Set（无序，不可重复） </span><br><span class="line">      ├-HashSet（使用了哈希表存取）</span><br><span class="line">      │    └-LinkedHashSet</span><br><span class="line">      └-SortedSet</span><br><span class="line">               └-TreeSet（有序）</span><br><span class="line">Map（键值对）  </span><br><span class="line">├-Hashtable   </span><br><span class="line">├-HashMap   </span><br><span class="line">└-WeakHashMap</span><br></pre></td></tr></table></figure>
<p>set是在HashMap的基础上实现的，HashSet的存储方式是把HashMap中的Key作为Set的对应存储项。HashMap是非同步的，线程不安全的，Hashtable虽然是同步线程安全的，但是已经过期了。 现在使用ConcurrentHashMap，这个是线程安全同步的。</p>
<p>Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>例如：排序(Sort)、倒序(reverse)、最大(max)、最小(min)、替换(fill)</p>
<p>使用sort方法可以根据元素的自然顺序对指定列表按升序进行排列。列表中所有元素都必须实现Comparable接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(list);//排序</span><br><span class="line">System.out.println(list);</span><br><span class="line">Collections.reverse(list);//倒序</span><br><span class="line">System.out.println(list);</span><br><span class="line">int max = Collections.max(list);//最大</span><br><span class="line">System.out.println(max);</span><br><span class="line">int min = Collections.min(list);//最小</span><br><span class="line"></span><br><span class="line">Collections.emptyList()  //空list</span><br></pre></td></tr></table></figure>

<p>CollectionUtils是对Collection集合操作的类方法，这个类不是java自带的类方法，需要另外导入一个commons-collections.jar包才可以使用这个类中方法。</p>
<p>例如：CollectionUtils.isEmpty(list)<br>它可以处理null，但是list.isEmpty里面为null，会NPE。</p>
<p>更多用法：<a href="https://blog.csdn.net/chaoge321/article/details/83788667">https://blog.csdn.net/chaoge321/article/details/83788667</a></p>
<h3 id="list的一些操作"><a href="#list的一些操作" class="headerlink" title="list的一些操作"></a>list的一些操作</h3><h4 id="一、Lists-newArrayList-和-new-ArrayList-："><a href="#一、Lists-newArrayList-和-new-ArrayList-：" class="headerlink" title="一、Lists.newArrayList() 和 new ArrayList() ："></a>一、Lists.newArrayList() 和 new ArrayList() ：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">Lists和Maps是谷歌的两个工具类,</span><br><span class="line"></span><br><span class="line">Lists.newArrayList()其实和new ArrayList()几乎一模一样,</span><br><span class="line"></span><br><span class="line">唯一它帮你做的(其实是javac帮你做的),就是自动推导尖括号里的数据类型.</span><br><span class="line"></span><br><span class="line">在 Java 7 之后，都允许类型推断 - 在运行时没有区别。</span><br><span class="line"></span><br><span class="line">java8 的new ArrayList&lt;&gt;()的&lt;&gt;里面可以不写类型，java回帮你自动推导类型</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>同样，还有Sets：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; sets = Sets.newHashSet(&quot;ww&quot;); //可直接定义</span><br><span class="line">Set&lt;String&gt; sets = new HashSet&lt;&gt;(Lists.newArrayList(&quot;11&quot;,&quot;22&quot;));</span><br><span class="line">//还得用list转换</span><br><span class="line"></span><br><span class="line">set没有get(i)方法，遍历得用迭代器。要么先转换成list。</span><br><span class="line">set转换为list：</span><br><span class="line">ArrayList&lt;Long&gt; list = new ArrayList(set);</span><br></pre></td></tr></table></figure>

<p>新建List：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(&quot;1&quot;, &quot;2&quot;); 不行</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list2.add(&quot;3&quot;);  //咩问题</span><br><span class="line">System.out.println(list2);</span><br><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list3.set(1, &quot;3&quot;); //设置除了0、1会报错</span><br><span class="line">System.out.println(list3);</span><br><span class="line">list3.add(&quot;3&quot;);  //报错：java.lang.UnsupportedOperationException</span><br><span class="line">System.out.println(list3);</span><br><span class="line">List&lt;String&gt; list4 = Collections.singletonList(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;); //报错：java.lang.UnsupportedOperationException</span><br><span class="line"></span><br><span class="line">String a[] = new String[] &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot; &#125;;</span><br><span class="line">List&lt;String&gt; list5 = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<p>✅Array.asList创建方式：<br>java.util.Arrays 类的 asList() 方法用于返回一个由指定数组支持的固定大小的列表。<br>Arrays.asList 最大特点是整个集合允许有多个元素存入数组，一旦初始化后，这个数组的长度就是固定的，但数组的元素可以修改，所以也就是为什么 add 和 remove 方法报错的原因。如果在开发中碰到长度可以确定的集合，并且在初始化时已经确定了储存元素的情况下，推荐使用。<br>Arrays.asList 中传入的数组参数中允许存在 null，但不允许只有一个 null</p>
<p>✅Collections.singletonList()创建方式：<br>Collection.singletonList 长度为 1，初始完后不可修改。根据这个特性，在开发的时候遇到只要储存一个元素的集合，并且整个过程存储或者传递为主，不会进行修改或调整的情况下，推荐使用。<br>Collections.singletonList 中保存元素的是一个对象</p>
<p>✅Arrays.asList() 和 Collections.singletonList()区别 ：<br>1、Arrays.asList()得到的List中元素是可变的，大小不可变。<br>而Collections.singletonList是不可变的，一旦修改就会导致UnsupportedOperationException异常抛出<br>2、Collections.singletonList()得到的List元素只能有1个<br>3、Arrays.asList(strArray)不具有add方法，可以通过set方法进行改变值。Collections.singletonList()返回的是不可变的集合，但是这个长度的集合只有1。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_41606477/article/details/108449415">https://blog.csdn.net/weixin_41606477/article/details/108449415</a></p>
<p>新建Set，除了上面的，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; list4 = Collections.singleton(&quot;1&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="二、对list排序：Comparator-java工具类"><a href="#二、对list排序：Comparator-java工具类" class="headerlink" title="二、对list排序：Comparator-java工具类"></a>二、对list排序：Comparator-java工具类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list.sort(Comparator.comparing(A::getB));</span><br><span class="line"></span><br><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序排序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序排序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序 属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序 属性二升序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));//先以属性一降序,再进行属性二升序</span><br><span class="line"></span><br><span class="line">//含Null数据排序,nullsLast空的放后面，距离Date类型属性</span><br><span class="line">list.stream().sorted(Comparator.comparing(item -&gt; item.属性, Comparator.nullsLast(Date::compareTo))).collect(Collectors.toList());</span><br><span class="line">// nullLast或nullFirst里面带类型，可以用Comparator.nullsLast(Comparator.naturalOrder()))</span><br><span class="line"></span><br><span class="line">//空/Null数据分组</span><br><span class="line">Map&lt;String, List&lt;类&gt;&gt; map = list.stream().collect(Collectors.groupingBy(item -&gt; &#123;</span><br><span class="line">  if (item.属性一 == null || item.属性一.equals(&quot;&quot;)) &#123;</span><br><span class="line">  　　return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return DateFormat.getDateInstance().format(item.属性一);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>list可以直接使用sort。<br>用sorted就需要先.stream()，再.collect(Collectors.toList())<br>::都得是get属性</p>
<p>自定义排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;list中元素&gt;()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(元素 o1, 元素 o2) &#123;</span><br><span class="line">    if(..)  return 1;  //表示o1在前</span><br><span class="line">    if(..)  return 0;  //表示一样</span><br><span class="line">    return -1；  //表示o2在前</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="三、list移除：-removeIf"><a href="#三、list移除：-removeIf" class="headerlink" title="三、list移除： removeIf"></a>三、list移除： removeIf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">removeIf() 方法用于删除所有满足特定条件的数组元素。</span><br><span class="line">ArrayList&lt;String&gt; sites = new ArrayList&lt;&gt;();</span><br><span class="line">sites.add(&quot;Taobao&quot;);</span><br><span class="line">sites.removeIf(e -&gt; e.contains(&quot;Tao&quot;));</span><br><span class="line">用了String的contains方法</span><br></pre></td></tr></table></figure>
<p>list元素可以先设置，再更改。</p>
<p>不能在循环中用正序索引进行移除，因为移除的过程中索引会变。<br>可以用倒序索引。<br>如果非得用循环移除，用迭代器。</p>
<p>for的下标倒序遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (&quot;b&quot;.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用list.stream().filter().collect()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; newList = list.stream()</span><br><span class="line">        .filter(e -&gt; !&quot;b&quot;.equals(e))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>用迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    if (&quot;b&quot;.equals(s)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🤔总结一下list移除方法：<br>1、removeIf<br>2、倒叙for循环<br>3、stream filter<br>4、迭代器</p>
<p>⚠️迭代器中，又移除，又对list增加元素是不行的，会引发并发错误。<br>map也是一样，用Entry遍历时，不能又remove又put，而且再循环里不能put新的，只能put已有的，不然会并发错误。也不能remove。用迭代器移除元素。</p>
<p>所以，替换List中的元素，用set方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">list.set(1, 4L);  //[1, 4, 3]</span><br></pre></td></tr></table></figure>

<p>【JAVA】List常用移除、过滤、去重、flatMap、peek等操作：<br><a href="https://blog.csdn.net/qq_38397501/article/details/116494227">https://blog.csdn.net/qq_38397501/article/details/116494227</a></p>
<h4 id="四、判断list为空"><a href="#四、判断list为空" class="headerlink" title="四、判断list为空"></a>四、判断list为空</h4><p>if(CollectionUtils.isEmpty(list)){}</p>
<h4 id="五、indexOf方法"><a href="#五、indexOf方法" class="headerlink" title="五、indexOf方法"></a>五、indexOf方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">indexOf() 方法返回动态数组中元素的索引值。</span><br><span class="line">int i = arraylist.indexOf(Object obj)</span><br></pre></td></tr></table></figure>

<h4 id="六、list、set、String转换"><a href="#六、list、set、String转换" class="headerlink" title="六、list、set、String转换"></a>六、list、set、String转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//list直接变set：</span><br><span class="line">Set&lt;Long&gt; set2 = new HashSet&lt;&gt;(list);</span><br><span class="line">Set&lt;Long&gt; set1 = Sets.newHashSet(list);</span><br><span class="line">//set变list：</span><br><span class="line">List&lt;Long&gt; list2 = new ArrayList&lt;&gt;(set1);</span><br><span class="line">List&lt;Long&gt; list3 = Lists.newArrayList(set1);</span><br></pre></td></tr></table></figure>

<p>,分割的String转换为List，看下面Splitter。</p>
<p>List转换为,分割字符串，看下面Joiner连接字符串。</p>
<h4 id="七、foreach"><a href="#七、foreach" class="headerlink" title="七、foreach"></a>七、foreach</h4><p>forEach() 方法用于遍历动态数组中每一个元素并执行特定操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testArray()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 往数组中添加元素</span><br><span class="line">    numbers.add(1);</span><br><span class="line">    numbers.add(2);</span><br><span class="line">    numbers.add(3);</span><br><span class="line">    numbers.add(4);</span><br><span class="line">    System.out.println(&quot;ArrayList: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">    // 将 lambda 表达式传递给 forEach</span><br><span class="line">    numbers.forEach((e) -&gt; &#123;</span><br><span class="line">        System.out.print(e + &quot; &quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach 增强for循环，用于遍历动态数组中每一个元素并执行特定操作。</p>
<p>List的forEach是在Iterable类中，<code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code>，stream的forEach在Stream中。</p>
<p>Iterable中的方法原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️使用中出现：提示Variable used in lambda expression should be final or effectively final</p>
<p>这句话的意思是：lambda表达式中使用的变量应该是final或者有效的final。</p>
<p>其实在 Java 8 之前：<br>匿名类中如果要访问局部变量的话，那个局部变量必须显式的声明为final。<br>lambda表达式是由匿名内部类演变过来的，他们的作用都是实现接口方法，于是类比匿名内部类，lambda表达式中使用的变量也需要是final类型。</p>
<p>所以：需要赋值到另一个变量中使用。并且为final类型，不是final类型也可以，变量名中加final。<br>因为：Java 8 之后，在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。</p>
<p>为什么 lambda 表达式或者匿名内部类不能访问非 final 的局部变量，为什么呢？</p>
<p>其实这就要说到Jvm内存模型和线程了，因为实例变量存在堆中，而局部变量是在栈上分配，<strong>lambda 表达(匿名内部类) 会在另一个线程中执行</strong>。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</p>
<p>转自：<a href="https://www.liangzl.com/get-article-detail-213550.html">https://www.liangzl.com/get-article-detail-213550.html</a></p>
<p>所以这个问题的原因不在forEach，而是在lambda表达式。<br>java的lambda表达式里不能出现变量，必须是final修饰的，但是可以让变量在定义时候就写入，这样就不算变量了。可以使用lambda表达式，不再报错。（只定义一次不再改，如果是需要多步才能定义出变量，那就写个方法出结果也可以）</p>
<p>不行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean ebola = false;</span><br><span class="line">ebola = list.size()&gt;10;//赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean ebola = checkEbola(list);//相当于定义时直接赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean checkEbola(ArrayList&lt;Object&gt; list)&#123;</span><br><span class="line">  return list.size()&gt;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="八、List截取"><a href="#八、List截取" class="headerlink" title="八、List截取"></a>八、List截取</h4><p>List自己的suubList方法，传参数起始索引和终点索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">    System.out.println(list.subList(1, list.size()));</span><br><span class="line">    // 2,3</span><br><span class="line"></span><br><span class="line">    // 新建固定大小的List</span><br><span class="line">    List&lt;Long&gt; list1 = Lists.newArrayListWithExpectedSize(3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、数组转换为List"><a href="#九、数组转换为List" class="headerlink" title="九、数组转换为List"></a>九、数组转换为List</h4><p>原文：<a href="https://www.jb51.net/article/221887.htm">https://www.jb51.net/article/221887.htm</a></p>
<p>1、使用ArrayList.asList(strArray)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">List&lt;String&gt; ints = Arrays.asList(str);</span><br><span class="line">//这里会报错</span><br><span class="line">ints.add(&quot;laopo&quot;);</span><br></pre></td></tr></table></figure>
<p>使用Arrays工具类Arrays.asList(strArray)方式,转换完成后,只能对List数组进行查改,不能增删,增删就会抛出UnsupportedOperationException 异常。<br>报错原因:Arrays.asList(str)返回值是java.util.Arrays类中一个私有静态内部类 java.utiil.Arrays.Arraylist,并不是我们平时用的java.util.ArrayList();</p>
<p>⚠️：使用的asList()方法会返回一个final的,固定长度的ArrayList类，并不是java.util.ArrayList，直接这样利用它进行add()或remove()是无效的。</p>
<p>2、使用new ArrayList(Arrays.asList(strArray))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">java.util.ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">strings.add(&quot;aop&quot;);</span><br><span class="line">strings.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>通过ArrayList的构造器,将Arrays.asList(strArray)的返回值由java.utilArrays.ArrayList转为java.util.ArrayList.</p>
<p>3、集合工具类Collections.addAll()方法（用这个）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">java.util.ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(str.length);</span><br><span class="line">Collections.addAll(stringList,str);</span><br></pre></td></tr></table></figure>
<p>通过Collections.addAll(arrayList, strArray)方式转换，根据数组的长度创建一个长度相同的List，然后通过Collections.addAll()方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。</p>
<p>4、JDK8的Stream流将3总基本类型数组转为List</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long[] longs = &#123;1, 2, 3&#125;;</span><br><span class="line">double[] doubles = &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(longs).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(doubles).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如果JDK版本在1.8以上,使用流stream来将下列3种数组快速转为List,分别是int[],long[],double[],不支持short[ ],byte[ ],char[]在JDK1.8中暂不支持.</p>
<p>⚠️ 不能把基本数据类型转化为列表<br>asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int [] intarray = &#123; 1 ,  2 ,  3 ,  4 ,  5 &#125;;</span><br><span class="line">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span><br><span class="line">List&lt; int []&gt; list = Arrays.asList(intarray);  //输出一个int[]元素的list</span><br></pre></td></tr></table></figure>

<p>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法“</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int [] intArray = &#123; 1 ,  2 ,  3 ,  4 &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Ints.asList(intArray);</span><br></pre></td></tr></table></figure>

<p>为什么int[]不能直接转为List,而Integer[]可以转为List,而Integer[]就可以转为List了,因为List中的泛型必须是引用类型。？？？</p>
<p>⚠️asList方法返回的是数组的一个视图</p>
<p>视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。</p>
<h4 id="十、List转为数组"><a href="#十、List转为数组" class="headerlink" title="十、List转为数组"></a>十、List转为数组</h4><p>一般数组是不能添加元素的，因为他们在初始化时就已定好长度了，不能改变长度。</p>
<p>1、 list.toArray();</p>
<p>直接将 list 转换成 Object[] 类型的 数组；<br>Object ： 对象类，是所有类的父类</p>
<p><code>Object[]  ans1 = list.toArray();</code></p>
<p>2、list.toArray(T[] a);</p>
<p>输出指定类型的数组，输出的数组类型与括号中参数类型一致；<br>必须是包装类（String、Integer、Character等），不能是基本数据类型了（string、int、char）；<br>// 创建数组时： int [ ] arr = new int [ ] {}; 使用的是基本数据类型</p>
<p><code>Integer[] ans2 = list.toArray(new Integer[list.size()]);</code><br>注意：idea提示用空的：<br><code>Integer[] ans2 = list.toArray(new Integer[0]);</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个list，并且对list赋值        </span><br><span class="line">List&lt;Integer&gt;  list = new ArrayList&lt;&gt;();       </span><br><span class="line">for (int i = 1; i &lt; 11; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//方法一：</span><br><span class="line">Object[]  ans1 = list.toArray();</span><br><span class="line">System.out.println(&quot;1:&quot; + Arrays.toString(ans1));</span><br><span class="line"> </span><br><span class="line">// 方法二：</span><br><span class="line">Integer[] ans2 = list.toArray(new Integer[list.size()]);</span><br><span class="line">System.out.println(&quot;2:&quot; + Arrays.toString(ans2));</span><br><span class="line"> </span><br><span class="line">1:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">2:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>


<p>原文链接：<a href="https://blog.csdn.net/Gc_680/article/details/122568085">https://blog.csdn.net/Gc_680/article/details/122568085</a></p>
<h4 id="十、分割list"><a href="#十、分割list" class="headerlink" title="十、分割list"></a>十、分割list</h4><p>Lists的方法，com.google.guava中。</p>
<p>使用场景：list集合中数据量过大，可根据需要进行拆分，进而通过循环或者多线程来处理数据。<br>或者是list拆分后，分批插入数据库。<br>Lists.partition方法，根据传入的size，对list进行拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将集合list按照 2 个元素一份进行划分</span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 2);</span><br></pre></td></tr></table></figure>

<h4 id="十一、list根据对象中某一元素去重"><a href="#十一、list根据对象中某一元素去重" class="headerlink" title="十一、list根据对象中某一元素去重"></a>十一、list根据对象中某一元素去重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-11 22:25</span><br><span class="line"> **/</span><br><span class="line">public class TestRemoveDup &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *     TreeSet的本质是一个&quot;有序的，并且没有重复元素&quot;的集合，它是通过TreeMap实现的。</span><br><span class="line">     *     TreeSet注意事项：</span><br><span class="line">     *     如果向TreeSet集合中添加元素的时候，元素本身没有具备自然顺序的特性，并且元素所属的类也没有</span><br><span class="line">     *     实现Comparable接口，那么必须在创建TreeSet对象的时候传入一个比较器；</span><br><span class="line">     */</span><br><span class="line">    //根据名字进行比较，相等时TreeSet会将该元素视为重复元素，不允许添加；</span><br><span class="line">    private List&lt;Person&gt; removeDupByName(List&lt;Person&gt; people) &#123;</span><br><span class="line">        Set&lt;Person&gt; personSet = new TreeSet&lt;&gt;(Comparator.comparing(Person::getName));</span><br><span class="line">        personSet.addAll(people);</span><br><span class="line">        return new ArrayList&lt;&gt;(personSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;Person&gt; removeDupByName2(List&lt;Person&gt; people) &#123;</span><br><span class="line">        List&lt;Person&gt; unique = people.stream().collect(</span><br><span class="line">                Collectors.collectingAndThen(</span><br><span class="line">                        Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Person::getName))), ArrayList::new)</span><br><span class="line">        );</span><br><span class="line">        return unique;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //filter的使用方式为： filter(item -&gt; item的逻辑判断 ) ，其中filter会保留判断条件为true的记录</span><br><span class="line">    private List&lt;Person&gt; removeDupByName3(List&lt;Person&gt; people) &#123;</span><br><span class="line">        //用一个name的list去重，没用TreeSet</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();//用来临时存储person的id</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = people.stream().filter(// 过滤去重</span><br><span class="line">                v -&gt; &#123;</span><br><span class="line">                    boolean flag = !names.contains(v.getName());</span><br><span class="line">                    names.add(v.getName());</span><br><span class="line">                    return flag;</span><br><span class="line">                &#125;</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        return personList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; people = new ArrayList&lt;&gt;();</span><br><span class="line">        Person p1 = new Person(&quot;Liu&quot;,30);</span><br><span class="line">        people.add(p1);</span><br><span class="line">        Person p2 = new Person(&quot;Mi&quot;,36);</span><br><span class="line">        people.add(p2);</span><br><span class="line">        Person p3 = new Person(&quot;Liu&quot;,31);</span><br><span class="line">        people.add(p3);</span><br><span class="line">        TestRemoveDup testRemoveDup = new TestRemoveDup();</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people1 = testRemoveDup.removeDupByName(people);</span><br><span class="line">        List&lt;Person&gt; people2 = testRemoveDup.removeDupByName2(people);</span><br><span class="line">        List&lt;Person&gt; people3 = testRemoveDup.removeDupByName3(people);</span><br><span class="line">        System.out.println(people1);</span><br><span class="line">        System.out.println(people2);</span><br><span class="line">        System.out.println(people3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    @ToString</span><br><span class="line">    @RequiredArgsConstructor</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private final String name;</span><br><span class="line">        private final Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的第三种，用filter方法，自定义一个方法，优雅一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unique = books.stream().filter(distinctByKey(o -&gt; o.getId())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter根据Predicate返回的布尔值来判断是否要过滤掉，</span><br><span class="line">会过滤掉返回值为false的数据。</span><br><span class="line">而我们自己定义的distinctByKey返回值就是Predicate，所以可以作为参数传入filter。</span><br><span class="line"></span><br><span class="line">distinctByKey也需要一个Function的参数。</span><br><span class="line">distinctByKey先是定义了一个线程安全的Map(相比于Hashtable以及Collections.synchronizedMap()，</span><br><span class="line">ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，</span><br><span class="line">但同时降低了对读一致性的要求)，因为在流计算中是多线程处理的，需要线程安全。</span><br><span class="line"></span><br><span class="line">然后将值作为key,TRUE作为value put到map中。</span><br><span class="line">这里的put方法使用的是putIfAbsent()。</span><br><span class="line">putIfAbsent()方法是如果key不存在则put如map中，并返回null。若key存在，则直接返回key所对应的value值。</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/zwh0910/p/15877284.html</span><br></pre></td></tr></table></figure>


<h4 id="十二、list-add和addAll的一个NPE问题"><a href="#十二、list-add和addAll的一个NPE问题" class="headerlink" title="十二、list.add和addAll的一个NPE问题"></a>十二、list.add和addAll的一个NPE问题</h4><p>背景：addAll遇到的一个空指针问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test7() &#123;</span><br><span class="line">    Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1L, 1L);</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">    System.out.println(map.get(2L)); //null</span><br><span class="line">    list.add(null); //没问题</span><br><span class="line">    //list.addAll(null); //会报空指针</span><br><span class="line">    //list.addAll(1L);  //addAll只能传Collection</span><br><span class="line"></span><br><span class="line">    list.add(1L);</span><br><span class="line">    list.add(3L);</span><br><span class="line">    list.add(1, 2L);</span><br><span class="line">    System.out.println(list);  //[null, 2, 1, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法是将元素可以插在指定的位置，如果参数只有一个的话就默认插在队列的尾部，而对于addAll方法，可以看其实作用差不多，但是参数必须为Collection 集合。</p>
<p>add方法参数为泛型E，所以他是支持任意类型的，但是这里要注意的一点是，如果你使用add方法并且传的参数为集合，那么其实 list集合会把这个参数中的集合当做一个整体，添加到原本的集合中。<br>而addAll方法，则会把参数里面的集合给分别放进原本的集合中。<br>(通过一个forEach 循环遍历后得到参数集合中的每个元素，在循环里面再分别调用add方法来实现这个功能)</p>
<p>⚠️addAll之后修改之前的list的元素：<br>修改是对新的list有效的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">a.setName(&quot;lll&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">list2.addAll(list1);</span><br><span class="line">System.out.println(list2); //[A(name=lll)]</span><br><span class="line">a.setName(&quot;www&quot;);</span><br><span class="line">System.out.println(list1); //[A(name=www)]</span><br><span class="line">System.out.println(list2); //[A(name=www)]</span><br></pre></td></tr></table></figure>

<h4 id="十三、list反转"><a href="#十三、list反转" class="headerlink" title="十三、list反转"></a>十三、list反转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用stream的sorted (这种方法只能用于普通类型)</span><br><span class="line">List&lt;Long&gt; li = Lists.newArrayList(1L, 2L);</span><br><span class="line">li = li.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line">System.out.println(li);</span><br><span class="line"></span><br><span class="line">2.使用Collections.reverse方法</span><br><span class="line">A a1 = new A(&quot;lll&quot;);</span><br><span class="line">A a2 = new A(&quot;hhh&quot;);</span><br><span class="line">List&lt;A&gt; list = Lists.newArrayList(a1, a2);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">3.保留原List进行反转</span><br><span class="line">List&lt;Integer&gt; listData = new ArrayList&lt;&gt;();</span><br><span class="line">listData.add(1);</span><br><span class="line">listData.add(2);</span><br><span class="line">List&lt;Integer&gt; tempData = Arrays.asList(new Integer[listData.size()]);</span><br><span class="line">Collections.copy(tempData, listData);</span><br><span class="line">Collections.reverse(listData);</span><br><span class="line">System.out.println(&quot;反转后原来:&quot; + tempData);</span><br><span class="line">System.out.println(&quot;反转后现在:&quot; + listData);</span><br></pre></td></tr></table></figure>

<h4 id="十四、list复制"><a href="#十四、list复制" class="headerlink" title="十四、list复制"></a>十四、list复制</h4><p>首先看一下初始化指定长度List的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(new Integer[10]);</span><br><span class="line">System.out.println(list.size());  //10</span><br><span class="line">System.out.println(list);  //都是null</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(10);</span><br><span class="line">System.out.println(list1.size());  //0</span><br><span class="line">System.out.println(list1);  //空[]</span><br></pre></td></tr></table></figure>

<p>list复制的几个方法：</p>
<p>1、copy一个List最简单方式就是使用构造器，这个构造器能接收一个集合参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(list);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.add(4);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.set(0, 5);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br></pre></td></tr></table></figure>
<p>对原来的list进行add，或者set修改某元素，不会影响到复制的。</p>
<p>但是由于使用这种方式的内部机制是：复制对象的引用而不是clone对象，所以对对象的每一个修改都将同时影响两个list。</p>
<p>正式由于上述的原因，使用构造器这种方法比较适用于那些不可改变对象在list间的复制。比如Integer、String…</p>
<p>2、addAll方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;();</span><br><span class="line">copy.addAll(list);</span><br></pre></td></tr></table></figure>
<p>和使用构造器一样，在使用这个方法时，两个list中的内容都将引用的是相同对象。</p>
<p>3、Collections.copy</p>
<p>Collections类提供了一些专门用于操作集合的静态方法。其中一个就是copy。Collections.copy(dest,source),这个方法接收两个参数，一个是source list 和一个dest list（dest list的长度应大于source list，不然会报错：IndexOutOfBoundsException）。</p>
<p>这个方法的特点是： 它将保持每一个被copy元素在目标集合中的下标和它们在源集合中的下标一样。  即： 源集合中下标为1的元素会被复制到目标集合的下标为1的位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; source = Arrays.asList(1,2,3);</span><br><span class="line">List&lt;Integer&gt; dest = Arrays.asList(4,5,6);</span><br><span class="line">Collections.copy(dest, source);</span><br><span class="line">System.out.println(dest);  //1 2 3</span><br><span class="line"></span><br><span class="line">A a1 = new A(&quot;111&quot;);</span><br><span class="line">A a2 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList(a1, a2);</span><br><span class="line">// List&lt;A&gt; list3 = new ArrayList&lt;&gt;(2); //这种初始化大小不行</span><br><span class="line">List&lt;A&gt; list3 = Lists.newArrayList(new A[2]);</span><br><span class="line">System.out.println(list3);  //[null, null]</span><br><span class="line">Collections.copy(list3, list2);</span><br><span class="line">System.out.println(list3);  //[ListTest.A(name=111), ListTest.A(name=222)]</span><br><span class="line">list2.get(0).setName(&quot;333&quot;);</span><br><span class="line">System.out.println(list3);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>注意：这种复制方法也是直接复制引用，而不是深拷贝对象，改变原来List的对象会影响复制的List。</p>
<p>4、使用Java8 stream</p>
<p>在Java8中，我们可以使用stream来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;A&gt; list4 = list2.stream().collect(Collectors.toList());</span><br><span class="line">list2.get(0).setName(&quot;444&quot;);</span><br><span class="line">System.out.println(list4);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>好处是可以用stream进行其他操作，但是还是浅拷贝。</p>
<p>5、对象深拷贝</p>
<p>首先，看下对象怎么深拷贝，重写Object的clone方法，并且需要实现Cloneable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">static</span><br><span class="line">class A implements Cloneable &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected A clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (A)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想要异常，就在clone方法里自己写set方法，新建对象返回。</p>
<p>对象的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a1 = new A(&quot;11&quot;);</span><br><span class="line">A a2 = a1;  //浅拷贝</span><br><span class="line">System.out.println(a2);</span><br><span class="line">System.out.println(a1 == a2);  //true</span><br><span class="line">A a3 = a1.clone();</span><br><span class="line">System.out.println(a1 == a3);  //false</span><br></pre></td></tr></table></figure>

<hr>
<p>Apache Commons Lang序列化 实现对象深拷贝</p>
<p>第一步、导入commons-lang3包</p>
<p>第二步、实体类实现Serializable接口</p>
<p>第三步、调用SerializationUtils工具类，实现深拷贝（注意：SerializationUtils不能直接拷贝List类型）<br><code>User user2 = SerializationUtils.clone(user1);</code></p>
<p>如果想拷贝List，需要新建一个实体类implements Serializable，然后将list变为其中属性，再用上面的操作深拷贝新建对象，再取其中的list。</p>
<p>或者用循环add深拷贝后的对象的方式实现list的深拷贝。</p>
<p>Java对象深拷贝详解（List深拷贝）:<br><a href="https://blog.csdn.net/weixin_42675423/article/details/128260074">https://blog.csdn.net/weixin_42675423/article/details/128260074</a></p>
<hr>
<p>6、json序列化实现list深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a4 = new A(&quot;111&quot;);</span><br><span class="line">A a5 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a4, a5);</span><br><span class="line">List&lt;A&gt; list2 = JSONObject.parseArray(JSONObject.toJSONString(list1), A.class); //深拷贝</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<h4 id="十五、list交集并集"><a href="#十五、list交集并集" class="headerlink" title="十五、list交集并集"></a>十五、list交集并集</h4><p>求两个list的交集</p>
<p>需要导入apache的包：commons-collections</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Lists.newArrayList(&quot;11&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;44&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">Collection&lt;String&gt; list3 = CollectionUtils.intersection(list1, list2);</span><br></pre></td></tr></table></figure>

<hr>
<p>从list1中移除存在list2中的元素（差集）：<code>list1.removeAll(list2)</code></p>
<p>调用流程：removeAll-&gt;contains-&gt;equals方法，对于引用类型，要使用removeAll，需要重写equals方法。<br>contains方法中，当对象o不为空时，迭代判断用到了Object的equals方法，而Object的equals方法指的是两个对象的引用是否相等，如果我们要判断两个对象的内容相等，这里就需要重写equals方法。</p>
<p>两个list的并集：<code>a.addAll(b);</code></p>
<p>两个list的交集：<code>a.retainAll(b);</code></p>
<p>要去重的：<code>List newList = b.stream().distinct().collect(Collectors.toList());</code></p>
<hr>
<p>lambda表达式取交集、并集、差集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list1.add(&quot;1&quot;);</span><br><span class="line">    list1.add(&quot;2&quot;);</span><br><span class="line">    list1.add(&quot;3&quot;);</span><br><span class="line">    list1.add(&quot;5&quot;);</span><br><span class="line">    list1.add(&quot;6&quot;);</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list2.add(&quot;2&quot;);</span><br><span class="line">    list2.add(&quot;3&quot;);</span><br><span class="line">    list2.add(&quot;7&quot;);</span><br><span class="line">    list2.add(&quot;8&quot;);</span><br><span class="line"> </span><br><span class="line">    // 交集</span><br><span class="line">    List&lt;String&gt; intersection = list1.stream().filter(item -&gt; list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---交集 intersection---&quot;);</span><br><span class="line">    intersection.parallelStream().forEach(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 差集 (list1 - list2)</span><br><span class="line">    List&lt;String&gt; reduce1 = list1.stream().filter(item -&gt; !list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---差集 reduce1 (list1 - list2)---&quot;);</span><br><span class="line">    reduce1.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">    // 并集</span><br><span class="line">    List&lt;String&gt; listAll = list1.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = list2.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(&quot;---并集 listAll---&quot;);</span><br><span class="line">    listAll.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 去重并集</span><br><span class="line">    List&lt;String&gt; listAllDistinct = listAll.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(&quot;---得到去重并集 listAllDistinct---&quot;);</span><br><span class="line">    listAllDistinct.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;---原来的List1---&quot;);</span><br><span class="line">    list1.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line">    System.out.println(&quot;---原来的List2---&quot;);</span><br><span class="line">    list2.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的，是线程不安全的，允许元素为null的双向链表。</p>
<p><a href="https://zhuanlan.zhihu.com/p/162980143">https://zhuanlan.zhihu.com/p/162980143</a></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="✅移除"><a href="#✅移除" class="headerlink" title="✅移除"></a>✅移除</h4><p>移除Set集合中的指定对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">set.add(&quot;111&quot;);</span><br><span class="line">set.add(&quot;222&quot;);</span><br><span class="line">set.remove(&quot;111&quot;);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<h4 id="获取上一个下一个元素"><a href="#获取上一个下一个元素" class="headerlink" title="获取上一个下一个元素"></a>获取上一个下一个元素</h4><p>用迭代器的<code>previous()</code>方法和<code>next()</code>方法</p>
<h3 id="Comparable、Comparator"><a href="#Comparable、Comparator" class="headerlink" title="Comparable、Comparator"></a>Comparable、Comparator</h3><p>要讲这个，就要讲list的排序，看上面，有几种办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.list.sort(Comparator.comparing(A::getB))</span><br><span class="line">2.list.stream.sorted(Comparator.comparing(A::getB)).collect(Collectors.toList())</span><br><span class="line">3.list.stream.sorted((a1,a2)-&gt;a1.compareTo(a2))</span><br><span class="line">4.直接Collections.sort(list)  </span><br><span class="line">//这个需要list的元素实现Comparable接口，重写compareTo方法，比如String就实现了</span><br><span class="line">5.Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>他们都是java的接口, 并且是用来对自定义的实体类比较大小的.</p>
<p>Comparable接口需要进行比较的实体类在定义时实现它，重写compareTo方法。<br>Comparator接口是在集合外部实现的排序，重写compare方法。Comparator接口比Comparable接口要灵活。</p>
<p>✅ compareTo()方法<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则表示两个对象相等，如果该方法返回一个正整数，则表明obj1大于obj2；如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>一些已经实现了Comparable接口的常用类：<br>Character：按照字符的UNICODE值进行比较<br>String：按照字符的UNICODE值进行比较<br>Date\Time：外面比里面新，返回1<br>Long：a.compareTo(b)，a比b大返回1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以特定格式返回日期格式化程序</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date oldTime = dateFormat.parse(&quot;2019-04-07 19:50:11&quot;);</span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 日期变为字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="stream流-parallelStream流"><a href="#stream流-parallelStream流" class="headerlink" title="stream流 parallelStream流"></a>stream流 parallelStream流</h3><p>stream(): 是串行执行，按照顺序执行</p>
<p>parallelStream()：是并行执行，异步执行，多线程，并且使用的线程池是ForkJoinPool.common，可能存在共享资源、线程安全等问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过滤：</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; 3);   //filter里面的条件是留下来的条件</span><br><span class="line">integerList = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">排序：</span><br><span class="line">.stream().sorted((e1,e2)-&gt;e1.compareTo(e2)).</span><br><span class="line"></span><br><span class="line">去重：</span><br><span class="line">.stream().distinct().</span><br><span class="line"></span><br><span class="line">按照对象中某一元素去重：[tolook]</span><br><span class="line">.stream().filter(...)</span><br><span class="line"></span><br><span class="line">返回指定流个数：</span><br><span class="line">.limit(5)</span><br><span class="line"></span><br><span class="line">跳过流中元素：</span><br><span class="line">.skip(2)</span><br><span class="line"></span><br><span class="line">map流映射：将接收的元素映射成另外一个元素：</span><br><span class="line">.map(类::get属性).collect...</span><br><span class="line">.map(对象-&gt;&#123;</span><br><span class="line">  构造另一种对象;</span><br><span class="line">  return 另一对象;</span><br><span class="line">&#125;).</span><br><span class="line">.map(string-&gt;Long.valueOf(string)).  //String变为Long</span><br><span class="line"></span><br><span class="line">对象list根据某一个元素变为map：(变成 元素-对象list的map)</span><br><span class="line">list.stream().collect(Collectors.groupingBy(类::get属性))</span><br><span class="line"></span><br><span class="line">//流的过程中对元素进行操作</span><br><span class="line">List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">list2.stream().forEach(s -&gt; list.add(Long.valueOf(s)));</span><br><span class="line"></span><br><span class="line">anyMatch判断</span><br><span class="line">想比较list1中是否存在list2中的任何对象</span><br><span class="line">可以遍历两个列表并使用.contains()比较所有元素</span><br><span class="line">但是更高效的方法是anyMatch：</span><br><span class="line">List&lt;Item&gt; list1;</span><br><span class="line">List&lt;Item&gt; list2;</span><br><span class="line">boolean anyMatch = list1.stream().anyMatch(x -&gt; x.equals(list2.stream()));</span><br><span class="line">System.out.println(anyMatch);</span><br><span class="line">很容易理解，即是有一个或一个以上的元素满足函数参数计算结果为true那整个方法返回值为true。</span><br></pre></td></tr></table></figure>

<h4 id="✅list-stream-mapToDouble"><a href="#✅list-stream-mapToDouble" class="headerlink" title="✅list.stream().mapToDouble"></a>✅list.stream().mapToDouble</h4><p>求最大最小，求和求平均</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list.stream().mapToDouble(User::getAge).sum()//和</span><br><span class="line">list.stream().mapToDouble(User::getAge).max()//最大</span><br><span class="line">list.stream().mapToDouble(User::getAge).min()//最小</span><br><span class="line">list.stream().mapToDouble(User::getAge).average()//平均值</span><br><span class="line"></span><br><span class="line">double sum = list.stream().mapToDouble(Integer::doubleValue).sum();</span><br></pre></td></tr></table></figure>

<h4 id="✅list变map"><a href="#✅list变map" class="headerlink" title="✅list变map"></a>✅list变map</h4><p>第一种：会出现键重复异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以id为主键转为map</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId,Function.identity()));</span><br></pre></td></tr></table></figure>

<p>第二种：不会出现重复键异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给出key重复时，使用哪个key作为主键，以下代码中的(key1, key2) -&gt; key2)代表key1和key2键重复时返回key2做主键</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId, Function.identity(), (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第三种：对象变为属性-属性map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不想返回对象，只返回对象里某个属性时 采用这种方式</span><br><span class="line">Map&lt;Long, String&gt; map = list.stream().collect(Collectors.toMap(User::getId, User::getAge, (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第四种：以某一属性分组，变为属性-对象list map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&gt; map = list.stream().collect(Collectors.groupingBy(User::getId));</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/lizaiismy/article/details/121352640">https://blog.csdn.net/lizaiismy/article/details/121352640</a></p>
<p>ps：<code>Function.identity()</code><br>Function是一个接口，Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。<br><code>Function.identity()</code>返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static  Function identity() &#123;</span><br><span class="line">    return t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>Function.identity()</code>是一个用来返回自己的lambda表达式</p>
<h4 id="✅stream流的max-min方法"><a href="#✅stream流的max-min方法" class="headerlink" title="✅stream流的max,min方法"></a>✅stream流的max,min方法</h4><p>max : 获取最大值<br>min : 获取最小值</p>
<p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></p>
<p>max、min 方法参数类型为 Comparator 接口,利用比较器自定义排序。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; personList = Arrays.asList(</span><br><span class="line">                new Person(1, &quot;大毛&quot;, 30, 175),</span><br><span class="line">                new Person(2, &quot;二毛&quot;, 35, 170),</span><br><span class="line">                new Person(3, &quot;三毛&quot;, 26, 173),</span><br><span class="line">                new Person(4, &quot;小毛&quot;, 30, 175));</span><br><span class="line"> </span><br><span class="line">        // 获取 person 类型流</span><br><span class="line">        Stream&lt;Person&gt; personStream = personList.stream();</span><br><span class="line">        // 按照年龄升序排序,然后获取排序后的最大值 o1-o2 代表升序排序;o2-o1 代表降序排序</span><br><span class="line">        Optional&lt;Person&gt; max = personStream.max(((o1, o2) -&gt; o1.getAge() - o2.getAge()));</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h4 id="✅now-after"><a href="#✅now-after" class="headerlink" title="✅now.after()"></a>✅now.after()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(oldTime))&#123;</span><br><span class="line">    System.out.println(&quot;now比after新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateFormat类"><a href="#✅DateFormat类" class="headerlink" title="✅DateFormat类"></a>✅DateFormat类</h4><p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p>
<p>在创建 DateFormat 对象时不能使用 new 关键字，而应该使用 DateFormat 类中的静态方法 getDateInstance()：<br><code>DateFormat df = DateFormat.getDatelnstance();</code><br>在创建了一个 DateFormat 对象后，可以调用该对象中的方法来对日期/时间进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义对象，日期、时间，也有getDateTimeInstance</span><br><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br><span class="line"></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"></span><br><span class="line">//字符串到Date</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line"></span><br><span class="line">//Date到字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br><span class="line"></span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(old))&#123;</span><br><span class="line">    System.out.println(&quot;now比old新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅SimpleDateFormat"><a href="#✅SimpleDateFormat" class="headerlink" title="✅SimpleDateFormat"></a>✅SimpleDateFormat</h4><p>DateFormat可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat</p>
<p>SimpleDateFormat 使得可以选择任何用户定义的日期/时间格式的模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date now = new Date(); // 创建一个Date对象，获取当前时间</span><br><span class="line">// 指定格式化格式</span><br><span class="line">SimpleDateFormat f = new SimpleDateFormat(&quot;今天是 &quot; + &quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;);</span><br><span class="line">// Date转为String</span><br><span class="line">System.out.println(f.format(now)); // 将当前时间袼式化为指定的格式</span><br><span class="line">// String转为Date</span><br><span class="line">String str=&quot;2008-08-08 12:12:12&quot;;</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date dd=sdf2.parse(str);</span><br><span class="line">System.out.println(dd);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="http://c.biancheng.net/view/878.html">http://c.biancheng.net/view/878.html</a></p>
<h4 id="✅FastDataFormat"><a href="#✅FastDataFormat" class="headerlink" title="✅FastDataFormat"></a>✅FastDataFormat</h4><p>Apache commons-lang中的FastDateFormat。也可以做时间的格式化。<br>FastDateFormat是线程安全的，可以直接使用，不必考虑多线程的情况<br>JDK里自带的SimpleDateFormat存在线程不安全问题。<br>SimpleDateFormat在对时间进行格式化的方法format中，会先对calendar对象进行setTime的赋值，若是有多个线程同时操作一个SimpleDateFormat实例的话，就会对calendar的赋值进行覆盖，进而产生问题。</p>
<p>FastDateFormat用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FastDateFormat f = FastDateFormat.getInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">String s = f.format(new Date());</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">Date dd=f.parse(s);</span><br></pre></td></tr></table></figure>


<h4 id="✅当前时间的后几秒："><a href="#✅当前时间的后几秒：" class="headerlink" title="✅当前时间的后几秒："></a>✅当前时间的后几秒：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前时间的后几秒</span><br><span class="line">Date data = new Date(System.currentTimeMillis() + 10 * 1000);</span><br><span class="line">System.out.println(data);</span><br><span class="line">加的是毫秒</span><br></pre></td></tr></table></figure>

<p>获取当前时间的月份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int mon = LocalDate.now().getMonthValue();</span><br></pre></td></tr></table></figure>

<h4 id="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"><a href="#✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】" class="headerlink" title="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"></a>✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】</h4><p>为什么需要LocalDate、LocalTime、LocalDateTime</p>
<p>1.Date如果不格式化，打印出的日期可读性差<br>Tue Sep 10 09:34:04 CST 2019<br>Date对时间处理比较麻烦。<br>getYear、getMonth这些方法吗，获取年月日很Easy，但都被弃用了。</p>
<p>2.使用SimpleDateFormat对时间进行格式化，但SimpleDateFormat是线程不安全的。SimpleDateFormat的format方法中的calendar是共享变量，并且这个共享变量没有做线程安全控制。当多个线程同时使用相同的SimpleDateFormat对象【如用static修饰的SimpleDateFormat】调用format方法时，多个线程会同时调用calendar.setTime方法，可能一个线程刚设置好time值。另外的一个线程马上把设置的time值给修改了导致返回的格式化时间可能是错误的。在多并发情况下使用SimpleDateFormat需格外注意 SimpleDateFormat除了format是线程不安全以外，parse方法也是线程不安全的。</p>
<p>多线程并发如何保证线程安全 - 避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次SimpleDateFormat对象 =&gt; 创建和销毁对象的开销大 - 对使用format和parse方法的地方进行加锁 =&gt; 线程阻塞性能差 - 使用ThreadLocal保证每个线程最多只创建一次SimpleDateFormat对象 =&gt; 较好的方法。</p>
<p>LocalDate用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只会获取年月日</span><br><span class="line">//获取当前年月日</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">//构造指定的年月日</span><br><span class="line">LocalDate localDate1 = LocalDate.of(2019, 9, 10);</span><br><span class="line"></span><br><span class="line">获取年、月、日、星期几</span><br><span class="line">int year = localDate.getYear();  //2022</span><br><span class="line">int year1 = localDate.get(ChronoField.YEAR); //2022</span><br><span class="line">Month month = localDate.getMonth();  //JUNE</span><br><span class="line">int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);  //6</span><br><span class="line"></span><br><span class="line">//获取当前日期是所在年的第几天、月的第几天、当前星期</span><br><span class="line">int day = localDate.getDayOfMonth();  //26</span><br><span class="line">int day1 = localDate.get(ChronoField.DAY_OF_MONTH);  //26</span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek(); //SUNDAY</span><br><span class="line">int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK); //7</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">int year = now.getDayOfYear();  //一年的第几天</span><br><span class="line">int month = now.getDayOfMonth();  //月的第几天</span><br><span class="line"></span><br><span class="line">System.out.println(LocalDate.MAX);  //+999999999-12-31</span><br><span class="line">System.out.println(LocalDate.MIN);  //-999999999-01-01</span><br><span class="line"></span><br><span class="line">//获取当前月，当前月天数</span><br><span class="line">Month month = now.getMonth();  //JANUARY</span><br><span class="line">int monthValue = now.getMonthValue();</span><br><span class="line">int i = now.lengthOfMonth();</span><br><span class="line"></span><br><span class="line">//with指定年月日</span><br><span class="line">LocalDate localDate = now.withDayOfMonth(1);  //当月的指定日</span><br><span class="line">LocalDate localDate1 = now.withDayOfYear(21);  //获取今年第第几天</span><br><span class="line">LocalDate localDate2 = now.withMonth(3);  //今年指定月份，日为当天的日期</span><br><span class="line">LocalDate localDate3 = now.withYear(2004);  //指定年份的今天</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LocalTime用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只会获取几点几分几秒</span><br><span class="line">创建LocalTime</span><br><span class="line">LocalTime localTime = LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">获取时分秒</span><br><span class="line">//获取小时</span><br><span class="line">int hour = localTime.getHour();</span><br><span class="line">int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">//获取分</span><br><span class="line">int minute = localTime.getMinute();</span><br><span class="line">int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">//获取秒</span><br><span class="line">int second = localTime.getSecond();</span><br><span class="line">int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取年月日时分秒，等于LocalDate+LocalTime</span><br><span class="line">创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, 6, 26, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 = localTime.atDate(localDate);</span><br><span class="line">获取LocalDate</span><br><span class="line">LocalDate localDate2 = localDateTime.toLocalDate();</span><br><span class="line">获取LocalTime</span><br><span class="line">LocalTime localTime2 = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<p>Instant: 可以精确到纳秒的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取秒数</span><br><span class="line">创建Instant对象</span><br><span class="line">Instant instant = Instant.now();  //提前北京时间8小时</span><br><span class="line"></span><br><span class="line">//根据时期添加偏移量</span><br><span class="line">OffsetDateTime offsetDateTime1 = instance.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(&quot;处理后时间为：&quot;+offsetDateTime1);</span><br><span class="line"></span><br><span class="line">获取秒数</span><br><span class="line">long currentSecond = instant.getEpochSecond();</span><br><span class="line">获取毫秒数</span><br><span class="line">long currentMilli = instant.toEpochMilli();</span><br><span class="line">如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便</span><br></pre></td></tr></table></figure>

<p>时间变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本</span><br><span class="line">增加、减少年数、月数、天数等 以LocalDateTime为例</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">14, 46, 56);</span><br><span class="line">//增加一年</span><br><span class="line">localDateTime = localDateTime.plusYears(1);</span><br><span class="line">localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">//减少一个月</span><br><span class="line">localDateTime = localDateTime.minusMonths(1);</span><br><span class="line">localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS);</span><br><span class="line">通过with修改某些值</span><br><span class="line">//修改年为2019</span><br><span class="line">localDateTime = localDateTime.withYear(2020);</span><br><span class="line">//修改为2022</span><br><span class="line">localDateTime = localDateTime.with(ChronoField.YEAR, 2022);</span><br><span class="line">还可以修改月、日</span><br></pre></td></tr></table></figure>

<p>时间计算:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">//得到今年第一天</span><br><span class="line">LocalDate localDate1 = localDate.with(firstDayOfYear());</span><br><span class="line">比如通过firstDayOfYear()返回了当前日期的第一天日期，还有很多方法这里不在举例说明</span><br></pre></td></tr></table></figure>

<p>格式化时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">//自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);</span><br><span class="line">String s3 = localDate.format(dateTimeFormatter);</span><br><span class="line">DateTimeFormatter默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过DateTimeFormatter的ofPattern方法创建自定义格式化方式</span><br><span class="line"></span><br><span class="line">//变为字符串：</span><br><span class="line">String currentTime = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(LocalDateTime.now());</span><br><span class="line">System.out.println(currentTime);</span><br><span class="line">String currentTime1 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">System.out.println(currentTime1</span><br></pre></td></tr></table></figure>

<p>解析时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 = LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">和SimpleDateFormat相比，DateTimeFormatter是线程安全的</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc</a></p>
<p>更多用法：<a href="https://zhuanlan.zhihu.com/p/158786867">https://zhuanlan.zhihu.com/p/158786867</a></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DateUtilsTest &#123;</span><br><span class="line">    public static final String DATE_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        // 获取指定格式时间字符串</span><br><span class="line">        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN));</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        // 获取当前月份</span><br><span class="line">        Integer month = LocalDateTime.now().getMonth().getValue();</span><br><span class="line">        System.out.println(month);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        // 时间戳</span><br><span class="line">        long timeStamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间戳：&quot; + timeStamp);</span><br><span class="line">        // 时间戳字符串到时间戳到LocalDateTime</span><br><span class="line">        LocalDateTime time = new Timestamp(timeStamp).toLocalDateTime();</span><br><span class="line">        System.out.println(&quot;LocatDateTime：&quot; + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：获取指定天后的日期字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDateTime.now().plusDays(1).format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="✅Calendar、Date、LocalDate-LocalTime关系"><a href="#✅Calendar、Date、LocalDate-LocalTime关系" class="headerlink" title="✅Calendar、Date、LocalDate/LocalTime关系"></a>✅Calendar、Date、LocalDate/LocalTime关系</h4><p>1、Date 类如今很多方法已经没有什么用处了，如今时间的处理并不直接在Date 类中进行，而是通过Calendar，或者LocalDate 来进行，我们在日常使用中，更多的是要来做一个记录日期的实例。</p>
<p>2、Date用于记录某一个含日期的、精确到毫秒的时间。重点在代表一刹那的时间本身。Calendar用于将某一日期放到历法中的互动——时间和年、月、日、星期、上午、下午、夏令时等这些历法规定互相作用关系和互动。Calendar本身代表公历的一个简化缩水版，姑且叫“计算机历”。</p>
<p>3、Java 8新增了LocalDate和LocalTime接口，为什么要搞一套全新的处理日期和时间的API？因为旧的java.util.Date实在是太难用了。<br>java.util.Date月份从0开始，一月是0，十二月是11，变态吧！java.time.LocalDate月份和星期都改成了enum，就不可能再用错了。<br>java.util.Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</p>
<p>来自：<a href="https://www.cnblogs.com/jaycekon/p/6179700.html">https://www.cnblogs.com/jaycekon/p/6179700.html</a></p>
<h4 id="✅Calender"><a href="#✅Calender" class="headerlink" title="✅Calender"></a>✅Calender</h4><p>Calendar 是一个抽象类, 无法通过直接实例化得到对象. 因此, Calendar 提供了一个方法 getInstance（工厂方法）,来获得一个Calendar的子类对象, 得到的 Calendar 由当前时间初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CalenderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set (2013, 5, 4, 13, 44, 51);//年月日时分秒 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.YEAR, 2014); //年</span><br><span class="line">        cal.set (Calendar.MONTH, 7); //月 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.DATE, 11); //日</span><br><span class="line">        cal.set (Calendar.HOUR_OF_DAY, 15); //时</span><br><span class="line">        cal.set (Calendar.MINUTE, 33); //分</span><br><span class="line">        cal.set (Calendar.SECOND, 32); //秒</span><br><span class="line"></span><br><span class="line">        //同时还有get、add方法，使用类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calendar是父类，GregorianCalendar是子类。<br>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。可以使用new关键字创建实例。</p>
<p>例子：返回当前时间加10分钟后的日期时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar calendar = new GregorianCalendar();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(GregorianCalendar.MINUTE, 10);</span><br><span class="line">Date after = calendar.getTime();</span><br><span class="line">System.out.println(after);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建Calendar对象</span><br><span class="line">Calendar calendar =Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getTime());//Calender变Date</span><br><span class="line">System.out.println(calendar.getTimeInMillis());//Calender变时间戳</span><br><span class="line">Calendar calendar1 = new GregorianCalendar();</span><br><span class="line">System.out.println(calendar1.getTime()); //输出一样</span><br><span class="line"></span><br><span class="line">//2.获取时间信息</span><br><span class="line">//获取年</span><br><span class="line">int year = calendar.get(Calendar.YEAR);</span><br><span class="line">//月</span><br><span class="line">int month = calendar.get(Calendar.MONTH);</span><br><span class="line">//日</span><br><span class="line">int day = calendar.get(Calendar.DAY_OF_MONTH);//DATE</span><br><span class="line">//小时</span><br><span class="line">int hour = calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">//分钟</span><br><span class="line">int minute = calendar.get(Calendar.MINUTE);</span><br><span class="line">//秒</span><br><span class="line">int second = calendar.get(Calendar.SECOND);</span><br><span class="line">System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+&quot;  &quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;);</span><br><span class="line"></span><br><span class="line">//修改时间</span><br><span class="line">Calendar calendar2 =Calendar.getInstance();</span><br><span class="line">calendar2.set(Calendar.DAY_OF_MONTH,5);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//add方法修改时间</span><br><span class="line">calendar2.add(Calendar.HOUR,-1);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//获取当月多少天</span><br><span class="line">int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH); //30</span><br><span class="line">int min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH); //1</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/a1439775520/article/details/98442556">https://blog.csdn.net/a1439775520/article/details/98442556</a> </p>
<p>🍎用Calender计算量日期相差天数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static int differentDays(Date date1,Date date2) &#123;</span><br><span class="line">    Calendar cal1 = Calendar.getInstance();</span><br><span class="line">    cal1.setTime(date1);</span><br><span class="line"></span><br><span class="line">    Calendar cal2 = Calendar.getInstance();</span><br><span class="line">    cal2.setTime(date2);</span><br><span class="line">    int day1= cal1.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    int day2 = cal2.get(Calendar.DAY_OF_YEAR);</span><br><span class="line"></span><br><span class="line">    int year1 = cal1.get(Calendar.YEAR);</span><br><span class="line">    int year2 = cal2.get(Calendar.YEAR);</span><br><span class="line">    if(year1 != year2) &#123;//不同年</span><br><span class="line">        int timeDistance = 0 ;</span><br><span class="line">        for(int i = year1 ; i &lt; year2 ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%4==0 &amp;&amp; i%100!=0 || i%400==0)    //闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 366;</span><br><span class="line">            &#125;</span><br><span class="line">            else    //不是闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 365;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return timeDistance + (day2-day1) ;</span><br><span class="line">    &#125; else &#123;// 同年</span><br><span class="line">        System.out.println(&quot;判断day2 - day1 : &quot; + (day2-day1));</span><br><span class="line">        return day2-day1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int differentDaysByMillisecond(Date date1,Date date2)&#123;</span><br><span class="line">    int days = (int) ((date2.getTime() - date1.getTime()) / (1000*3600*24));</span><br><span class="line">    return days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅时间戳"><a href="#✅时间戳" class="headerlink" title="✅时间戳"></a>✅时间戳</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void timeStampTest() &#123;</span><br><span class="line">  // 当前时间时间戳</span><br><span class="line">  long nowStamp = System.currentTimeMillis();</span><br><span class="line">  System.out.println(&quot;毫秒时间戳：&quot; + nowStamp);</span><br><span class="line">  long nowhaomiao = System.currentTimeMillis() * 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳&quot; + nowhaomiao);</span><br><span class="line">  long nowhaomiao1 = System.nanoTime() / 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳1&quot; + nowhaomiao1); //不行</span><br><span class="line"></span><br><span class="line">  // 昨天这个时间时间戳</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.add(Calendar.DAY_OF_YEAR, -1);</span><br><span class="line">  //calender.getTime变Date，再getTime变时间戳（long型的）</span><br><span class="line">  System.out.println(&quot;昨天此时：&quot; + calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 昨天某时间的时间戳</span><br><span class="line">  Calendar calendar1 = Calendar.getInstance();</span><br><span class="line">  calendar.set(calendar1.get(Calendar.YEAR), calendar1.get(Calendar.MONTH), calendar1.get(Calendar.DAY_OF_MONTH) - 1, 23, 59, 59);</span><br><span class="line">  System.out.println(calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 时间戳转换为Date</span><br><span class="line">  Date now = new Date(nowStamp);  //long型</span><br><span class="line">  //如果是时间戳字符串，用下面</span><br><span class="line">  //Date now1 = new Date(Long.parseLong(nowStamp));</span><br><span class="line">  System.out.println(&quot;now: &quot; + now);</span><br><span class="line">  // 再转换为字符串</span><br><span class="line">  String format = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line">  SimpleDateFormat sdf = new SimpleDateFormat(format);</span><br><span class="line">  System.out.println(&quot;now: &quot; + sdf.format(now));</span><br><span class="line"></span><br><span class="line">  // 日期格式字符串转换为时间戳</span><br><span class="line">  String s = &quot;2022-06-25 12:12:12&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">      // String-Date-long型时间戳</span><br><span class="line">      System.out.println(&quot;时间戳：&quot; + String.valueOf(sdf.parse(s).getTime()));</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateUtils工具类"><a href="#✅DateUtils工具类" class="headerlink" title="✅DateUtils工具类"></a>✅DateUtils工具类</h4><p>apache.commons.lang3包下的工具类</p>
<p>1、获取指定日期的开始时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDateUtils() throws ParseException &#123;</span><br><span class="line">    // 获取指定日期的开始时间</span><br><span class="line">    DateFormat df = DateFormat.getDateInstance();</span><br><span class="line">    Date date = df.parse(&quot;2022-06-24 14:01:01&quot;);</span><br><span class="line">    Date begin = org.apache.commons.lang3.time.DateUtils.truncate(date, Calendar.DATE);</span><br><span class="line">    System.out.println(&quot;初始时间：&quot; + begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅计算两个时间段之间的所有天"><a href="#✅计算两个时间段之间的所有天" class="headerlink" title="✅计算两个时间段之间的所有天"></a>✅计算两个时间段之间的所有天</h4><p>输入：begin:‘2022-08-01’ end:‘2022-08-05’<br>输出：”2021-08-01”,”2021-08-02”,”2021-08-03”,”2021-08-04”,”2021-08-05”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; findDates(String beginTime, String endTime)</span><br><span class="line">        throws ParseException &#123;</span><br><span class="line">    List&lt;String&gt; allDate = new ArrayList();</span><br><span class="line">    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    Date dBegin = sdf.parse(beginTime);</span><br><span class="line">    Date dEnd = sdf.parse(endTime);</span><br><span class="line">    allDate.add(sdf.format(dBegin));</span><br><span class="line">    Calendar calBegin = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calBegin.setTime(dBegin);</span><br><span class="line">    Calendar calEnd = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calEnd.setTime(dEnd);</span><br><span class="line">    // 测试此日期是否在指定日期之后</span><br><span class="line">    while (dEnd.after(calBegin.getTime())) &#123;</span><br><span class="line">        // 根据日历的规则，为给定的日历字段添加或减去指定的时间量</span><br><span class="line">        calBegin.add(Calendar.DAY_OF_MONTH, 1);</span><br><span class="line">        allDate.add(sdf.format(calBegin.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;时间==&quot; + allDate);</span><br><span class="line">    return allDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅判断是否同一天"><a href="#✅判断是否同一天" class="headerlink" title="✅判断是否同一天"></a>✅判断是否同一天</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    LocalDate localDate1 = date1.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    LocalDate localDate2 = date2.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    return localDate1.isEqual(localDate2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    SimpleDateFormat fmt = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">    return fmt.format(date1).equals(fmt.format(date2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自：<a href="https://blog.csdn.net/nandao158/article/details/121905050">https://blog.csdn.net/nandao158/article/details/121905050</a></p>
<h4 id="✅获取今天星期几"><a href="#✅获取今天星期几" class="headerlink" title="✅获取今天星期几"></a>✅获取今天星期几</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>

<p>获取到的数字，星期一到星期七对应数字{2，3，4，5，6, 7，0}，所以需要减一，减一之后判断是不是等于0，等于0就变成7.</p>
<h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="int变String-String变int"><a href="#int变String-String变int" class="headerlink" title="int变String,String变int"></a>int变String,String变int</h4><p>第一种方式：使用int的封装类Integer，在Integer里面用他的toString方法。（性能最好）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=3；</span><br><span class="line">String s=Integer.toString(i);</span><br></pre></td></tr></table></figure>

<p>第二种方式：String的valueOf方法，传参是Object（性能第二）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">String s=String.valueOf(i);</span><br></pre></td></tr></table></figure>

<p>第三种方式，直接在int后面加一个空的字符串，因为在java里面，默认任务int类型和字符串类型相加，为字符串类型。（性能最差）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=2；</span><br><span class="line">String s=i+&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>string变int/Long：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i1 = Integer.parseInt(s);</span><br><span class="line">Integer i = Integer.valueOf(s);</span><br><span class="line">Long l = Long.valueOf(s);</span><br><span class="line">Long l1 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>

<p><code>Integer.parseInt</code> 方法：<br>parseInt(String s, int radix)： s表示字符串  radix表示字符串数值的进制，例如：parseInt(“100”, 16) = 256<br>parseInt(String s)：相当于默认是10进制</p>
<h4 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h4><p>String.format(String format, Object… args)<br>字符串格式化方法，sout也这么用。</p>
<p><code>String str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);  </code></p>
<p>%s    字符串类型    “hello”<br>%c    字符类型    ‘m’<br>%b    布尔类型    true<br>%d    整数类型（十进制）    88<br>%x    整数类型（十六进制）    FF<br>%o    整数类型（八进制）    77<br>%f    浮点类型    8.888<br>%a    十六进制浮点类型    FF.35AE<br>%e    指数类型    9.38e+5<br>%g    通用浮点类型（f和e类型中较短的）    不举例(基本用不到)<br>%h    散列码    不举例(基本用不到)<br>%%    百分比类型    ％(%特殊字符%%才能显示%)<br>%n    换行符    不举例(基本用不到)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    String str=null;  </span><br><span class="line">    str=String.format(&quot;Hi,%s&quot;, &quot;小超&quot;);  </span><br><span class="line">    System.out.println(str);  </span><br><span class="line">    str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);            </span><br><span class="line">    System.out.println(str);                           </span><br><span class="line">    System.out.printf(&quot;字母c的大写是：%c %n&quot;, &#x27;C&#x27;);  </span><br><span class="line">    System.out.printf(&quot;布尔结果是：%b %n&quot;, &quot;小超&quot;.equal(&quot;帅哥&quot;));  </span><br><span class="line">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class="line">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class="line">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class="line"></span><br><span class="line">日期格式：%tx x代表日期转换符</span><br><span class="line">c	包括全部日期和时间信息	星期六 十月 27 14:21:20 CST 2007</span><br><span class="line">F	“年-月-日”格式	2007-10-27</span><br><span class="line">D	“月/日/年”格式	10/27/07</span><br><span class="line">r	“HH:MM:SS PM”格式（12时制）	02:25:51 下午</span><br><span class="line">T	“HH:MM:SS”格式（24时制）	14:28:16</span><br><span class="line">R	“HH:MM”格式（24时制）	14:28</span><br><span class="line"></span><br><span class="line">Date date=new Date();                                  </span><br><span class="line">//c的使用  </span><br><span class="line">System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class="line">//f的使用  </span><br><span class="line">System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class="line">//d的使用  </span><br><span class="line">System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class="line">//r的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class="line">//t的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class="line">//R的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.printf(&quot;%f&quot;, d);// &quot;f&quot;表示格式化输出浮点数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%9.2f&quot;, d);// &quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+9.2f&quot;, d);// &quot;+&quot;表示输出的数带正负号。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%-9.4f&quot;, d);// &quot;-&quot;表示输出的数左对齐（默认为右对齐）。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+-9.3f&quot;, d);// &quot;+-&quot;表示输出的数带正负号且左对齐。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%d&quot;, i);// &quot;d&quot;表示输出十进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%o&quot;, i);// &quot;o&quot;表示输出八进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%x&quot;, i);// &quot;d&quot;表示输出十六进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%#x&quot;, i);// &quot;d&quot;表示输出带有十六进制标志的整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%s&quot;, s);// &quot;d&quot;表示输出字符串。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;, d, i, s);  </span><br><span class="line">// 可以输出多个变量，注意顺序。  </span><br><span class="line">System.out.println();  </span><br></pre></td></tr></table></figure>

<h4 id="Strings-nullToEmpty"><a href="#Strings-nullToEmpty" class="headerlink" title="Strings.nullToEmpty"></a>Strings.nullToEmpty</h4><p>Strings、Lists、Maps 都是google提供的工具类。<br>使用之前导入包guava。</p>
<p>vo.setS(String.nullToEmpty(s));  一般用于给对象属性赋值，如果为null，就设空。</p>
<p>其他guava工具类使用：<a href="https://www.w3cschool.cn/article/17770773.html">https://www.w3cschool.cn/article/17770773.html</a></p>
<h4 id="StringUtils工具类"><a href="#StringUtils工具类" class="headerlink" title="StringUtils工具类"></a>StringUtils工具类</h4><p>StringUtils工具类是org.apache.commons.lang3包下的工具类，对String类型的操作作了封装，是对Java自带的API的有效补充，可以帮助我们更高效快速地处理字符串。</p>
<p>导入commons-lang3包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String substringAfter(String str,String separator)：</span><br><span class="line">在第一次出现分隔符后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringAfterLast(String str,String separator)：</span><br><span class="line">在最后一次出现分隔符之后获取子字符串。</span><br></pre></td></tr></table></figure>

<p>工具类：一般是直接用它的静态方法，直接用类来调用，例如：Collections、Arrays等jaa自带的工具类；Lists、Maps等google工具类；CollectionUtils、StringUtils等apache工具类。</p>
<p>更多：<a href="https://cloud.tencent.com/developer/article/1662921">https://cloud.tencent.com/developer/article/1662921</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringUtils.EMPTY = &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 只替换一次--&gt;结果是：phhhss</span><br><span class="line">StringUtils.replaceOnce(&quot;sshhhss&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 全部替换</span><br><span class="line">StringUtils.replace(&quot;sshhhs&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 定义替换次数</span><br><span class="line">StringUtils.replace(&quot;sshhhsshss&quot;, &quot;ss&quot;, &quot;7777&quot;,2);</span><br><span class="line">// 检验字符串是否不为null且不为“”</span><br><span class="line">if(!StringUtils.isEmpty(s))</span><br><span class="line"></span><br><span class="line">//忽略大小写的比较：</span><br><span class="line">System.out.println(StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;aBC&quot;));</span><br></pre></td></tr></table></figure>

<p><code>ObjectUtils.allNotNull(o1, o2)</code> 是commons-lang3包下的，返回boolean，表示是否所有的对象都不为null，false表示有null。</p>
<h4 id="string自己的方法"><a href="#string自己的方法" class="headerlink" title="string自己的方法"></a>string自己的方法</h4><p>✅str.trim()  用于删除字符串的头尾空白符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = new String(&quot;   hello   &quot;);</span><br><span class="line">System.out.println( str.trim() );</span><br></pre></td></tr></table></figure>

<p>✅str.replaceAll(正则表达式, 替换字符串)<br>使用给定的参数 replacement 替换字符串所有匹配给定的正则表达式的子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String Str = new String(&quot;www.hello.com&quot;);</span><br><span class="line">System.out.println(Str.replaceAll(&quot;(.*)hello(.*)&quot;, &quot;hi&quot; ));</span><br></pre></td></tr></table></figure>

<p>✅str.replace(原字符/字符串, 替换成的新字符/字符串)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String replace(char oldChar, char newChar)</span><br><span class="line">用新字符newChar 替换所有的 旧字符oldChar 。</span><br><span class="line"></span><br><span class="line">String replace(CharSequence target, CharSequence replacement)</span><br><span class="line">用新字符串replacement替换所有的 旧字符串target。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换所有的 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line"></span><br><span class="line">String replaceFirst(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换第一个 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line">————————————————</span><br><span class="line">另外，StringBuilder中也有该方法：</span><br><span class="line">replace(int start，int end，String str)</span><br><span class="line">用str 替换 start–end的子串。//不包括end</span><br></pre></td></tr></table></figure>

<p>✅str.indexof() 用于返回字符串中某部分的索引<br>1、 indexOf(String str): 返回指定字符str在字符串中（方法调用者）第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。<br>2、indexOf(String str, int index): 返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;01234567890123456789&quot;;</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;));  //return 1</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;,5));  //return 11</span><br></pre></td></tr></table></figure>

<p>str.lastIndexOf(“//“)  返回最后一次出现字符/字符串的位置。</p>
<p>✅String.join()静态方法<br>用于将list/set变为String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 2L);</span><br><span class="line">// 元素中类型变换</span><br><span class="line">List&lt;String&gt; ls = list.stream().distinct().map(String::valueOf).collect(Collectors.toList());</span><br><span class="line">// 里面的ls不能为空，必须是String元素类型</span><br><span class="line">String s = String.join(&quot;,&quot;, ls);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">//用set也可以</span><br><span class="line">Set&lt;Long&gt; set = Sets.newHashSet(1L, 2L);</span><br><span class="line">Set&lt;String&gt; ss = set.stream().map(i-&gt;String.valueOf(i)).collect(Collectors.toSet());</span><br><span class="line">s = String.join(&quot;,&quot;, ss);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>✅获取某个位置的字符<br><code>char c = s.charAt(index);</code></p>
<h4 id="Splitter工具类（String拆分成list）"><a href="#Splitter工具类（String拆分成list）" class="headerlink" title="Splitter工具类（String拆分成list）"></a>Splitter工具类（String拆分成list）</h4><p>是google出品的，guava包下的工具类，用于对字符串分割处理。</p>
<p>首先，已有的对字符串进行分割的方法：</p>
<p>1.String自带的split()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;1,2,3&quot;;</span><br><span class="line">String[] split = s.split(&quot;,&quot;);</span><br></pre></td></tr></table></figure>
<p>不足之处：如果,后有空格的话，还需要做进一步处理，<br>并且分割后以数组接收，如果数据过多，还需要再转为集合。</p>
<p>2.使用Patter类的split静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br></pre></td></tr></table></figure>

<p>3.Splitter来分割字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SplitterTest &#123;</span><br><span class="line"></span><br><span class="line">    //定义一个拆分器，“,”分隔，去空格</span><br><span class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;).trimResults().omitEmptyStrings();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String s = &quot;1,2, 3&quot;;</span><br><span class="line">        List&lt;String&gt; list = splitter.splitToList(s);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        List&lt;Long&gt; list1 = list.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Joiner连接字符串"><a href="#Joiner连接字符串" class="headerlink" title="Joiner连接字符串"></a>Joiner连接字符串</h4><p>google guava提供的用来连接字符串的类。需要导包：guava。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 连接字符串list</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB:CC</span><br><span class="line"></span><br><span class="line">//过滤其中的null</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, null);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).skipNulls().join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB</span><br><span class="line"></span><br><span class="line">// 可以先定义一个Join对象</span><br><span class="line">private static Joiner MY_JOINER = Joiner.on(&quot;/&quot;).skipNulls();</span><br><span class="line">String s = MY_JOINER.join(..);  里面的参数是Object类型，可以多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多用法：<a href="https://blog.csdn.net/qq_44143796/article/details/122998799">https://blog.csdn.net/qq_44143796/article/details/122998799</a></p>
<h4 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h4><p>✅截取字符串</p>
<p>1、string自己的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">System.out.println(s.substring(2)); //llo</span><br><span class="line">System.out.println(s.substring(2, 4)); //ll 左闭右开</span><br></pre></td></tr></table></figure>

<p>2、StringUtils提供的方法（apache）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringUtils.substring(&quot;hello world&quot;, 4);   // 返回值，从第4位截取到字符串末尾 : o wrold</span><br><span class="line">StringUtils.substring(&quot;hello world&quot;, 4, 10); // 返回值，从第4位截取到第9位 :   o wrol</span><br><span class="line"></span><br><span class="line">//截取某个字符串之前的字符</span><br><span class="line">StringUtils.substringBefore(&quot;hello world&quot;, &quot;l&quot;); </span><br><span class="line">//结果是：he          这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringBeforeLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：hello wor   这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取某个字符串之后的字符</span><br><span class="line">StringUtils.substringAfter(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果是：lo world   这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringAfterLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：d          这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取两个字符串之间隔的字符</span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;o&quot;);    </span><br><span class="line">//结果是： w   两个o之间的字符串。   </span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;); </span><br><span class="line">//结果是： lo wo   第一个字符“l”与第一个字符“r”之间的字符串   </span><br><span class="line">StringUtils.substringsBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;);</span><br><span class="line">//结果是：数组 [lo wo]   第一个字符“l”与第一个字符“r”之间的字符串，以数组形式返回。   </span><br></pre></td></tr></table></figure>

<p>3、string自己的split方法<br>将字符串按照分割符截取，以数组形式返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;hello, world, ni,  hao&quot;;</span><br><span class="line">String[]  strs=str.split(&quot;,&quot;);</span><br><span class="line">for(int i=0,len=strs.length;i&lt;len;i++)&#123;</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//空格也算了</span><br><span class="line">hello</span><br><span class="line"> world</span><br><span class="line"> ni</span><br><span class="line">  hao</span><br></pre></td></tr></table></figure>

<p><code>split(String regex)</code> 参数regex称为分割符,可以使用正则表达式来表示。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str= &quot;a33b444c555d&quot;;</span><br><span class="line">//正则表达式中\d+表示一个或多个数字,java中\\表示一个普通\</span><br><span class="line">//String[] split = str.split(Pattern.compile(&quot;\\d+&quot;).toString());</span><br><span class="line">//两种写法都是一样的,下面写法简洁</span><br><span class="line">String[] split = str.split(&quot;\\d+&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa|bbb|ccc&quot;;</span><br><span class="line">//使用|作为分隔符,其余特殊字符同理</span><br><span class="line">//两个\表示一个\,加了\后表示仅匹配字符本身</span><br><span class="line">String[] split = str.split(&quot;\\|&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa,bbb#ccc&quot;;</span><br><span class="line">//使用,或#分割字符串</span><br><span class="line">String[] split = str.split(&quot;,|#&quot;);</span><br></pre></td></tr></table></figure>

<p><code>split(String regex,int limit)</code> limit控制分割的次数，只填一个正则表达式的话,limit默认是0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）limit &gt; 0,(从左到右)最多分割 n - 1 次,数组的长度将不会大于 n,结尾的空字符串不会丢弃</span><br><span class="line">//limit=3,切割2次,末尾会分割出一个&quot;&quot;空字符串</span><br><span class="line">String[] split = &quot;abcb&quot;.split(&quot;b&quot;,3);</span><br><span class="line">//split:&#123;&quot;a&quot;,&quot;c&quot;,&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">（2）limit &lt; 0,匹配到多少次就分割多少次,而且数组可以是任何长度。结尾的空字符串不会丢弃</span><br><span class="line"></span><br><span class="line">（3）limit=0不限制分割次数，要注意结尾的空字符串将会丢弃</span><br></pre></td></tr></table></figure>

<p>split方法完整用法：<a href="https://blog.csdn.net/qq_41740883/article/details/111696866">https://blog.csdn.net/qq_41740883/article/details/111696866</a></p>
<p>✅字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接用+，内部会替换成StringBuilder的append方法</span><br><span class="line">    // 不建议在 for 循环中使用 “+” 进行字符串拼接，会创建多个StringBuilder 对象</span><br><span class="line">    String s1 = &quot;hel&quot;;</span><br><span class="line">    String s2 = null;</span><br><span class="line">    System.out.println(s1 + s2); //helnull  如果是null，当作字符串null来处理</span><br><span class="line">    </span><br><span class="line">    // 2.StringBuilder的append方法 （非线程安全）</span><br><span class="line">    StringBuilder s3 = new StringBuilder(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s3.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 3.StringBuffer的append方法 （线程安全）</span><br><span class="line">    StringBuffer s4 = new StringBuffer(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s4.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 4.String类的concat方法</span><br><span class="line">    System.out.println(s1.concat(&quot;lo&quot;));</span><br><span class="line">    //System.out.println(s1.concat(null)); //NPE</span><br><span class="line">    </span><br><span class="line">    // 5.String类的静态join方法 JDK 1.8 提供，可以分隔符，也可以多个字符串(看上面，也可以是list/set)</span><br><span class="line">    System.out.println(String.join(&quot;&quot;, &quot;hel&quot;, &quot;lo&quot;)); //第一个参数为字符串连接符，后面可以是很多个字符串连接</span><br><span class="line">    </span><br><span class="line">    // 6.org.apache.commons.lang3.StringUtil的join方法（为什么使用这个会慢？？？）</span><br><span class="line">    // 不用担心 NullPointerException,内部使用的仍然是 StringBuilder</span><br><span class="line">    System.out.println(StringUtils.join(&quot;hel&quot;, &quot;lo&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/ChineseSoftware/article/details/122956817">https://blog.csdn.net/ChineseSoftware/article/details/122956817</a></p>
<p>concat与+的区别：<br>①如果拼接的字符串是 null，concat 时候就会抛出 NullPointerException，“+” 操作符会当做是 “null” 字符串来处理。<br>②如果拼接的字符串是一个空字符串(“”)，那么 concat 的效率要更高一点。毕竟不需要 new StringBuilder 对象。<br>③如果拼接的字符串非常多，concat 的效率就会下降，因为用到字符数组，开销就大。</p>
<p>✅字符串翻转</p>
<p>1、用stringBuffer或者stringBuilder自带的reverse方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String newS = new StringBuilder(old).reverse().toString();</span><br></pre></td></tr></table></figure>

<p>2、将字符串拆分为char数组，然后交换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[] charArray = s.toCharArray();</span><br><span class="line">int start = 0, end = charArray.length - 1;</span><br><span class="line">for (; start &lt; end; start++, end--) &#123;</span><br><span class="line">    charArray[start] ^= charArray[end];//采用异或</span><br><span class="line">    charArray[end] ^= charArray[start];</span><br><span class="line">    charArray[start] ^= charArray[end];</span><br><span class="line">&#125;</span><br><span class="line">String newS = new String(charArray);</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">while (start &lt; end) &#123;</span><br><span class="line">    //交换首尾char值</span><br><span class="line">    char c = charArray[end];</span><br><span class="line">    charArray[end] = charArray[start];</span><br><span class="line">    charArray[start] = c;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、stringBuffer倒序拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">for (int i = s.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    sb.append(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>4、利用栈的先进后出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">Stack stack = new Stack();</span><br><span class="line">for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    stack.push(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">    //stack会返回栈顶值，并且会把该值删除</span><br><span class="line">    sb.append(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>5、切割递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    if (s.length() &lt;= 1) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //每次把第一个放在后面</span><br><span class="line">    return reverse(s.substring(1)) + s.substring(0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、二分递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    int length = s.length();</span><br><span class="line">    if (length &lt;= 1) return s;</span><br><span class="line">    String left = s.substring(0, length / 2);</span><br><span class="line">    String right = s.substring(length / 2, length);</span><br><span class="line">    return reverse(right) + reverse(left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.jb51.net/article/237801.htm">https://www.jb51.net/article/237801.htm</a></p>
<p>✅删除字符串最后一个字符</p>
<p>1、String的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">System.out.println(s.substring(0, s.length() - 1));</span><br></pre></td></tr></table></figure>

<p>2、replaceFirst方法 正则表达式匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;abcd&quot;;</span><br><span class="line">str = str.replaceFirst(&quot;.$&quot;, &quot;&quot;);</span><br><span class="line">//匹配除“\n”和&quot;\r&quot;之外的任何单个字符</span><br><span class="line">//匹配输入行尾。</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_35764295/article/details/126106534">https://blog.csdn.net/qq_35764295/article/details/126106534</a></p>
<h4 id="StringBuilder操作"><a href="#StringBuilder操作" class="headerlink" title="StringBuilder操作"></a>StringBuilder操作</h4><p>✅删除最后一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&#x27;a&#x27;).append(&#x27;b&#x27;).append(&#x27;c&#x27;);</span><br><span class="line">sb.deleteCharAt(sb.length()-1);</span><br><span class="line">System.out.println(sb); //ab</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">sb.delete(sb.length()-1, sb.length());</span><br></pre></td></tr></table></figure>

<h3 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a>map相关</h3><h4 id="map几种遍历方式"><a href="#map几种遍历方式" class="headerlink" title="map几种遍历方式"></a>map几种遍历方式</h4><p>一、Map.Entry遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">  System.out.println(&quot;key= &quot; + entry.getKey());</span><br><span class="line">  System.out.println(&quot;value= &quot; + entry.getValue());</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>二、通过Iterator迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**通过entrySet()方法将key和value存放到Set集合中，Set集合中有迭代器**/</span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,String&gt;&gt; iterators = entry.iterator();</span><br><span class="line">while(iterators.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,String&gt; entrys  = iterators.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+entrys.getKey()+&quot;&amp;&amp;value=&quot;+entrys.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、通过keySet()遍历<br>keySet()：将Map中所有的key存放到Set集合中。因为Set集合有迭代器，可以通过迭代器循环key，再通过get()方法，得到每个key所对应的value；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**通过keySet()方法将所有的key值存放到Set集合中,Set集合中有迭代器**/</span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+key+&quot;  &quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以不用迭代器，直接for循环</span><br><span class="line">for (String key: map.keySet()) &#123;</span><br><span class="line">  System.out.println(&quot;key:&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、values()遍历<br>values()获取集合中的所有的value值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = map.values();</span><br><span class="line">再for遍历得到value，同样也可以用迭代器</span><br><span class="line">Iterator var3 = values.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">  String value = (String)var3.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、直接foreach map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;第五种:&quot; + key + &quot; ：&quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="MapUtils工具类"><a href="#MapUtils工具类" class="headerlink" title="MapUtils工具类"></a>MapUtils工具类</h4><p>MapUtils是 org.apache.commons.collections 工具包中常用的工具类<br>需要导入包：commons-collections4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int value = MapUtils.getInteger(map, key, 0)</span><br><span class="line">//将结果转换为Integer，如果转换失败则使用默认值</span><br></pre></td></tr></table></figure>

<p>更多用法：<a href="https://blog.csdn.net/u012894692/article/details/82557843">https://blog.csdn.net/u012894692/article/details/82557843</a></p>
<h4 id="map的一些操作"><a href="#map的一些操作" class="headerlink" title="map的一些操作"></a>map的一些操作</h4><p>✅map的size</p>
<p>map.size() 返回 hashMap 中键/值对的数量。</p>
<p>✅map的put和putIfAbsent<br>1.使用 put 方法添加键值对，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null；如果已经存在对应的值，则会<strong>覆盖旧值</strong>，value 为新的值，返回值为旧的value。<br><code>map.put(key, value)</code></p>
<p>2.使用 putIfAbsent 方法添加键值对，不存在才加入，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null，如果已经存在对应的值，则依旧为原来的值，返回值为 value（旧的值）。<br><code>map.putIfAbsent(key, value)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;11&quot;, &quot;11&quot;);</span><br><span class="line">    System.out.println(map.put(&quot;11&quot;, &quot;22&quot;));  //输出11</span><br><span class="line">    System.out.println(map.put(&quot;22&quot;, &quot;22&quot;));  //输出null</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;11&quot;, &quot;33&quot;));  //输出22</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;33&quot;, &quot;44&quot;));  //输出33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>✅map.getOrDefault(key, defaultvalue)<br>用于map获取value，与.get(key)不同的是，如果得到的value是null的话，可以给一个默认值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;StudentGrade&gt; gradeList = Lists.newArrayList();</span><br><span class="line">//把学生成绩list变为map：学生-成绩list</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeMap = Maps.newHashMap();</span><br><span class="line">for(StudentGrade studentGrade : gradeList) &#123;</span><br><span class="line">  List&lt;String&gt; grades = gradeMap.getOrDefault(studentGrade.getName(), Lists.newArrayList());</span><br><span class="line">  grades.add(studentGrade.getGrade());</span><br><span class="line">  gradeMap.put(studentGrade.getName(), grades); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅对map的某个value加一</p>
<p>用<code>map.get(i)++;</code> 不行。得先：<code>int v = map.get(i) + 1;</code> 然后：<code>map.put(i, v);</code></p>
<p>✅某key是否存在<br><code>map.containsKey(key)</code></p>
<p>✅json字符串转换为map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, String&gt; map = JSON.parseObject(jsonString, Map.class);</span><br></pre></td></tr></table></figure>

<p>✅ceilingEntry()</p>
<p>java.util.TreeMap.ceilingEntry() 返回具有最小键值（大于或等于指定键）的键值对，如果没有这样的键，则返回null。(取比输入值大的)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;1&quot;);</span><br><span class="line">map.put(3, &quot;3&quot;);</span><br><span class="line">Map.Entry&lt;Integer, String&gt; entry = map.ceilingEntry(2);</span><br><span class="line">System.out.println(entry.getValue()); //3</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>定义枚举类，定义在一个包中，和impl、service、vo包平级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum SexEnum:int &#123;</span><br><span class="line">    male,female;</span><br><span class="line">&#125;</span><br><span class="line">多个枚举成员之间使用逗号分隔，</span><br><span class="line">如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum DemoEnum &#123;</span><br><span class="line">  LIU(&quot;liu&quot;, 1),</span><br><span class="line">  WANG(&quot;wang&quot;, 2);</span><br><span class="line">  UN_KNOW(&quot;unknow&quot;, 99)</span><br><span class="line"></span><br><span class="line">  private final String name;</span><br><span class="line">  private final int age;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  private DemoEnum(String name, int age)&#123; </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //可以存一个map供外部使用，里面是直接的enum类</span><br><span class="line">  static Map&lt;String, DemoEnum&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    for (DemoEnum enum : DemoEnum.values()) &#123;</span><br><span class="line">      map.put(enum.getName(), enum)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DemoEnum getEnumByName(String name) &#123;</span><br><span class="line">    return map.get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //根据属性获得enum，再获得另一属性</span><br><span class="line">  //可以使用上面构造个map，再从map获取的方法</span><br><span class="line">  //也可以加个方法，遍历获取，根据属性获取enum</span><br><span class="line">  public static DemoEnum nameOf(String name) &#123;</span><br><span class="line">    for (DemoEnum e : DemoEnum.values()) &#123;</span><br><span class="line">      if (e.name = name) &#123;</span><br><span class="line">        return e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UN_KNOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的values()方法，获取定义的成员数组：<br><code>DemoEnum[] values = DemoEnum.values();</code></p>
<p>Enum valueOf方法：<br>通过字符串来获取枚举enum：<br><code>DemoEnum e = DemoEnum.valueOf(&quot;LIU&quot;)</code></p>
<h3 id="File相关"><a href="#File相关" class="headerlink" title="File相关"></a>File相关</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。<br>File对象代表磁盘中实际存在的文件和目录。<br>自我理解：File对象就是文件路径在java里的一个抽象，并不代表真实文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建文件：</span><br><span class="line">String dirname = &quot;/java&quot;;</span><br><span class="line">File f1 = new File(dirname);</span><br><span class="line"></span><br><span class="line">// 判断该文件是否是一个目录</span><br><span class="line">if (f1.isDirectory()) &#123; &#125;</span><br><span class="line">f1.isFile() 是否是文件</span><br><span class="line"></span><br><span class="line">// 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</span><br><span class="line">String s[] = f1.list();</span><br><span class="line">for (int i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  File f = new File(dirname + &quot;/&quot; + s[i]);</span><br><span class="line">  if (f.isDirectory()) &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a directory&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a file&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName()  返回此抽象路径名表示的文件或目录的名称。（文件名）</span><br><span class="line"></span><br><span class="line">public String getPath()  将此抽象路径名转换为一个路径名字符串。（路径名）</span><br><span class="line"></span><br><span class="line">public String getParent()  返回此抽象路径名的父路径名的路径名字符串（路径名）</span><br><span class="line"></span><br><span class="line">public File getParentFile()  返回父文件</span><br><span class="line"></span><br><span class="line">public boolean exists()  测试此抽象路径名表示的文件或目录是否存在。</span><br><span class="line"></span><br><span class="line">// 创建文件所在目录：</span><br><span class="line">File file = new File(&quot;/Users/liuxuan/MyProject/hi.md&quot;);</span><br><span class="line">File dirFile = file.getParentFile();</span><br><span class="line">if(dirFile != null &amp;&amp; !dirFile.exists())&#123;</span><br><span class="line">  dirFile.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多方法：<a href="https://www.runoob.com/java/java-file.html">https://www.runoob.com/java/java-file.html</a></p>
<p>✅文件读写的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IOException &#123;</span><br><span class="line">    // 1. 新建文件夹</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    File file1 = new File(filePath);</span><br><span class="line">    boolean isSame = file.equals(file1);  //true 重写了，变值比较</span><br><span class="line">    boolean isSame1 = file == file1;  //false 地址比较</span><br><span class="line">    System.out.println(isSame);  //true</span><br><span class="line">    if(!file.getParentFile().exists()) &#123;</span><br><span class="line">        File dirFile = file.getParentFile();</span><br><span class="line">        dirFile.mkdirs();  //建立父文件夹</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.字节数组直接写文件，下面有加一步输出流的方式</span><br><span class="line">    String filePath1 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi.java&quot;;</span><br><span class="line">    File file2 = new File(filePath1);</span><br><span class="line">    if(file2.exists()) &#123;</span><br><span class="line">        boolean res = file2.delete();</span><br><span class="line">        System.out.println(&quot;delete:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] data = &quot;hi&quot;.getBytes();</span><br><span class="line">    byte[] data1 = &quot;System.out.println(\&quot;hi\&quot;)&quot;.getBytes();  //String变字节数组</span><br><span class="line">    try &#123;</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data);</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data1);  //覆写的方式</span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组</span><br><span class="line">    FileInputStream in = new FileInputStream(file2);  //也有传入路径字符串的构造函数</span><br><span class="line">    // 输入流变字节数组</span><br><span class="line">    byte[] data2 = IOUtils.toByteArray(in);</span><br><span class="line">    //String content = data2.toString();  //字节数组变String，用这个不对</span><br><span class="line">    String content = new String(data2);  //得用它</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content);</span><br><span class="line">    String content4 = Arrays.toString(data2);</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content4); //这样输出的是数字</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组，另种方法</span><br><span class="line">    FileInputStream in1 = new FileInputStream(file2);</span><br><span class="line">    byte[] data3 = new byte[20];</span><br><span class="line">    String content3 = CharStreams.toString(new InputStreamReader(in1, Charsets.UTF_8)); //这里也消耗输入流</span><br><span class="line">    System.out.println(&quot;前面获取输入流内容：&quot; + content3);</span><br><span class="line">    int num = in1.read(data3);  //输入流消耗20个字节</span><br><span class="line">    System.out.println(&quot;几个字节：&quot; + num);</span><br><span class="line">    String content1 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content1);   //这里只剩几个可以展示</span><br><span class="line">    String content2 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容2：&quot; + content2);  //这里已经没有了</span><br><span class="line"></span><br><span class="line">    // 4.写文件：用输出流 字节数组-&gt;输出流-&gt;文件</span><br><span class="line">    String filePath2 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi2.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file3 = new File(filePath2);</span><br><span class="line">    FileOutputStream out = new FileOutputStream(filePath2);</span><br><span class="line">    byte[] data4 = &quot;System.out.println(\&quot;hi2\&quot;)&quot;.getBytes();</span><br><span class="line">    out.write(data4);  //如果文件存在内容，则是覆盖的方式</span><br><span class="line">    if(file3.exists()) System.out.println(&quot;写入成功&quot;);</span><br><span class="line">    //关闭流</span><br><span class="line">    IOUtils.closeQuietly(in);</span><br><span class="line">    IOUtils.closeQuietly(out);</span><br><span class="line"></span><br><span class="line">    // 5.copy文件：文件-输入流-字节数组-输出流-文件，用IOUtils.copy()一步到位</span><br><span class="line">    String filePath3 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi3.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file4 = new File(filePath3);</span><br><span class="line">    FileInputStream in3 = new FileInputStream(file3);</span><br><span class="line">    FileOutputStream out2 = new FileOutputStream(file4);</span><br><span class="line">    IOUtils.copy(in3, out2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅获取文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.方法一：使用java io</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    long size = file.length();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.方法二：使用java nio</span><br><span class="line">    Path filePath1 = Paths.get(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;);  //绝对路径</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(filePath1);</span><br><span class="line">    long size1 = fileChannel.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size1 + &quot;B&quot;);</span><br><span class="line">    Path filePath2 = Paths.get(&quot;src/test/resources/hi.md&quot;);  //项目下路径</span><br><span class="line">    FileChannel fileChannel2 = FileChannel.open(filePath2);</span><br><span class="line">    long size2 = fileChannel2.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size2 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 3.方法三：使用  apache commons io (只能读文件夹的大小)</span><br><span class="line">    String dir = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile&quot;;</span><br><span class="line">    File file1 = new File(dir);</span><br><span class="line">    long size3 = FileUtils.sizeOfDirectory(file1);</span><br><span class="line">    System.out.println(&quot;文件夹大小：&quot; + size3 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 用户可读视角？</span><br><span class="line">    String display = FileUtils.byteCountToDisplaySize(size);</span><br><span class="line">    System.out.println(display);  //117 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File流"><a href="#File流" class="headerlink" title="File流"></a>File流</h4><p>JAVA中针对文件的读写操作设置了一系列的流，其中主要有FileInputStream,FileOutputStream,FileReader,FileWriter四种最为常用的流</p>
<p>一、FileInputStream流</p>
<p>被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等</p>
<p>若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  File file=new File(&quot;xxxxxxxx&quot;); </span><br><span class="line">  //根据路径创建File类对象--这里路径即使错误也不会报错，因为只是产生File对象，还并未与计算机文件读写有关联</span><br><span class="line">        </span><br><span class="line">  try&#123;</span><br><span class="line">    FileInputStream fileInputStream=new FileInputStream(file);</span><br><span class="line">    //与根据File类对象的所代表的实际文件建立链接创建fileInputStream对象</span><br><span class="line">      &#125;catch (FileNotFoundException e)&#123;</span><br><span class="line">          System.out.println(&quot;文件不存在或者文件不可读或者文件是目录&quot;);</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 也可以根据文件路径名字符串进行建立</span><br><span class="line">FileInputStream fileInputStream=new FileInputStream(filepath);</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://blog.csdn.net/ai_bao_zi/article/details/81097898">https://blog.csdn.net/ai_bao_zi/article/details/81097898</a></p>
<p>IO流的关系：<a href="https://www.cnblogs.com/lianshan/p/11911773.html">https://www.cnblogs.com/lianshan/p/11911773.html</a><br><a href="https://blog.csdn.net/q306507291/article/details/118825930">https://blog.csdn.net/q306507291/article/details/118825930</a></p>
<h4 id="FileUtils-工具类"><a href="#FileUtils-工具类" class="headerlink" title="FileUtils 工具类"></a>FileUtils 工具类</h4><p>apache 的commons-io包下的FileUtils，导包：commons-io</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File file = new File(&quot;E:\\java\\file04\\abc雪.jpg&quot;);</span><br><span class="line">//删除指定文件，从不引发异常。</span><br><span class="line">FileUtils.deleteQuietly(file);</span><br><span class="line"></span><br><span class="line">//将byte数组写为File</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">FileUtils.writeByteArrayToFile(new File(path), bytes)</span><br><span class="line"></span><br><span class="line">//删除掉指定目录的文件</span><br><span class="line">FileUtils.deleteExistFile(new File(localpath));</span><br></pre></td></tr></table></figure>
<p>更多方法：<a href="https://blog.csdn.net/qq_42402854/article/details/83374559">https://blog.csdn.net/qq_42402854/article/details/83374559</a></p>
<h4 id="IOUtils工具类"><a href="#IOUtils工具类" class="headerlink" title="IOUtils工具类"></a>IOUtils工具类</h4><p>它是 Apache Commons IO 的一部分 。该类的所有成员函数都被用来处理输入 - 输出流。这些方法基于 InputStream,  OutputStream,  Reader 和 Writer工作。</p>
<p>所有成员字段和方法都是静态的，不需要创建对象，直接用类名调用。</p>
<p>✅输入流转为字节数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将输入流转换成字符数组:</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br></pre></td></tr></table></figure>

<p>✅关闭流<br>之前关闭流，往往在finally中，因为会抛出IOException，所以finally中需要try catch，并且close之前需要判断是否为null。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">  if (in != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      in.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          LOGGER.warn(&quot;Fail to close stream : &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以使用 IOUtils.closeQuietly 来精简代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] data = new byte[1024];</span><br><span class="line">InputStream in = null;</span><br><span class="line">OutputStream out = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">      in = new FileInputStream(&quot;foo.txt&quot;);</span><br><span class="line">      in.read(data);</span><br><span class="line"></span><br><span class="line">      out = new FileOutputStream(&quot;foo.txt&quot;);</span><br><span class="line">      data = &quot;Hello, World&quot;.getBytes();</span><br><span class="line">      out.write(data);</span><br><span class="line"></span><br><span class="line">      IOUtils.copy(in, out);</span><br><span class="line"></span><br><span class="line">      in.close(); //close errors are handled</span><br><span class="line">      out.close();</span><br><span class="line">&#125; catch (IOException e) &#123; </span><br><span class="line">      // error handling</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">      IOUtils.closeQuietly(in);</span><br><span class="line">      IOUtils.closeQuietly(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<a href="https://blog.csdn.net/sulia1234567890/article/details/120569718">https://blog.csdn.net/sulia1234567890/article/details/120569718</a></p>
<p>✅写文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws IOException &#123;</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    OutputStream out = new FileOutputStream(file, true);</span><br><span class="line">    IOUtils.write(&quot;hello&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;\n&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;hi&quot;, out);</span><br><span class="line">    //也可以传字节数组、字符数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️new FileOutputStream(“b.txt”,true);</p>
<p>默认第二个参数是false，表示不追加，每次new对象都会清空之前的内容创建新的内容，ture表示在之前的基础上追加内容</p>
<p>✅字节数组转换为String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] data = &quot;hello world&quot;.getBytes();</span><br><span class="line">//apache里io的IOUtils需要commons-io包</span><br><span class="line">String s1 = IOUtils.toString(data, &quot;utf-8&quot;);</span><br><span class="line">String s2 = new String(data);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>

<h4 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h4><p>需要依赖：spring-web</p>
<p>首先，“流”是一个抽象的概念，它是对输入输出设备的一种抽象理解，在java中，对数据的输入输出操作都是以“流”的方式进行的。“流”具有方向性，输入流、输出流是相对的。当程序需要从数据源中读入数据的时候就会开启一个输入流，相反，写出数据到某个数据源目的地的时候也会开启一个输出流。</p>
<p>MultipartFile是SpringMVC提供简化上传操作的工具类。实现文件的快速上传，不需要先将File转换成output流 再传输过去 接收端接收流再生成文件。</p>
<p>在不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据，文件是以二进制流传递到后端的，然后需要我们自己转换为File类。使用了MultipartFile工具类之后，我们对文件上传的操作就简便许多了。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_45393094/article/details/112056436">https://blog.csdn.net/weixin_45393094/article/details/112056436</a></p>
<p>✅内部方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MultipartFile extends InputStreamSource &#123;</span><br><span class="line">    //getName() 返回参数的名称</span><br><span class="line">    String getName();</span><br><span class="line">    //获取源文件的昵称</span><br><span class="line">    @Nullable</span><br><span class="line">    String getOriginalFilename();</span><br><span class="line">    //getContentType() 返回文件的内容类型</span><br><span class="line">    @Nullable</span><br><span class="line">    String getContentType();</span><br><span class="line">    //isEmpty() 判断是否为空，或者上传的文件是否有内容</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    //getSize() 返回文件大小 以字节为单位</span><br><span class="line">    long getSize();</span><br><span class="line">    //getBytes() 将文件内容转化成一个byte[] 返回</span><br><span class="line">    byte[] getBytes() throws IOException;</span><br><span class="line">    //getInputStream() 返回InputStream读取文件的内容</span><br><span class="line">    InputStream getInputStream() throws IOException;</span><br><span class="line"></span><br><span class="line">    default Resource getResource() &#123;</span><br><span class="line">        return new MultipartFileResource(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //transferTo(File dest) 用来把 MultipartFile 转换换成 File</span><br><span class="line">    void transferTo(File var1) throws IOException, IllegalStateException;</span><br><span class="line"></span><br><span class="line">    default void transferTo(Path dest) throws IOException, IllegalStateException &#123;</span><br><span class="line">        FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅MockMultipartFile</p>
<p>可以用MockMultipartFile创建MultipartFile。需要导入spring-test.jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MockMultipartFile(String name, @Nullable String originalFilename, @Nullable String contentType, InputStream contentStream)</span><br><span class="line">第一个参数：传输后的文件名 </span><br><span class="line">第二个：旧文件名字（可为空） </span><br><span class="line">第三：类型</span><br><span class="line">第四：输入流</span><br></pre></td></tr></table></figure>

<p>✅MultipartFile与File的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws IOException &#123;</span><br><span class="line">    // 1.File转为MultipartFile：file-InputStream-MultipartFile</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    System.out.println(file.getName());  //hello.java</span><br><span class="line">    System.out.println(FilenameUtils.getExtension(file.getName()));  //后缀java</span><br><span class="line">    FileInputStream in = new FileInputStream(file);</span><br><span class="line">    MultipartFile mf = new MockMultipartFile(file.getName(), file.getName(), &quot;text/plain&quot;, in);</span><br><span class="line">    System.out.println(mf.getName()); //hello.java</span><br><span class="line">    System.out.println(mf.getOriginalFilename());  //hello.java</span><br><span class="line"></span><br><span class="line">    // 2.MultipartFile转为File</span><br><span class="line">    try &#123;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        //得到文件后缀</span><br><span class="line">        String originalName = mf.getOriginalFilename();</span><br><span class="line">        String ext = &quot;.&quot; + FilenameUtils.getExtension(originalName);</span><br><span class="line">        String fileName = uuid + ext;</span><br><span class="line">        File targetFile = new File(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/&quot;, fileName);</span><br><span class="line">        //第一个参数：文件夹  第二个参数：文件名</span><br><span class="line">        // 方法一：MultipartFile - 字节数组 - File本地</span><br><span class="line">        FileUtils.writeByteArrayToFile(targetFile, mf.getBytes());</span><br><span class="line">        // 方法二：MultipartFile - 字节数组 - 输出流 - File本地</span><br><span class="line">        byte[] data = mf.getBytes();</span><br><span class="line">        FileOutputStream out = new FileOutputStream(targetFile);</span><br><span class="line">        out.write(data);</span><br><span class="line">        IOUtils.closeQuietly(out);</span><br><span class="line">        // 方法三：直接用MultipartFile内部方法</span><br><span class="line">        mf.transferTo(targetFile);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        System.out.println(&quot;失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅使用MultipartFile实现文件上传的一个case</p>
<p>背景：文件上传备份希望它是和主业务线程处于异步情况下的，这样可以更快的响应给用户反馈，减少等待时间。<br>MultipartFile异步保存文件transferto 报错java.io.FileNotFoundException: XXX.tmp (No such file or directory)</p>
<p>原因：由于SpringBoot上传文件后会形成MultiPartFile的实例，在临时文件夹中生成临时文件，并且此实例执行此临时文件。当主线程执行结束后，<br>SpringMVC会清除掉此临时文件，导致子线程在处理此实例的时候找不到此实例指向的临时文件，MultipartFile对象就变成了null,从而报FileNotFoundException！</p>
<p>解决：先获取传InputStrem，传传InputStrem。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_42408648/article/details/126272849">https://blog.csdn.net/weixin_42408648/article/details/126272849</a></p>
<p>✅MultipartFile 对上传的文件大小进行限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MultipartFileUtil &#123;</span><br><span class="line"></span><br><span class="line">private final static Integer FILE_SIZE = 5;//文件上传限制大小</span><br><span class="line">private final static String FILE_UNIT = &quot;M&quot;;//文件上传限制单位（B,K,M,G）</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param len  文件长度</span><br><span class="line">     * @param size 限制大小</span><br><span class="line">     * @param unit 限制单位（B,K,M,G）</span><br><span class="line">     * @描述 判断文件大小</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkFileSize(Long len, int size, String unit) &#123;</span><br><span class="line">        double fileSize = 0;</span><br><span class="line">        if (&quot;B&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len;</span><br><span class="line">        &#125; else if (&quot;K&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1024;</span><br><span class="line">        &#125; else if (&quot;M&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1048576;</span><br><span class="line">        &#125; else if (&quot;G&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1073741824;</span><br><span class="line">        &#125;</span><br><span class="line">        return !(fileSize &gt; size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //文件上传调用</span><br><span class="line">    public static String upload(MultipartFile file) &#123;</span><br><span class="line">        boolean flag = checkFileSize(file.getSize(), FILE_SIZE, FILE_UNIT);</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;上传文件大小超出限制&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="https://blog.csdn.net/w_shimmer/article/details/124341265">https://blog.csdn.net/w_shimmer/article/details/124341265</a></p>
<h4 id="java-nio-file-文件操作"><a href="#java-nio-file-文件操作" class="headerlink" title="java.nio.file 文件操作"></a>java.nio.file 文件操作</h4><p>自 Java7 开始，Java 终于简化了文件读写的基本操作，新增了 java.nio.file 库，通过与 Java8 新增的 stream 结合可以使得文件操作变得更加优雅。</p>
<p>1️⃣文件和目录路径Path</p>
<p>java.nio.file.Paths 类包含一个静态方法 <code>static.get()</code>，可以接受一系列 String 字符串或一个统一资源标识符 URI 作为参数，并且转换返回一个 <code>Path</code> 对象。</p>
<p>一个 Path 对象表示一个文件或者目录的路径，是一个跨操作系统和文件系统的抽象，目的是在构造路径时可以不必关注底层操作系统。如果 Path 仅由一个空的名称元素组成，则认为是空的路径。使用空路径访问文件等同于访问文件系统的默认目录。Path 接口的实现是不可变且安全的，可供多个并行线程使用.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;);</span><br><span class="line">System.out.println(path1); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path2 = Paths.get(&quot;C:/path/to/nowhere/NoFile.txt&quot;);</span><br><span class="line">System.out.println(path2); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">URI uri = path2.toUri();  //转换为URI对象，可以用于构建web资源的绝对uri</span><br><span class="line">System.out.println(uri); //file:///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path3 = Paths.get(uri);</span><br><span class="line">System.out.println(path3);</span><br><span class="line"></span><br><span class="line">// 返回表示此路径的绝对路径的Path对象</span><br><span class="line">Path p = Paths.get(&quot;FileTest.java&quot;).toAbsolutePath();  //相对于当前项目目录</span><br><span class="line">System.out.println(p); ///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">// 返回表示此路径的真实路径的Path对象，也即是带上盘符（根路径）</span><br><span class="line">Path p2 = Paths.get(&quot;/Users/liuxuan/Downloads/test&quot;).toRealPath();</span><br><span class="line">// getNameCount() 返回路径中的名称元素的数量</span><br><span class="line">for(int i = 0; i &lt; p.getNameCount(); i++) &#123;</span><br><span class="line">    // 返回此路径的名称元素作为 Path对象</span><br><span class="line">    System.out.println(p.getName(i));</span><br><span class="line">&#125;</span><br><span class="line">// 测试路径是否以给定的路径结束，这里会输出 end with &#x27;.java&#x27;:false</span><br><span class="line">System.out.println(&quot;ends with &#x27;.java&#x27;: &quot; + p.endsWith(&quot;.java&quot;));</span><br><span class="line">// Path 也实现了 iterable 接口，会对路径中的名称元素进行遍历</span><br><span class="line">for(Path pp : p) &#123;</span><br><span class="line">    System.out.println(pp);</span><br><span class="line">&#125;</span><br><span class="line">// getRoot() 返回此路径的根路径作为Path对象，为null则该路径不具有根</span><br><span class="line">// startsWith() 效果和 endsWith() 相似</span><br><span class="line">// 这里会输出 Starts with C:\ true</span><br><span class="line">System.out.println(&quot;Starts with &quot; + p.getRoot() + &quot; &quot; + p.startsWith(p.getRoot()));</span><br></pre></td></tr></table></figure>

<p>有时我们还需要通过对 Path 对象增加或修改一部分来构造一个新的 path 对象，可以使用 relativize() 移除 Path 的根路径，或者使用 resolve() 添加 Path 的尾路径，注意添加的路径可以不是真实存在的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用..可以跳转到上一级路径，但必须使用normalize()方法</span><br><span class="line">// 假设当前路径为/Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">Path base = Paths.get(&quot;..&quot;, &quot;..&quot;, &quot;..&quot;).toAbsolutePath().normalize();</span><br><span class="line">System.out.println(base); ///Users/liuxuan/MyProject</span><br><span class="line">// 构造此路径和给定路径之间的相对路径</span><br><span class="line">Path p4 = base.relativize(p);</span><br><span class="line">System.out.println(p4);</span><br><span class="line">// 使用resolve构造路径</span><br><span class="line">// 此时路径为C:\Users\Bruce\Documents\GitHub\string</span><br><span class="line">Path convoluted = p.getParent().resolve(&quot;string&quot;);</span><br><span class="line">System.out.println(convoluted);</span><br></pre></td></tr></table></figure>

<p>2️⃣Files工具类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取文件的字节数组：</span><br><span class="line">byte[] fileBytes = Files.readAllBytes(Paths.get(&quot;/Users/liuxuan/Downloads/test/cal.sh&quot;));</span><br><span class="line">System.out.println(new String(fileBytes));</span><br></pre></td></tr></table></figure>

<p>获取文件夹中的文件夹数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String path = &quot;/Users/liuxuan/Downloads/&quot;;</span><br><span class="line">File fileDir = new File(path);</span><br><span class="line">if (!fileDir.exists() || !fileDir.isDirectory()) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String[] fileList = fileDir.list();</span><br><span class="line">int count = 0;</span><br><span class="line">for (String file : fileList) &#123;</span><br><span class="line">    if (new File(path + file).isDirectory()) &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">File[] files = fileDir.listFiles();</span><br><span class="line">for (File file : files) &#123;</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Files实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;/Users/liuxuan/Downloads/&quot;);</span><br><span class="line">if (!Files.exists(path1) || !Files.isDirectory(path1)) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long dirCount = Files.list(path1).filter(Files :: isDirectory).count();</span><br><span class="line">System.out.println(dirCount);</span><br></pre></td></tr></table></figure>

<p>使用<code>Files.list(path)</code>需要注意，它返回的是<code>Stream&lt;Path&gt;</code>，如果没有关闭，并且代码频繁使用，将导致打开的文件过多而报错（每个进程可以打开的文件数量是有限制的）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps -mlVv | grep javaTest</span><br><span class="line">lsof -p 进程id | wc -l</span><br></pre></td></tr></table></figure>

<p>所以要关闭流：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.手动关闭</span><br><span class="line">Stream&lt;Path&gt; paths = Files.list(path);</span><br><span class="line">paths.close();</span><br><span class="line"></span><br><span class="line">2.try resource自动关闭流</span><br><span class="line">try(Stream&lt;Path&gt; paths = Files.list(path)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多该包下的用法：<br><a href="https://blog.csdn.net/CSDN_handsome/article/details/109743637">https://blog.csdn.net/CSDN_handsome/article/details/109743637</a></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>看《java基础》<br>针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set.stream().map(i-&gt;String.valueOf(i)).</span><br><span class="line">括号内的i，表示流处理中的元素，也是lambda表达式的输入</span><br><span class="line">只有一句语句，省去了&#123;&#125;，省去了return</span><br><span class="line"></span><br><span class="line">使用现有的方法，比如上面的，可以变成lambda表达式的引用形式::</span><br><span class="line">.map(String::valueOf).</span><br><span class="line"></span><br><span class="line">上面的方法例如map()，内部的传参是只有一个函数式接口，</span><br><span class="line">有的方法穿参，除了一个函数式接口还有其他，所以会有其他参数。</span><br><span class="line">例如：</span><br><span class="line">方法：showSum(int x, int y, Calculate cu)</span><br><span class="line">使用：showSum(10, 20, (x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>



<h3 id="spring-expression-Spel表达式-java语言解析"><a href="#spring-expression-Spel表达式-java语言解析" class="headerlink" title="spring-expression Spel表达式 java语言解析"></a>spring-expression Spel表达式 java语言解析</h3><p>ExpressionParse接口是springframework包下的。<br>对表达式进行解析，通过字符串传入解析器，进行解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //将一整个语句直接定义了字符串 ,其中对字符串的开始索引与结束索引使用替代变量</span><br><span class="line">    //变量前需要加#</span><br><span class="line">    String str = &quot;#var + 2&quot;;</span><br><span class="line">    //1定义一个专属的表达式解析工具</span><br><span class="line">    ExpressionParser parser = new SpelExpressionParser() ;</span><br><span class="line">    //2定义一个表达式处理类</span><br><span class="line">    Expression exp = parser.parseExpression(str);</span><br><span class="line">    //3进行最终的表达式计算，这个上下文用来传参</span><br><span class="line">    EvaluationContext context = new StandardEvaluationContext() ;</span><br><span class="line">    context.setVariable(&quot;var&quot;, 5);</span><br><span class="line">    //4通过表达式进行结果计算</span><br><span class="line">    System.out.println(exp.getValue(context, Integer.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger类是系统底层保护的int类型，通过提供执行方法的控制进行值的原子操作。AtomicInteger它不能当作Integer来使用。</p>
<p>从JAVA 1.5开始，AtomicInteger 属于java.util.concurrent.atomic 包下的一个类。</p>
<p>AtomicInteger通过调用构造函数可以直接创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始值是 0</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(); </span><br><span class="line"> </span><br><span class="line">//初始值是 100</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line"> </span><br><span class="line">int currentValue = atomicInteger.get();         //100</span><br><span class="line"> </span><br><span class="line">atomicInteger.set(1234);                        //当前值1234</span><br></pre></td></tr></table></figure>

<p>什么时候用？<br>1、作为多个线程同时使用的原子计数器。<br>2、在比较和交换操作中实现非阻塞算法。</p>
<p>原子计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一些以原子方式执行加法和减法操作的方法:</span><br><span class="line">addAndGet()- 以原子方式将给定值添加到当前值，并在添加后返回新值。</span><br><span class="line">getAndAdd() - 以原子方式将给定值添加到当前值并返回旧值。</span><br><span class="line">incrementAndGet()- 以原子方式将当前值递增1并在递增后返回新值。它相当于i ++操作。</span><br><span class="line">getAndIncrement() - 以原子方式递增当前值并返回旧值。它相当于++ i操作。</span><br><span class="line">decrementAndGet()- 原子地将当前值减1并在减量后返回新值。它等同于i-操作。</span><br><span class="line">getAndDecrement() - 以原子方式递减当前值并返回旧值。它相当于-i操作。</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.addAndGet(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //102</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndAdd(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.incrementAndGet());    //105  </span><br><span class="line">        System.out.println(atomicInteger);                      //105  </span><br><span class="line">                 </span><br><span class="line">        System.out.println(atomicInteger.getAndIncrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //106</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.decrementAndGet());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //105</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndDecrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较和交换：<br>1、比较和交换操作将内存位置的内容与给定值进行比较，并且只有它们相同时，才将该内存位置的内容修改为给定的新值。这是作为单个原子操作完成的。<br>2、原子性保证了新值是根据最新信息计算出来的; 如果在此期间该值已被另一个线程更新，则写入将失败。<br><code>boolean compareAndSet(int expect, int update)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        //1、默认初始值</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">        //2、默认初始值和给定值，都是100，所以会更改成功</span><br><span class="line">        boolean isSuccess = atomicInteger.compareAndSet(100,110);   //current value 100</span><br><span class="line">        //3、返回true</span><br><span class="line">        System.out.println(isSuccess);      //true</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">        //4、默认初始值是110,给定值是100，所以会更改失败</span><br><span class="line">        isSuccess = atomicInteger.compareAndSet(100,120);       //current value 110</span><br><span class="line">        //5、返回false</span><br><span class="line">        System.out.println(isSuccess);      //false</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.jianshu.com/p/073096a729f6">https://www.jianshu.com/p/073096a729f6</a></p>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>返回Class类型的对象。只是getClass()，返回当前运行时类。object.getClass()前面带对象.getClass()返回对象的类。</p>
<p>Class常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IllegalAccessException, InstantiationException, IOException &#123;</span><br><span class="line">  Class cl = getClass();</span><br><span class="line">  System.out.println(cl); //class org.example.javaer.ClassTest</span><br><span class="line">  String name = cl.getName(); // org.example.javaer.ClassTest</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  Object classTest = cl.newInstance(); //创建实例</span><br><span class="line">  String packName = cl.getPackage().getName();</span><br><span class="line">  System.out.println(packName); //org.example.javaer</span><br><span class="line">  ClassLoader classLoader = cl.getClassLoader(); //获取类加载器</span><br><span class="line">  System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">  //getResourceAsStream从项目下文件中获取输入流</span><br><span class="line">  //读取文件内容为String</span><br><span class="line">  InputStream in = cl.getResourceAsStream(&quot;/hi.md&quot;); //加&quot;/&quot;，/表示src/test/resources下（ClassPath根目录）</span><br><span class="line">  System.out.println(IOUtils.toString(in, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">  //读取为字节数组</span><br><span class="line">  byte[] bytes = IOUtils.toByteArray(in);</span><br><span class="line">  System.out.println(bytes);</span><br><span class="line"></span><br><span class="line">  InputStream in1 = cl.getResourceAsStream(&quot;src/test/resources/hi.md&quot;); //不行，NPE</span><br><span class="line">  System.out.println(IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅获取各种路径"><a href="#✅获取各种路径" class="headerlink" title="✅获取各种路径"></a>✅获取各种路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.获取ClassPath根路径（类加载根路径），到src/test/resources，两种方法</span><br><span class="line">    String path1 = getClass().getResource(&quot;/&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path1);</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + getClass().getClassLoader().getResource(&quot;&quot;)); //和上面一样</span><br><span class="line"></span><br><span class="line">    // 2.获取绝对路径</span><br><span class="line">    String path2 = getClass().getResource(&quot;&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/classes/org/example/javaer/</span><br><span class="line">    System.out.println(&quot;绝对路径：&quot; + path2);</span><br><span class="line"></span><br><span class="line">    // 3.获取项目路径 两种方法</span><br><span class="line">    File dir = new File(&quot;&quot;); //参数为空</span><br><span class="line">    String path3 = dir.getCanonicalPath(); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path3);</span><br><span class="line">    String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">    String allPath = System.getProperty(&quot;java.class.path&quot;); //所有jar包的路径</span><br><span class="line">    System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">    // 再看看</span><br><span class="line">    String path5 = getClass().getResource(&quot;/&quot;).getPath(); //这样获得的前面没有file</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path5);</span><br><span class="line">    URL url = getClass().getClassLoader().getResource(&quot;&quot;); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.51cto.com/u_15057811/4080631">https://blog.51cto.com/u_15057811/4080631</a></p>
<h4 id="✅System-getProperty-方法"><a href="#✅System-getProperty-方法" class="headerlink" title="✅System.getProperty()方法"></a>✅System.getProperty()方法</h4><p>获取当前系统的版本等一些信息。<br>内部key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">String allPath = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">Java.version</span><br><span class="line">Java 运行时环境版本</span><br><span class="line">java.vendor</span><br><span class="line">Java 运行时环境供应商</span><br><span class="line">java.vendor.url</span><br><span class="line">Java 供应商的 URL</span><br><span class="line">java.home</span><br><span class="line">Java 安装目录</span><br><span class="line">java.vm.specification.version</span><br><span class="line">Java 虚拟机规范版本</span><br><span class="line">java.vm.specification.vendor</span><br><span class="line">Java 虚拟机规范供应商</span><br><span class="line">java.vm.specification.name</span><br><span class="line">Java 虚拟机规范名称</span><br><span class="line">java.vm.version</span><br><span class="line">Java 虚拟机实现版本</span><br><span class="line">java.vm.vendor</span><br><span class="line">Java 虚拟机实现供应商</span><br><span class="line">java.vm.name</span><br><span class="line">Java 虚拟机实现名称</span><br><span class="line">java.specification.version</span><br><span class="line">Java 运行时环境规范版本</span><br><span class="line">java.specification.vendor</span><br><span class="line">Java 运行时环境规范供应商</span><br><span class="line">java.specification.name</span><br><span class="line">Java 运行时环境规范名称</span><br><span class="line">java.class.version</span><br><span class="line">Java 类格式版本号</span><br><span class="line">java.class.path</span><br><span class="line">Java 类路径</span><br><span class="line">java.library.path</span><br><span class="line">加载库时搜索的路径列表</span><br><span class="line">java.io.tmpdir</span><br><span class="line">默认的临时文件路径</span><br><span class="line">java.compiler</span><br><span class="line">要使用的 JIT 编译器的名称</span><br><span class="line">java.ext.dirs</span><br><span class="line">一个或多个扩展目录的路径</span><br><span class="line">os.name</span><br><span class="line">操作系统的名称</span><br><span class="line">os.arch</span><br><span class="line">操作系统的架构</span><br><span class="line">os.version</span><br><span class="line">操作系统的版本</span><br><span class="line">file.separator</span><br><span class="line">文件分隔符（在 UNIX 系统中是“/”）</span><br><span class="line">path.separator</span><br><span class="line">路径分隔符（在 UNIX 系统中是“:”）</span><br><span class="line">line.separator</span><br><span class="line">行分隔符（在 UNIX 系统中是“/n”）</span><br><span class="line">user.name</span><br><span class="line">用户的账户名称</span><br><span class="line">user.home</span><br><span class="line">用户的主目录</span><br><span class="line">user.dir</span><br><span class="line">用户的当前工作目录</span><br></pre></td></tr></table></figure>

<h4 id="✅类加载器"><a href="#✅类加载器" class="headerlink" title="✅类加载器"></a>✅类加载器</h4><p>用来把类装载进内存的。</p>
<p>非常不错的详解：<a href="https://blog.csdn.net/m0_68064743/article/details/123957150">https://blog.csdn.net/m0_68064743/article/details/123957150</a></p>
<h4 id="✅getSimpleName"><a href="#✅getSimpleName" class="headerlink" title="✅getSimpleName"></a>✅getSimpleName</h4><p>Class.getSimpleName()方法返回此Class对象表示的类或接口的简单名称，作为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String className1 = SomeTest.class.getName();</span><br><span class="line">System.out.println(className1); //com.liuxuan.study.SomeTest</span><br><span class="line">String className2 = SomeTest.class.getSimpleName();</span><br><span class="line">System.out.println(className2); //SomeTest</span><br></pre></td></tr></table></figure>

<h3 id="Class-forName方法"><a href="#Class-forName方法" class="headerlink" title="Class.forName方法"></a>Class.forName方法</h3><p>Class类的静态方法forName()<br>和上面的一样，都是返回Class类型的对象，区别在于object.getClass()用于根据对象获取Class对象；Class.forName(className)用于根据类名获取Class对象。</p>
<h4 id="✅-首先讲述Class是个什么样的对象"><a href="#✅-首先讲述Class是个什么样的对象" class="headerlink" title="✅ 首先讲述Class是个什么样的对象"></a>✅ 首先讲述Class是个什么样的对象</h4><p>1、 Class类封装了类或接口的运行时状态</p>
<p>Java程序在运行时，系统一直对所有的对象进行所谓的运行时类型标识，这些标示纪录了每个对象所属的类。<br>虚拟机通常使用运行时类型信息选择正确方法去执行，用来保存这些类型信息的类是Class类。</p>
<p>2、Class类型的对象，是加载类时自动创建的</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时，由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。</p>
<p>3、虚拟机为每种类型管理一个独一无二的Class对象</p>
<p>每个类（型）都有一个Class对象。<br>运行程序时，Java虚拟机(JVM)首先检查所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<p>4、基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。</p>
<p>5、每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p>
<p>6、一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</p>
<h4 id="✅-结合反射使用举例"><a href="#✅-结合反射使用举例" class="headerlink" title="✅ 结合反射使用举例"></a>✅ 结合反射使用举例</h4><p>对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<p>getMethod()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。</p>
<p>getDeclaredMethod()对象表示的类或接口声明的所有方法,包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p>
<p>一个实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line">    private static final String defName = &quot;《程序猿植发》&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;我是静态代码块，输出: &quot; + defName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印生产日期：</span><br><span class="line">    public static String printProduceDate(String name) &#123;</span><br><span class="line">        return &quot;我是静态方法printProduceDate，输出: &quot; + name + &quot;, produce is:&quot; + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line">        System.out.println(&quot;我是Book声明的构造方法！&quot;);</span><br><span class="line">        name = defName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString(String msg) &#123;</span><br><span class="line">        return name + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">    //1-将指定类加载到JVM中（ClassNotFoundException）</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Book&quot;); //加载过程会执行static静态代码块 out：我是静态代码块，输出: 《程序猿植发》</span><br><span class="line">    System.out.println(aClass);  //out:class com.junit.demo.Book</span><br><span class="line"></span><br><span class="line">    //2.1-访问静态方法：NoSuchMethodException，InvocationTargetException</span><br><span class="line">    Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">    String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);  </span><br><span class="line">    //反射静态方法 第一个参数是Class对象(也可以传入null？) 第二个参数是输入</span><br><span class="line">    System.out.println(result); //out：我是静态方法printProduceDate，输出: 《程序猿的颈椎自传》, produce is:1626682894095</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.2-初始化对象：</span><br><span class="line">    Book obj = (Book) aClass.newInstance();  //out:我是Book声明的构造方法！</span><br><span class="line">    System.out.println(&quot;得到对象后访问get方法：&quot; + obj.toString(&quot;&quot;));  //out:得到对象后访问get方法：《程序猿植发》</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.3-初始化对象后访问方法：</span><br><span class="line">    Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">    String result3 = (String) method3.invoke(aClass.newInstance()/*obj*/, &quot;这本书是我的伙伴！&quot;); </span><br><span class="line">    //反射非静态方法，第一个参数是对象，第二个是输入。</span><br><span class="line">    System.out.println(result3); //out：《程序猿植发》这本书是我的伙伴！</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Book.class.getName()); //com.junit.demo.Book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>☝️通过反射方式访问静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 由Class获取方法：第一个参数为方法名，第二个参数为方法的参数类型。</span><br><span class="line">Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">// 引用方法：(引用实例/调用静态方法可为null，参数值/有多个用逗号隔开)，参数值要和参数类型的数量匹配！</span><br><span class="line">String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;printProduceDate&quot;, String.class).invoke(null, &quot;《程序猿的颈椎自传》&quot;);</span><br></pre></td></tr></table></figure>

<p>✌️通过反射方式访问实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//方法一：直接转化实例化后的对象，直接调用方法</span><br><span class="line">Book book= (Book) aClass.newInstance();</span><br><span class="line">// book.setName(&#x27;xxx&#x27;); or book.getName(); or more...</span><br><span class="line"></span><br><span class="line">//方法二：使用invoke调用指定实例a的指定方法b</span><br><span class="line">Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">//这里的book可以是已实例化的对象，或者使用 aClass.newInstance() 传入，详见简写：</span><br><span class="line">String result3 = (String) method3.invoke(book, &quot;这本书是我的伙伴！&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;toString&quot;, String.class).invoke(aClass.newInstance(), &quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果是类似于工具类可用于全部类访问的，可以使用一个实例化对象，而不需要每次都newInstance。</p>
<p>另外，方法一适用于需要映射的类是已知或少数时，反之需要统一按指定字符串反射调用方法的话，需使用方法二。</p>
<p>☝️通过反射方式访问私有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Netbar &#123;</span><br><span class="line">    private Double random = Math.random();</span><br><span class="line"></span><br><span class="line">    public Double getRandom() &#123;</span><br><span class="line">        return random;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Netbar createNew() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Netbar getInstance() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Netbar netbar = new Netbar();</span><br><span class="line">        System.out.println(&quot;Random:: &quot; + netbar.getRandom());</span><br><span class="line">        Netbar netbar2 = netbar.createNew();</span><br><span class="line">        System.out.println(&quot;Random2:: &quot; + netbar2.getRandom());</span><br><span class="line">        Netbar netbar3 = Netbar.getInstance();</span><br><span class="line">        System.out.println(&quot;Random3:: &quot; + netbar3.getRandom());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有非静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;createNew&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(aClass.newInstance()); //传入对象</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;getInstance&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(null);  //静态方法可以传入null</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：Java之Class.forName方法详解：<br><a href="https://blog.csdn.net/qq_26599807/article/details/118900090">https://blog.csdn.net/qq_26599807/article/details/118900090</a></p>
<h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><p>首先，浅拷贝和深拷贝都是针对一个已有对象的操作。</p>
<p>在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象（引用数据类型）。而一般使用 『 = 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(12345);</span><br><span class="line">    Student stu2 = stu1;</span><br><span class="line">    stu2.setNumber(54321);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2.getNumber());  //改2，1跟着也改了</span><br><span class="line">    //原因出在(stu2 = stu1) 这一句。</span><br><span class="line">    //该语句的作用是将stu1的引用赋值给stu2。其实，stu1和stu2在堆内存中指向的是同一个对象</span><br><span class="line"></span><br><span class="line">    // 2.新建一个，再set</span><br><span class="line">    Student stu3 = new Student();</span><br><span class="line">    stu3.setNumber(stu1.getNumber());</span><br><span class="line">    stu3.setNumber(111);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生3:&quot; + stu3.getNumber());  //改2，1不会跟着也改了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。</p>
<p>所谓的浅拷贝和深拷贝，只是在拷贝对象的时候，对 类的实例对象 这种引用数据类型的不同操作而已。</p>
<p>总结来说：</p>
<p>1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p>Object 上的 clone() 方法<br>在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。<br>而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。</p>
<p>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常) 该接口为标记接口(不含任何方法)<br>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象（native为本地方法)</p>
<hr>
<p>转自：<a href="https://www.cnblogs.com/hongshi/p/16189920.html">https://www.cnblogs.com/hongshi/p/16189920.html</a></p>
<h4 id="✅浅拷贝"><a href="#✅浅拷贝" class="headerlink" title="✅浅拷贝"></a>✅浅拷贝</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    //ClassTest.Student(number=1, name=ll, teacher=ClassTest.Teacher(age=24)) hashCode:1407343478</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    //ClassTest.Student(number=2, name=oo, teacher=ClassTest.Teacher(age=24)) hashCode:1940447180</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">    //teacher的hashCode：83 83</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">    //浅拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面的Teacher对象，实际上还是指向了同一个对象，只对对它的引用进行了传递。</p>
<p>注意⚠️：String作为不可更改的类（immutable class），在new赋值的时候，就已经创建了一个新的对象；表现出来的是深拷贝（和基本数据类型一样）。</p>
<h4 id="✅深拷贝"><a href="#✅深拷贝" class="headerlink" title="✅深拷贝"></a>✅深拷贝</h4><p>两种方法：<br>1、序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。<br>2、继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。也就是让Teacher类也实现Cloneable接口，重写clone方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">//        //浅拷贝</span><br><span class="line">//        @Override</span><br><span class="line">//        public Object clone() &#123;</span><br><span class="line">//            try&#123;</span><br><span class="line">//                return super.clone();</span><br><span class="line">//            &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            return null;</span><br><span class="line">//        &#125;</span><br><span class="line">    //深拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Student stu = (Student)super.clone();</span><br><span class="line">            stu.setTeacher((Teacher)this.teacher.clone());</span><br><span class="line">            return stu;</span><br><span class="line"></span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher implements Cloneable&#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanUtils-copyProperties"><a href="#BeanUtils-copyProperties" class="headerlink" title="BeanUtils.copyProperties"></a>BeanUtils.copyProperties</h4><p><code>BeanUtils.copyProperties（source,target）</code>有两个参数，用于将事件源的数据拷贝到目标源中。BeanUtils有两个，一个是spring的，一个是apache的commons下的。用法一样，但是两者的区别在于：一个是将前者拷贝给后者，另一个是将后者拷贝给前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student studentOne  = new StudentOne(&quot;张三&quot;);</span><br><span class="line">Student studentTwo  = new StudentOne();  //先新建一个要拷贝出来的对象</span><br><span class="line">//BeanUtils.copyProperties是将studentOne的数据拷贝给studentTwo</span><br><span class="line">BeanUtils.copyProperties(studentOne, studentTwo);</span><br><span class="line">//spring的第一个是输入，第二个谁输出</span><br></pre></td></tr></table></figure>

<p>如果两个类不一样时，只会拷贝属性一样的内容。<br>使用场景：开发中经常遇到，把父类的属性拷贝到子类中。<br>BeanUtils是浅拷贝。浅拷贝：引用的一个内存地址)。</p>
<p>通常用于转换器Convertor，用来转换一个类的对象为另一个类的对象，重写里面的convert方法来用。</p>
<h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><h4 id="hashcode-1"><a href="#hashcode-1" class="headerlink" title="hashcode"></a>hashcode</h4><p>1、hash和hash表是什么？</p>
<blockquote>
<p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值。</p>
</blockquote>
<p>2、hashcode　</p>
<blockquote>
<p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。<br>每个对象都有hashcode，对象的hashcode怎么得来的呢？<br>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？<br>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。所以，hashcode是什么呢？就是在hash表中对应的位置。</p>
</blockquote>
<blockquote>
<p>这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p>
</blockquote>
<p>3、hashcode有什么作用</p>
<blockquote>
<p>为什么hashcode不直接写物理地址呢，还要另外用一张hash表来代表对象的地址？<br>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)<br>为什么hashcode就查找的更快，比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。<br>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果没一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，所以比较的次数会让你觉得也挺多的，实际上，如果hash表很大，那么比较的次数就很少很少了。<br>通过对原始方法和使用hashcode方法进行对比，我们就知道了hashcode的作用，并且为什么要使用hashcode了</p>
</blockquote>
<p>4、equals方法和hashcode的关系</p>
<blockquote>
<p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p>
</blockquote>
<blockquote>
<p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p>
</blockquote>
<blockquote>
<p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同<br>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
</blockquote>
<p>5、为什么equals方法重写的话，建议也一起重写hashcode方法</p>
<blockquote>
<p>比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。</p>
</blockquote>
<p>Integer的重写方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;  // 变成比较Integer内部的final int常量的值是否相等</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hashCode方法也是用的值</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Integer.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int hashCode(int value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode是用于查找使用的，而 equals是用于比较两个对象的是否相等的。hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的.</p>
<p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致.</p>
<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_44364444/article/details/120054230">https://blog.csdn.net/weixin_44364444/article/details/120054230</a></p>
<h4 id="java变量地址"><a href="#java变量地址" class="headerlink" title="java变量地址"></a>java变量地址</h4><p>java的变量不能直接获取真实的地址，只能使用<code>System.out.println(obj.hashcode())</code>输出的时对象的哈希码，而非内存地址。</p>
<p>在Java中是不可能得到对象真正的内存地址的，因为Java中堆是由JVM管理的不能直接操作。只能说此时打印出的Hash码表示了该对象在JAVA虚拟机中的内存位置，Java虚拟机会根据该hash码最终在真正的的堆空间中给该对象分配一个地址.</p>
<p>要想得到变量在物理内存中的真实地存，那只有用JNI技术调用c/c++去实现，否则无能为力，因为java超不出JVM，而JVM对物理内存地址是“不可见”的，否则java中不就有了指针，而去直接操作内存了，当然这是与java语言相违背的。</p>
<p>转自：<a href="https://blog.csdn.net/feng3702592/article/details/126722686">https://blog.csdn.net/feng3702592/article/details/126722686</a></p>
<h4 id="、equals、hashCode"><a href="#、equals、hashCode" class="headerlink" title="==、equals、hashCode"></a>==、equals、hashCode</h4><p>1、==对于普通变量是值比较，对于包装类型变量，是内存地址比较，也就是比较是不是同一个对象。</p>
<p>2、包装类型重写了equals方法，变成了值比较。</p>
<p>3、hashCode表示在hash表中的位置。equals一样，那么hashCode一定一样。（只要值是一样的，hashCode就会是相同的。）<br>原因：尽管不同的数值类型的包装类，计算hashCode的算法不一样，但是底层都是拿对应的原始数据类型的值去进行hashCode计算。<br>反过来：</p>
<p>4、同一个对象的，hashCode值一定相同，但是 hashCode相同，不一定是同一个对象，也不一定equals为true。</p>
<p>关系：同一个对象（==）最小的圈，equals为true中间圈，hashCode一样最大圈。<code>（equals要看重写了没有，不重写就是==）</code></p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-24 00:45</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> *hashCode相同，不一定是同一个对象</span><br><span class="line"> *同一个对象的，hashCode值一定相同</span><br><span class="line"> *</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *普通对象的HashCode值源码解释：</span><br><span class="line"> * equals相同则hashCode一定一样</span><br><span class="line"> *If two objects are equal according to the equals(Object) method, then calling</span><br><span class="line"> *the hashCode method on each of the two objects must produce the same integer result.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *equals不一样，hashCode不一定不一样</span><br><span class="line"> * It is not required that if two objects are unequal according to the</span><br><span class="line"> *java.lang.Object.equals(java.lang.Object) method, then calling the hashCode</span><br><span class="line"> *method on each of the two objects must produce distinct integer results.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *However, the programmer should be aware that producing distinct integer results</span><br><span class="line"> *for unequal objects may improve the performance of hash tables.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;--------------------普通对象-----------------------&quot;);</span><br><span class="line">        HashCodeTest test3=new HashCodeTest();</span><br><span class="line">        HashCodeTest test4=new HashCodeTest();</span><br><span class="line">        System.out.println(test3.equals(test4));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test3.hashCode() == test4.hashCode());//false</span><br><span class="line"></span><br><span class="line">        HashCodeTest test1=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        HashCodeTest test2=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        System.out.println(test1.equals(test2));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test1.hashCode() == test2.hashCode());//false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------String-----------------------&quot;);</span><br><span class="line">        String s1=&quot;abc&quot;;</span><br><span class="line">        String s2=&quot;abc&quot;;</span><br><span class="line">        System.out.println(s1.equals(s2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s1.hashCode() == s2.hashCode());//true</span><br><span class="line">        System.out.println(s1==s2); //true(是一个对象)</span><br><span class="line"></span><br><span class="line">        String s5=new String(&quot;abc&quot;);</span><br><span class="line">        String s6=new String(&quot;abc&quot;);</span><br><span class="line">        System.out.println(s5.equals(s6));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s5.hashCode() == s6.hashCode());//true</span><br><span class="line">        System.out.println(s5==s6); //false(不是一个对象)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String s3=new String();</span><br><span class="line">        String s4=new String();</span><br><span class="line">        System.out.println(s3.hashCode());//0</span><br><span class="line">        System.out.println(s4.hashCode());//0</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 数值型原始类型对应的包装类(Byte,Short,Integer,Float,Double)，hashCode算法都是基于</span><br><span class="line">         * 对应的原始数据类型，所以只要包装类的数值相同，那么hashCode必然相同</span><br><span class="line">         *</span><br><span class="line">         * Double类关于hashCode源码说明：</span><br><span class="line">         * Double类的hashCode是根据对应的double值计算获得的。</span><br><span class="line">         *</span><br><span class="line">         * Returns a hash code for a &#123;@code double&#125; value; compatible with</span><br><span class="line">         * &#123;@code Double.hashCode()&#125;.</span><br><span class="line">         *</span><br><span class="line">         * @param value the value to hash</span><br><span class="line">         * @return a hash code value for a &#123;@code double&#125; value.</span><br><span class="line">         * @since 1.8</span><br><span class="line">         */</span><br><span class="line">        /*Double类关于hashCode源码：</span><br><span class="line">         * public static int hashCode(double value) &#123;</span><br><span class="line">            long bits = doubleToLongBits(value);</span><br><span class="line">            return (int)(bits ^ (bits &gt;&gt;&gt; 32));</span><br><span class="line">        &#125;*/</span><br><span class="line">        System.out.println(&quot;--------------------原始类型对应的包装类-----------------------&quot;);</span><br><span class="line">        Double d1=5.0;</span><br><span class="line">        Double d2=5.0;</span><br><span class="line">        System.out.println(d1.equals(d2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d1.hashCode() == d2.hashCode());//true</span><br><span class="line">        System.out.println(d1==d2);//false (？？？为啥是false，和String不一样)</span><br><span class="line"></span><br><span class="line">        Double d3=new Double(5.0);</span><br><span class="line">        Double d4=new Double(5.0);</span><br><span class="line">        System.out.println(d3.equals(d4));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d3.hashCode() == d4.hashCode());//true</span><br><span class="line">        System.out.println(d3==d4);//false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未解：<code>Double d1=5.0; Double d2=5.0</code> 不是共用一个对象。但是<code>String s1=&quot;1&quot;; String s2=&quot;1&quot;</code>是共用。</p>
<h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><p>背景：代码中需要捕获到专门的异常进行特殊处理，主要是为了不影响主流程，该用try…catch，是在调用的时候catch，还是在调用方法里catch？<br>🤔如果是只想在这次调用时补货异常就在调用处使用，如果是想把方法包装好随意调用不发生异常就在方法里捕获。作用是：发生异常了不中断流程，只是打个error log之类的。如果不加，就是自动抛出throws异常了。</p>
<p>背景：里面方法的异常，外面方法能不能catch到？里面方法也catch了，外面方法还能不能catch到？<br>🤔里面方法没有catch异常的话，外面方法是能捕获到的，并且运行时异常不用在里面的方法上加throws，外面方法就能捕获到。编译时异常必须做：catch住处理或者throw + throws，或者直接throws出去，这样才能在外面方法捕获到。如果里面方法捕获了异常，但是没throw出去（运行时异常throw了不需要throws，编译时异常throw了还需要throws），外面方法就捕获不到这个异常。</p>
<p>背景：什么时候需要在方法上throws异常，一定要throws吗？<br>🤔运行时异常，可以不在方法上throws，虚拟机会自动捕获抛出去。编译时异常通常在编译时就要求throws出去异常，或者用try…catch进行异常处理（打log之类）。</p>
<p>背景：什么时候需要try..catch..throw..throws<br>🤔首先运行时异常可以不throws，如果没有try..catch，会自动throws出去，所以如果不是try..catch..对特殊异常捕获，没必要try..catch..throws。编译型异常如果是try..catch..打log了，就不用throws了。如果想抛出去，就直接throws就行。所以不需要try..catch..throw..throws。如果即想用try..catch..finally..还想throws出去，就用。</p>
<h4 id="✅java的异常体系"><a href="#✅java的异常体系" class="headerlink" title="✅java的异常体系"></a>✅java的异常体系</h4><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p><img src="https://img-blog.csdnimg.cn/2019101117003396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MjI5NTY3,size_16,color_FFFFFF,t_70"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1/0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常，编译时异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<hr>
<p>Error是java程序运行中不可预料的异常情况（正常情况下不大可能出现的情况），这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。【表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误 ，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形.应用程序不应该抛出这种类型的对象(一般是由虚拟机抛出).假如出现这种错误,除了尽力使程序安全退出外,在其他方面是无能为力的。】</p>
<p>Exception：<br>1．可以是可被控制(checked) 或不可控制的(unchecked)。<br>2．表示一个由程序员导致的错误。<br>3．应该在应用程序级被处理。<br>Error：<br>1．总是不可控制的(unchecked)。<br>2．经常用来用于表示系统错误或低层资源的错误。<br>3．如何可能的话，应该在系统级被捕捉。</p>
<hr>
<h4 id="✅常见的-Error-和-Exception："><a href="#✅常见的-Error-和-Exception：" class="headerlink" title="✅常见的 Error 和 Exception："></a>✅常见的 Error 和 Exception：</h4><p>1）运行时异常（RuntimeException）也称 【非检查型异常 UncheckedException】：</p>
<p>Nullpointer Exception：空指针异常；<br>ClassCastException：类型强制转换异常<br>IllegalArgumentException：传递非法参数异常<br>IndexOutOfBoundsException：下标越界异常<br>NumberFormatException：数字格式异常<br>ArrayIndexOutOfBoundsException: 数组越界异常<br>ArrayStoreException: 数据存储异常，操作数组时类型不一致<br>ArithmeticException： (算术异常)<br>BufferOverflowException： (缓冲区溢出异常)</p>
<p>2）非运行时异常（CheckedException）也称 【检查型异常】：</p>
<p>ClassNotFoundException：找不到指定 class 的异常<br>IOException：IO 操作异常<br>FileNotFoundException：文件不存在异常<br>SQLException：SQL语句异常<br>InterruptedException： (中断异常-调用线程睡眠时候)</p>
<p>3）错误（Error）：</p>
<p>NoClassDefFoundError：找不到 class 定义异常<br>StackOverflowError：深递归导致栈被耗尽而抛出的异常<br>OutOfMemoryError：内存溢出异常</p>
<h4 id="✅遇到的异常记录"><a href="#✅遇到的异常记录" class="headerlink" title="✅遇到的异常记录"></a>✅遇到的异常记录</h4><h4 id="ExecutionException"><a href="#ExecutionException" class="headerlink" title="ExecutionException"></a>ExecutionException</h4><p>future.get()抛出的，ExecutionException包装正在执行的线程抛出的任何异常。没明白，应该是个检查型异常。是必须要程序员处理的。</p>
<p><a href="https://www.orcode.com/question/618888_kb0916.html">https://www.orcode.com/question/618888_kb0916.html</a><br><a href="https://www.mianshigee.com/question/91669mas/">https://www.mianshigee.com/question/91669mas/</a></p>
<h4 id="InterruptException"><a href="#InterruptException" class="headerlink" title="InterruptException"></a>InterruptException</h4><p>future.get()会抛出，Thread.sleep也会抛出。<br>当线程正在等待、休眠或以其他方式被占用，并且线程在活动之前或活动期间被中断时抛出。 有时，方法可能希望测试当前线程是否被中断，如果是，则立即抛出此异常。<br>活动线程的执行中断行为，可以抛出这样的异常。<br><a href="https://blog.csdn.net/kevinmeanscool/article/details/123566970">https://blog.csdn.net/kevinmeanscool/article/details/123566970</a></p>
<h4 id="java-lang-NoClassDefFoundError"><a href="#java-lang-NoClassDefFoundError" class="headerlink" title="java.lang.NoClassDefFoundError"></a>java.lang.NoClassDefFoundError</h4><p>NoClassDefFoundError可能出现的情况<br>目前有发现几种情况<br>1.一种情况就是因为静态变量加载不到原因<br>2.工程里没有将jar添加到classpath，maven项目的，需要根据项目情况排查</p>
<p>实际原因：在报错的test类所在的包里，没有引某个包，导致找不到某类。<br>首先用：<code>mvn dependency:tree</code>，查看依赖jar的关系，看一下这个类的包是哪个，引用了没。<br>发现在父pom里有这个包，但是在报错的包里没有用父pom，也没引那个包。<br>所以，在报错的包的pom里，引用那个包就解决。</p>
<h4 id="NoUniqueBeanDefinitionException"><a href="#NoUniqueBeanDefinitionException" class="headerlink" title="NoUniqueBeanDefinitionException"></a>NoUniqueBeanDefinitionException</h4><p>不唯一的bean定义异常<br>没有一个合适的bean类型（cn.cy.bean.Tool）可用，预期有一个单独的匹配的bean，但是找到了多个。</p>
<p>看看是不是一个接口有多个实现类，然后在某类中注入该接口中没有指定注入哪个。</p>
<blockquote>
<p>通常如果一个接口多个实现类，会根据条件Enum选择哪个类执行的话，加一个ServiceFacade类来根据条件选择，这个类实现Service接口和InitializingBean接口，里面定义一个map&lt;Enum, 接口Service&gt;，在使用到实现类的方法中，注入ServiceFacade就行。</p>
</blockquote>
<p>解决方法：<br>1、注入接口的地方 <code>@Autowired + @Qualifer(&quot;whichImpl&quot;)</code><br>2、注入接口的地方 <code>@Resource(name=&quot;whichImpl&quot;)</code></p>
<p>参考：<a href="https://blog.csdn.net/weixin_46030002/article/details/125661107">https://blog.csdn.net/weixin_46030002/article/details/125661107</a></p>
<h4 id="BeanCreationException"><a href="#BeanCreationException" class="headerlink" title="BeanCreationException"></a>BeanCreationException</h4><p>Bean创建过程中抛出异常。具体有以下几种常见异常，包括上面的NoUniqueBeanDefinitionException 也是一种。</p>
<p>1.org.springframework.beans.factory.NoSuchBeanDefinitionException</p>
<p>上下文中不存在此Bean，一般原因在没有声明Bean，BeanA尝试注入BeanB，但是spring上下文中不存在BeanB。检查是否用@Component @Service @Controller @Repository 注入了bean。</p>
<p>2.org.springframework.beans.factory.NoUniqueBeanDefinitionException</p>
<p>当一个Bean有多个实现，例如BeanB1 和BeanB2都实现了同一个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BeanB1 implements IBeanB &#123; ... &#125;</span><br><span class="line">@Component</span><br><span class="line">public class BeanB2 implements IBeanB &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">@Component</span><br><span class="line">public class BeanA &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private IBeanB dependency;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.org.springframework.beans.BeanInstantiationException</p>
<p>Bean 实例化过程中出现异常，具体原因需要查看nested exception后面报错</p>
<p>3.1 Custom Exception<br>业务自定义抛出异常，如下抛出空指针异常</p>
<p>3.2 java.lang.InstantiationException<br>在xml配置中使用抽象类定义bean</p>
<p>3.3 java.lang.NoSuchMethodException<br>如果一个bean类没有默认的构造方法，spring在创建bean实例时.</p>
<p>4.org.springframework.beans.factory.CannotLoadBeanClassException</p>
<p>当spring加载不到bean对应的类文件时，这种异常将会被抛出。这种情况很有可能发生在当配置文件中的类路径全称找不到对应文件时。</p>
<p>更多：<a href="https://blog.csdn.net/m0_37578675/article/details/117075030">https://blog.csdn.net/m0_37578675/article/details/117075030</a></p>
<hr>
<h4 id="✅NoClassDefFoundError-和-ClassNotFoundException-的区别："><a href="#✅NoClassDefFoundError-和-ClassNotFoundException-的区别：" class="headerlink" title="✅NoClassDefFoundError 和 ClassNotFoundException 的区别："></a>✅NoClassDefFoundError 和 ClassNotFoundException 的区别：</h4><p>区别一：<br>NoClassDefFoundError它是Error，<br>ClassNotFoundException是Exception。</p>
<p>区别二：<br>NoClassDefFoundError是JVM运行时通过classpath加载类时，找不到对应的类而抛出的错误。<br>ClassNotFoundException是编译时异常，在编译过程中必须将ClassNotFoundException异常抛出！</p>
<p>NoClassDefFoundError发生场景如下：<br>1、类依赖的class或者jar不存在 （简单说就是maven生成运行包后被篡改）<br>2、类文件存在，但是存在不同的域中 （简单说就是引入的类不在对应的包下)<br>3、大小写问题，javac编译的时候是无视大小的，很有可能你编译出来的class文件就与想要的不一样！这个没有做验证？？？</p>
<p>ClassNotFoundException发生场景如下：<br>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>举例说明如下:<br>Class.forName(“abc”); 比如abc这个类不存项目中，代码编写时，就会提示此异常是检查性异常，比如将此异常抛出。</p>
<hr>
<h4 id="✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别："><a href="#✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别：" class="headerlink" title="✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别："></a>✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别：</h4><p>1:checked （检查型异常）也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。编译器要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，<br>另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try …catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法名的后边，eg:  方法名（） throws  IOExecption。</p>
<p>理解：检查型异常，要么：try… catch.. 打log，要么：try..catch..throw..throws（多此一举，没必要），要么只是throws。</p>
<p>2:runtime exception（运行时异常），编译器不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try …catch）,会直接throws出去，如果不想throws出去，就try catch 打log。<br>如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。  当出现这样的异常时，总是由虚拟机接管。</p>
<p>原文：<a href="https://www.cnblogs.com/liangbaolong/p/12884224.html">https://www.cnblogs.com/liangbaolong/p/12884224.html</a></p>
<hr>
<h4 id="✅多异常捕获："><a href="#✅多异常捕获：" class="headerlink" title="✅多异常捕获："></a>✅多异常捕获：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; catch(NullPointerException | IOException e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| 符合 可以 写多个，符合其中之一。<br>注意要把异常范围小的放在前面，范围大的放在后面。<br>⚠️注意在try内return或者break了，finally也会执行的。</p>
<h4 id="catch-Exeception-e-和catch-Throwable-e"><a href="#catch-Exeception-e-和catch-Throwable-e" class="headerlink" title="catch(Exeception e)和catch(Throwable e)"></a>catch(Exeception e)和catch(Throwable e)</h4><p>Throwable可以捕获Error和Exception两大类的异常，其中Error是比较严重不可控的异常。而Exception是可以被编程处理的异常。<br>Exception只能捕获RuntimeException和IOException。</p>
<p>回顾一下java的异常体系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Throwable: Java中所有异常和错误类的父类。只有这个类的实例（或者子类的实例）可以被虚拟机抛出或者被java的throw关键字抛出。同样，只有其或其子类可以出现在catch子句里面。</span><br><span class="line">Error: Throwable的子类，表示严重的问题发生了，而且这种错误是不可恢复的。</span><br><span class="line">Exception: Throwable的子类，应用程序应该要捕获其或其子类（RuntimeException例外），称为checked exception。比如：IOException, NoSuchMethodException...</span><br><span class="line">RuntimeException: Exception的子类，运行时异常，程序可以不捕获，称为unchecked exception。比如：NullPointException.</span><br></pre></td></tr></table></figure>

<p>❓应该catch (Throwable th) 还是 catch (Exception)?</p>
<p>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。第一种catch相当于比第二种catch多捕捉了把Error和其子类。</p>
<p>❓Error是否需要捕捉?</p>
<p>JDK中Error类的的注释里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)”来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。</p>
<p>❓Error可以catch吗？ 可以catch了后做些其他处理吗？</p>
<p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p>
<p>假设进行网络连接操作的时候，IOException 发生了，可能是网络中断，我可以再尝试几次。</p>
<p>假设OutOfMemoryError发生了，就算被捕捉了，可以有什么手段让程序正常运行下去吗？ 假设ExceptionInInitializerError发生了，类无法被正常初始化，这个是可以通过捕捉来恢复的吗？</p>
<p>👌结论：Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用</p>
<p>转自：如何处理异常? catch Exception OR catch Throwable<br><a href="https://www.cnblogs.com/smile361/p/5521278.html">https://www.cnblogs.com/smile361/p/5521278.html</a></p>
<p>举一个用<code>catch (Throwable e)</code>的例子：<br>目的是确保异常被打印，一个无线递归，导致的StackOverflowError</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Throwable_demo &#123;</span><br><span class="line">    static void generate_throwable() &#123;</span><br><span class="line">        generate_throwable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //此种情形下我们要catch Throwable, 以确保异常被打印...</span><br><span class="line">        try &#123;</span><br><span class="line">            final int[] times = &#123; 0 &#125;;</span><br><span class="line">            Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        ++times[0];</span><br><span class="line">                        System.out.println(times[0]);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(10);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread1.start();</span><br><span class="line">            generate_throwable();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            //若catch的是Exception：</span><br><span class="line">            //因finally中的exit指令，在打印异常前程序就会终止。</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;end.&quot;);</span><br><span class="line">            //如果不exit: 因 thread1 未停止，程序不会终止。</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅项目中的自定义异常"><a href="#✅项目中的自定义异常" class="headerlink" title="✅项目中的自定义异常"></a>✅项目中的自定义异常</h4><p>继承RuntimeException扩展一个新的异常作为整个类库的异常基类。<br>里面定义异常编码啥的。</p>
<p>如果需要根据异常进行不同的处理，建议给自定义异常增加一个ERROR_CODE字段，这样无论在服务器还是客户端都可以根据不同的ERROR_CODE进行对应的处理。但是出现这种情况的时候，应该需要考虑一下设计思路了，一般来讲根据异常来决定业务流程不是一个好的设计方案。</p>
<h3 id="ArrayList线程安全问题"><a href="#ArrayList线程安全问题" class="headerlink" title="ArrayList线程安全问题"></a>ArrayList线程安全问题</h3><p>ArrayList 是线程不安全的集合类，当多线程环境下，并发对同一个ArrayList执行add，可能会丢数据。如果多线程又是add，又是输出list，会发生并发错误。</p>
<p>⚠️为什么说可能呢，因为有时候add得太快，就没出问题。</p>
<blockquote>
<p>ConcurrentModificationException: 并发修改异常<br>    使用迭代器循环，在循环中用ArrayList的add/remove方法会出现该异常。原因及解决方法：<a href="https://blog.csdn.net/u013168615/article/details/116570591">https://blog.csdn.net/u013168615/article/details/116570591</a></p>
</blockquote>
<hr>
<p>多线程对List进行add又遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 1; i &lt;= 30; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(0, 8));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread.sleep(60 * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常：Exception in thread “Thread-0” java.util.ConcurrentModificationException</p>
<h4 id="✅ArrayList为什么线程不安全"><a href="#✅ArrayList为什么线程不安全" class="headerlink" title="✅ArrayList为什么线程不安全"></a>✅ArrayList为什么线程不安全</h4><p>多线程对ArrayList进行add有可能会造成数据丢失。也有可能会造成数组越界。</p>
<blockquote>
<p>线程安全：指当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染等意外情况。</p>
<p>线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染等意外情况。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line"> implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 列表元素集合数组如果新建ArrayList对象时没有指定大小，那么会将 </span><br><span class="line">    * EMPTY_ELEMENTDATA赋值给elementData，</span><br><span class="line">    * 并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY </span><br><span class="line">    */</span><br><span class="line">    transient Object[] elementData; </span><br><span class="line">    // 列表大小，elementData中存储的元素个数</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的实现主要就是：<br>1️⃣用了一个 Object 的数组，用来保存所有的元素；<br>2️⃣一个 size 变量用来保存当前数组中已经添加了多少元素。</p>
<p>ensureCapacityInternal() 的作用就是如果将当前的新元素加到列表后面，判断列表的 elementData 数组的大小是否满足。如果 size + 1 的这个需求长度大于 elementData 这个数组的长度，那么就要对这个数组进行扩容。由此看到 add 元素时，实际有两个大的步骤：<br>1️⃣判断 elementData 数组 capacity 容量是否满足需求，是否需要扩容。<br>2️⃣在 elementData 对应位置上设置值。<br><code>这样就出现了第一个导致线程不安全的隐患，在多个线程进行 add 操作时可能会导致 elementData 数组越界。</code></p>
<hr>
<p>为什么会数组越界ArrayIndexOutOfBoundsException？</p>
<p>ArrayList 默认数组大小为 10。假设现在已经添加进去 9 个元素了，size = 9。</p>
<p>1、线程 A 执行完 add 方法中的 ensureCapacityInternal(size+1) 挂起了。<br>2、线程 B 开始执行，校验数组容量发现不需要扩容。于是把 “b” 放在了下标为 9 的位置，且 size 自增 1。此时 size = 10。<br>3、线程 A 接着执行，尝试把 “a” 放在下标为 10 的位置，因为 size = 10。但因为数组还没有扩容，最大的下标才为 9，所以会抛出数组越界异常ArrayIndexOutOfBoundsException。</p>
<hr>
<p>为什么会数据丢失？</p>
<p>ArrayList线程不安全，当一条线程执行list.add()的时候会出现被另一条线程的值覆盖，比如线程A对list进行add，携带的size是n，同时线程B也进行add操作，携带的size也是n，所以ArrayList没有达到扩容的条件，A的值应该放在ArrayList的第n位，但是B的值也将放在第n位，覆盖了A的值，导致数据丢失。</p>
<p>源码：<br>第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这里可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：<br>elementData[size] = e;<br>size = size + 1;</p>
<p>ArrayList 为什么线程不安全：<br><a href="https://blog.csdn.net/ChineseSoftware/article/details/117047757">https://blog.csdn.net/ChineseSoftware/article/details/117047757</a></p>
<hr>
<p>ArrayList的所有方法都没有加Lock，也没有加synchronized，因此在并发操作下，扩容函数grow()会存在问题。</p>
<p>举个简单的例子：<br>elementData数组刚刚添加了最后一个元素，也就是刚好满员了<br>这时2个线程同时又调用了add，那么就必须要执行grow进行扩容<br>第1个线程调用完grow()，然后也调用了elementData[size++] = e，把新元素添加上去<br>第2个线程又调用一次grow()，整个elementData数组就乱掉了。</p>
<h4 id="✅多线程情况下该用什么："><a href="#✅多线程情况下该用什么：" class="headerlink" title="✅多线程情况下该用什么："></a>✅多线程情况下该用什么：</h4><p>1、使用 Vector 初始化 list 对象，效率低<br><code>List&lt;String&gt; list = new Vector&lt;&gt;();</code><br>Vector.add使用了synchronized加锁<br>转换成ArrayList：<br><code>List&lt;String&gt; newList = new ArrayList&lt;String&gt;(vector);</code></p>
<p>2、使用 Collections.synchronizedList<br><code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code><br><code>List&lt;String&gt; list = Collections.synchronizedList(Lists.newArrayList());</code><br>add方法同样加了 synchronized 锁。</p>
<p>3、使用 CopyOnWriteArrayList<br><code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></p>
<p>写时复制，即向一个容器添加元素的时候，不直接向当前容器添加，而是将当前容器进行复制，然后向新容器进行添加操作，最后将原容器的引用指向新的容器。</p>
<p>这样的好处是允许并发的读而不需要加锁（因为容器内元素未发生变化），提升效率，仅写时上锁，读和写再不同的容器中，体现了读写分离的思想 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原文：<a href="https://www.cnblogs.com/fhblikesky/p/13692641.html">https://www.cnblogs.com/fhblikesky/p/13692641.html</a></p>
<h4 id="✅list的ConcurrentModificationException问题"><a href="#✅list的ConcurrentModificationException问题" class="headerlink" title="✅list的ConcurrentModificationException问题"></a>✅list的ConcurrentModificationException问题</h4><p>除了多线程修改ArrayList的操作会造成该问题之外，在迭代器中用list.add或list.remove去添加删除list元素，也会造成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iterator it = myList.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Iterator it = myList.iterator(); it.hasNext();) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (String value : myList) &#123;</span><br><span class="line">    System. out.println( &quot;List Value:&quot; + value);</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>原因看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出</li>
<li>lastRet：表示上一个访问的元素的索引</li>
<li>expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。</li>
<li>modCount: 是在 ArrayList 中赋值的，并且初始值为 0，在 add 和 remove 的时候（修改元素的时候）会增加 1.</li>
</ul>
<p>hasNext方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasNext 方法，在方法中的 size 是 ArrayList 中的变量，这个 ConcurrentModificationException 异常存在的原因之一就在这个方法体现出来了，在多线程的情况下，如果使用迭代器遍历时，ArrayList数组元素变少导致 cursor &gt; size，然后数组越界。在正常情况下当 cursor == size代表已经到数组尽头了.</p>
<p>next 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    int i = cursor;</span><br><span class="line">    if (i &gt;= size)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">    if (i &gt;= elementData.length)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    cursor = i + 1;</span><br><span class="line">    return (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next 方法中先是判断了 modCount 是否等于 expectedModCount，不相等则抛出 并发修改异常，否则取到游标，然后判断游标是否大于数组长度或者元素个数。最后游标加一，然后返回数的同时使 lastRet 等于 i。</p>
<p>remove方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList.this.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 remove 掉元素的时候更新下自己的 expectedModCount。注意的是remove后 lastRet 会变成 -1，也就是不能连续 remove 两次，因为在 next 中检查了 lastRet 的值不能小于 0。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">if (modCount != expectedModCount)</span><br><span class="line">throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当modCount != expectedModCount时，执行next()就会抛出ConcurrentModificationException<br>而什么时候会造成modCount != expectedModCount呢？<br>ArrayList.add()和remove()方法，每执行一次都会modCount++，但不改变expectedModCount的值。expectedModCount的值是在构建迭代的时候初始为expectedModCount=modCount的。<br>在构建迭代器之后，再使用ArrayList.add()方法就造成了modCount != expectedModCount<br>构建迭代器后，用迭代器来add和remove就没有问题。因为它会在改变modCount的值之后，又把值赋给了expectedModCount，从而保证modCount=expectedModCount</p>
<hr>
<p>解决方法：用迭代器的remove方法<br>多线程情况下，iterator是线程私有，也即是说expectedModCount是每个线程私有。使用Vector也不行。<br>所以：<br>在使用iterator迭代的时候使用synchronized或者Lock进行同步。不推荐，因为增删造成的同步锁可能会阻塞遍历操作。<br>使用并发容器CopyOnWriteArrayList或者ConcurrentHashMap代替ArrayList和Vector。CopyOnWriteArrayList不能使用Iterator.remove()进行删</p>
<p>ConcurrentModificationException异常原因和解决方法：<br><a href="https://blog.csdn.net/qq_44613591/article/details/114108920">https://blog.csdn.net/qq_44613591/article/details/114108920</a></p>
<p>Java 遍历List ConcurrentModificationException 异常解析：<br><a href="https://blog.csdn.net/qq_30051139/article/details/54019515">https://blog.csdn.net/qq_30051139/article/details/54019515</a></p>
<h4 id="总结多线程下ArrayList的几个问题"><a href="#总结多线程下ArrayList的几个问题" class="headerlink" title="总结多线程下ArrayList的几个问题"></a>总结多线程下ArrayList的几个问题</h4><p>1.多线程add可能会丢数据，也可能数组越界，但不会并发错误<br>2.多线程add又打印ArrayList，会并发错误，应为System.out方法里用了迭代器。<br>3.用迭代器遍历中又用ArrayList的add和remove方法，会并发错误。</p>
<p>实验：对partition后的某个subList进行add的话，会牵一发而动全身，因为每个subList是多大已经规定好，对前面的subList进行add，add的元素会跑到下一个subList，以此类推。原来的list也会改变。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList进行add，会并发错误。<br>🤔为什么单纯ArrayList多线程add不会并发错误，这里就会。<br>这里使用的是AbstractList的add方法，其中用到ArrayList的size方法会检查modCount。但是ArrayList的add方法用的是ArrayList的add方法。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList只是打印，在主线程里再add，会并发错误。原因：打印List也会用到迭代器。<br>如果是在线程里循环遍历打印单个元素，不会有错误。并且会实时反映增加的元素。</p>
<h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h3><p>1、泛型与Object的区别</p>
<p>方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object doSomething(Object obj) &#123;....&#125;</span><br><span class="line">​</span><br><span class="line">public &lt;T&gt; T doSomething(T t) &#123;....&#125;</span><br></pre></td></tr></table></figure>

<p>无论是T还是 obj，你都只能调用Object类型的参数和返回值。</p>
<p>但是，如果是使用了泛型的类，和普通的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass&lt;Foo&gt; my = new MyClass&lt;Foo&gt;();</span><br><span class="line">Foo foo = new Foo();</span><br><span class="line"></span><br><span class="line">泛型：</span><br><span class="line">Foo newFoo = my.doSomething(foo);</span><br><span class="line"></span><br><span class="line">Object:</span><br><span class="line">Foo newFoo = (Foo) my.doSomething(foo);</span><br></pre></td></tr></table></figure>

<p>因此，使用泛型的好处：</p>
<p>1.不需要做强制类型转换</p>
<p>2.编译时更安全。如果使用Object类的话，你没法保证返回的类型一定是Foo，也许是其它类型。这时你就会在运行时得到一个类型转换异常（ClassCastException）</p>
<p>转自：<a href="https://blog.csdn.net/SDDDDDSA/article/details/120733398">https://blog.csdn.net/SDDDDDSA/article/details/120733398</a></p>
<p>2、泛型<code>&lt;T&gt; T</code> 与 T 的区别</p>
<p>方法返回前的<code>&lt;T&gt; </code>是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.jt.test;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @Description</span><br><span class="line"> * 有的方法返回值为 &lt;T&gt; T ，有的方法返回值为 T ,区别在那里 ？</span><br><span class="line"> **/</span><br><span class="line">public class Request&lt;E&gt; &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public &lt;T&gt; T getObject(Class&lt;T&gt; tClass) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        T t = tClass.newInstance();</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 方法返回前的 &lt;T&gt; 是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，</span><br><span class="line">     * 也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同</span><br><span class="line">     *</span><br><span class="line">     * 参数 T</span><br><span class="line">     *  第一个 表示是泛型</span><br><span class="line">     *  第二个 表示是返回是T类型的数据</span><br><span class="line">     *  第三个 表示限制参数类型为T</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private &lt;T&gt; T getListFirst(List&lt;T&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 这个只能传T类型的数据</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private E getListFirst2(List&lt;E&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; data2 = new ArrayList&lt;&gt;();</span><br><span class="line">        // 入参由List&lt;T&gt;的T 决定，因为返回值为&lt;T&gt; T ,所以入参不受 Request&lt;T&gt; 影响</span><br><span class="line">        Integer a = new Request&lt;String&gt;().getListFirst(data);</span><br><span class="line"> </span><br><span class="line">        // 编译出错，入参由Request&lt;T&gt; T的决定，受Request&lt;T&gt;影响</span><br><span class="line">        //new Request&lt;String&gt;().getListFirst2(data);</span><br><span class="line"> </span><br><span class="line">        // 没什么区别</span><br><span class="line">        String aa = new Request&lt;String&gt;().getListFirst(data2);</span><br><span class="line">        String bb = new Request&lt;String&gt;().getListFirst2(data2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="https://blog.csdn.net/qianzhitu/article/details/107962657">https://blog.csdn.net/qianzhitu/article/details/107962657</a></p>
<p>3、泛型通配符</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>常用的 T，E，K，V，？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<p>？表示不确定的 java 类型<br>T (type) 表示具体的一个java类型<br>K V (key value) 分别代表java键值中的Key Value<br>E (element) 代表Element</p>
<p>更多：<a href="https://blog.csdn.net/minkeyto/article/details/116205607">https://blog.csdn.net/minkeyto/article/details/116205607</a></p>
<p>学长教学妹java泛型：<a href="https://blog.csdn.net/m0_67401499/article/details/125401501">https://blog.csdn.net/m0_67401499/article/details/125401501</a></p>
<h3 id="java可变参数"><a href="#java可变参数" class="headerlink" title="java可变参数"></a>java可变参数</h3><p>java可变参数是指在调用方法时传入不定长度的参数，本质上是基于数组实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">//在定义方法时，在最后一个形参上加&quot;…&quot;就表示该形参可以接受多个参数值，多个参数值被当做数组传入。</span><br><span class="line">public static void element(Integer... args)&#123; &#125;</span><br><span class="line">//参数为数组</span><br><span class="line">public static void element(Integer[] args)&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">public static void element(Integer... args) &#123;</span><br><span class="line">    for (int arg : args) &#123;</span><br><span class="line">        System.out.print(arg + &quot;  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //都可以</span><br><span class="line">    element(1,2,3);</span><br><span class="line">    int[] array=&#123;1,2,3&#125;;</span><br><span class="line">    element(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️可变参数只能做为函数的最后一个参数，前面有没有其他参数都可以，一个函数最多只能有一个可变参数。</p>
<p>可变参数在编译为字节码后，在方法签名中是以数组形态出现的，如果两个方法签名编译后的是一致的话，是不能编译通过的，不可以作为方法的重载。</p>
<p>可变参数作为参数的方法可以传入数组类型的数据或者直接传入多个数据，但是数组作为参数的方法只能传入数组类型的数据。</p>
<p>反射时，可变参数的注意事项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void element(Integer... args)&#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arrry=&#123;1,2,3&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //反射是运行时获取的，在运行时看来，可变参数和数组上是一致的。因而方法的签名为([java/lang/Integer;)V</span><br><span class="line">            //Method对象的方法声明为Object invoke (Object obj,Object.. args)</span><br><span class="line">            //args虽然是一个可变长度的参数，但是args的长度受限于该方法对象代表的真实方法的参数列表长度,</span><br><span class="line">            //从运行时签名来看，([java/lang/Integer;)V实际上是一个形参，即Integer[] args,因此invoke (Object obj,Object.. args)中可变参数args的实际参数长度只能为1。</span><br><span class="line">            Method method = Demo5.class.getMethod(&quot;element&quot;, Integer[].class);</span><br><span class="line">            //array的长度为3，不符合</span><br><span class="line">            method.invoke(null,arrry);</span><br><span class="line">            //将Integer[]转为Object[]，长度还是为3，不符合</span><br><span class="line">            method.invoke(null,(Object[])arrry);</span><br><span class="line">            //将整个Integer[]转为一个Object，长度为1，符合</span><br><span class="line">            method.invoke(null,(Object)arrry);</span><br><span class="line">            //Object[]的长度为1，符合，和上面相同</span><br><span class="line">            method.invoke(null,new Object[]&#123;arrry&#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/weixin_43413307/article/details/125485292">https://blog.csdn.net/weixin_43413307/article/details/125485292</a></p>
<h3 id="类中的布尔类型get方法注意"><a href="#类中的布尔类型get方法注意" class="headerlink" title="类中的布尔类型get方法注意"></a>类中的布尔类型get方法注意</h3><p>@Getter自动生成getter方法，但是：<br>1.Boolean类型,生成的get方法是get开头的(建议使用这个).<br>2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).</p>
<p>用到布尔值的属性时,最好统一使用大写的包装类Boolean.<br>如果用小写的booean基本类型,最好重写get方法,保证是getXxxx的格式即可.<br>*如果这个对象涉及到反射,反射一般会默认调取对象的get方法,对于这个is的情况,是走不通的.</p>
<h3 id="java的native方法"><a href="#java的native方法" class="headerlink" title="java的native方法"></a>java的native方法</h3><p>什么是native方法？<br>一个Native Method是一个java调用非java代码的接口。Native Method的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<p>使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p>
<p>例如：<br>Thread.sleep(1000); 还有 Thread.start0() 都是native方法。<br>在JDK 源码 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法</p>
<p>native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。<br>java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.native方法是java与其他语言协作的时候使用的，底层实现不是java(c,c++)</span><br><span class="line">2.native并不是java实现的，所以直接调用就好，不需要管他底层实现</span><br><span class="line">3.native方法实际上是java用于调用底层操作系统的方法,java只能调用，不能查看和修改</span><br><span class="line">4.java是跨平台语言，自然而然会失去对底层的控制，于是想要调用底层方法，就必须使用native方法间接调用底层操作系统的方法(c,c++实现)</span><br><span class="line">5.随着java的不断发展，native方法越来越少</span><br><span class="line">6.native是一个关键字，其修饰的方法只说明不实现</span><br><span class="line">7.native方法加载到 本地栈中</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/TheWayForDream/article/details/122202601</span><br></pre></td></tr></table></figure>

<p>JNI：Java Native Interface：<a href="https://www.zhihu.com/question/28001771/answer/2049534464">https://www.zhihu.com/question/28001771/answer/2049534464</a><br>native用法：<a href="https://www.jb51.net/article/195760.html">https://www.jb51.net/article/195760.html</a></p>
<h3 id="printStackTrace-方法"><a href="#printStackTrace-方法" class="headerlink" title="printStackTrace()方法"></a>printStackTrace()方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">… &#125; catch(Exception e) &#123;</span><br><span class="line">e.printStackTrace() ; &#125;</span><br></pre></td></tr></table></figure>

<p>try语句中出现异常时，系统会自动将catch括号中的Exception e 初始化。</p>
<p>printStackTrace()：在命令行打印异常信息在程序中出错的位置及原因。<br>System.out.println(e)：打印异常</p>
<p>不建议使用printStackTrace()的原因：<br>e.printStackTrace() 语句要产生的字符串记录的是堆栈信息，太长太多，内存会被填满。</p>
<p>短时间内大量请求访问此接口 -&gt; 代码本身有问题，很多情况下抛异常  -&gt; e.printStackTrace() 来打印异常到控制台 -&gt; 产生错误堆栈字符串到字符串池内存空间 -&gt; 此内存空间一下子被占满了 -&gt; 开始在此内存空间产出字符串的线程未完成，就没空间了 -&gt;  大量线程产出字符串产出到一半，等在这儿（等有内存了继续搞）-&gt; 相互等待，等内存，锁死了，整个应用挂掉了。</p>
<p>为什么不建议printStackTrace：<a href="https://blog.csdn.net/kzadmxz/article/details/89914896">https://blog.csdn.net/kzadmxz/article/details/89914896</a></p>
<p>建议：logger.error(“***”,  e);</p>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><p>✅1.使用Math方法</p>
<p>java本身的，不需要导入包，Math.random()随机生成一个double类型[0，1)，如果想生成1~100的随机数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = (int)(Math.random()*100)+1;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println((int)0.01); //0</span><br></pre></td></tr></table></figure>

<p>✅2.使用Random方法生成随机数</p>
<p>Random类是java.until下的一个根据随机算法的起源数字进行一些变化，从而得到随机数字的方法。</p>
<p>随机算法的起源数字被成为种子数（seed）。</p>
<p>虽然Random类产生的数字是随机的，但在相同种子数（seed）下的相同次数产生的随机数是相同的（伪随机）。</p>
<p>Random中共有两种构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、public Random（）</span><br><span class="line">此构造方法是以系统自身的时间为种子数来构造Random对象。</span><br><span class="line"></span><br><span class="line">2、public Random（long seed）</span><br><span class="line">此构造方法可以自己来选定具体的种子来构造Random对象。</span><br></pre></td></tr></table></figure>

<p>常用方法：都可以加参数表示范围，范围是左闭右开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">random.nextInt()	返回值为整数,范围是int类型范围</span><br><span class="line">random.nextLong()	返回值为长整型，范围是long类型的范围</span><br><span class="line">random.nextFloat()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextDouble()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextBoolean（）	返回值为boolean值，true和false概率相同</span><br><span class="line">radom.nextGaussian()	返回值为呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random r = new Random();//以系统自身时间为种子数</span><br><span class="line">int i = r.nextInt();</span><br><span class="line">System.out.println(&quot;i&quot;+i);</span><br><span class="line">Scanner sc  =new Scanner(System.in);</span><br><span class="line">int j = sc.nextInt();</span><br><span class="line">Random r2 = new Random(j);//自定义种子数</span><br><span class="line">Random r3 = new Random(j);//这里是为了验证上方的注意事项：Random类是伪随机，相同种子数相同次数产生的随机数相同</span><br><span class="line">int num  = r2.nextInt(1000);</span><br><span class="line">int num2 = r3.nextInt(1000);</span><br><span class="line">System.out.println(&quot;num&quot;+num);</span><br><span class="line">System.out.println(&quot;num2&quot;+num2);</span><br></pre></td></tr></table></figure>

<p>✅3.使用SecureRandom生成随机数</p>
<p>java.util.Random的实例不是加密安全的，要是知道setSeed值(即时间戳)，很明显能把随机数给猜出来。所以不建议使用Random。SecureRandom来获取加密安全的伪随机数生成器，以供对安全敏感的应用程序使用。</p>
<p>在安全应用场景，随机数应该使用安全的随机数。密码学意义上的安全随机数，要求必须保证其不可预测性。</p>
<p>密码学安全的伪随机数产生器：JDK的java.security.SecureRandom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SecureRandom random = new SecureRandom();</span><br><span class="line">String returnValue = &quot;&quot;;</span><br><span class="line">int randomInt = 0;</span><br><span class="line">int range = 9;</span><br><span class="line">for(int i=0; i&lt;5; i++ )&#123;</span><br><span class="line">    randomInt = random.nextInt(range+1);</span><br><span class="line">    returnValue = returnValue + randomInt;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">secureRandom.setSeed(System.currentTimeMillis()); //使用系统时间作为种子</span><br><span class="line">如果同一毫秒连续调用，则得到的随机数则是相同的。</span><br><span class="line">不要自己指定种子。应当使用系统随机源。采用无参构造方法实例化</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSecureRandom() throws NoSuchAlgorithmException &#123;</span><br><span class="line">    //指定算法名称</span><br><span class="line">    SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0 ; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-------------------&quot;);</span><br><span class="line">    secureRandom = new SecureRandom();</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getInstance方法"><a href="#getInstance方法" class="headerlink" title="getInstance方法"></a>getInstance方法</h3><p>两个使用场景：</p>
<p>✅1.抽象类</p>
<p>抽象类是无法直接new出来的，所以想要通过实例化的话只能通过getInstance()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GetInstanceTest &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Person p = Person.getInstance(&quot;Limbo&quot;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public Person(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public void eat();</span><br><span class="line">    public static  PersonImpl getInstance(String title) &#123;</span><br><span class="line">        return new PersonImpl(title);</span><br><span class="line">    &#125;</span><br><span class="line">    //必须static：</span><br><span class="line">    static class PersonImpl extends Person</span><br><span class="line">    &#123;</span><br><span class="line">        public PersonImpl(String title) &#123;</span><br><span class="line">            super(title);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void eat()</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Eat!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅2.单例设计模式</p>
<p>一般在单例模式下使用.getInstance()创建对象.<br>单例模式：一个类有且只有一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingleTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Singleton s = Singleton.getInstance();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    private String content;</span><br><span class="line">    //在自己内部定义自己的一个实例</span><br><span class="line">    private static Singleton SINGLETON = null;</span><br><span class="line">    //private 只能在自己内部供自己去访问</span><br><span class="line">    private Singleton(String title, String content) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    //此静态方法供外部直接访问</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (SINGLETON == null)</span><br><span class="line">            SINGLETON = new Singleton(&quot;Kobe&quot;, &quot;MVP&quot;);</span><br><span class="line">        return SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.title + &quot; - &quot; + this.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getInsance()t:在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。</p>
<p>(1)对象使用之前通过getinstance得到，而不需要自己定义，用完之后不需要delete；</p>
<p>(2)new 一定要生成一个新对象，分配内存；getInstance() 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于new；</p>
<p>(3) new创建后只能当次使用，而getInstance()可以跨栈区域使用，或者远程跨区域使用。所以getInstance()通常是static静态实例方法。</p>
<p>摘自：<a href="https://www.cnblogs.com/baxianhua/p/9341953.html">https://www.cnblogs.com/baxianhua/p/9341953.html</a></p>
<h3 id="lang3下的Pair"><a href="#lang3下的Pair" class="headerlink" title="lang3下的Pair"></a>lang3下的Pair</h3><p>org.apache.commons.lang3.tuple.Pair</p>
<p>Pair 用于存储左右元素对，Pair&lt;Left, Right&gt;。主要有两个子类，ImmutablePair 和 MutablePair。</p>
<p>Pair 实现了 java.util.Map.Entry，因此 left 和 right 也可以视作 key-value。不同于Map，Pair只能存一组键值对。</p>
<p>of 方法 以 static 调用的形式创建一个 Pair 实例. 默认创建的是 ImmutablePair。left, right值final 修饰， 值第一次被设置后不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; pair = Pair.of(1, &quot;1&quot;);</span><br><span class="line">System.out.println(pair.getLeft());</span><br><span class="line">System.out.println(pair.getKey());</span><br><span class="line">System.out.println(pair.getRight());</span><br><span class="line">System.out.println(pair.getValue());</span><br><span class="line">pair.setValue(&quot;2&quot;); //java.lang.UnsupportedOperationException</span><br></pre></td></tr></table></figure>

<p>org.apache.commons.lang3.tuple.MutablePair<br>继承了 Pair，left 和 right 值可变。</p>
<p>Pair与Map：<br>1.共通点: Pair 和 Map 都是以 key, value 进行存储。<br>2.不同点:<br>Pair 通过 getKey(), getValue() 获取 key 和 value，没有增加键值对的操作。<br>Map 是通过 get(key) 获取 key 对应的 value，通过 values() 获取所有的value，而且还可以通过 put 增加键值对。<br>Pair 保存的是一对 key-value，而 Map 可以保存多对 key-value。</p>
<p>⚠️Pair的一个使用场景：VO中用到的小数据结构，不想再构造一个pojo了，有两组键值对的数据，比如Point，只有x和y。就可以用<code>List&lt;Pair&lt;String, Double&gt;&gt;</code> 表示。<br>⚠️但是Pair不能被json解析。</p>
<h3 id="几种排序算法"><a href="#几种排序算法" class="headerlink" title="几种排序算法"></a>几种排序算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-交换排序</span><br><span class="line"> -冒泡排序</span><br><span class="line"> -快速排序</span><br><span class="line">-插入排序</span><br><span class="line"> -直接插入排序</span><br><span class="line"> -希尔排序</span><br><span class="line">-选择排序</span><br><span class="line"> -简单选择排序</span><br><span class="line"> -堆排序</span><br><span class="line">-归并排序</span><br><span class="line">-基数排序</span><br></pre></td></tr></table></figure>

<h4 id="✅冒泡排序"><a href="#✅冒泡排序" class="headerlink" title="✅冒泡排序"></a>✅冒泡排序</h4><p>1.从第一个元素开始，比较相邻的两个元素。如果第一个比第二个大，则进行交换,此时最后的元素应是最大的数。<br>2.对剩余元素重复以上步骤，直到没有任何一对元素需要比较为止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void bubbleSortOpt(int[] arr) &#123;</span><br><span class="line">    if(arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序优化：<br>假如待排序数组是 2、1、3、4、5 这样的情况，按照上述代码实现，第一次循环即可得出正确结果。但循环并不会停止，而是继续执行，直到结束为止。显然，之后的循环遍历是没有必要的。</p>
<p>为了解决这个问题，我们可以设置一个标志位，用来表示当前次循环是否有交换，如果没有，则说明当前数组已经完全排序，直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int bubbleSortOpt2(int[] arr) &#123;</span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序再优化：<br>比如 3、4、2、1、6、7、8 这个数组，第一次循环后，变为 3、2、1、4、6、7、8 的顺序，我们发现，1 之后的 4 、6、7、8 已经有序了，第二次循环就没必要对后面这段再遍历比较。<br>记录最后发生交换的地点，就是我们要找的分界点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int bubbleSortOpt3(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int len = arr.length - 1;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 记录最后一次交换位置</span><br><span class="line">        int lastChange = 0;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                // 每交换一次更新一次</span><br><span class="line">                lastChange = j;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (lastChange == 0) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        len = lastChange;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅快速排序"><a href="#✅快速排序" class="headerlink" title="✅快速排序"></a>✅快速排序</h4><p>快速排序的思想很简单，先找一个基准数，先把待排序的数组根据基准数拆成左右两个区间，左边都比中间的基准数小，右边都比基准数大。接着左右两边各自再做同样的操作，完成后再拆分再继续，一直到各区间只有一个数为止。<br>算法的实现需要用到递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line"></span><br><span class="line">    if(start &lt; end) &#123;</span><br><span class="line">        // 把数组中的首位数字作为基准数</span><br><span class="line">        int pivot = arr[start];</span><br><span class="line">        // 记录需要排序的下标</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end;</span><br><span class="line">        // 循环找到比基准数大的数和比基准数小的数</span><br><span class="line">        while(low &lt; high) &#123;</span><br><span class="line">            // 右边的数字比基准数大</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用右边的数替换左边的数</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            // 左边的数字比基准数小</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用左边的数替换右边的数</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把标准值赋给下标重合的位置</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        // 处理所有小的数字</span><br><span class="line">        quickSort(arr, start, low);</span><br><span class="line">        // 处理所有大的数字</span><br><span class="line">        quickSort(arr, low + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Java 实现的八种常用排序算法:<br><a href="https://blog.csdn.net/CSDN_handsome/article/details/109055036">https://blog.csdn.net/CSDN_handsome/article/details/109055036</a></p>
<p>想实现一个根据对象某属性首尾相接的排序，用Comparator自定义排序没行得通，所以：先弄一个end的Set，然后便利start，找到第一个对象，然后造一个start-对象的Map，然后用end找对象，一个一个找到。</p>
<h3 id="java链式编程"><a href="#java链式编程" class="headerlink" title="java链式编程"></a>java链式编程</h3><p>链式编程的原理是返回一个this对象，也就是返回对象本身，从而达到链式效果。</p>
<p>链式编程，中间操作的返回值都是自己，每个操作的输出是体现在自己对象的改变中的，类似于<code>Stream&lt;T&gt;</code></p>
<p>链式编程的案例：</p>
<p>1、StringBuilder 和 StringBuffer中的append()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder buffer = new StringBuilder();</span><br><span class="line">buffer.append(&quot;你&quot;).append(&quot;好&quot;).append(&quot;!&quot;);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、String 进行字符串操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String string = String.valueOf(&quot;123&quot;).concat(&quot;,4567890&quot;).replace(&#x27;,&#x27;, &#x27;!&#x27;).substring(2, 8);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">返回的是对象本身，所以可以使用链式编程</span><br><span class="line">public static String valueOf(Object obj) &#123;</span><br><span class="line">    return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">     // 省略...</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、 Stream 流式计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    // 相同元素去重</span><br><span class="line">    .distinct()</span><br><span class="line">    // 升序排序</span><br><span class="line">    .sorted((c1, c2) -&gt; c1.compareTo(c2))</span><br><span class="line">    // 遍历</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">方法返回的是对象本身，所以可以使用链式编程</span><br><span class="line">Stream&lt;T&gt; distinct();</span><br><span class="line">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span><br></pre></td></tr></table></figure>

<p>自己做一个链式编程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.setAge(10).setName(&quot;11&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Integer age;</span><br><span class="line"></span><br><span class="line">        public Person setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Person setAge(Integer age) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="java数组、字符串、list的最大长度"><a href="#java数组、字符串、list的最大长度" class="headerlink" title="java数组、字符串、list的最大长度"></a>java数组、字符串、list的最大长度</h3><p>✅数组的最大长度：<br>数组的length属性是int类型，占4个字节，最大值为Integer.MAX_VALUE= 2^31-1【21亿多】<br>注意：这是理论上的最大长度，堆内存不一定能开辟那么大的存储空间来存储该数组。</p>
<p>✅字符串的最大长度：<br>运行时：<br>String、StringBuilder、StringBuffer底层都是基于字符数组char[ ]的，该数组的最大长度也为Integer.MAX_VALUE，所以一个字符串最大21亿多个字符【每个字符在java8中占1个字节】，即占2^32-2个字节，即差2个字节达到4GB。<br>2^10字节=1KB，2^20=1MB，2^30=1GB</p>
<p>编译时：<br>java源码通过javac编译后生成的字节码文件中，静态常量池中字符串常量的长度最多为65535，因为JVM为了解决历史上的一个BUG，所以强制要求编译时字符串的最大长度为65534。</p>
<p>✅ArrayList和LinkedList的最大长度<br>ArrayList底层是数组，最大值为Integer.MAX_VALUE= 231-1【21亿多】<br>LinkedList底层是链表，理论是无上限长度。</p>
<h3 id="Java元组Tuple"><a href="#Java元组Tuple" class="headerlink" title="Java元组Tuple"></a>Java元组Tuple</h3><p>Java中的Tuple是一种数据结构，可存放多个元素，每个元素的数据类型可不同。Tuple与List集合类似，但是不同的是，List集合只能存储一种数据类型，而Tuple可存储多种数据类型。<br>可能你会说，Object类型的List实际也是可以存储多种类型的啊？但是在创建List的时候，需要指定元素数据类型，也就是只能指定为Object类型，获取的元素类型就是Object，如有需要则要进行强转。而Tuple在创建的时候，则可以直接指定多个元素数据类型。</p>
<p>元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。关系数据库中的 一条记录就是一个元组， 一个表就是一个关系， 纪录组成表， 元组生成关系， 这就是关系数据库的核心理念。</p>
<p>元组的使用就是通过泛型定义一个类，然后去保存多个类型属性。所以可以认为元组完全是基于泛型的。返回的所有类型属性外包一层对象然后返回这个对象，其实就是作为元组的实现定义。</p>
<p>元组不同于List，List存储相同的数据类型，虽然也可以存储不同的数据类型，那就不符合泛型了。</p>
<p>元组不同于数组，数组种存储的相同的数据类型。</p>
<p>元组不同于map，map类型是键值对存在的，而元组中的值，值之间没有关系。</p>
<p>元组的值可以是不同数据类型，值与值之间没有关系。</p>
<p>理解：元祖相当于定义一个VO，里面有不同的属性类型，可以包装不同类型。和list区别是，十元祖就可以放10个不同类型的数据。元祖的优点其实还是可以防止代码的冗余，不用写更多的方法，可以通过一个返回多个我想要的类型属性。上面的Pair就是实现这么一个功能，也是元祖。</p>
<hr>
<p>依赖Jar包：javatuples</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javatuples&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javatuples&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>jar包中的结构很简单，其中的类主要是tuple基础类、扩展的一元组、二元组…十元组，以及键值对元组；接口的作用是提供【获取创建各元组时传入参数值】的方法。</p>
<p>其中三元祖的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.javatuples;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">import org.javatuples.valueintf.IValue0;</span><br><span class="line">import org.javatuples.valueintf.IValue1;</span><br><span class="line">import org.javatuples.valueintf.IValue2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A tuple of three elements.</span><br><span class="line"> * &lt;/p&gt; </span><br><span class="line"> * </span><br><span class="line"> * @since 1.0</span><br><span class="line"> * </span><br><span class="line"> * @author Daniel Fern&amp;aacute;ndez</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public final class Triplet&lt;A,B,C&gt; </span><br><span class="line">        extends Tuple</span><br><span class="line">        implements IValue0&lt;A&gt;,</span><br><span class="line">                    IValue1&lt;B&gt;,</span><br><span class="line">                    IValue2&lt;C&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -1877265551599483740L;</span><br><span class="line"></span><br><span class="line">    private static final int SIZE = 3;</span><br><span class="line"></span><br><span class="line">    private final A val0;</span><br><span class="line">    private final B val1;</span><br><span class="line">    private final C val2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;A,B,C&gt; Triplet&lt;A,B,C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return new Triplet&lt;A,B,C&gt;(value0,value1,value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般调用静态方法with，传入元组数据，创建一个元组。可以自定义一个工具类，提供公共方法，根据传入的参数个数，返回不同的元组对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.study;</span><br><span class="line"></span><br><span class="line">import com.liuxuan.repository.domain.Student;</span><br><span class="line">import org.javatuples.Pair;</span><br><span class="line">import org.javatuples.Triplet;</span><br><span class="line">import org.javatuples.Unit;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-02-06 22:32</span><br><span class="line"> **/</span><br><span class="line">public class TupleUtils&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 单元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A&gt; Unit&lt;A&gt; with(final A value0) &#123;</span><br><span class="line">        return Unit.with(value0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 双元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B&gt; Pair&lt;A, B&gt; with(final A value0, final B value1) &#123;</span><br><span class="line">        return Pair.with(value0, value1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 三元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B, C&gt; Triplet&lt;A, B, C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return Triplet.with(value0, value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Triplet&lt;Integer, String, String&gt;&gt; roleList = new ArrayList&lt;Triplet&lt;Integer, String, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        Triplet&lt;Integer, String, String&gt; studentTriplet = TupleUtils.with(11, &quot;sid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; teacherTriplet = TupleUtils.with(22, &quot;tid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; programmerTriplet = TupleUtils.with(33, &quot;id&quot;, &quot;graduate&quot;);</span><br><span class="line"></span><br><span class="line">        roleList.add(studentTriplet);</span><br><span class="line">        roleList.add(teacherTriplet);</span><br><span class="line">        roleList.add(programmerTriplet);</span><br><span class="line"></span><br><span class="line">        for (Triplet&lt;Integer, String, String&gt; triplet : roleList) &#123;</span><br><span class="line">            System.out.println(triplet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TupleUtils中提供了with的重载方法，调用时根据传入的参数值个数，返回对应的元组对象。</p>
<p>参考：<a href="https://blog.csdn.net/qq_35006663/article/details/100301416">https://blog.csdn.net/qq_35006663/article/details/100301416</a></p>
<hr>
<p>org.apache.commons.lang3.tuple 中的元祖</p>
<p>用于处理一对键值的对象pair类似于Map.entry，commons lang3增加了可以处理3个值的Triple基类，此包下定义了<code>Pair&lt;L,R&gt;</code>抽象基类，及MutablePair,MutableTriple,ImmutablePair,ImmutableTriple子类。一个线程非安全，另一个线程安全。</p>
<p>接口：<br>1.<code>Pair</code>：封装一对键值对。<br>实现类：可变：<code>MutablePair&lt;L,R&gt;</code>，不可变：<code>ImmutablePair</code><br>2.<code>Triple</code>：封装3个值的类<br>实现类：<code>ImmutableTriple</code>; <code>MuttableTriple&lt;L,M,R&gt;</code></p>
<h3 id="Preconditions-checkArgument校验字段"><a href="#Preconditions-checkArgument校验字段" class="headerlink" title="Preconditions.checkArgument校验字段"></a>Preconditions.checkArgument校验字段</h3><p>guava中的静态方法，用来确认参数是不是符合要求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;31.0.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String param = &quot;&quot;;</span><br><span class="line">//旧式写法</span><br><span class="line">if (StringUtils.isEmpty(param)) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;param字段不能为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//新式写法：期望这个字段不能为空</span><br><span class="line">Preconditions.checkArgument(StringUtils.isNotEmpty(param), &quot;param字段不能为空&quot;);</span><br></pre></td></tr></table></figure>

<p>新式的校验是：要求我们对某个字段的要求是什么，当逻辑未命中要求时，则抛出异常。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>drainTo()方法：<br>ArrayBlockingQueue是有界的阻塞队列，该队列内部使用数组支持的元素存储。<br>drainTo()方法用于将所有元素传输到集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int capacity = 10;</span><br><span class="line">ArrayBlockingQueue queue = new ArrayBlockingQueue(capacity);</span><br><span class="line">queue.add(11);</span><br><span class="line">queue.add(22);</span><br><span class="line">queue.add(33);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[11, 22, 33]</span><br><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">queue.drainTo(list);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[]</span><br><span class="line">System.out.println(&quot;collection = &quot; + list); //[11, 22, 33]</span><br></pre></td></tr></table></figure>

<h3 id="java获取本地ip"><a href="#java获取本地ip" class="headerlink" title="java获取本地ip"></a>java获取本地ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String localIP = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">System.out.println(localIP);</span><br></pre></td></tr></table></figure>

<h3 id="guava中的ImmutableList"><a href="#guava中的ImmutableList" class="headerlink" title="guava中的ImmutableList"></a>guava中的ImmutableList</h3><p>ImmutableList是一个不可变、线程安全的列表集合，它只会获取传入对象的一个副本，而不会影响到原来的变量或者对象。</p>
<p>ImmutableList创建不可变对象有两种方法，一种是使用静态of方法，另外一种是使用静态内部类Builder。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态内部类构建方法 :</span><br><span class="line">ImmutableList&lt;Integer&gt; list = ImmutableList .&lt;Integer&gt;builder()</span><br><span class="line">                        .add(12)</span><br><span class="line">                        .add(23)</span><br><span class="line">                        .add(34)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">静态方法提供了多个参数的of静态方法:</span><br><span class="line">ImmutableList&lt;String&gt; list3 = ImmutableList .&lt;String&gt;of(&quot;12&quot;,&quot;23&quot;);</span><br><span class="line"></span><br><span class="line">复制数组中的元素到ImmutableList中:</span><br><span class="line"> List&lt;String&gt; list4 = new ArrayList&lt;String&gt;();</span><br><span class="line">list4.add(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;);</span><br><span class="line">list4.add(&quot;3&quot;);</span><br><span class="line">//copy数组list4的一个副本</span><br><span class="line">List&lt;String&gt; list5 = ImmutableList .&lt;String&gt;copyOf(list4);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程池Executor、ExecutorService、Executors三者关系"><a href="#线程池Executor、ExecutorService、Executors三者关系" class="headerlink" title="线程池Executor、ExecutorService、Executors三者关系"></a>线程池Executor、ExecutorService、Executors三者关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6f13f22d0f1e6bc6930273b38666f8cc.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f207168124eedfd3438e9f714a53fa30.png"></p>
<p>层次关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;&#125;</span><br><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;&#125;</span><br><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125;</span><br><span class="line">public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1.ExecutorService 接口继承了Executor 接口，是Executor 的子接口。</p>
<p>2.Executor接口中定义了execute()方法，用来接收一个Runnable接口的对象，而ExecutorService接口中定义的submit()方法可以接收Runnable和Callable接口对象。</p>
<p>3.Executor接口中execute()方法不返回任何结果，而ExecutorService接口中submit()方法可以通过一个 Future 对象返回运算结果。</p>
<p>4.Executor和ExecutorService除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。<br>比如：调用 shutDown() 方法终止线程池。</p>
<p>5.Executors 是一个工具类，类似于 Collections。Executors 类提供工厂方法用来创建不同类型的线程池。比如:<br>　　 Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池，<br>　　 Executors.newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，<br>　　 Executors.newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>　　 Executors.newScheduledThreadPool(int corePoolSize) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>转自：<a href="https://www.cnblogs.com/whx20100101/p/9862392.html">https://www.cnblogs.com/whx20100101/p/9862392.html</a></p>
<p>使用Executors还是ExecutorService？<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：<br>AbortPolicy: 直接抛异常<br>CallerRunsPolicy: 用调用者的线程来运行任务<br>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>DiscardPolicy 直接将新任务丢弃</p>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p>
<p>参考：<a href="https://blog.csdn.net/weixin_43921491/article/details/115717604">https://blog.csdn.net/weixin_43921491/article/details/115717604</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(...);</span><br><span class="line">executor.submit(()-&gt;单条语句);</span><br><span class="line"></span><br><span class="line">executor.submit(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="线程池java-util-concurrent-ThreadPoolExecutor"><a href="#线程池java-util-concurrent-ThreadPoolExecutor" class="headerlink" title="线程池java.util.concurrent.ThreadPoolExecutor"></a>线程池java.util.concurrent.ThreadPoolExecutor</h3><p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, </span><br><span class="line">int maximumPoolSize, </span><br><span class="line">long keepAliveTime, </span><br><span class="line">TimeUnit unit, </span><br><span class="line">BlockingQueue workQueue,  </span><br><span class="line">RejectedExecutionHandler handler) </span><br><span class="line"></span><br><span class="line">corePoolSize： 线程池维护线程的最少数量 </span><br><span class="line">maximumPoolSize：线程池维护线程的最大数量 </span><br><span class="line">keepAliveTime： 线程池维护线程所允许的空闲时间 </span><br><span class="line">unit： 线程池维护线程所允许的空闲时间的单位 </span><br><span class="line">workQueue： 线程池所使用的缓冲队列 </span><br><span class="line">handler： 线程池对拒绝任务的处理策略 </span><br><span class="line"></span><br><span class="line">unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性： </span><br><span class="line">NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。 </span><br><span class="line"></span><br><span class="line">workQueue可用的队列类是：java.util.concurrent.ArrayBlockingQueue </span><br><span class="line"></span><br><span class="line">handler有四个选择： </span><br><span class="line">（1）ThreadPoolExecutor.AbortPolicy()   抛出java.util.concurrent.RejectedExecutionException异常 </span><br><span class="line">（2）ThreadPoolExecutor.CallerRunsPolicy()  重试添加当前的任务，他会自动重复调用execute()方法 </span><br><span class="line">（3）ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务 （等待队列里面最早进入的）</span><br><span class="line">（4）ThreadPoolExecutor.DiscardPolicy()     抛弃当前的任务 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个任务（ Runnable类型的对象）通过execute(Runnable)方法欲添加到线程池时：<br>1、如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br>2、如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br>3、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量小于maximumPoolSize，建新的线程来处理被添加的任务。<br>4、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 </p>
<p>也就是：处理任务的优先级为：<br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </p>
<p>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 </p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws InterruptedException &#123;</span><br><span class="line">    ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 3, TimeUnit.SECONDS,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(3), new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    class ThreadPoolTask implements Runnable, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 0;</span><br><span class="line">        // 保存任务所需要的数据</span><br><span class="line">        private Object threadPoolTaskData;</span><br><span class="line"></span><br><span class="line">        ThreadPoolTask(Object tasks) &#123;</span><br><span class="line">            this.threadPoolTaskData = tasks;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + getTask());</span><br><span class="line">            try &#123;</span><br><span class="line">                // //便于观察，等待一段时间</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            threadPoolTaskData = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getTask() &#123;</span><br><span class="line">            return this.threadPoolTaskData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 产生一个任务，并将其加入到线程池</span><br><span class="line">            String task = &quot;task@ &quot; + i;</span><br><span class="line">            System.out.println(&quot;put &quot; + task);</span><br><span class="line">            threadPool.submit(new ThreadPoolTask(task));</span><br><span class="line">            // 便于观察，等待一段时间</span><br><span class="line">            Thread.sleep(2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">    // 也可以直接用lambda表达式往线程池里加线程</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + &quot;lambda&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">put task@ 1</span><br><span class="line">pool-1-thread-1start ..task@ 1</span><br><span class="line">put task@ 2</span><br><span class="line">pool-1-thread-2start ..task@ 2</span><br><span class="line">put task@ 3</span><br><span class="line">put task@ 4</span><br><span class="line">put task@ 5</span><br><span class="line">put task@ 6</span><br><span class="line">pool-1-thread-3start ..task@ 6</span><br><span class="line">put task@ 7</span><br><span class="line">pool-1-thread-4start ..task@ 7</span><br><span class="line">put task@ 8</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util....</span><br><span class="line">pool-1-thread-1start ..task@ 3</span><br><span class="line">pool-1-thread-2start ..task@ 4</span><br><span class="line">pool-1-thread-3start ..task@ 5</span><br><span class="line"></span><br><span class="line">因为线程加入线程池很快，线程都还没处理完，所以最开始先2个线程，</span><br><span class="line">然后3个加入队列，然后再来2个，扩大线程池，再一个就抛出异常了，</span><br><span class="line">慢慢队列中的三个会被执行。</span><br><span class="line"></span><br><span class="line">如果是DiscardOldestPolicy策略，就把最早进入队列的怼出去。</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/abcwywht/article/details/54744152">https://blog.csdn.net/abcwywht/article/details/54744152</a></p>
<p>✅规范创建线程池<br>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。目的是规避资源耗尽的风险。FixedThreadPool和SingleThreadPool允许请求队列长度Integer.MAX_VALUE，可能堆积大量请求，OOM。CachedThreadPool允许创建线程数量Integer.MAX_VALUE，可能创建大量线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;Runnable&gt;(6),</span><br><span class="line">                new ThreadFactory() &#123;</span><br><span class="line">                    AtomicInteger id = new AtomicInteger(0);</span><br><span class="line">                    @Override</span><br><span class="line">                    public Thread newThread(Runnable r) &#123;</span><br><span class="line">                        return new Thread(r, &quot;thread-poolName-&quot; + id.incrementAndGet());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        threadPool.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //可以直接用lambda表达式：</span><br><span class="line">        threadPool.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面没加线程池到最大和队列满了该怎么办的参数，可以加。</p>
<h3 id="ThreadPoolExecutor的execute方法和submit方法"><a href="#ThreadPoolExecutor的execute方法和submit方法" class="headerlink" title="ThreadPoolExecutor的execute方法和submit方法"></a>ThreadPoolExecutor的execute方法和submit方法</h3><p>1、execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</p>
<p>2、execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕/取消等操作。</p>
<p>3、submit会对Runnable或Callable入参封装成RunnableFuture对象（同时继承了Runnable接口和Future接口），调用execute方法并返回。FutureTask是实现了RunnableFuture接口</p>
<p>4、通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。（FutureTask则是将catch到的异常存下来，在get的时候再去判断任务执行状态，如果任务状态是异常，则再抛出ExecutionException异常。）</p>
<p>参考：<a href="https://blog.csdn.net/happyyear1/article/details/122378013">https://blog.csdn.net/happyyear1/article/details/122378013</a><br><a href="https://blog.csdn.net/Mr_Zhang____/article/details/121866974">https://blog.csdn.net/Mr_Zhang____/article/details/121866974</a></p>
<h3 id="ThreadPoolExecutor的submit返回值Future"><a href="#ThreadPoolExecutor的submit返回值Future" class="headerlink" title="ThreadPoolExecutor的submit返回值Future"></a>ThreadPoolExecutor的submit返回值Future</h3><p>✅Executor接口中的execute方法：<br>这个方法是没有返回值的，而且只接受Runnable。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ExecutorService接口中的submit方法：<br>这个方法接收两种参数，Callable和Runnable。返回值是Future。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>✅Callable接口和Runnable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">  V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Runnable &#123;</span><br><span class="line">  public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1、Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值<br>2、Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。</p>
<p>✅Future接口<br>通过他可以获得任务执行的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean var1);</span><br><span class="line"> </span><br><span class="line">    boolean isCancelled();</span><br><span class="line"> </span><br><span class="line">    boolean isDone();</span><br><span class="line"> </span><br><span class="line">    V get() throws InterruptedException, ExecutionException;  //获取返回值</span><br><span class="line"> </span><br><span class="line">    V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅submit(Callable task)实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(2);</span><br><span class="line">        //创建一个Callable，3秒后返回String类型</span><br><span class="line">        Callable myCallable = new Callable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">                return &quot;call方法返回值&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">        Future future = executor.submit(myCallable);</span><br><span class="line">        System.out.println(&quot;提交任务之后，获取结果之前 &quot;+getStringDate());</span><br><span class="line">        System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">        System.out.println(&quot;获取到结果之后 &quot;+getStringDate());</span><br><span class="line">    &#125;</span><br><span class="line">    public static String getStringDate() &#123;</span><br><span class="line">        Date currentTime = new Date();</span><br><span class="line">        SimpleDateFormat formatter = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line">        String dateString = formatter.format(currentTime);</span><br><span class="line">        return dateString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">提交任务之前 09:09:28</span><br><span class="line">提交任务之后，获取结果之前 09:09:29</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取到结果之后 09:09:32</span><br></pre></td></tr></table></figure>

<p>✅get()方法的阻塞性</p>
<p>通过上面的输出可以看到，在调用submit提交任务之后，主线程本来是继续运行了。但是运行到future.get()的时候就阻塞住了，一直等到任务执行完毕，拿到了返回的返回值，主线程才会继续运行。</p>
<p>这里注意一下，他的阻塞性是因为调用get()方法时，任务还没有执行完，所以会一直等到任务完成，形成了阻塞。</p>
<p>任务是在调用submit方法时就开始执行了，如果在调用get()方法时，任务已经执行完毕，那么就不会造成阻塞。</p>
<p>submit多个任务时，总阻塞时间是最长的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Callable myCallable = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">        return &quot;call方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Callable myCallable2 = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;calld2方法执行了&quot;);</span><br><span class="line">        return &quot;call2方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">Future future = executor.submit(myCallable);</span><br><span class="line">Future future2 = executor.submit(myCallable2);</span><br><span class="line">System.out.println(&quot;提交任务之后 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;开始获取第一个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">System.out.println(&quot;获取第一个返回值结束，开始获取第二个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值2: &quot;+future2.get());</span><br><span class="line">System.out.println(&quot;获取第二个返回值结束 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">提交任务之前 14:14:47</span><br><span class="line">提交任务之后 14:14:48</span><br><span class="line">开始获取第一个返回值 14:14:48</span><br><span class="line">calld2方法执行了</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取第一个返回值结束，开始获取第二个返回值 14:14:53</span><br><span class="line">获取返回值2: call2方法返回值</span><br><span class="line">获取第二个返回值结束 14:14:53</span><br></pre></td></tr></table></figure>

<p>✅submit(Runnable task, T result)实现</p>
<p>虽然submit传入Runnable不能直接返回内容，但是可以通过submit(Runnable task, T result)传入一个载体，通过这个载体获取返回值。这个其实不能算返回值了，是交给线程处理一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(2); //不推荐这样创建</span><br><span class="line">    Result res = new Result();</span><br><span class="line">    Future&lt;Result&gt; future = executor.submit(new MyThread(res), res);</span><br><span class="line">    System.out.println(&quot;返回的结果  name: &quot; + future.get().getName()); //新名字</span><br><span class="line">    System.out.println(&quot;原来的Data  name: &quot; + res.getName()); //原来的也变成了新名字</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyThread implements Runnable &#123;</span><br><span class="line">    private Result result;</span><br><span class="line">    public MyThread(Result result) &#123;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.println(&quot;线程  执行:&quot;);</span><br><span class="line">            result.setName(&quot;新名字&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public static class Result &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️T是Runnable里面的属性，创建时传入，线程中赋值，get方法拿到，之前传入的变量也跟着变化。</p>
<p>✅get(long var1, TimeUnit var3)<br>前面都是用的get()方法获取返回值，那么因为这个方法是阻塞的，有时需要等很久。所以有时候需要设置超时时间。</p>
<p>get(long var1, TimeUnit var3)这个方法就是设置等待时间的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future future1 = executor.submit(myCallable);</span><br><span class="line">System.out.println(&quot;开始拿结果 &quot;+getStringDate());</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;返回的结果是： &quot;+future1.get(3, TimeUnit.SECONDS)+ &quot; &quot;+getStringDate());</span><br><span class="line">&#125; catch (TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(&quot;超时了 &quot;+getStringDate());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;结束拿结果 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">过了三秒就抛出超时异常了，主线程继续运行，不会再继续阻塞。</span><br></pre></td></tr></table></figure>


<p>✅execute与submit的异常处理</p>
<p>使用submit方法还有一个特点就是，他的异常可以在主线程中catch到。<br>而使用execute方法执行任务是捕捉不到异常的。<br>用下面这个Runnable来说,这个 里面一定会抛出一个异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runnable myRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.execute(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用execute：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            executor.execute(myRunnable);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不会输出抓到异常那行日志，输出是在线程pool-1-thread-1中，并不是在主线程中。说明主线程的catch不能捕捉到这个异常。异常在线程中直接抛出。</p>
<p>使用submit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">           Future future1= executor.submit(myCallable);</span><br><span class="line">            future1.get();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以抓到异常。得有get方法。</p>
<p>转自：<a href="https://blog.csdn.net/zdx1515888659/article/details/109537577">https://blog.csdn.net/zdx1515888659/article/details/109537577</a></p>
<p>✅项目中的线程池中异常捕获<br>项目中想将线程池中线程的异常在外面捕获到，传递给前端。<br>所以用submit方法，返回Future&lt;?&gt;，在submit方法后直接get，future.get()，有两个异常需要处理：ExecutionException、InterruptException，直接方法上throws出去。调用这个方法的方法要不也throws（给前端透出异常），要不就try..catch..打log（这样无法给前端透出异常）。<br>⚠️注意：用get方法相当于是阻塞了，本来起线程，把要执行的动作交给线程池里的线程(submit)，然后不需要管线程执行完就直接退出干别的了，加了get的话，就要等线程执行完了。如果是大量任务一次交给线程池(线程池里的队列)，需要考虑get带来的阻塞性是否能接受。本来想异步，加了get捕获异常之后，变成同步的了。</p>
<p>🤔线程池中的线程出现异常，get方法这里会报异常，如果是throws，异常抛出到外面，线程池里的其他线程不受影响。外面的方法如果没有catch会中断。</p>
<p>🤔那么问题来了，get超时了的话，线程池中的线程还在继续做吗？<br>首先，countDownLatch超时了是继续做的。<br>future.get(2,TimeUnit.SECOND);<br>如果超时了，线程中断，会报异常TimeOutExcepTion，看是不是要捕获了。<br>即使捕获了，线程也不会继续执行了。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>场景：做多线程并行优化，多线程写入一个文件，首先输入流是可以共享的，只是需要重新定义一个做传递（不管是普通变量还是引用变量），但是for循环里面线程submit完，直接走到主线程上传文件的部分，这时线程池内线程还没往文件里写东西，上传了一个空文件。</p>
<p>想要：做一个同步，知道线程都执行完了，才进行下一步，起到阻塞的作用。</p>
<p>CountDownLatch可以做到，当做一个计数器，计算多少个线程执行完了：</p>
<p>让一些线程阻塞直到另外一些完成后才被唤醒。<br>CountDownLatch主要有两个方法：<br>（1）当一个或多个线程调用await方法时,线程会被阻塞，直到满足条件.<br>（2）其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/li1325169021/article/details/122353217">https://blog.csdn.net/li1325169021/article/details/122353217</a></p>
<p>实例：模拟公司所有员工都下班后，值班人员锁门离开公司。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void closeDoor() throws InterruptedException &#123;</span><br><span class="line">        //创建CountDownLatch,初始容量为10，模拟10名员工</span><br><span class="line">        CountDownLatch countDownLatch=new CountDownLatch(10);</span><br><span class="line">        for (int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;忙完工作，下班。&quot;);</span><br><span class="line">                //计数器减1</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,&quot;员工编号：&quot;+String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t值班人员锁门离开公司&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三步：</p>
<p>1、线程池外定义初始计数：<br>CountDownLatch countDownLatch=new CountDownLatch(10);<br>2、线程池内executorService.submit()的线程new Runnable(){@Overide public void run() {}} run方法内，线程执行完毕后：<br>countDownLatch.countDown();<br>3、最后要进行操作前：<br>countDownLatch.await();</p>
<p>✅countDownLatch超时终止：<br><code>latch.await(10, TimeUnit.SECONDS);  //等待10秒后，如果线程没有执行完，则不再等待，进入后续</code></p>
<p>超时后，线程依然会执行，不会中断。</p>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>1、public interface ScheduledExecutorService extends ExecutorService 延迟或定期执行任务。 </p>
<p>2、schedule 方法使用各种延迟创建任务，并返回一个可用于取消或检查执行的任务对象</p>
<p>3、scheduleAtFixedRate 和 scheduleWithFixedDelay 方法创建并执行某些在取消前一直定期运行的任务</p>
<p>4、所有的 schedule 方法都接受相对延迟和周期作为参数，而不是绝对的时间或日期</p>
<p>5、SheduleExecutorService 是JDK 1.5出来的，比以前的 Timer 性能好</p>
<p>Timer用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    TimerTask task = new TimerTask() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Task performed on: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;later: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer timer = new Timer(&quot;Timer&quot;);</span><br><span class="line"></span><br><span class="line">    long delay = 100L;</span><br><span class="line">    // 第一个参数是TimeTask对象，第二个参数是延迟（只有第二个参数时执行一次），第三个参数是周期执行的周期</span><br><span class="line">    timer.schedule(task, delay, 4000);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timer中，如果任务执行时间&gt;周期，则会等待上一个任务执行完，立马执行第二个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test5() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; run : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果任务执行时间&gt;周期，则会等上一个执行完立马执行下一个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test6() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; go : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与scheduleAtFixedRate：不同的是：这个是等上一个执行完，delay多长时间后，再执行下一个。</p>
<p>✅ScheduledExecutorService对象的创建方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(3);</span><br><span class="line">创建一个线程池，它可安排在给定延迟后运行任务或者定期地执行任务。</span><br><span class="line">corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内。</span><br><span class="line">运行发现有多个线程执行，但是效果一样。</span><br><span class="line"></span><br><span class="line">可以传参ThreadFactory，用来命名和设置守护线程</span><br><span class="line">ScheduledExecutorService executorService2 = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">    Thread t = new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    t.setDaemon(true); //设置为守护线程</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行任务。</span><br><span class="line">可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </span><br><span class="line">同样这是一个无界的任务队列，即虽然线程只有一个，但是新增的任务会在队列中排队等待执行</span><br><span class="line"></span><br><span class="line">3、用ScheduledExecutorService 的实现类 ScheduledThreadPoolExecutor（推荐）</span><br><span class="line">ScheduledExecutorService executorService1 = new ScheduledThreadPoolExecutor(1);</span><br></pre></td></tr></table></figure>

<p>✅规范创建：<br>要使用带有ThreadFactory参数的ScheduledThreadPoolExecutor构造方法创建，这样可以方便设置线程名字。方便出措时回溯。并且提供自定义的ThreadFactory实现或三方实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService3 = new ScheduledThreadPoolExecutor(1, new ThreadFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService executorService4 = new ScheduledThreadPoolExecutor(1,</span><br><span class="line">    new BasicThreadFactory.Builder().namingPattern(&quot;myThread&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure>


<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>用来创建线程的，其中也只是有一个newthread方法。</p>
<p>作用：<br>给线程命名，查看创建线程数<br>给线程设置是否是后台运行<br>设置线程优先级</p>
<p>自定义ThreadFactory：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.demo.factory;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadFactory;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class MyThreadFactory implements ThreadFactory&#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    private boolean isDaemon;</span><br><span class="line"></span><br><span class="line">    public MyThreadFactory(boolean isDaemon)&#123;</span><br><span class="line">        this.isDaemon = isDaemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">        Thread thread =  new MyWorkThread(atomicInteger,r);</span><br><span class="line">        thread.setDaemon(isDaemon);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(new MyThreadFactory(false));</span><br><span class="line">        for (int i=0;i&lt;1000;i++)&#123;</span><br><span class="line">            executorService.execute(new TestRunnable(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private String msg;</span><br><span class="line"></span><br><span class="line">        public TestRunnable(String msg)&#123;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;runnable:&quot;+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅三种创建 ThreadFactory 的方式</p>
<p>第一种 CustomizableThreadFactory<br>Spring 框架提供的 CustomizableThreadFactory。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadFactory springThreadFactory = new CustomizableThreadFactory(&quot;springThread-pool-&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种 ThreadFactoryBuilder<br>Google guava 工具类 提供的 ThreadFactoryBuilder ,使用链式方法创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadFactory guavaThreadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;retryClient-pool-&quot;).build();</span><br><span class="line">//-pool-后面加%d ？</span><br></pre></td></tr></table></figure>

<p>第三种 BasicThreadFactory<br>Apache commons-lang3 提供的 BasicThreadFactory.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadFactory basicThreadFactory = new BasicThreadFactory.Builder().namingPattern(&quot;basicThreadFactory-&quot;).build();</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/u010648555/article/details/106137206/">https://blog.csdn.net/u010648555/article/details/106137206/</a></p>
<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><p>进程：操作系统结构的基础、操作系统进行资源分配和调度的独立单元<br>线程：进程中独立运行的子任务，程序执行的单元。<br>例如：启动jvm相当于起了一个进程，jvm内：main方法、垃圾回收等相当于多个线程。<br>cpu是运算和控制的中心，在cpu的运行过程中，同一时刻只能执行一个进程。<br>多线程下，cpu在不同的线程之间进行切换，多线程不一定比单线程快。<br>多线程执行时，执行顺序是随机的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.sleep(1000);  //休息1s，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">新建Thread线程：</span><br><span class="line">Thread thread = new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;, &quot;name&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h4 id="start、run、join方法"><a href="#start、run、join方法" class="headerlink" title="start、run、join方法"></a>start、run、join方法</h4><p>start： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 </p>
<p>run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>
<p>join方法在线程外使用，表示等待thread线程执行完毕，再继续执行当前join方法所在的线程。在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<p>✅多线程累加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 线程安全的累加</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">/**</span><br><span class="line">    * 创建线程</span><br><span class="line">    */</span><br><span class="line">class CreateThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private final Object lock = new Object(); //使用一个Java对象作为一个锁</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (num &lt;= 100) &#123;</span><br><span class="line">                    System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot;  num: &quot; + num );</span><br><span class="line">                    num++;</span><br><span class="line">                    lock.notifyAll(); //不加也一样</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必须共用一个Runnable</span><br><span class="line">CreateThread myThread1 = new CreateThread();</span><br><span class="line">Thread thread1 = new Thread(myThread1, &quot;thread1&quot;);</span><br><span class="line">Thread thread2 = new Thread(myThread1, &quot;thread2&quot;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程休眠等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws InterruptedException &#123;</span><br><span class="line">    // 线程类还必须放前面</span><br><span class="line">    class CreateThread1 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程执行&quot;);</span><br><span class="line">            Thread.yield(); //线程让步</span><br><span class="line">            System.out.println(&quot;继续执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread thread1 = new Thread(new CreateThread1(), &quot;thread1&quot;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();  //插队执行</span><br><span class="line">    System.out.println(&quot;main线程&quot;);</span><br><span class="line">    Thread.sleep(1000 * 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>单测方法有一个问题，当单测方法结束的时候，里面的线程也要结束，不管是不是执行完成。单测方法结束的时候会把里面的资源释放掉，导致里面的线程提前结束。<br>结论：尽量不要在test中开启线程，开启的话，sleep一下，等线程执行完。</p>
<p>但是在main方法中，main方法执行完以后子线程并不会退出，因为子线程是非守护线程。</p>
<p>首先，JVM程序在什么情况下能够正常退出<br>The Java Virtual Machine exits when the only threads running are all daemon threads.<br>当JVM中不存在任何一个正在运行的非守护线程时，则JVM进程即会退出。<br>main线程是一个非守护线程。只剩下守护线程，就会退出。</p>
<p>什么是守护线程？<br>在Java中有两类线程：</p>
<ul>
<li>User Thread(用户线程)</li>
<li>Daemon Thread(守护线程)</li>
</ul>
<p>JVM中的垃圾回收就是典型的守护线程，当JVM要退出时，如果垃圾回收线程还在运行，导致程序无法退出。这就很尴尬了。守护线程主要是为了给其他的线程提供服务，比如说计时器，清空高速缓存等等操作。当被守护线程死亡，守护线程往往也会死亡，当虚拟机中只剩下守护线程时，虚拟机就会退出，因为此时也没有运行程序的必要了</p>
<p>守护线程经常被用来执行一些后台任务，如果你希望JVM退出时，线程能够正常退出，守护线程是你的首选。<br>守护线程应该永远不去访问固有资源，比如说文件或者数据库，因为它会在任何时候甚至一个操作的中间发生中断。</p>
<h3 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h3><p>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<p>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。</p>
<p>在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</p>
<p>synchronized的作用主要有三个：</p>
<p>原子性：确保线程互斥地访问同步代码；<br>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；<br>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/m0_53474063/article/details/112389756">https://blog.csdn.net/m0_53474063/article/details/112389756</a></p>
<p>✅wait方法、notify方法、notifyAll方法</p>
<p>等待池：<br>假设线程 A 调用了锁对象的 wait() 方法，则 A线程就会释放该对象的锁(因为 wait() 方法必须出现在 synchronized 中，所以在执行 wait() 方法之前 A线程就已经拥有了该对象的锁)，同时线程 A进入到了该对象的等待池中。如果有其它线程调用了相同对象的 notifyAll() 方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，重新争夺锁的拥有权。如果另外的一个线程调用了相同对象的 notify() 方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。</p>
<p>锁池：<br>假设线程 A已经拥有了锁，而其它的线程想要调用该对象的 synchronized 方法(或者 synchronized 块)，其他未获得锁的线程在进入对象的 synchronized 方法之前都需要先获得该对象的锁的拥有权，但是该对象的锁目前正被 A线程拥有，所以这些线程就进入了该对象的锁池中。</p>
<h3 id="leeco-按序打印"><a href="#leeco-按序打印" class="headerlink" title="leeco 按序打印"></a>leeco 按序打印</h3><p>三个不同的线程 A、B、C，调用同一个类的三个不同的方法，想要异步调用三个线程，但是实现线程调用类中方法的同步输出。实现异步转同步的操作。<br>线程内run方法里面负责打印。<br>比如先调用second，再调用first，输出的是first-second。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object(); //得定义，不然是null</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 1) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 2) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printSecond.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 3) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            printThird.run();</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leeco-交替打印FooBar"><a href="#leeco-交替打印FooBar" class="headerlink" title="leeco 交替打印FooBar"></a>leeco 交替打印FooBar</h3><p>两个不同的线程将会共用一个 FooBar实例，分别调用两个打印方法，保证线程是交替打印的。<br>需要加循环，循环里面再抢锁。如果不加循环，wait之后进入等待池，其他线程notifyAll，只是告诉其他线程可以抢锁，并不是唤醒其他线程让他们开始抢锁。抢锁这个动作还是需要自己触发的。<br>如果把循环加在synchronized里面就不对了，没有主动触发抢锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    public FooBar(int n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void foo(Runnable printFoo) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 1) &#123; //不需要while，if就行</span><br><span class="line">                //表示的是拿错锁了，释放掉</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    //wait进入锁池，再进来就是重新获锁进来了</span><br><span class="line">                &#125;</span><br><span class="line">                //锁拿对了，就进行处理</span><br><span class="line">                printFoo.run();</span><br><span class="line">                index =2;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void bar(Runnable printBar) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 2) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                index =1;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="synchronized的对象锁和类锁"><a href="#synchronized的对象锁和类锁" class="headerlink" title="synchronized的对象锁和类锁"></a>synchronized的对象锁和类锁</h3><p>上面的两个leeco例子中，因为是创建一个对象进行调用，多线程共享那个lock，所以lock不需要static，只需要对象锁。但是如果创建多个对象调用，就需要类锁了。（比如接口的方法要控制多个请求同步）</p>
<p>synchronized关键字可以用在方法和代码块上。这些方法或者代码块可以使静态的也可以是非静态的。</p>
<p>对象锁-一个对象一把锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁-一个类一把锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized static void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass&#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (DemoClass.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final static Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁：static synchronized 是要控制类的所有实例的并发访问，static synchronized是限制多线程中该类的所有实例同时访问jvm中该类所对应的代码块。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-22 23:44</span><br><span class="line"> **/</span><br><span class="line">public class SynchroObject extends Thread &#123;</span><br><span class="line">    private static volatile int n = 0;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            add();</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(5);</span><br><span class="line">                //测试多线程的private变量，发现多个线程对象的private变量是不同的</span><br><span class="line">                System.out.println(&quot;lock hashcode:&quot; + lock.hashCode());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果同步方法是static的，则多线程正确同步</span><br><span class="line">    //如果同步方法不是static的，则不是正确同步</span><br><span class="line">    private static synchronized void add() &#123;</span><br><span class="line">        n++;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread threads[] = new Thread[100];</span><br><span class="line">        for (int i = 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = new SynchroObject();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.join(); //等待该线程终止</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; n= &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：<br>1、synchronized(this){/<em>区块</em>/} 作用域是当前对象。被synchronized修饰符修饰的实例方法，跟整个方法体被一个synchronized(this) { … } 包围住，意思完全一样。</p>
<p>2、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法。</p>
<p>3、根据java语言的规定，你不能在构造方法上使用synchronized关键字，这是非法的并且会导致编译错误。</p>
<p>转自：synchronized的对象锁和类锁：<a href="https://www.cnblogs.com/ZenoLiang/p/14713160.html">https://www.cnblogs.com/ZenoLiang/p/14713160.html</a></p>
<p>✅多线程synchronized变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-06-27 09:15</span><br><span class="line"> **/</span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建并开启4个线程，模拟四个售票窗口</span><br><span class="line">        SaleThread saleThread = new SaleThread();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口1&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口2&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口3&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口4&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SaleThread implements Runnable&#123;</span><br><span class="line">    //大前提：票得是static的，除非创建线程共用一个SaleThread对象</span><br><span class="line">    //不共用Runnable对象的话，且票不是static的，则每个线程各自卖</span><br><span class="line">    private static Integer tickets = 100;  //多线程共享的变量</span><br><span class="line">    //定义任意一个对象，用作同步代码块的锁</span><br><span class="line">    //如果不是static变量，达不到同步效果</span><br><span class="line">    //如果是static变量，多线程对象共享该变量。正确同步。</span><br><span class="line">    //如果上面创建线程用的是同一个SaleThread对象，则不管是不是static的，都是正确同步的。</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                if(tickets&gt;0)&#123;</span><br><span class="line">                    int i = tickets;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        Thread.sleep(1);  //模拟售票耗时过程</span><br><span class="line">                    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果lock是static，则hashcode一样。tickets的hashcode一直在变</span><br><span class="line">                    System.out.println(lock.hashCode() + &quot;  &quot; + tickets.hashCode());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +&quot;正在发售第&quot;+tickets--+&quot;张票&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程共享变量问题"><a href="#多线程共享变量问题" class="headerlink" title="多线程共享变量问题"></a>多线程共享变量问题</h3><p>在并发编程的艺术中探讨了静态变量和成员变量的区别。<br>由static修饰的变量称为静态变量，其实质上就是一个全局变量。<br>本质是说静态变量是类所有对象共享，成员变量是对象专有。</p>
<p>这里探讨一下全局变量和局部变量的区别：</p>
<p>首先各种变量的分类：<br>变量分为全局变量（成员变量）和局部变量，全局变量又分为静态变量和实例变量。<br>所以上边对静态变量和成员变量的区分，应该是静态变量</p>
<p>✅什么是静态变量：<br>1：为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。<br>2：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。<br>3：被static修饰后的值可以直接类名.值进行引用，而无需new一个对象进行调用<br>4：在JVM中，静态变量的加载顺序在对象之前，因此静态变量不依附于对象存在，可以在不实例化类的情况下直接使用静态变量</p>
<p>✅局部变量和全局变量（成员变量）：<br>在方法体中声明的变量叫做：局部变量。<br>在方法体外声明的变量叫做：成员变量。成员变量又可以分为：实例变量和静态变量。</p>
<p>全局变量和局部变量的区别:<br>1，作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等<br>2，内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区<br>3，生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了<br>4，使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。</p>
<p>✅多线程访问全局变量(成员变量)和局部变量：</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloThreadTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        HelloThread r = new HelloThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(r);</span><br><span class="line">        Thread t2 = new Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloThread implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        //int i = 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Hello number: &quot; + i++);</span><br><span class="line"></span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep((long) Math.random() * 1000);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (50 == i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，i是成员变量，则HelloThread的对象r只包含这一个i，两个Thread对象因为由r构造，所以共享了同一个i。</p>
<p>如果i改为在run方法中定义，那么就是局部变量，由于局部变量对于每一个线程来说都有自己的拷贝，所以各个线程之间不再共享同一个变量。</p>
<p>总结：<br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。</p>
<p>如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
<p>转自：<a href="http://t.zoukankan.com/xiaowenwu-p-5077639.html">http://t.zoukankan.com/xiaowenwu-p-5077639.html</a></p>
<p>⚠️这里所说的全局变量和局部变量，说的是线程对象内的，不是传入线程的是局部变量还是全局变量。猜测：不分传入的是全局变量还是局部变量，都是有拷贝的，因为传入的变量对线程来说是成员变量。</p>
<p>实验：一个ArrayList，对代码块儿来说是局部变量，传入线程中，只读list的hashcode，传入线程前和线程中的hashcode一样。</p>
<p>实验：ArrayList增加一个元素，hashCode会变，改变一个对象的某个属性，hashCode不变。</p>
<h3 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h3><p>成员变量：从上面的例子，如果使用一个Runnable对象创建多个线程，多个线程共享成员变量，多个线程对该变量进行操作是彼此影响的，是线程不安全的。也就是上面加了锁，达到了线程安全。</p>
<p>局部变量：每个线程都会有局部变量的拷贝，一个线程对局部变量的操作不会影响其他线程。（上面的i）</p>
<p>多线程之间就是因为数据共享在多个线程才导致了线程不安全，这就要求线程间的数据需要隔离，从根本上解决了线程安全问题。</p>
<p>因此ThreadLocal：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值(副本)。</p>
<p>✅例子：多个线程共用一个Runnable对象，内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:28</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        int local = 1;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">            local = (int) (Math.random() * 100D);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;threadLocal:&quot; +threadLocal.get());</span><br><span class="line">            System.out.println(&quot;local:&quot; +local);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">threadLocal:40</span><br><span class="line">threadLocal:32</span><br><span class="line">local:95</span><br><span class="line">local:95</span><br></pre></td></tr></table></figure>

<p>每个线程拥有自己的ThreadLocal变量，但是共享local变量。</p>
<p>✅例子：多个线程共同对一个对象进行操作，对象内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:55</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample2 &#123;</span><br><span class="line">    private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    int local = 1;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalExample2 demo = new ThreadLocalExample2();</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                demo.threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">                demo.local = (int) (Math.random() * 100D);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;threadLocal:&quot; +demo.threadLocal.get());</span><br><span class="line">                System.out.println(&quot;local:&quot; +demo.local);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(&quot;线程&quot; + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的效果。</p>
<p>多线程变量共享和隔离，ThreadLocal讲解：<a href="https://blog.csdn.net/JokerLJG/article/details/121284966">https://blog.csdn.net/JokerLJG/article/details/121284966</a></p>
<p>线程私有变量的另一个方法：多个对象构造方法传入不同的值：<a href="https://blog.csdn.net/qq_43209615/article/details/124993090">https://blog.csdn.net/qq_43209615/article/details/124993090</a></p>
<p>SimpleDateFormat不是线程安全的解决：<a href="https://blog.csdn.net/sinat_38816924/article/details/122642680">https://blog.csdn.net/sinat_38816924/article/details/122642680</a></p>
<h3 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h3><p>Runnable是接口。Thread是实现了Runnable接口的类，并进行了扩展，而Thread和Runnable的实质是实现的关系，不是同类东西，所以Runnable或Thread本身没有可比性。</p>
<p>Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。<br>而Thread也是可以的，只不过是多个thread对象共享static变量，或者提交同一个Thread对象，并且static只是可见，还需要加同步才是线程安全的。</p>
<blockquote>
<p>这里只探讨共享变量的问题，想实现线程安全，要么加同步，要么volatile+原子性变量。</p>
</blockquote>
<p>还是卖票：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test3  extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private int ticket = 10;</span><br><span class="line"></span><br><span class="line">        public void run()&#123;</span><br><span class="line">            for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">                synchronized (this)&#123;</span><br><span class="line">                    if(this.ticket&gt;0)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(100);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+&quot;卖票----&gt;&quot;+(this.ticket--));</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] arg)&#123;</span><br><span class="line">            Test3 t1 = new Test3();</span><br><span class="line">            new Thread(t1,&quot;线程1&quot;).start();</span><br><span class="line">            new Thread(t1,&quot;线程2&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/zhaojianting/article/details/97664370">https://blog.csdn.net/zhaojianting/article/details/97664370</a></p>
<h3 id="获取线程池中的线程？"><a href="#获取线程池中的线程？" class="headerlink" title="获取线程池中的线程？"></a>获取线程池中的线程？</h3><p>貌似无法获取线程。<br>但是可以获取线程池中活动的线程数：<br>ThreadPoolExecutor的getActiveCount方法。<br><code>public class ThreadPoolExecutor extends AbstractExecutorService &#123;</code><br><code>public abstract class AbstractExecutorService implements ExecutorService &#123;</code><br><code>public interface ExecutorService extends Executor &#123;</code></p>
<p>ExecutorService先转型一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">System.out.println(((ThreadPoolExecutor)executorService).getActiveCount());  //0</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolTaskExecutor"><a href="#ThreadPoolTaskExecutor" class="headerlink" title="ThreadPoolTaskExecutor"></a>ThreadPoolTaskExecutor</h3><p>ThreadPoolTaskExecutor是一个spring的线程池技术。ThreadPoolTaskExecutor是spring core包中的，而ThreadPoolExecutor是JDK中的JUC。ThreadPoolTaskExecutor是对ThreadPoolExecutor进行了封装处理。</p>
<p>Spring自带的线程池ThreadPoolTaskExecutor：<br><a href="https://zhuanlan.zhihu.com/p/346086161">https://zhuanlan.zhihu.com/p/346086161</a></p>
<h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><p>Spring内置定时任务调度，主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意须要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay。</p>
<p>Spring内置定时任务调度@Scheduled使用详解：<br><a href="https://www.jb51.net/article/201373.htm">https://www.jb51.net/article/201373.htm</a></p>
<p>@Scheduled注解：<br><a href="http://www.javashuo.com/article/p-otgzzukq-hc.html">http://www.javashuo.com/article/p-otgzzukq-hc.html</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java实现自定义注解</title>
    <url>/2022/03/19/myblog/JAVA/java%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="关于注解"><a href="#关于注解" class="headerlink" title="关于注解"></a>关于注解</h3><p>Annotation，注解是Java SE 5.0版本开始引入的概念，它是对java源代码的说明，是一种元数据（描述数据的数据）。</p>
<ul>
<li>注释<br>   注释是对代码的说明，给代码的读者看，便于帮读者梳理业务逻辑；</li>
<li>注解<br>  注解也是对代码的说明，需要配合工具（解析它的代码）使用，参与代码的编译，给应用程序看的。</li>
</ul>
<p>注解的渊源：</p>
<p>在频繁使用注解之前，是用xml 来作为元数据使用，在最开始使用ssm(Spring,SpringMVC,Mybatis)框架时，bean与bean之间的依赖关系是通过xml文件来配置，这个xml文件和源代码分散，当微服务、分布式注解流行，系统越来越大，需要越来越多的xml文件来配置管理，文件配置冗长，而且类型不安全（运行期才会发现错误）,此时就需要一种比较简单直观而且类型安全的配置方式，注解就应运而生了，按照Springboot“约定大于配置”的方式，通过注解来约定其含义，更是减少了xml配置文件的数量。<br>     对于一些经常变动或者配置复杂的配置，使用xml文件来说是比较合适的，所以现在经常是注解和xml方式共存。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/zt15732625878/article/details/99671586">https://blog.csdn.net/zt15732625878/article/details/99671586</a></p>
<p>————————————————</p>
<h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><p>按照来源划分，可以分为 JDK的注解，第三方的注解，自定义注解。</p>
<p>JDK注解</p>
<p>Java 内置三大注解<br>@Override （标记重写方法）<br>@Deprecated （标记过时）<br>@SuppressWarnings （忽略警告）</p>
<p>元注解 (注解的注解)<br>@Target （注解的作用目标）<br>@Retention （注解的生命周期）<br>@Document （注解是否被包含在JavaDoc中）<br>@Inherited （是否允许子类集成该注解）</p>
<p>第三方注解（主要来源于各种框架）<br>Spring注解<br>@RequestMapping,@RestController,@Configuration,@Value,@Controller,@Service,@Repository,@Component等<br>SpringBoot注解<br>@SpringBootApplication,@EnableAutoConfiguration等<br>JPA注解<br>@Table,@Entity,@Column,@Id等<br>……</p>
<p>自定义注解<br>使用元注解自己定义的注解</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>1&gt;.每一个方法实际上是声明了一个配置参数,<br>2&gt;.方法的名称就是参数的名称,<br>3&gt;.返回值类型就是参数的类型,(返回值类型只能是基本类型、Class、String、enum)<br>4&gt;.可以通过default来声明参数的默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    注解元素的声明<span class="number">1</span> </span><br><span class="line">    注解元素的声明<span class="number">2</span></span><br><span class="line">    <span class="function">type <span class="title">elementName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">type <span class="title">elementName</span><span class="params">()</span> <span class="keyword">default</span> value</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Service的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ElementType.TYPE 代表在类上使用</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">// RetentionPolicy.RUNTIME 代表运行时使用，可以通过反射获取到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//包含在JavaDoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//允许通过包扫描的方式自动检测</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有注解</strong>，<strong>默认是一个实现了Annotation接口的接口。</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解是一种能被添加到java源代码中的元数据，可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理。</p>
<p>注解的基本元素：</p>
<ul>
<li>修饰符<br> 访问修饰符必须为public,不写默认为pubic；</li>
<li>关键字<br> 关键字为@interface；</li>
<li>注解名称<br> 注解名称为自定义注解的名称，使用时还会用到；</li>
<li>注解类型元素<br> 注解类型元素是注解中内容，可以理解成自定义接口的实现部分；</li>
</ul>
<p>使用元注解修饰注解：</p>
<p>@Target，@Retention,@Document,@Inherited用来修饰注解。</p>
<p><strong>@Target</strong><br> 表明该注解可以应用的java元素类型。<br>ElementType.TYPE    应用于类、接口（包括注解类型）、枚举<br>ElementType.FIELD    应用于属性（包括枚举中的常量）<br>ElementType.METHOD    应用于方法<br>ElementType.PARAMETER    应用于方法的形参<br>ElementType.CONSTRUCTOR    应用于构造函数<br>ElementType.LOCAL_VARIABLE    应用于局部变量<br>ElementType.ANNOTATION_TYPE    应用于注解类型<br>ElementType.PACKAGE    应用于包<br>ElementType.TYPE_PARAMETER    1.8版本新增，应用于类型变量<br>ElementType.TYPE_USE    1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）</p>
<p>@Retention<br>  表明该注解的生命周期<br>RetentionPolicy.SOURCE    编译时被丢弃，不包含在类文件中<br>RetentionPolicy.CLASS    JVM加载时被丢弃，包含在类文件中，默认值<br>RetentionPolicy.RUNTIME    由JVM 加载，包含在类文件中，在运行时可以被获取到</p>
<p>@Document<br>  表明该注解标记的元素可以被Javadoc 或类似的工具文档化</p>
<p>@Inherited<br>  表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Info &#123;</span><br><span class="line">      <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;tracy&quot;</span>;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">isDelete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义注解"><a href="#使用自定义注解" class="headerlink" title="使用自定义注解"></a>使用自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="comment">// 为Person类配置了刚刚定义的注解@Info</span></span><br><span class="line"><span class="meta">@Info(isDelete = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反射解析注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取Person的Class对象(类)</span></span><br><span class="line">            Person person = Person.builder().build();</span><br><span class="line">            Class clazz = person.getClass();</span><br><span class="line">            <span class="comment">//判断类上是否有Info注解</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Info.class)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Person类上配置了Info注解！&quot;</span>);</span><br><span class="line">                <span class="comment">//获取该对象上Info类型的注解</span></span><br><span class="line">                Info infoAnno = (Info) clazz.getAnnotation(Info.class);</span><br><span class="line">                System.out.println(<span class="string">&quot;infoAnno.value :&quot;</span> + infoAnno.value() + <span class="string">&quot;,infoAnno.isDelete:&quot;</span> + infoAnno.isDelete());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Person类上没有配置Info注解！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类或者接口来说，Class类(java.lang包下)中提供了一些方法用于反射注解，当然对于字段、方法来说反射注解的方式很类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回指定的注解</span></span><br><span class="line">getAnnotation</span><br><span class="line"><span class="comment">//判断当前元素是否被指定注解修饰</span></span><br><span class="line">isAnnotationPresent</span><br><span class="line"><span class="comment">//返回所有的注解</span></span><br><span class="line">getAnnotations</span><br></pre></td></tr></table></figure>

<p>————————————————</p>
<p>参考链接：<a href="https://blog.csdn.net/zt15732625878/article/details/100061528">https://blog.csdn.net/zt15732625878/article/details/100061528</a></p>
<p>————————————————</p>
<h3 id="使用自定义注解例子2"><a href="#使用自定义注解例子2" class="headerlink" title="使用自定义注解例子2"></a>使用自定义注解例子2</h3><p>&lt;1&gt;.作用在属性上注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FiledAnnotation &#123;</span><br><span class="line">	 <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;GetFiledAnnotation&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;.作用在方法上注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodAnnotation &#123;</span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;MethodAnnotation&quot;</span>;   </span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> &quot;https:<span class="comment">//www.cnblogs.com&quot;;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>&lt;3&gt;.作用在类上注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TypeAnnotation &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;Is-TypeAnnotation&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt;.使用自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TypeAnnotation(value = &quot;doWork&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"><span class="meta">@FiledAnnotation(value = &quot;CSDN博客&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String myfield = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MethodAnnotation()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;do the getDefaultInfo method&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@MethodAnnotation(name = &quot;百度&quot;, url = &quot;www.baidu.com&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefineInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;do the getDefineInfo method&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;5&gt;.测试自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	</span><br><span class="line">    Class cls = Class.forName(<span class="string">&quot;com.zbz.annotation.pattern3.Worker&quot;</span>);</span><br><span class="line">    Method[] method = cls.getMethods();</span><br><span class="line">    <span class="comment">/**判断Worker类上是否有TypeAnnotation注解*/</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = cls.isAnnotationPresent(TypeAnnotation.class);</span><br><span class="line">    <span class="comment">/**获取Worker类上是TypeAnnotation注解值*/</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    	TypeAnnotation typeAnno = (TypeAnnotation) cls.getAnnotation(TypeAnnotation.class);</span><br><span class="line">    	System.out.println(<span class="string">&quot;@TypeAnnotation值:&quot;</span> + typeAnno.value());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**方法上注解*/</span></span><br><span class="line">    List&lt;Method&gt; list = <span class="keyword">new</span> ArrayList&lt;Method&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; method.length; i++) &#123;</span><br><span class="line">        list.add(method[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Method m : list) &#123;</span><br><span class="line">    	MethodAnnotation methodAnno = m.getAnnotation(MethodAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> (methodAnno == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        System.out.println( <span class="string">&quot;方法名称:&quot;</span> + m.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法上注解name = &quot;</span> + methodAnno.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法上注解url = &quot;</span> + methodAnno.url());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**属性上注解*/</span></span><br><span class="line">    List&lt;Field&gt; fieldList = <span class="keyword">new</span> ArrayList&lt;Field&gt;();  <span class="comment">//Field表示属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field f : cls.getDeclaredFields()) &#123;<span class="comment">// 访问所有字段</span></span><br><span class="line">    	FiledAnnotation filedAno = f.getAnnotation(FiledAnnotation.class);</span><br><span class="line">    	System.out.println( <span class="string">&quot;属性名称:&quot;</span> + f.getName());</span><br><span class="line">    	System.out.println(<span class="string">&quot;属性注解值FiledAnnotation = &quot;</span> + filedAno.value());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/zhangbeizhen18/article/details/87885441/">https://blog.csdn.net/zhangbeizhen18/article/details/87885441/</a></p>
<p>————————————————</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>自定义注解像是为类或者什么的新增加了属性，可以有默认值，通过类可以获得类上的自定义注解，然后通过注解获得注解中的值。注解不是属于对象的。定义在属性上的，可以用属性注解来区别这些属性，相当于属性名的别名。</p>
<h3 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h3><p>自定义注解+AOP：<a href="https://zhuanlan.zhihu.com/p/283936459">https://zhuanlan.zhihu.com/p/283936459</a></p>
<p>使用方法上的注解，实现通过注解来唤醒一个类里方法的效果：</p>
<p><a href="https://www.jianshu.com/p/b5b79434d3b5">https://www.jianshu.com/p/b5b79434d3b5</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常规接口、类</title>
    <url>/2022/04/30/myblog/JAVA/java%E6%8E%A5%E5%8F%A3&amp;%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>位于java.io.Serializable包中，一般在创建实体类的时候会去实现这个接口，目的是为了序列化。</p>
<p>序列化指的是把对象转化成字节序列的过程，就是把内存中的对象转换成一连串的字节bytes描述的过程。<br>反序列化就是将字节bytes数据恢复为对象的过程。</p>
<p>需要将内存中对象状态数据保存到文件或数据库中时，需要进行序列化。这个比较直观的就是通过ObjectOutputStream和FileOutputStream向文件中保存对象时，实现了Serializable接口的对象会以二进制数据的形式保存到文件中，而未实现Serializable接口的对象则会直接报错，无法保存。</p>
<p>serialVersionUID：<br>如果在进行反序列化前，将某个实体类原有的serialVersionUID改变，在进行反序列化时就会报InvalidClassException异常。<br>如果没有指定serialVersionUID，在进行序列化时，JVM会通过计算给该类一个默认的serialVersionUID值。<br>但是不建议不指定serialVersionUID，高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。个人认为应该是指不同编译器编译的不同类可能产生一个相同的默认serialVersionUID。<br>另外尽量用private来修饰serialVersionUID。</p>
<hr>
<p>Serializable其实是个空接口，用来标识当前类可以被序列化。<br>告诉jvm，让jvm帮忙做序列化。</p>
<p>实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。</p>
<p>✅什么是序列化？</p>
<p>序列化（serialize） - 序列化是将对象转换为字节流。<br>反序列化（deserialize） - 反序列化是将字节流转换为对象。</p>
<p>作用：<br>序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。<br>在网络上传送对象的字节序列。<br>RMI(远程方法调用)</p>
<p>什么时候用：<br>1、想把内存中的对象状态保存到一个文件中或者数据库中时<br>2、想把对象通过网络进行传输时</p>
<p>✅如何使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Gender类，表示性别</span><br><span class="line">// 每个枚举类型都会默认继承类java.lang.Enum，而Enum类实现了Serializable接口，所以枚举类型对象都是默认可以被序列化的。</span><br><span class="line">public enum Gender &#123;  </span><br><span class="line">    MALE, FEMALE  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// Person 类实现了 Serializable 接口，它包含三个字段。另外，它还重写了该类的 toString() 方法，以方便打印 Person 实例中的内容。</span><br><span class="line">public class Person implements Serializable &#123;  </span><br><span class="line">    private String name = null;  </span><br><span class="line">    private Integer age = null;  </span><br><span class="line">    private Gender gender = null;  </span><br><span class="line"></span><br><span class="line">    public Person() &#123;  </span><br><span class="line">        System.out.println(&quot;none-arg constructor&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    public Person(String name, Integer age, Gender gender) &#123;  </span><br><span class="line">        System.out.println(&quot;arg constructor&quot;);  </span><br><span class="line">        this.name = name;  </span><br><span class="line">        this.age = age;  </span><br><span class="line">        this.gender = gender;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 省略 set get 方法</span><br><span class="line">    @Override </span><br><span class="line">    public String toString() &#123;  </span><br><span class="line">        return &quot;[&quot; + name + &quot;, &quot; + age + &quot;, &quot; + gender + &quot;]&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// SimpleSerial类，是一个简单的序列化程序，它先将Person对象保存到文件person.out中，然后再从该文件中读出被存储的Person对象，并打印该对象。</span><br><span class="line">public class SimpleSerial &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        File file = new File(&quot;person.out&quot;);  </span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file)); // 注意这里使用的是 ObjectOutputStream 对象输出流封装其他的输出流</span><br><span class="line">        Person person = new Person(&quot;John&quot;, 101, Gender.MALE);  </span><br><span class="line">        oout.writeObject(person);  </span><br><span class="line">        oout.close();  </span><br><span class="line"> </span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));  // 使用对象输入流读取序列化的对象</span><br><span class="line">        Object newPerson = oin.readObject(); // 没有强制转换到Person类型  </span><br><span class="line">        oin.close();  </span><br><span class="line">        System.out.println(newPerson);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// 上述程序的输出的结果为：</span><br><span class="line">arg constructor  </span><br><span class="line">[John, 31, MALE]</span><br></pre></td></tr></table></figure>

<p>转自：简书<br><a href="https://www.jianshu.com/p/8e4a9cac727f">https://www.jianshu.com/p/8e4a9cac727f</a></p>
<p>csdn：<a href="https://blog.csdn.net/u011568312/article/details/57611440">https://blog.csdn.net/u011568312/article/details/57611440</a></p>
<h3 id="MultipartFile接口"><a href="#MultipartFile接口" class="headerlink" title="MultipartFile接口"></a>MultipartFile接口</h3><p>用于http中获取前台传来的文件</p>
<p>位于：package org.springframework.web.multipart;包下<br>中文名：多组件文档<br>继承自：InputStreamSource,并封装了getInputStream()方法<br>此方法用法：<code>@RequesParam(&quot;file&quot;)MultipartFile file</code><br><code>InputStream is  = file.getInputStream();</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getName():得到的是@RequesParam(value = &quot;file&quot;)中的value值，不会为空。</span><br><span class="line">String getOriginalFilename():获取的是文件的完整名称，包括文件名称+文件拓展名。</span><br><span class="line">String getContentType()：返回文件内容类型，不是文件扩展名（例如：jpeg图片：image/jpeg）</span><br><span class="line">boolean isEmpty()：返回上传的文件是否为空，即multipart形式中没有选择任何文件或者选择的文件没有内容</span><br><span class="line">long getSize()：以字节为单位返回文件大小</span><br><span class="line">byte[] getBytes()：以字节数组的形式返回文件内容</span><br><span class="line">InputStream getInputStream()：返回一个字节流</span><br><span class="line">void transferTo()：用来将接收文件传输到给定目标路径，会抛出IOException、IllegalStateException异常。该方法在实际项目开发中使用较少。</span><br></pre></td></tr></table></figure>





<h3 id="Pattern类-amp-Matcher类"><a href="#Pattern类-amp-Matcher类" class="headerlink" title="Pattern类&amp;Matcher类"></a>Pattern类&amp;Matcher类</h3><p>Pattern类是java.util.regex包中的final类。是正则表达式的编译表示形式，此类的实例是不可变的，可供多个并发线程安全使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义</span><br><span class="line">public final class Pattern extends Object implements Serializable</span><br><span class="line"></span><br><span class="line">//Pattern调用静态方法compile返回Pattern实例。</span><br><span class="line">// 将给定的正则表达式编译并赋予给Pattern类</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line"></span><br><span class="line">// 增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ </span><br><span class="line">static Pattern compile(String regex, int flags) </span><br><span class="line">//先不明白</span><br><span class="line"></span><br><span class="line">//Pattern.split()（静态方法）和string.split()用途一样，</span><br><span class="line">//是将字符串从正则表达式匹配的地方分开</span><br><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input, 3)));</span><br><span class="line">// 第二种，第二个参数用来限制将输入分割成字符串的数量</span><br></pre></td></tr></table></figure>

<p>正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\d 表示数字，前面多了第一个\，是转义的意思。</span><br><span class="line">+表示重复前面的</span><br><span class="line">\\d+ 表示多个数字</span><br></pre></td></tr></table></figure>

<p>Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查，此类的实例用于多个并发线程是不安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern.matcher 静态方法：</span><br><span class="line">Pattern.matcher(String regex,CharSequence input)</span><br><span class="line">静态方法,用于快速匹配字符串,匹配全部字符串</span><br><span class="line"></span><br><span class="line">pattern.matcher(CharSequence input):</span><br><span class="line">返回一个Matcher对象。</span><br><span class="line">Matcher类的构造方法也是私有的,不能随意创建,</span><br><span class="line">只能通过pattern.matcher(CharSequence input)方法得到该类的实例</span><br><span class="line"></span><br><span class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;); </span><br><span class="line">Matcher m=p.matcher(&quot;22bb23&quot;); </span><br><span class="line">m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</span><br></pre></td></tr></table></figure>

<p>用Pattern以及Matcher匹配例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;aa11bb&quot;;</span><br><span class="line">String paternStr = &quot;\\d+&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line">if (matcher.find()) &#123;   //有匹配就行</span><br><span class="line">    System.out.println(matcher.group(0));  //输出11</span><br><span class="line">&#125;</span><br><span class="line">if (matcher.matches()) &#123;  //需要完全匹配</span><br><span class="line">    System.out.println(matcher.group(0));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<br><a href="https://blog.csdn.net/woniu317/article/details/52186694">https://blog.csdn.net/woniu317/article/details/52186694</a><br><a href="http://www.51gjie.com/java/759.html">http://www.51gjie.com/java/759.html</a></p>
<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 </p>
<p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：起到了转换类型的作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(s -&gt; Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(Function&lt;String, Integer&gt; function) &#123;</span><br><span class="line">        int num = function.apply(&quot;10&quot;);</span><br><span class="line">        System.out.println(num + 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法：如andThen方法<br><a href="http://t.zoukankan.com/liyihua-p-12286100.html">http://t.zoukankan.com/liyihua-p-12286100.html</a></p>
<p>和@FunctionalInterface作用一样？</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只有一个抽象方法的接口。</p>
<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。可以有多个default方法。</p>
<p>为了避免别人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，可以在接口上加上一个注解<code>@FunctionalInterface</code>, 这样别人就无法在里面添加新的接口函数了。</p>
<p><code>@FunctionalInterface public interface Function&lt;T, R&gt; &#123;   &#125;</code></p>
<p>在java.util.function包下：</p>
<h4 id="✅Function接口"><a href="#✅Function接口" class="headerlink" title="✅Function接口"></a>✅Function接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数型接口：<code>Function&lt;T, R&gt;</code>，有参有返回值，接受一个T类型的参数，并返回一个R类型的返回值。</p>
<p>其中的抽象方法：<code>R apply(T t);</code></p>
<p>T是输入，R是输出，表示一个类型转换，lambda表达式实现apply方法。<br>stream的map方法，传参就是Function，表示映射。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line">    Function&lt;String, String&gt; function = (str) -&gt; &#123;</span><br><span class="line">        return &quot;hello,&quot; + str;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String funDemo(String str2, Function&lt;String, String&gt; function) &#123;</span><br><span class="line">        return function.apply(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFunDemo() &#123;</span><br><span class="line">        System.out.println(funDemo(&quot;小明&quot;, function));</span><br><span class="line">        System.out.println(funDemo(&quot;小美&quot;, str -&gt; &quot;hello&quot;+str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅Predicate接口"><a href="#✅Predicate接口" class="headerlink" title="✅Predicate接口"></a>✅Predicate接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断言型接口：<code>Predicate&lt;T&gt;</code> 有参有返回值，返回值是boolean类型，用来判断某项条件是否满足。经常用来进行筛滤操作。</p>
<p>其中的抽象方法：<code>boolean test(T t);</code></p>
<p>T是输入，输出boolean类型，表示一种条件过滤。<br>stream的filter方法穿参是Predicate。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PredicateTest &#123;</span><br><span class="line">    Predicate&lt;Integer&gt; predicate = (i) -&gt; &#123;</span><br><span class="line">        return i &gt; 10;</span><br><span class="line">    &#125;;</span><br><span class="line">    boolean preDemo(Integer i, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">        return predicate.test(i);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testPreDemo() &#123;</span><br><span class="line">        System.out.println(preDemo(12, predicate));//打印结果：true</span><br><span class="line">        System.out.println(preDemo(12, i -&gt; i &gt; 13));//打印结果：false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅Consumer接口"><a href="#✅Consumer接口" class="headerlink" title="✅Consumer接口"></a>✅Consumer接口</h4><p>消费型接口：Consumer 有参无返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerTest &#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = (str) -&gt; &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;;</span><br><span class="line">    public void conDemo(String str, Consumer&lt;String&gt; consumer) &#123;</span><br><span class="line">        consumer.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testConDemo() &#123;</span><br><span class="line">        conDemo(&quot;hello&quot;, consumer);//打印结果：hello</span><br><span class="line">        conDemo(&quot;hello&quot;, s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>更多函数式接口：<br><a href="https://blog.csdn.net/weixin_45580378/article/details/124853396">https://blog.csdn.net/weixin_45580378/article/details/124853396</a></p>
<p>迷惑：<br>1.函数式接口中的default方法是干嘛的<br>2.泛型。<code>Function&lt;T, R&gt;</code>代表两个泛型；<code>Function&lt;? super T, ? extends R&gt; mapper</code>代表限制泛型类型？</p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Java 8 提供的，是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。</p>
<p>Optional，可以避免没有必要的 null 值检查.</p>
<p><code>public final class Optional&lt;T&gt; &#123;&#125;</code></p>
<p>Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。<br>在 Java 8 之前，任何访问对象方法或属性的调用都可能导致NullPointerException.</p>
<p>✅创建Optional对象</p>
<p>1）可以使用静态方法 empty() 创建一个空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty); // 输出：Optional.empty</span><br><span class="line"></span><br><span class="line">@Test(expected = NoSuchElementException.class)</span><br><span class="line">    public void whenCreateEmptyOptional_thenNull() &#123;</span><br><span class="line">        Optional&lt;Person&gt; emptyOpt = Optional.empty();</span><br><span class="line">        System.out.println(emptyOpt);</span><br><span class="line">        emptyOpt.get(); //NoSuchElementException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）可以使用静态方法 of() 创建一个非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;11&quot;);</span><br><span class="line">System.out.println(opt); // 输出：Optional[11]</span><br></pre></td></tr></table></figure>

<p>传递给 of() 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p>
<p>3）可以使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">System.out.println(optOrNull); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>

<p>✅ifPresent方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return value != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">    if (value != null)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过方法 isPresent() 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 obj != null 的判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;11&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br></pre></td></tr></table></figure>

<p>ifPresent(Consumer&lt;? super T&gt; consumer) 是如果不为null的话，对对象做什么操作。</p>
<p>java中的Optional：<br><a href="https://www.jb51.net/article/214824.htm">https://www.jb51.net/article/214824.htm</a><br>一文彻底搞懂 Java 的 Optional：<br><a href="https://blog.csdn.net/qing_gee/article/details/104767082">https://blog.csdn.net/qing_gee/article/details/104767082</a></p>
<h3 id="GenericConverter接口"><a href="#GenericConverter接口" class="headerlink" title="GenericConverter接口"></a>GenericConverter接口</h3><p>是spring框架中用于进行类型转换的接口，可以将一种类型的对象转换成另一种类型的对象。</p>
<p>GenericConverter是converter接口的一个比较精致的实现，它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</p>
<p>getConvertibleTypes返回一个source-&gt;target的键值对，然后通过实现convert接口来实现你的转换逻辑。sourceTypeDescrptor能让你获取到存放着即将被转换的值的field，而targetTypeDescriptor能让你获得被转换后的值将被存放的field。</p>
<p>GenericConverter的一个很好的例子就是能将array转collection的ArrayToCollectionConverter。</p>
<p>例子：<br>1、首先需要写一个配置类，它作为converter们的注册中心，然后将自己重写的GenericConverter注册进来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public ConvertService getConvertService() &#123;</span><br><span class="line">    ConversionServiceFactoryBean bean = new ConversionServiceFactoryBean();</span><br><span class="line">    Set&lt;?&gt; sets = Sets.newHashSet(new MyGenericConverter());</span><br><span class="line">    bean.setConverters(sets);</span><br><span class="line">    bean.afterPropertiesSet();</span><br><span class="line">    return bean.getObject();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyGenericConverter implements GenericConverter &#123;</span><br><span class="line">    /**</span><br><span class="line">        * 告诉转换器总部，我这个转换器支持什么样的转换，可以支持多个转换</span><br><span class="line">        * 此处支持 string -&gt; list 和 string -&gt; map</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;ConvertiblePair&gt; getConvertibleTypes() &#123;</span><br><span class="line">        Set&lt;ConvertiblePair&gt; convertiblePairs = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        ConvertiblePair stringToArray = new ConvertiblePair(String.class, Array.class);</span><br><span class="line">        ConvertiblePair stringToMap = new ConvertiblePair(String.class, Map.class);</span><br><span class="line">        convertiblePairs.add(stringToArray);</span><br><span class="line">        convertiblePairs.add(stringToMap);</span><br><span class="line">        return convertiblePairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * @param source     被转换的东西</span><br><span class="line">        * @param sourceType 被转换的东西的上下文，可以用于设置条件，具体咋玩看typeDescriptor，比如可以用来判断转换源是否拥有某些注解</span><br><span class="line">        *                   @see TypeDescriptor</span><br><span class="line">        * @param targetType 转换目标类型的上下文</span><br><span class="line">        * @return</span><br><span class="line">        * 案例场景：如果转换源被@Resource标识，并且目标类型为List，则转换list</span><br><span class="line">        *                                         目标类型为map，则转换为map</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) &#123;</span><br><span class="line">        Resource annotation = sourceType.getAnnotation(Resource.class);</span><br><span class="line">        if (annotation!= null)&#123;</span><br><span class="line">            if (targetType.getType() == List.class)&#123;</span><br><span class="line">                return Arrays.asList(source.toString().split(&quot;:&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            if (targetType.getType() == Map.class)&#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;a&quot;,source.toString().split(&quot;:&quot;)[0]);</span><br><span class="line">                map.put(&quot;b&quot;,source.toString().split(&quot;:&quot;)[1]);</span><br><span class="line">                return map;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        DefaultConversionService defaultConversionService = new DefaultConversionService();</span><br><span class="line">        defaultConversionService.addConverter(new MyGenericConverter());</span><br><span class="line"></span><br><span class="line">        Apple apple = new Apple();</span><br><span class="line">        apple.setName(&quot;1:2&quot;);</span><br><span class="line"></span><br><span class="line">        List convert = (List) defaultConversionService.convert(apple.getName(),</span><br><span class="line">                new TypeDescriptor(Apple.class.getDeclaredField(&quot;name&quot;)),</span><br><span class="line">                new TypeDescriptor(ResolvableType.forRawClass(List.class),null,null));</span><br><span class="line">        System.out.println(convert.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、getConvertibleTypes 用于告诉注册中心，你重写的converter能够支持什么样的转换，比如我的就支持string到list，string到map的转换</p>
<p>参考：GenericConverter的用法随笔<br><a href="https://blog.csdn.net/qq_26950567/article/details/103685810">https://blog.csdn.net/qq_26950567/article/details/103685810</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常规注解</title>
    <url>/2022/04/29/myblog/JAVA/java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。</p>
<p>所有的注解本质上都是继承自 Annotation 接口。但是，手动定义一个接口继承 Annotation 接口无效的，需要通过 @interface 声明注解，Annotation 接口本身也不定义注解类型，只是一个普通的接口。</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="@Pattern"></a>@Pattern</h3><p>用来限定string格式，用正则表达式来限定。<br>需要导入validation-api包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class StudentVO&#123;</span><br><span class="line">        @Pattern(regexp = &quot;^[A-Za-z]+$&quot;, message = &quot;只能字母&quot;)</span><br><span class="line">        private String name;</span><br><span class="line">        private Long age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>常用的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 匹配首尾空格的正则表达式：(^\s*)|(\s*$)</span><br><span class="line">  2 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line">  3 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line">  4 只能输入n位的数字：&quot;^\d&#123;n&#125;$&quot;。</span><br><span class="line">  5 只能输入至少n位的数字：&quot;^\d&#123;n,&#125;$&quot;。</span><br><span class="line">  6 只能输入m~n位的数字：。&quot;^\d&#123;m,n&#125;$&quot;</span><br><span class="line">  7 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line">  8 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line">  9 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 10 只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 11 只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。</span><br><span class="line"> 12 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 13 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 14 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 15 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 16 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 17 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。</span><br><span class="line"> 18 验证用户密码：&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</span><br><span class="line"> 19 验证是否含有^%&amp;&#x27;,;=?$\&quot;等字符：&quot;[^%&amp;&#x27;,;=?$\x22]+&quot;。</span><br><span class="line"> 20 只能输入汉字：&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 21 验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。</span><br><span class="line"> 22 验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 23 验证电话号码：&quot;^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 24 验证身份证号（15位或18位数字）：&quot;^\d&#123;15&#125;|\d&#123;18&#125;$&quot;。</span><br><span class="line"> 25 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 26 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 27 匹配中文字符的正则表达式： [\u4e00-\u9fa5]</span><br><span class="line"> 28 匹配双字节字符(包括汉字在内)：[^\x00-\xff]</span><br><span class="line"> 29 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> 30 String.prototype.len=function()&#123;return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 31 匹配空行的正则表达式：\n[\s| ]*\r</span><br><span class="line"> 32 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36927265/article/details/87864026</span><br></pre></td></tr></table></figure>

<p>在control层，前端调用来进行数据校验。</p>
<p>一、VO对象内用@Pattern限定，control方法中用@Valid检查。<br><a href="http://www.wpf123.com/post/97.html">http://www.wpf123.com/post/97.html</a></p>
<p>二、control类用@Validated注解，方法内String参数用@Pattern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Validated</span><br><span class="line">class Controller &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">public ResponseEntity&lt;List&lt;Permission&gt;&gt; query(</span><br><span class="line">    @RequestHeader(&quot;iv-user&quot;) String userId,</span><br><span class="line">        @Pattern(regexp = &quot;^accessor$&quot;, message = &quot;请求参数不合法&quot;)</span><br><span class="line">        @RequestParam(&quot;findBy&quot;) String accessor,</span><br><span class="line">        @RequestParam(&quot;accessorId&quot;) long accessorId)&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JSONField"><a href="#JSONField" class="headerlink" title="@JSONField"></a>@JSONField</h3><p>来自fastjson，fastjson是阿里巴巴出品的快速解析json的一个工具,</p>
<p>一、name属性：用来指定JSON串中key的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(name = &quot;AGE&quot;)</span><br><span class="line">private String age;</span><br></pre></td></tr></table></figure>
<p>也可以作用在setter、getter方法上。</p>
<p>二、format规定日期格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private Date date;</span><br></pre></td></tr></table></figure>

<p>三、ordinal：规定字段的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(ordinal = 3)</span><br><span class="line">private int f0;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 2)</span><br><span class="line">private int f1;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 1)</span><br><span class="line">private int f2;</span><br></pre></td></tr></table></figure>

<p>四、serialize/deserialize指定字段不序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JSONField(serialize=false)</span><br><span class="line">public Date date;</span><br></pre></td></tr></table></figure>

<p>五、<code>@JSONField(serializeUsing=xxx.class, deserializeUsing=xxx.class)</code><br>指定序列化和反序列化字段使用的序列化器和反序列化器。<br>需要实现<code>ObjectSerializer</code>接口。</p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>LomBok中的注解，用来简化代码。</p>
<p>1.默认情况下，将打印所有非静态字段。<br>2.如果要跳过某些字段，可以用注释这些字段@ToString.Exclude。<br>3.可以使用精确指定要被toString方法包含的字段，先设置@ToString(onlyExplicitlyIncluded = true)，然后使用@ToString.Include标记每个要包含的字段。<br>4.可以更改用于标识成员的名称@ToString.Include(name = “some other name”)，name相当于给字段起别名。<br>5.可以通过更改成员的打印顺序@ToString.Include(rank = 1)。rank 表示该字段的优先级，值越大排在越前面，默认为 0，等级相同的成员以它们在源文件中出现的顺序打印。</p>
<h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>出于安全原因，浏览器禁止Ajax调用驻留在当前原点之外的资源。</p>
<p>跨源资源共享（CORS）是由大多数浏览器实现的W3C规范，允许您灵活地指定什么样的跨域请求被授权，而不是使用一些不太安全和不太强大的策略，如IFRAME或JSONP。</p>
<p>参数：<br>origins： 允许可访问的域列表<br>maxAge:准备响应前的缓存持续的最大时间（以秒为单位）。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CrossOrigin(origins = &#123;&quot;http://domain2.com&quot;,&quot;。。。&quot;&#125;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://cloud.tencent.com/developer/article/188106">https://cloud.tencent.com/developer/article/188106</a></p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>开发restful API时，会用到，@RestController 是@controller和@ResponseBody 的结合。</p>
<p>@Controller 将当前修饰的类注入Spring IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。</p>
<p>@ResponseBody 它的作用是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController  </span><br><span class="line">@RequestMapping(&quot;/home&quot;)  </span><br><span class="line">public class IndexController &#123;  </span><br><span class="line">    @RequestMapping(&quot;/&quot;)  </span><br><span class="line">    String get() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/  </span><br><span class="line">        return &quot;go to home&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @RequestMapping(&quot;/index&quot;)  </span><br><span class="line">    String index() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/index/  </span><br><span class="line">        return &quot;go to index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://www.jianshu.com/p/6f5aec232c97">https://www.jianshu.com/p/6f5aec232c97</a></p>
<p>✅RequestMapping参数</p>
<p>1，value，method<br>value：指定请求的实际地址，指定的地址可以是URI Template模式。<br>method：指定请求的method类型，GET、POST、PUT、DELETE等。</p>
<p>2，consumes，produces<br>consumes：指定处理请求的提交内容类型（content-type），例如application/json，text/html。<br>produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型才返回。不但可以设置返回值类型还可以设定返回值的字符编码。</p>
<p>3，params，headers<br>params：指定request中必须包含某些参数值时，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p>前后端数据json数据类型</p>
<p>1，json对象类型，即前端定义的Content type为application/x-www-form-urlencoded等，后端应使用@RequestParam注解接收此类型的json参数。</p>
<p>2，json字符串类型，即前端定义的Content type为application/json，后端应使用@RequestBody注解接收json参数。</p>
<p>转自：<a href="https://www.cnblogs.com/FlyGoldfish/articles/15649305.html">https://www.cnblogs.com/FlyGoldfish/articles/15649305.html</a></p>
<p>在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/web&quot;)</span><br><span class="line">piblic class TestController &#123;</span><br><span class="line">    // 方法仅处理请求方式是GET和request Content-Type为“application/json”类型的请求</span><br><span class="line">    //普通参数用@RequestParam</span><br><span class="line">    @RequestMapping(value = &quot;/test1&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = &quot;application/json&quot;)</span><br><span class="line">    public String test2(@RequestParam(&quot;id&quot;) String id)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对象类型用@RequestBody</span><br><span class="line">    @RequestMapping(value = &quot;/test2&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    public String test2(@RequestBody VO vo)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指定返回值类型为json</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json&quot;)</span><br><span class="line">public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">   JSONObject object = new JSONObject();</span><br><span class="line">   object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">   return object;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    //@responseBody就是返回值是json数据，使用@responseBody，就可以省略produces属性</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回值是json数据，字符编码为utf-8</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json;charset=utf-8&quot;)</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多用法：<a href="https://blog.csdn.net/weixin_46058921/article/details/122141863">https://blog.csdn.net/weixin_46058921/article/details/122141863</a></p>
<p>✅MediaType<br>consumes参数中可以用的。</p>
<p>MediaType媒体类型：决定浏览器将以什么形式、什么编码对资源进行解析Content-Type：也属于MediaType媒体类型，主要用于在请求头中指定资源的MediaType</p>
<p><a href="https://javajgs.com/archives/75280">https://javajgs.com/archives/75280</a></p>
<p>✅RequestMapping、GetMapping、PostMapping的区别</p>
<p>@RequestMapping是一个无方法的注解。@GetMapping和@PostMapping是组合注解，分别是@RequestMapping(method = RequestMethod.GET)和@RequestMapping(method = RequestMethod.POST)的缩写。<br>GET、POST是方法的映射，表示为<br>@RequestMapping(method = RequestMethod.${方法})</p>
<p>在一开始的映射是使用@RequestMapping(method = RequestMethod.${方法})来表示。后来Spring4.3中引进了@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping注解来帮助简化常用的HTTP方法的映射。</p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：f(@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””) String s</span><br><span class="line">       , 其他入参）</span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"> </span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</span><br></pre></td></tr></table></figure>

<p>✅@RequestParam如何接收List参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;hello&quot;, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public boolean hello(@RequestParam(value = &quot;userIds&quot;) List&lt;Long&gt; userIds) &#123;</span><br><span class="line">   </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接在Params中加：1,2,3</p>
<p>⚠️：@RequestBody传的vo，并且指明传入json格式（contentType），放在body-row中。<br>用的是@RequestParam传参，放在Params中，放在body-row中用json格式不行。放在Params中，相当于是加在url后面。</p>
<p>✅@RequestParam如何接收Date参数</p>
<p>首先引入joda-time包。maven的dependency：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Controller代码里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String testMethod(@RequestParam @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date testdate)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接2022-09-24 00:00:00</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)，因此@RequestBody只能用于接收POST请求的参数<br>@RequestParam接收的是key-value里面的参数(URL中的参数)，通常用于接收GET请求的参数（POST也能接收只接收URL里的，请求体的接收不到）</p>
<p>即：<br>如果参数是放在请求体VO中，传入后台的话，那么后台要用@RequestBody才能接收到；<br>如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收。</p>
<p>总结：<br>@RequestParam和@RequestBody都能接收Post方式请求传来的数据，但是@RequestParam不能接收json字符串，而@RequestBody能，@RequestBody不能接收form-data类型的内容，@RequestParam能。<br>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。<br>@ReuestBody接受单个参数的时候只能先使用Map&lt;String,Object&gt; params接收,然后再使用params.get(“name”)获取参数的值。</p>
<p>更多：<a href="https://blog.csdn.net/justry_deng/article/details/80972817">https://blog.csdn.net/justry_deng/article/details/80972817</a></p>
<h3 id="postman上如何请求"><a href="#postman上如何请求" class="headerlink" title="postman上如何请求"></a>postman上如何请求</h3><p>✅post请求，传参是list的话，用@RequestParam的话只能放在url后面，长度是有限制的。用@RequestBody是放在body里。</p>
<p>✅关于@RequestParam传参和@RequestBody传参，在postman中如何加：<br>1、@RequestParam的参数可以放在postman的param中（跟在url后面），也可以放在body里的form-data里（放在body里的），但是不能放在body的raw里。能放在哪里需要看consume参数的MedisType，想放在form-data里需要设置MedisType为multipart/form-data，或者不要限定为json。<br>2、@RequestBody的参数放在body里的raw里格式为json。一般传对象vo。</p>
<p>✅RequestBody传map型参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String testMethod(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman如何请求：<br>1.设置请求方式为Post<br>2.在Headers中添加Content-Type，值为application/json<br>3.在body中选择row，选择json数据格式，最后在下面以json的数据格式填写参数</p>
<p>✅@RequestParam传参什么时候放在form-data里，什么时候放在params里</p>
<p>长的话放在form-data里，不是跟在url后的。如果放在params里就是跟在url后面的。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody 注解的作用是将Controller的方法返回的对象，通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</p>
<p>@ResponseBody的作用其实是将java对象转为json格式的数据，然后直接写入HTTP response 的body中；一般在异步获取数据时使用</p>
<p>@ResponseBody 是作用在方法上的</p>
<p>更多：<a href="https://blog.csdn.net/weixin_47609799/article/details/124843709">https://blog.csdn.net/weixin_47609799/article/details/124843709</a></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>lombok中的注解。<br>Builder 使用创建者模式又叫建造者模式。简单来说，就是一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程。</p>
<p>@Builder注解的作用主要是用来生成对象，并且可以为对象链式赋值。放在实体类上。<br>​@Builder​​注释为你的类生成相对略微复杂的构建器API。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student student = Student.builder()</span><br><span class="line">        .name( &quot;admin&quot; )</span><br><span class="line">        .age( 18 )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>与@Singular结合使用<br>使用@Singular注释注释一个集合字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Singular</span><br><span class="line">private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">.hobbies( &quot;110&quot; ).hobbies( &quot;112&quot; )</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/g56467467464/article/details/105407741">https://blog.csdn.net/g56467467464/article/details/105407741</a></p>
<h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>baomidou.mybatisplus的注解<br>@TableName是mybatis-plus中的注解，主要是实现实体类型和数据库中的表实现映射。<br>放在实体类DO上。</p>
<p>虽然功能相同，但是，@TableName是mybatis-plus中的注解，@Table是Hibernate中的注解。</p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>1 、@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。<br>2、一般写在mappe接口（DAO接口）的入参，对应xml中#{}中的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">Mapper接口方法：</span><br><span class="line">public int findById(@Param(&quot;userId&quot;) int userId);</span><br><span class="line">对应的xml文件：</span><br><span class="line"> &lt;select id=&quot;findById&quot; resultMap=&quot;baseMap&quot;&gt;</span><br><span class="line">    select &lt;include redif=&quot;all_column_list&quot;&gt; from table_name</span><br><span class="line">    where user_id = #&#123;userId&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p>
<p>使用了@Param后，可以不用parameterType？ 存疑</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><p>在使用Mybatis持久层框架来操作数据库时，我们可以使用@Mapper注解和@MapperScan注解来将Mapper接口类交给Sprinig进行管理。</p>
<p>目的就是为了不再写mapper映射文件（xml文件）。</p>
<p>Spring Boot的核心理念是：不建议使用xml文件配置。但是，这对MyBatis来说进退两难，因为MyBatis离不开xml，需要xml来配置sql语句。为了迎合Spring Boot的发展理念，MyBatis官方开发了mybatis-spring-boot-starter，我们要想更少的依赖xml，需要深入的研究mybatis-spring-boot-starter中的用法，尤其是@MapperScan和@Mapper的用法。</p>
<p>一、注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解<br>在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类</p>
<p>二、@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。指定要变成实现类的接口所在的包<br>添加位置：是在Springboot启动类上面添加，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication  </span><br><span class="line">@MapperScan(&#123;&quot;cn.mybatis.mappers.class&quot;,&quot;cn.mybatis.mappers.student&quot;&#125;)  </span><br><span class="line">public class SpringbootMybatisDemoApplication&#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">       SpringApplication.run(SpringbootMybatisDemoApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终实现：直接在Mapper类中采用注解的形式操作数据库，通过@MapperScan扫描制定的映射器存放路径，最终不需要加任何注解，也不需要对应的xml文件来配置sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//不需要加任何注解，也不需要对应的xml文件</span><br><span class="line">public interface UserMapper&#123;</span><br><span class="line">     @Select(&quot;select * from user&quot;)</span><br><span class="line">     List&lt;User&gt; getUserList(String userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="http://www.mybatis.cn/archives/862.html">http://www.mybatis.cn/archives/862.html</a></p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>@PostContruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。可作为一些数据的常规化加载，比如数据字典之类的。</p>
<p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public @PostConstruct void someMethod()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行时机：在依赖注入完成后被自动调用。在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct &gt;&gt; init &gt;&gt; service &gt;&gt; destroy &gt;&gt; PreDestroy</p>
<p>该注解与BeanPostProcessor接口有关，它有个实现类CommonAnnotationBeanPostProcessor，就是专门处理@PostConstruct  @PreDestroy注解。</p>
<hr>
<p>InitialzingBean接口的afterPropertiesSet和配置bean时的init-method，也有类似功能。</p>
<p>initMethod和InitializingBean是spring提供的两种对类的属性进行装配的方式。initMethod和InitializingBean指定方法的执行顺序在普通属性装配之后，initMethod指定的方法又在InitializingBean指定的方法之后执行。</p>
<p>三者执行顺序：Construction &gt; 对象属性set() 方法-&gt; @PostConstruct -&gt; InitializingBean -&gt; initMethod</p>
<p>总结：可不可以理解为@PostConstruct在初始化自己bean时，依赖注入其他属性bean后执行，而InitialzingBean接口又是在它后面。</p>
<p>参考：<a href="https://blog.csdn.net/chinawangfei/article/details/122825129">https://blog.csdn.net/chinawangfei/article/details/122825129</a></p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>@Deprecated是java内置注解，此注解可以用在方法，属性，类上，表示已废弃，不维护，可能会删除。<br>表示不推荐程序员使用，但是还可以使用。</p>
<h3 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h3><p>用于对象属性字段的规则检测，为了避免使用冗余的代码进行if判断，使用@Valid注解实现。</p>
<p>是Spring中的注解，需要引入依赖，如果是 springboot 项目，那么可以不用引入了，已经引入了，就存在于最核心的 web 开发包 spring-boot-starter-web 里面。</p>
<p>如果不是，需要引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法：在被检验的实体类中，使用注解加一些限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NotBlank(message = &quot;请输入名称&quot;)</span><br><span class="line">@Length(message = &quot;名称不能超过个 &#123;max&#125; 字符&quot;, max = 10)</span><br><span class="line">public String name;</span><br><span class="line"> </span><br><span class="line">@NotNull(message = &quot;请输入年龄&quot;)</span><br><span class="line">@Range(message = &quot;年龄范围为 &#123;min&#125; 到 &#123;max&#125; 之间&quot;, min = 1, max = 100)</span><br><span class="line">public Integer age;</span><br><span class="line"></span><br><span class="line">@Email(message = &quot;邮箱不正确&quot;)</span><br><span class="line">@Min(value = 1000000)</span><br><span class="line"></span><br><span class="line">@NotEmpty(message=&quot;不能为空&quot;)</span><br><span class="line">@Size(message=&quot;最多5个&quot;, max=5)</span><br><span class="line">private List&lt;Intefer&gt; list;</span><br></pre></td></tr></table></figure>

<p>在Controller的对应方法中，对传入参数加@Valid注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/action/register&quot;)</span><br><span class="line">public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;</span><br><span class="line">    return userService.register(registerUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_43587472/article/details/110388778">https://blog.csdn.net/weixin_43587472/article/details/110388778</a></p>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><p>springframework中的注解。<br>声明式事务管理，是建立在AOP之上，本质上是对方法前后进行拦截，然后再目标方法开始之前创建或加入一个一个事务，在执行完目标方法之后，根据执行情况提交或者回滚事务。</p>
<p>简而言之：@Transactional注解在代码执行出错时进行事务的回滚。</p>
<p>java异常模型：<br>Throwable是最顶层的父类，有Error和Exception两个子类。<br>Error表示严重的错误（如OOM等）；<br>Exception可以分为运行时异常（RuntimeException及其子类）和非运行时异常（Exception的子类中，除了RuntimeException及其子类之外的类）。</p>
<p>非运行时异常是检查异常（checked exceptions），一定要try catch，因为这类异常是可预料的，编译阶段就检查的出来；<br>Error和运行时异常是非检查异常（unchecked exceptions），不需要try catch，因为这类异常是不可预料的，编辑阶段不会检查，没必要检查，也检查不出来。</p>
<p>spring的@Transactional注解可以很方便的开启事务，但是默认只在遇到运行时异常和Error时才会回滚，非运行时异常不回滚，即Exception的子类中，除了RuntimeException及其子类，其他的类默认不回滚。</p>
<p>而rollbackFor属性可以解决这个问题，rollbackFor = Exception.class表示Exception及其子类的异常都会触发回滚，同时不影响Error的回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 运行时异常，正常回滚</span><br><span class="line">@Transactional</span><br><span class="line">public void save()&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new RuntimeException(&quot;我是异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非运行时异常，加rollbackFor属性，抛出异常，并回滚</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void save() throws IOException&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new IOException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/c5988db897fc">https://www.jianshu.com/p/c5988db897fc</a></p>
<p>使用方法：<br>1.需要在启动类上添加@EnableTransactionManagement注解。<br>2.当作用在类上，该类所以public方法都具有该类型的事务属性。也可以加在public方法上。</p>
<p><a href="https://blog.51cto.com/u_9177933/2978291">https://blog.51cto.com/u_9177933/2978291</a></p>
<h3 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h3><p>✅java的异常体系</p>
<p><img src="https://img-blog.csdnimg.cn/2019101117003396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MjI5NTY3,size_16,color_FFFFFF,t_70"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1/0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<p>✅@SneakyThrows的作用：<br>普通Exception类,也就是我们常说的受检异常或者Checked Exception会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成IOException。</p>
<p>但是现实大部分情况下的异常，我们都是一路往外抛了事。所以渐渐的java程序员处理Exception的常见手段就是外面包一层RuntimeException，接着往上丢.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Lombok的@SneakyThrows就是为了消除这样的模板代码。<br>使用注解后不需要担心Exception的处理.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">public class SneakyThrowsExample implements Runnable &#123;</span><br><span class="line">  @SneakyThrows(UnsupportedEncodingException.class)</span><br><span class="line">  public String utf8ToString(byte[] bytes) &#123;</span><br><span class="line">    return new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @SneakyThrows</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    throw new Throwable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：最重要的是throw (T)t, 使用泛型,将传入的Throwable强转为RuntimeException异常.<br>虽然, 我们抛出的异常不是RuntimeException,但是可以骗过javac编译器,泛型最后存储为字节码文件时并没有泛型信息.</p>
<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/qq_22162093/article/details/115486647">https://blog.csdn.net/qq_22162093/article/details/115486647</a></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>@Data注解是lombok.jar包下的注解，该注解通常用在实体bean上，不需要写出set和get方法，但是具备实体bean所具备的方法，简化编程提高变成速度。</p>
<p>@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。</p>
<p>@Data ：注在类上，提供类的get、set、equals、hashCode、toString等方法<br>@AllArgsConstructor ：注在类上，提供类的全参构造<br>@NoArgsConstructor ：注在类上，提供类的无参构造<br>@Setter ：注在属性上，提供 set 方法<br>@Getter ：注在属性上，提供 get 方法<br>@EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法<br>@Log4j/@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log</p>
<h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>lombok中的注解。可用于生成有参构造函数，也可以方便在写controller或者Service层的时候，需要注入很多的mapper接口或者另外的service接口的时候就避免会写很多的@Autowired注解。</p>
<p>实体类有参构造函数：<br>必须声明的变量为final</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">static class Person &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequiredArgsConstructor(onConstructor =@_(@Autowired))<br>写在类上可以代替@Autowired注解，需要注意的是在注入时需要用final定义，或者使用@notnull注解.<br>当我们需要注入Bean的时候可以直接在类名称上使用。代替了Autowrited注解.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/v1/demo&quot;)</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class DemoController &#123;</span><br><span class="line">    private final DemoService demoService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>作用：抑制编译器警告，有时候可以看到idea中有警告的颜色标注，当我们不希望看到这些警告的时候，可以使用 SuppressWarnings注解来抑制警告信息。<br>在<code>&#123;&quot; &quot;&#125; </code>中，可以写入你希望抑制(不显示)警告信息。</p>
<p>例如：<br><code>@SuppressWarnings&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all，抑制所有警告</span><br><span class="line">boxing，抑制与封装/拆装作业相关的警告</span><br><span class="line">cast，抑制与强制转型作业相关的警告</span><br><span class="line">dep-ann，抑制与淘汰注释相关的警告</span><br><span class="line">deprecation，抑制与淘汰的相关警告</span><br><span class="line">fallthrough，抑制与switch陈述式中遗漏break相关的警告</span><br><span class="line">finally，抑制与未传回finally区块相关的警告</span><br><span class="line">hiding，抑制与隐藏变数的区域变数相关的警告</span><br><span class="line">incomplete-switch，抑制与switch陈述式(enum case)中遗漏项目相关的警告</span><br><span class="line">javadoc，抑制与javadoc相关的警告</span><br><span class="line">nls，抑制与非nls字串文字相关的警告</span><br><span class="line">null，抑制与空值分析相关的警告</span><br><span class="line">rawtypes，抑制与使用raw类型相关的警告</span><br><span class="line">resource，抑制与使用Closeable类型的资源相关的警告</span><br><span class="line">restriction，抑制与使用不建议或禁止参照相关的警告</span><br><span class="line">serial，抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告</span><br><span class="line">static-access，抑制与静态存取不正确相关的警告</span><br><span class="line">static-method，抑制与可能宣告为static的方法相关的警告</span><br><span class="line">super，抑制与置换方法相关但不含super呼叫的警告</span><br><span class="line">synthetic-access，抑制与内部类别的存取未最佳化相关的警告</span><br><span class="line">sync-override，抑制因为置换同步方法而遗漏同步化的警告</span><br><span class="line">unchecked，抑制与未检查的作业相关的警告</span><br><span class="line">unqualified-field-access，抑制与栏位存取不合格相关的警告</span><br><span class="line">unused，抑制与未用的程式码及停用的程式码相关的警告</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/qq_41684621/article/details/123807986">https://blog.csdn.net/qq_41684621/article/details/123807986</a></p>
<p>✅<code>Raw use of parameterized class</code> 参数化类型的原始使用</p>
<p>指出省略了类型的参数化类的使用。这种对参数化类型的原始使用在Java中是有效的，但是会破坏使用类型参数的目的，并可能掩盖错误。此检查反映了编译阶段对原始类型的警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList(); //不指定范型，默认为Object类型</span><br><span class="line">list.add(&quot;123&quot;);</span><br><span class="line">list.add(1L);</span><br><span class="line">list.add(0.11d);</span><br><span class="line">// 可以这样构造list，但是下面转类型会出错，不能吧String类型转为double。</span><br><span class="line">//java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double</span><br><span class="line">for (Object o : list) &#123;</span><br><span class="line">    double a = (double) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是直接使用原生态类型的实现，在编译时期不会有任何问题，但是一旦运行就会报错：Exception in thread “main” java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double，代码设计应该使错误尽早被发现，而这就是不安全的表现了，而且可读性而言，缺少了形式类型参数，我们很难明白List存储的类型是什么，表述性变差。</p>
<p>如果确定使用是安全的，不会在运行时候导致错误，则可通过 <code>@SuppressWarnings(&quot;rawtypes&quot;)</code>消除使用原生态类型警告。</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1677759">https://cloud.tencent.com/developer/article/1677759</a></p>
<p>✅<code>Unchecked call to ... </code> 调用未经检查</p>
<p>比如上面add的时候就会提示，表示未检查add的参数的类型，因为定义list的时候没指定类型，如果指定类型就不报了。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java诊断</title>
    <url>/2022/09/10/myblog/JAVA/java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="java诊断工具arthas"><a href="#java诊断工具arthas" class="headerlink" title="java诊断工具arthas"></a>java诊断工具arthas</h2><h3 id="✅简介"><a href="#✅简介" class="headerlink" title="✅简介"></a>✅简介</h3><p>Arthas 是Alibaba开源的Java诊断工具。安装在系统所在服务器。可以帮助开发人员或者运维人员查找问题，分析性能，bug追踪。</p>
<p>解决问题：<br>1、以全局视角来查看系统的运行状况、健康状况。<br>2、反编译源码，查看jvm加载的是否为预期的文件内容。<br>3、查看某个方法的返回值，参数等等。<br>4、方法内调用路径及各方法调用耗时。<br>5、查看jvm运行状况。<br>6、外部.class文件重新加载到jvm里。<br>等等…..</p>
<p>场景：<br>1）调用接口时，接口返回异常信息，如果该异常信息没有清晰的定位到代码，那么我们通常只能依靠大脑回忆代码，来估计错误发生地了，如果无法估计，一般情况下就会进入测试环境，模拟复现，如果无法复现。<br>2）这个查询，耗时20s，我们想要分析一下到底是哪些代码导致的。但是该方法内部又穿插调用了其它业务功能方法，难道手写System.currentTimeMillis()自己做减运算，还是guava的StopWatch亦或是commons的StopWatch？这几种方式需要我们手动嵌入代码，容易遗漏、费力还费时。<br>等等<br>arthas可以为我们解决上述问题，帮助程序员尽早下班，尽早交代。</p>
<h3 id="✅安装启动"><a href="#✅安装启动" class="headerlink" title="✅安装启动"></a>✅安装启动</h3><p>下载: wget <a href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a><br>启动: java -jar arthas-boot.jar</p>
<p>退出arthas<br>quit —— 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响<br>shutdown —— 关闭 Arthas 服务端，所有 Arthas 客户端全部退出 &amp; 重置所有增强过的类，就不用单独调用reset</p>
<h3 id="✅应用"><a href="#✅应用" class="headerlink" title="✅应用"></a>✅应用</h3><p>1、查看某方法耗时</p>
<p><code>trace cn.asae.e.contract.web.ContractController getContract</code></p>
<p>2、显示进程相关信息，仪表盘</p>
<p><code>dashboard</code></p>
<p>3、查看类里某个方法的返回值和入参</p>
<p>命令+类完全限定名+监测方法+表达式<br><code>watch cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs &quot;&#123;params,returnObj&#125;&quot;</code></p>
<p>4、时空隧道</p>
<p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p>
<p><code>tt -t cn.asae.e.contract.web.ContractSubjectController getContractSubjectLogs</code><br>-t 代表记录下每次方法执行情况</p>
<p>5、查看JVM已加载的类信息</p>
<p><code>sc -d cn.asae.e.contract.web.ContractSubjectController</code></p>
<p>-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。<br>如果一个类被多个ClassLoader所加载，则会出现多次</p>
<p>转自：<a href="https://www.cnblogs.com/jiawen010/p/15513454.html">https://www.cnblogs.com/jiawen010/p/15513454.html</a></p>
<p>其他：<a href="https://blog.csdn.net/weixin_37650458/article/details/123561000">https://blog.csdn.net/weixin_37650458/article/details/123561000</a></p>
<h2 id="fullGC"><a href="#fullGC" class="headerlink" title="fullGC"></a>fullGC</h2><h3 id="✅什么是GC-amp-heap分区"><a href="#✅什么是GC-amp-heap分区" class="headerlink" title="✅什么是GC &amp; heap分区"></a>✅什么是GC &amp; heap分区</h3><p>Java垃圾回收机制，Java通过可达性分析一个对象的引用是否存在，当不存在的时候，将回收堆中的对象。回收无用内存空间</p>
<p>一般而言，GC主要是针对运行的数据区的。作为程序员要关注的区域主要有5块，分别是方法区(Method Area)，Java栈(Java stack)，本地方法栈(Native Method Stack)，堆(Heap)，程序计数器(Program Counter Register)。实际jvm在管理内存的时候，比这个分的更细致，只不过做应用程序开发，我们只需要关注这5块就可以了。</p>
<p>“堆”，也就是Heap了，它是Jvm管理的内存中最大的一块。程序的主要数据也都是存放在堆内存中的，也就是说程序所创建的对象基本上都在该区域进行内存分配，这一块区域被所有的线程所共享，通常出现线程安全问题的一般都是这个区域的数据出现的问题。通常我们所说的gc主要是针对java heap这块区域的。</p>
<p>Heap区在设计上是分代设计的，其划分为了Eden、Survivor 和 Tenured/Old ，其中Eden区、Survivor(存活)属于年轻代，Tenured/Old区属于老年代或者持久代。</p>
<p>一般我们将年轻代发生的GC称为Minor GC，对老年代进行GC称为Major GC。</p>
<p>而FullGC是对整个堆来说的，在最近几个版本的JDK里默认包括了对永生带即方法区的回收(JDK8中无永生带了)，出现Full GC的时候经常伴随至少一次的Minor GC,但非绝对的。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<hr>
<p>JVM的堆区对象分配的一般规则：</p>
<ol>
<li><p>对象优先在Eden区分配，当eden不够分配时，进行一次minor gc。（java对象大多很快没掉，所以minor gc很频繁）</p>
</li>
<li><p>大对象直接进入老年代(-XX:PretenureSizeThreshold=3145728 这个参数来定义多大的对象直接进入老年代)</p>
</li>
<li><p>长期存活的对象将进入老年代(-XX:MaxTenuringThreshold=1设置晋升老年代的年龄阈值)</p>
</li>
<li><p>动态对象年龄判定：虚拟机并不会永远地要求对象的年龄都必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄的所有对象的大小总和大于Survivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>
</li>
<li><p>空间分配担保：计算新生代minor gc后剩下的对象若survivor无法容纳，是否能通过老年代来担保分配空间，如果不能，需要触发一次full gc。HandlePromotionFailure=false设置是否允许老年代担保。</p>
</li>
<li><p>只要老年代的连续空间大于(新生代所有对象的总大小或者历次晋升的平均大小)就会进行minor GC，否则会进行full GC。</p>
</li>
</ol>
<h3 id="✅FullGC的触发条件"><a href="#✅FullGC的触发条件" class="headerlink" title="✅FullGC的触发条件"></a>✅FullGC的触发条件</h3><p>FullGC是针对整个Heap区而言的，它将在以下几种情况被触发：</p>
<p>1、在程序中调用了System.gc()方法。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI(Java远程方法调用)调用System.gc。</p>
<p>2、老年代空间不足。老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误【java.lang.OutOfMemoryError: Java heap space】，而为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>3、Permanet Generation空间满了。也就是以前所说的方法区，Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC（concurrent mark sweep 标记清除算法）的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p>4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。分配很大的对象。所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但停顿时间不得不变长了，JVM设计者们还提供了另外一个参数 <code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p>
<h3 id="✅分代收集算法"><a href="#✅分代收集算法" class="headerlink" title="✅分代收集算法"></a>✅分代收集算法</h3><p>针对年轻代和老年代，JVM将使用不同的垃圾收集算法进行收集，达到高效的垃圾回收。</p>
<p>1、年轻代采用的是标记-复制算法，将需要回收的对象标记，将不需要的对象移动到Survivor空间，然后将标记对象回收，该算法可以实现对大多数会失效的对象进行回收，对少部分不需要回收的对象进行转移，保证eden区拥有连续的内存空间，而且复制的效率高。</p>
<p>因为在年轻代不需要回收的对象一般是很少的，每次垃圾收集时都有大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>2、老年代采用的是标记-整理算法，将需要回收的对象标记，将不需要的对象进行移动整理，使不需要回收的对象占用连续的内存空间，再清除回收对象，保证老年代拥有连续的内存空间，而且整理效率高。</p>
<p>因为在老年代需要回收的对象一般是很少的，其存活率较高、没有额外空间对它进行分配担保。</p>
<p>3、CMS GC（concurrent mark sweep 标记清除算法）老年代中使用：标记所有需要回收的对象，在标记完后统一回收。缺点：标记清除效率不高，产生碎片多。但是并发收集，低停顿。</p>
<p>转自：<a href="https://blog.csdn.net/weixin_35291771/article/details/114075710">https://blog.csdn.net/weixin_35291771/article/details/114075710</a></p>
<p>探秘Java虚拟机——内存管理与垃圾回收：<br><a href="http://www.blogjava.net/chhbjh/archive/2012/01/28/368936.html">http://www.blogjava.net/chhbjh/archive/2012/01/28/368936.html</a></p>
<h3 id="✅什么是fullgc"><a href="#✅什么是fullgc" class="headerlink" title="✅什么是fullgc"></a>✅什么是fullgc</h3><p>一些概念：</p>
<p>GC<br>GC 全称为garbage collection,中文含义为垃圾回收，在jvm中的含义为回收无用内存空间</p>
<p>Young space<br>中文名为年轻代或者新生代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较短的对象</p>
<p>Tenured space<br>中文名为老年代或年老代，为JVM 堆的一部分，由分代GC概念划分而来，保存生命周期较长的对象</p>
<p>Minor GC<br>minor gc指的是发生在年轻代或者说新生代（Young space）中的gc，也有人称其为young gc或者ygc,在下文中我们统一使用minor gc表示</p>
<p>Major GC<br>major gc指的是发生在老年代（Tenured space）中的gc，也有人称为old gc,o gc,cms gc等，在下文我们统一使用major gc表示</p>
<p>stop the world<br>指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现看起来就像是全世界都停止运转了一样,而不论何种gc算法，不论是minor gc还是major gc都会stop the world，区别只在于stop the world的时间长短。</p>
<p><strong>什么是Full GC</strong></p>
<p>先说一下结论，Full GC这个概念是没有官方定义的，而且含义还特别混乱，在不同地方表达的含义是不同的，需要就不同的场景分别进行讨论。</p>
<p>大众认知上：<br>在通常意义上人们口中说的Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等，这个是最常见的一种认知，很多人也就了解到这个程度，因此在遇到一些特殊场景的时候就会发现实际情况和自己的认知会发生冲突</p>
<p>从GC日志上：<br>在gc.log中会发现在部分gc日志头中也有Full GC这样的字眼，这里表示的含义是在这次GC的全过程中，都是Stop The world的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态</p>
<p>阿里老哥总结的：<a href="https://blog.csdn.net/kep159/article/details/103088438">https://blog.csdn.net/kep159/article/details/103088438</a></p>
<h3 id="✅jstat查看GC"><a href="#✅jstat查看GC" class="headerlink" title="✅jstat查看GC"></a>✅jstat查看GC</h3><p><strong>使用jstat 查出来的FGC 次数和时间，实际上指的是老年代的收集器发生Stop the world 的次数和持续时间</strong></p>
<p>1、查询GC使用情况：<br><code>jstat -gcutil 23484 1000 5</code></p>
<p>1000是间隔时间，5是总共打印5次，可缺省。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0: 新生代中Survivor space 0区已使用空间的百分比</span><br><span class="line">S1: 新生代中Survivor space 1区已使用空间的百分比</span><br><span class="line">E: 新生代已使用空间的百分比</span><br><span class="line">O: 老年代已使用空间的百分比</span><br><span class="line">M：元数据区使用比例</span><br><span class="line">CCS：压缩使用比例</span><br><span class="line">YGC: 从应用程序启动到当前，发生Yang GC 的次数</span><br><span class="line">YGCT: 从应用程序启动到当前，Yang GC所用的时间【单位秒】</span><br><span class="line">FGC: 从应用程序启动到当前，发生Full GC的次数</span><br><span class="line">FGCT: 从应用程序启动到当前，Full GC所用的时间</span><br><span class="line">GCT: 从应用程序启动到当前，用于垃圾回收的总时间【单位秒】</span><br></pre></td></tr></table></figure>

<p>2、垃圾总体回收统计<br><code>jstat -gc 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 68.75   0.00  62.73   0.17  96.39  90.54      2    0.010     0    0.000    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区的大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">OC：老年代大小</span><br><span class="line">OU：老年代使用大小</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure>

<p>3、新生代垃圾回收统计<br><code>jstat -gcnew 91185 1000 5</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">5120.0 5120.0 3520.2    0.0  7  15 5120.0  33280.0  20877.8      2    0.010</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">TT:对象在新生代存活的次数</span><br><span class="line">MTT:对象在新生代存活的最大次数</span><br><span class="line">DSS:期望的幸存区大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br></pre></td></tr></table></figure>

<p>4、堆内存统计<br><code>jstat -gccapacity 18528 1000 5 //整体统计</code><br><code>jstat -gcnewcapacity 18528 1000 5 //新生代统计</code><br><code>jstat -gcoldcapacity 18528 1000 5 //老年代统计</code></p>
<h2 id="java堆栈"><a href="#java堆栈" class="headerlink" title="java堆栈"></a>java堆栈</h2><h3 id="✅java内存空间"><a href="#✅java内存空间" class="headerlink" title="✅java内存空间"></a>✅java内存空间</h3><p>JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：程序计数器。2：本地方法栈。3：方法区。4：栈。5：堆。<br>堆和栈都是Java用来在RAM中存放数据的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序计数器：线程私有，存储当前线程所执行的字节码行号指示器。</span><br><span class="line">循环、跳转、异常处理、线程恢复等基础功能都依赖该计数器。溢出概率极低。</span><br><span class="line"></span><br><span class="line">java虚拟机栈：线程私有。局部变量表的大小在编译器确定。</span><br><span class="line">方法的相关调用信息、变量信息，对象的引用。</span><br><span class="line">会抛出：StackOverflowError和OutOfMemoryError</span><br><span class="line"></span><br><span class="line">本地方法栈：为本地方法所服务</span><br><span class="line"></span><br><span class="line">java堆：线程共享区域，存储对象实例及数组。有可能抛出OutOfMemoryError</span><br><span class="line"></span><br><span class="line">方法区：线程共享区域，存储已被虚拟机加载的类信息、常量、静态变量，即时变异后的代码。</span><br><span class="line">又叫永久代，java8中逐步取消，被metaspace元数据区取代。有可能抛出OutOfMemoryError</span><br><span class="line"></span><br><span class="line">直接内存：NIO机制，使用Native函数库直接分配堆外内存。</span><br></pre></td></tr></table></figure>

<p>1、堆</p>
<p>可以把堆理解为一家餐厅，里面有200张桌子，也就是最多能同时容纳200桌客人就餐，来一批客人就为他们安排一些桌子，如果某天来的客人特别多，超过200桌了，那就不能再接待超出的客人了。</p>
<p>当然，进来吃饭的客人不可能是同时的，有的早，有的晚，先吃好的客人，老板会安排给他们结账走人，然后空出来的桌子又能接待新的客人。</p>
<p>这里，堆就是餐厅，最大容量200桌就是堆内存的大小，老板就相当于GC(垃圾回收)，给客人安排桌子就相当于java创建对象的时候分配堆内存，结账就相当于GC回收对象占用的空间。</p>
<p>2、栈</p>
<p>接着把栈比作一口废井，这口井多年不用已经没水了，主人现在把它作为贮存自酿酒的地方，存酒的时候就用绳子勾着酒坛子慢慢放下去，后面再存就一坛一坛堆着放上去，取酒的时候就先取最上面的坛子。</p>
<h3 id="✅什么时候存到堆Heap里"><a href="#✅什么时候存到堆Heap里" class="headerlink" title="✅什么时候存到堆Heap里"></a>✅什么时候存到堆Heap里</h3><p>存放：存放由new创建的对象和数组。</p>
<p>在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，会在栈中定义一个引用变量，这个变量的取值等于数组或者对象在堆内存中的首地址，引用变量相当于为数组或者对象起的一个别名，或者代号。</p>
<p>数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p>
<p>堆内存的特点是什么？<br>第一点：堆其实可以类似的看做是管道，或者说是平时去排队买票的情况差不多，所以堆内存的特点就是：先进先出，后进后出，也就是你先排队好，你先买票。<br>第二点：堆可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但缺点是，由于要在运行时动态分配内存，存取速度较慢。<br>new对象在堆中如何分配？<br>由Java虚拟机的自动垃圾回收器来管理。</p>
<h3 id="✅什么时候存到栈Stack里"><a href="#✅什么时候存到栈Stack里" class="headerlink" title="✅什么时候存到栈Stack里"></a>✅什么时候存到栈Stack里</h3><p>存放：在函数中定义的一些基本类型的变量(8种，int, short, long, byte, float, double, boolean, char，不包含String)和对象的引用变量、main方法、方法函数</p>
<p>当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</p>
<p>栈内存的特点<br>第一点：栈内存就好像一个矿泉水瓶，往里面放入东西，那么先放入的沉入底部，所以它的特点是：先进后出，后进先出<br>第二点：存取速度比堆要快，仅次于寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
<p>栈中主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和对象句柄。<br>栈内存分配机制<br>栈内存可以称为一级缓存，由垃圾回收器自动回收<br>例子：<br>int a = 3;<br>int b = 3;</p>
<h3 id="✅堆栈的区别"><a href="#✅堆栈的区别" class="headerlink" title="✅堆栈的区别"></a>✅堆栈的区别</h3><p>JVM是基于堆栈的虚拟机，JVM为新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p>
<p>差异：<br>1). 堆内存用来存放由new创建的对象和数组<br>2). 栈内存用来存放方法或者局部变量等<br>3). 堆是先进先出，后进后出<br>4). 栈是先进后出，后进先出<br>5). 共享性的不同：栈内存是线程私有的，<strong>堆内存是所有线程共有的</strong><br>6). 生存空间不同：栈中数据的生存空间一般在当前scopes内(就是由{…}括起来的区域).</p>
<p>栈：</p>
<p>函数中定义的基本类型变量，对象的引用变量都在函数的栈内存中分配。<br>栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。<br>栈内存中的数据，没有默认初始化值，需要手动设置。</p>
<p>堆：</p>
<p>堆内存用来存放new创建的对象和数组。<br>堆内存中所有的实体都有内存地址值。<br>堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。<br>堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）</p>
<h3 id="✅String-str-“abc”的内部工作"><a href="#✅String-str-“abc”的内部工作" class="headerlink" title="✅String str = “abc”的内部工作"></a>✅String str = “abc”的内部工作</h3><p>(1)先定义一个名为str的对String类的对象引用变量：String str；</p>
<p>(2)在栈中查找有没有存放值为”abc”的地址（引用），如果没有，则在栈中开辟一个存放字面值为”abc”的地址，接着在堆中创建一个新的String类的对象“abc”，并将该字符串指向这个地址，而且在栈中这个地址旁边记下这个引用的对象“abc”。如果已经有了值为”abc”的地址，则查找对象“abc”，并返回“abc”的地址。</p>
<p>(3)将str指向对象“abc”的地址。</p>
<p>值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！<br><strong>（有点问题，指向的是堆中的字符串常量池里的字符串吧？？）</strong></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  </span><br><span class="line">System.out.println(str1==str2); //true</span><br></pre></td></tr></table></figure>

<p>str1.equals(str2)；的方式是将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。<br>结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。实现堆中数据的共享。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = “abc”;  </span><br><span class="line">String str2 = “abc”;  //没创建新对象，创建了一个新引用变量</span><br><span class="line">str1 = “bcd”;   //改变值，只能创建一个新对象，引用变量指向新的对象</span><br><span class="line">System.out.println(str1 + “,” + str2); //bcd, abc  </span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。</p>
<p>💡原因：事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str1 = new String(“abc”);</span><br><span class="line">String str2 = “abc”;</span><br><span class="line">System.out.println(str1==str2); //false</span><br></pre></td></tr></table></figure>

<p>💡原因：只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。<br><strong>（与字符串常量池共享吧？）</strong></p>
<p><strong>意思是：String str = “abc” 的创建对象方式，会在栈中保存“abc”。（字符串常量池中吧？）如果多次这样创建一个值的String对象，会先去栈里看有没有，如果有，堆里就不新建对象了，栈里新建一个引用变量指向那个对象，如果没有就新建，但是new方式不会看，都是新建。</strong></p>
<p>结论：</p>
<p>(1)我们在使用诸如String str = “abc”; 的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为”abc”的String对象。</p>
<p>(2)使用String str = “abc”; 的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”); 的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。</p>
<p>(3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。</p>
<p>(4)由于String类的不可改变immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p>
<p>参考：<br>程序中堆栈空间加载过程：<a href="https://www.jb51.net/article/229958.htm">https://www.jb51.net/article/229958.htm</a><br>堆栈区别、String创建过程：<a href="https://zhuanlan.zhihu.com/p/529280783">https://zhuanlan.zhihu.com/p/529280783</a></p>
<h3 id="String不可变怎么理解"><a href="#String不可变怎么理解" class="headerlink" title="String不可变怎么理解"></a>String不可变怎么理解</h3><p>看了一圈优点模糊，主要几个疑问：<br>1、<code>String s = &quot;abc&quot;;</code>，到底怎么个流程，已有的字符串怎么找到的。<br>2、字符串常量池在哪里存的。初步结论是java8在堆中。<br>3、运行时常量池和字符串常量池？</p>
<p><strong>看看jvm虚拟机再解惑吧</strong></p>
<p>string类为什么是不可变的：<br><a href="https://blog.csdn.net/liuqinhou/article/details/126160186">https://blog.csdn.net/liuqinhou/article/details/126160186</a></p>
<p>String源码角度分析为什么不可变，通过反射的方法改变：<br><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></p>
<p>浅谈为什么Java里面String类是不可变的：<br><a href="https://www.jb51.net/article/157814.htm">https://www.jb51.net/article/157814.htm</a></p>
<p>String是如何实现其对象不可变：<br><a href="https://zhuanlan.zhihu.com/p/498718374">https://zhuanlan.zhihu.com/p/498718374</a></p>
<p>Java 常量池详解（一）字符串常量池：<br><a href="https://blog.csdn.net/Prior_SX/article/details/123463430">https://blog.csdn.net/Prior_SX/article/details/123463430</a></p>
<p>字符串常量池和运行时常量池是在堆还是在方法区？<br><a href="https://www.cnblogs.com/cosmos-wong/p/12925299.html">https://www.cnblogs.com/cosmos-wong/p/12925299.html</a></p>
<p>Java8中字符串常量池到底是在哪里：<br><a href="https://blog.51cto.com/u_14234228/2489846">https://blog.51cto.com/u_14234228/2489846</a></p>
<h3 id="✅堆内存共享性问题"><a href="#✅堆内存共享性问题" class="headerlink" title="✅堆内存共享性问题"></a>✅堆内存共享性问题</h3><p>问题来源：既然各个java进程共享堆内存，那么看fullgc的情况跟哪个进程线程有什么关系呢？</p>
<p>没错，堆是全局共享的，但是会存在一些问题</p>
<p>就是多个线程在堆上同时申请空间，如果在并发的场景中，两个线程先后把对象引用指向了同一个堆的内存区域，那可能就会出现问题；为了解决这个问题呢，就得进行同步控制，说到同步控制，就会影响到效率。</p>
<p>为了解决这个并发问题，对象的内存分配过程就必须进行同步控制。<br>HotSpot虚拟机（HotSpot虚拟机是目前最流行的虚拟机）的方案：<br>每个线程在Java堆中预先分配一小块内存，然后在给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。<br>这种方案被称之为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。</p>
<p><strong>TLAB</strong></p>
<p>TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是<strong>线程专属</strong>的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，<strong>只给当前线程使用</strong>，这样<strong>每个线程都单独拥有一个空间</strong>，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p><strong>所以说，因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。</strong></p>
<p>⚠️TLAB是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。也就是说，虽然每个线程在初始化时都会去堆内存中申请一块TLAB，并不是说这个TLAB区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。并且，在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。</p>
<p>⚠️TLAB带来的问题：<br>TLAB是在eden区分配的，因为eden区域本身就不太大，而且TLAB空间的内存也非常小，默认情况下仅占有整个Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配。<br>遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么我们经常说：小的对象比大的对象分配起来更加高效。<br>————————————————<br>为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”。</p>
<p>当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。</p>
<p>总结：<br>为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。</p>
<p>在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p>
<p>所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分配上，是线程独享的。</p>
<p>TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/jiey0407/article/details/125190629">https://blog.csdn.net/jiey0407/article/details/125190629</a></p>
<h2 id="jvm性能监控工具"><a href="#jvm性能监控工具" class="headerlink" title="jvm性能监控工具"></a>jvm性能监控工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>java virtual machine process status tool<br>jps 主要用来输出 JVM 中运行的进程状态信息</p>
<p>语法格式：<code>jps [options] [hostid]</code><br>如果不指定 hostid 就默认为当前主机或服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure>

<p>jps命令获取实际的进程id，是去用户的临时目录下去拿进程id的。<br>文件路径：/tmp/hsperfdata_{userName}/，存储了当前用户的进程信息。</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>stack trace for java 显示虚拟机的线程快照。<br>jstack 主要用来查看某个 Java 进程内的线程堆栈信息。</p>
<p>语法格式：<code>jstack [option] pid</code><br>如果是在64位机器上，需要指定选项”-J-d64”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br><span class="line">-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</span><br></pre></td></tr></table></figure>

<p>jstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。例如：找出某个 Java 进程中最耗费 CPU 的 Java 线程并定位堆栈信息。</p>
<p>第一步先找出 Java 进程 ID<br><code>ps -ef | grep 应用 | grep -v grep</code></p>
<p>第二步找出该进程内最耗费 CPU 的线程<br>可以使用 <code>ps -Lfp pid </code>或者 <code>ps -mp pid -o THREAD, tid, time</code> 或者 <code>top -Hp pid</code> .【有没有可以输出按时间排序的，且区分daemon的】</p>
<p>使用<code>printf &quot;%x\n&quot; 线程id</code> 将线程id转换为16进制值。</p>
<p><code>jstack 进程id | grep 16进制线程id</code><br>从而定位代码，可能是哪里wait时间长了。</p>
<p><code>jstack -l 进程id 查看进程下所有线程</code></p>
<hr>
<p>jstack打印的信息怎么看：<br>dump 文件里，值得关注的线程状态有：<br>死锁，Deadlock（重点关注）<br>执行中，Runnable<br>等待资源，Waiting on condition（重点关注）<br>等待获取监视器，Waiting on monitor entry（重点关注）<br>暂停，Suspended<br>对象等待中，Object.wait() 或 TIMED_WAITING<br>阻塞，Blocked（重点关注）<br>停止，Parked</p>
<hr>
<p><strong>实例一：Waiting to lock 和 Blocked</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;RMI TCP Connection(267865)-172.16.5.25&quot; daemon prio=10 tid=0x00007fd508371000 nid=0x55ae waiting for monitor entry [0x00007fd4f8684000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at org.apache.log4j.Category.callAppenders(Category.java:201)</span><br><span class="line">- waiting to lock &lt;0x00000000acf4d0c0&gt; (a org.apache.log4j.Logger)</span><br><span class="line">at org.apache.log4j.Category.forcedLog(Category.java:388)</span><br><span class="line">at org.apache.log4j.Category.log(Category.java:853)</span><br><span class="line">at org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234)</span><br><span class="line">at com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110)</span><br></pre></td></tr></table></figure>

<p>说明：<br>1）线程状态是 Blocked，阻塞状态。说明线程等待资源超时！<br>2）“ waiting to lock &lt;0x00000000acf4d0c0&gt;”指，线程在等待给这个 0x00000000acf4d0c0 地址上锁（英文可描述为：trying to obtain  0x00000000acf4d0c0 lock）。<br>3）在 dump 日志里查找字符串 0x00000000acf4d0c0，发现有大量线程都在等待给这个地址上锁。如果能在日志里找到谁获得了这个锁（如locked &lt; 0x00000000acf4d0c0 &gt;），就可以顺藤摸瓜了。<br>4）“waiting for monitor entry”说明此线程通过 synchronized(obj) {……} 申请进入了临界区，从而进入了下图1中的“Entry Set”队列，但该 obj 对应的 monitor 被其他线程拥有，所以本线程在 Entry Set 队列中等待。<br>5）第一行里，”RMI TCP Connection(267865)-172.16.5.25”是 Thread Name 。tid指Java Thread id。nid指native线程的id。prio是线程优先级。[0x00007fd4f8684000]是线程栈起始地址。</p>
<hr>
<p><strong>实例二：Waiting on condition 和 TIMED_WAITING</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;RMI TCP Connection(idle)&quot; daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2 waiting on condition [0x00007fd4f1a59000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</span><br><span class="line">at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</span><br><span class="line">at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）“TIMED_WAITING (parking)”中的 timed_waiting 指等待状态，但这里指定了时间，到达指定的时间后自动退出等待状态；parking指线程处于挂起中。</p>
<p>2）“waiting on condition”需要与堆栈中的“parking to wait for  &lt;0x00000000acd84de8&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)”结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue 并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到 SynchronousQueue 中时必须有另一个线程正在等待接受移交的任务，因此这就是本线程在等待的条件。<br>3）别的就看不出来了。</p>
<hr>
<p><strong>实例三：in Obejct.wait() 和 TIMED_WAITING</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;RMI RenewClean-[172.16.5.19:28475]&quot; daemon prio=10 tid=0x0000000041428800 nid=0xb09 in Object.wait() [0x00007f34f4bd0000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</span><br><span class="line">- locked &lt;0x00000000aa672478&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</span><br><span class="line">at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）“TIMED_WAITING (on object monitor)”，对于本例而言，是因为本线程调用了 java.lang.Object.wait(long timeout) 而进入等待状态。</p>
<p>2）“Wait Set”中等待的线程状态就是“ in Object.wait() ”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ，“ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。</p>
<p>3）RMI RenewClean 是 DGCClient 的一部分。DGC 指的是 Distributed GC，即分布式垃圾回收。</p>
<p>4）请注意，是先 locked &lt;0x00000000aa672478&gt;，后 waiting on &lt;0x00000000aa672478&gt;，之所以先锁再等同一个对象，请看下面它的代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static private class  Lock &#123; &#125;;</span><br><span class="line">private Lock lock = new Lock();</span><br><span class="line">public Reference&lt;? extends T&gt; remove(long timeout)</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">        if (r != null) return r;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            lock.wait(timeout);</span><br><span class="line">            r = reallyPoll();</span><br><span class="line">            ……</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于  locked &lt;0x00000000aa672478&gt; ）；当执行到 lock.wait(timeout);，线程就放弃了 Monitor 的所有权，进入“Wait Set”队列（对应于  waiting on &lt;0x00000000aa672478&gt; ）。<br>5）从堆栈信息看，是正在清理 remote references to remote objects ，引用的租约到了，分布式垃圾回收在逐一清理呢。</p>
<p>转自：<a href="https://www.cnblogs.com/nexiyi/p/java_thread_jstack.html">https://www.cnblogs.com/nexiyi/p/java_thread_jstack.html</a></p>
<h3 id="jmap和jhat"><a href="#jmap和jhat" class="headerlink" title="jmap和jhat"></a>jmap和jhat</h3><p>jmap（Memory Map）和jhat（Java Heap Analysis Tool）</p>
<p>jmap用来查看<strong>堆内存</strong>使用状况，一般结合jhat使用。<br>jmap语法格式：<code>jmap [option] pid</code>  pid为进程id</p>
<p>打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息</p>
<p>使用<strong>jmap -heap pid</strong>查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。</p>
<p>使用<code>jmap -histo pid</code> / <code>jmap -histo:live pid</code>查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象.<br>加上<code>| more</code> 按类别统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap -histo:live 21711 | more </span><br><span class="line">num     #instances         #bytes  class name------------</span><br><span class="line">   1:         38445        5597736  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         38445        5237288  &lt;methodKlass&gt;</span><br><span class="line"></span><br><span class="line">class name是对象类型</span><br></pre></td></tr></table></figure>

<p>还有一个很常用的情况是：用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。jmap进行dump命令格式如下：<code>jmap -dump:format=b,file=dumpFileName pid</code></p>
<p>例如：<code>jmap -dump:format=b,file=/tmp/dump.dat 进程id</code></p>
<p>dump.dat文件很大。<br>dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：<code>jhat -port 9998 /tmp/dump.dat</code><br>然后就可以在浏览器中输入主机地址：9998 查看了。##### ###</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM统计监测工具<br>jvm statistics monitoring tool：用于收集虚拟机各方面的运行数据。</p>
<p>语法格式：<code>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</code></p>
<p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。 例如：<code>jstat -gc 进程id 250 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstat -gc 21711 250 4 </span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line"></span><br><span class="line">S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</span><br><span class="line">运行以来，总耗时，单位s</span><br><span class="line">EC、EU：Eden区容量和使用量</span><br><span class="line">OC、OU：年老代容量和使用量</span><br><span class="line">PC、PU：永久代容量和使用量</span><br><span class="line">YGC、YGT：年轻代GC次数和GC耗时</span><br><span class="line">FGC、FGCT：Full GC次数和Full GC耗时</span><br><span class="line">GCT：GC总耗时</span><br></pre></td></tr></table></figure>

<p>JVM堆内存布局：<br>堆内存 = 年轻代 + 年老代 + 永久代<br>年轻代 = Eden区 + 两个Survivor区（From和To）</p>
<p><code>jstat -gcutil 23484 1000 5</code> 监视内容基本与gc相同，但输出的主要是已占用的总空间的百分比。</p>
<p><code>jstat -gccause 23484 1000 5</code> 查询gc的原因。</p>
<h3 id="hprof"><a href="#hprof" class="headerlink" title="hprof"></a>hprof</h3><p>（Heap/CPU Profiling Tool）<br>hprof能够展现CPU使用率，统计堆内存使用情况。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -agentlib:hprof[=options] ToBeProfiledClass</span><br><span class="line">java -Xrunprof[:options] ToBeProfiledClass</span><br><span class="line">javac -J-agentlib:hprof[=options] ToBeProfiledClass</span><br></pre></td></tr></table></figure>

<p>例如：<code>java -agentlib:hprof=cpu=samples,interval=20,depth=3 主类</code><br>每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，在当前目录。</p>
<p>例如：<code>javac -J-agentlib:hprof=cpu=times Hello.java</code><br>能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）。</p>
<p>JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解：<a href="https://zhuanlan.zhihu.com/p/294950372?utm_medium=social&amp;utm_oi=690843302169178112">https://zhuanlan.zhihu.com/p/294950372?utm_medium=social&amp;utm_oi=690843302169178112</a></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>虚拟机配置信息，<code>jinfo 进程id</code></p>
<h3 id="图像化界面分析工具"><a href="#图像化界面分析工具" class="headerlink" title="图像化界面分析工具"></a>图像化界面分析工具</h3><p>VisualVM、JProfile、MAT</p>
<h2 id="几种排查思路"><a href="#几种排查思路" class="headerlink" title="几种排查思路"></a>几种排查思路</h2><h3 id="线程cpu占用高"><a href="#线程cpu占用高" class="headerlink" title="线程cpu占用高"></a>线程cpu占用高</h3><p>1.<code>ps -ef|grep java</code> 或者 jps 查找出进程id<br>2.<code>top -Hp 进程id</code> 查找出最耗cpu的线程id <code>top -c</code>看进程的<br>3.<code>printf &quot;%x\n&quot;</code> 线程id  转换为16进制的id<br>4.使用<code>jstack 进程id | grep 16进制线程id</code>  查找出堆栈信息，分析</p>
<p>另外，arthas也可以打印出前多少个线程及占有cpu情况<br><code>thread -n 5</code></p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>除了程序计数器，其他内存存储都可能OOM。<br>有可能：数据量大、JVM内存容量参数分配不合理、代码bug死循环无限分配容量<br>1、内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案；<br>2、内存溢出，内存中的对象都还必须存活着，这说明Java堆分配空间不足，检查堆设置大小（-Xmx与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况。</p>
<p>1.先使用jmap看一下堆内存使用情况<br>2.<code>jmap -dump:format=b,file=/tmp/dump.dat 进程id</code> dump文件<br>3.使用MAT工具分析<br>mat工具的使用：<a href="https://developer.aliyun.com/article/44641">https://developer.aliyun.com/article/44641</a></p>
<h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>1.<code>jstat -gcutil 进程id 1000 40</code>查看gc情况，1s一次，40次动态看gc增长<br>2.找到gc.log<br>里面有gc前堆使用空间&gt;gc后堆已使用空间，还有用户态消耗的cpu时间、内核态消耗的cpu时间、操作从开始到结束经过的时间。</p>
<p>模拟gc看日志：<br><a href="https://javastack.blog.csdn.net/article/details/109006521">https://javastack.blog.csdn.net/article/details/109006521</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>log日志与maven打包</title>
    <url>/2022/04/03/myblog/JAVA/log%E6%97%A5%E5%BF%97%E4%B8%8Emaven%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>工作中需要将应用部署在本地，想来之前用go的时候貌似是直接编译运行就在本地部署了，但是java需要用到maven打包，还没打包过，学习一下。顺便工作中查看日志对log4j、sjf4j、logback、lomback这几个东西有点迷糊，所以先学一下日志相关的，然后建工程打包部署在本地看下效果。</p>
<h3 id="1-lombok"><a href="#1-lombok" class="headerlink" title="1.lombok"></a>1.lombok</h3><p>自然不必多说，lombok可以通过简单的注解的形式来帮助我们简化和消除一些必须有但显得很臃肿的Java代码，比如常见的Getter&amp;Setter、toString()、构造函数等等。lombok不仅方便编写，同时也让我们的代码更简洁。</p>
<p>lombok提供了一个功能完整的jar包，可以很方便的与我们的项目进行集成。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>第一步：加入lombok依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>scop=provided，表示它只在编译阶段生效，不需要打入包中，lombok在编译期将带lombok注解的java文件正确编译为完整的class文件。</p>
<p>第二步：idea中添加lombok插件</p>
<p>否则会报缺少方法和没有设置属性的异常。</p>
<p>第三步：设置启用注释处理</p>
<p>设置中 Annotation processors，enable annotation processing。</p>
<h4 id="lombok原理"><a href="#lombok原理" class="headerlink" title="lombok原理"></a>lombok原理</h4><ol>
<li>javac对源代码进行分析，生成了一棵抽象语法树（AST）</li>
<li>编译过程中调用实现了“JSR 269 API”的Lombok程序</li>
<li>此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点</li>
<li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）</li>
</ol>
<h3 id="2-SLF4J"><a href="#2-SLF4J" class="headerlink" title="2.SLF4J"></a>2.SLF4J</h3><h4 id="接口与包关系"><a href="#接口与包关系" class="headerlink" title="接口与包关系"></a>接口与包关系</h4><p>Simple logging Facade for Java，意思为简单日志门面，它是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于<strong>它只是一个接口</strong>，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要<strong>通过接口绑定的具体的日志系统来实现</strong>，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p>
<p>SLF4J只是一个接口，实际使用时必须要结合具体的日志系统来使用，我们首先来看SLF4J和各个具体的日志系统进行绑定时的框架原理图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e5308c09a82e0c57889adea715d6a602.png"></p>
<p>slf4j原理很简单，他只提供一个核心slf4j api(就是slf4j-api.jar包)，这个包只有日志的接口，并没有实现，所以如果要使用就得<strong>再给它提供一个实现了些接口的日志包</strong>，比 如：log4j、common logging、jdk log日志实现包等，但是<strong>这些日志实现又不能通过接口直接调用</strong>，实现上他们根本就和slf4j-api不一致，因此slf4j又增加了一层来<strong>转换各日志实现包的使用</strong>，当然slf4j-simple除外。其结构如下： </p>
<blockquote>
<p>slf4j-api(接口层)<br> | |<br>各日志实现包的连接层( slf4j-jdk14, slf4j-log4j)<br> | |<br>各日志实现包     </p>
</blockquote>
<p><strong>所以，结合各日志实现包使用时提供的jar包情况为：</strong></p>
<p>SLF4J和logback结合使用时需要提供的jar：slf4j-api.jar、logback-classic.jar、logback-core.jar</p>
<p>SLF4J和log4j结合使用时需要提供的jar：slf4j-api.jar、slf4j-log4j12.jar、log4j.jar</p>
<p>和log4j2配合需要导入log4j2的<strong>log4j-api.jar</strong>、<strong>log4j-core.jar</strong>和桥接包<strong>log4j-slf4j-impl.jar</strong>。</p>
<p>SLF4J和JDK中java.util.logging结合使用时需要提供的jar：slf4j-api.jar、slf4j-jdk14.jar</p>
<p>SLF4J和simple(SLF4J本身提供的一个接口的简单实现)结合使用时需要提供的jar：slf4j-api.jar、slf4j-simple.jar</p>
<p>当然还有其他的日志实现包，以上是经常会使用到的一些。</p>
<p>*<strong>注意，以上slf4j和各日志实现包结合使用时最好只使用一种结合，不然的话会提示重复绑定日志，并且会导致日志无法输出。*</strong></p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>*<strong>slf4j-api.jar:对外提供统一的日志调用接口，该接口具体提供的调用方式和方法举例说明：*</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Tester.class);  </span><br><span class="line">　　<span class="comment">//通过LoggerFactory获取Logger实例</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//接口里的统一的调用方法，各具体的日志系统都有实现这些方法</span></span><br><span class="line">　　		logger.info(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>); </span><br><span class="line">       logger.debug(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.error(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.trace(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">       logger.warn(<span class="string">&quot;testlog: &#123;&#125;&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lombok提供的@Slf4j注解，可以省去获取Logger对象的步骤，直接使用log.info()…</p>
<p><strong>如果系统中之前已经使用了log4j做日志输出，想使用slf4j作为统一的日志输出，该怎么办呢？</strong></p>
<p>如果之前系统中是单独使用log4j做为日志输出的，这时再想使用slf4j做为日志输出时，如果系统中日志比较多，此时更改日志输出方法肯定是不太现实的，这个时候就可以使用log4j-over-slf4j.jar将使用log4j日志框架输出的日志路由到slf4j上来统一采用slf4j来输出日志。</p>
<h4 id="为什么使用？"><a href="#为什么使用？" class="headerlink" title="为什么使用？"></a>为什么使用？</h4><p><strong>为什么要使用SLF4J?</strong></p>
<ul>
<li> slf4j是一个<strong>日志接口，自己没有具体实现日志系统</strong>，只提供了一组标准的调用api,这样<strong>将调用和具体的日志实现分离</strong>，<strong>使用slf4j后有利于根据自己实际的需求更换具体的日志系统</strong>，比如，之前使用的具体的日志系统为log4j，想更换为logback时，只需要删除log4j相关的jar，然后加入logback相关的jar和日志配置文件即可，而不需要改动具体的日志输出方法，试想如果没有采用这种方式，当你的系统中日志输出有成千上万条时，你要更换日志系统将是多么庞大的一项工程。如果你开发的是一个面向公众使用的组件或公共服务模块，那么一定要使用slf4的这种形式，这有利于别人在调用你的模块时保持和他系统中使用统一的日志输出。</li>
<li><strong>slf4j日志输出时可以使用{}占位符</strong>，如，logger.info(“testlog: {}”, “test”)，而如果只使用log4j做日志输出时，只能以logger.info(“testlog:”+”test”)这种形式，前者要比后者在性能上更好，后者采用+连接字符串时就是new 一个String 字符串，在性能上就不如前者。</li>
</ul>
<h3 id="3-log4j-log-for-java"><a href="#3-log4j-log-for-java" class="headerlink" title="3.log4j(log for java)"></a>3.<strong>log4j(log for java)</strong></h3><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以<strong>控制日志信息输送的目的地</strong>是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以<strong>控制每一条日志的输出格式</strong>；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以<strong>通过一个配置文件来灵活地进行配置</strong>，而不需要修改应用的代码。</p>
<p><strong>如何使用？</strong></p>
<ul>
<li>引入jar,使用log4j时需要的jar为：log4j.jar。</li>
<li>定义配置文件log4j.properties或log4j.xml</li>
<li>在具体的类中进行使用：<ul>
<li>在需要日志输出的类中加入：private static final Logger logger = Logger.getLogger(Tester.class);  //通过Logger获取Logger实例</li>
<li>在需要输出日志的地方调用相应方法即可：logger.debug(“System …..”)</li>
</ul>
</li>
</ul>
<h3 id="4-logback"><a href="#4-logback" class="headerlink" title="4.logback"></a>4.logback</h3><p>logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现(即直接实现了slf4j的接口，而log4j并没有直接实现，所以就需要一个适配器slf4j-log4j12.jar)，logback一共有以下几个模块：</p>
<ul>
<li>logback-core：其它两个模块的基础模块</li>
<li>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</li>
<li>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能</li>
</ul>
<p>同样，单独使用它时，需要引入以上jar，然后进行配置文件的配置，最后就是在相关类中进行使用，使用时加入以下语句:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Test.class);</span><br><span class="line"> 　logger.info(<span class="string">&quot;打印日志&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要改代码的日志级别：改logback-spring.xml里的<code>&lt;root level=&quot;INFO&quot;&gt;</code></p>
<h3 id="5-log发展史"><a href="#5-log发展史" class="headerlink" title="5.log发展史"></a>5.log发展史</h3><p>从JDK1.4开始提供java.until.logging日志框架来打印日志，但是大佬觉得JUL太难用了，就自己手撸了个log4j，后来log4j发现安全漏洞，加上代码结构问题难以维护，于是从1.2就停止更新log4j，并又重新手撸了个log4j2，再后来，这个大佬又双手撸了一个性能更高、功能更全的logback。</p>
<p>从此，这个大佬构建了log的世界，也创造了最常见的日志框架：log4j、log4j2、logback。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用log4j，需要log4j.jar</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line">Logger logger_log4j = Logger.getLogger(Test.class);</span><br><span class="line">logger_log4j.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用log4j2，需要log4j-api.jar、log4j-core.jar</span></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line">Logger logger_log4j2 = LogManager.getLogger(Test.class);</span><br><span class="line">logger_log4j2.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logback，需要logback-classic.jar、logback-core.jar</span></span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.Logger;</span><br><span class="line"><span class="keyword">import</span> ch.qos.logback.classic.LoggerContext;</span><br><span class="line">Logger logger_logback = <span class="keyword">new</span> LoggerContext().getLogger(Test.class);</span><br><span class="line">logger_logback.info(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.until.logging，简称jul</span></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line">Logger logger_jul = Logger.getLogger(<span class="string">&quot;java.Test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从上面不难看出，使用不同的日志框架，就要引入不同的jar包，使用不同的代码获取Logger。</p>
<p>于是Apache Commons Logging出现了。</p>
<p>Common-logging提供了一个日志入口，称作”门面日志”，即它不负责写日志，而是<strong>提供用一个统一的接口，通过jar来决定使用的日志框架</strong>，这样就不要再更换框架的时候再修改代码了。后来开发了log4j的大佬又因为嫌弃Common-logging难用，开发了门面日志框架<strong>slf4j</strong>，今天就拿slf4j讲述门面日志。</p>
<p>门面日志和设计模式中的<strong>外观模式</strong>如出一辙，本身不提供服务，为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。slf4j就像是菜鸟驿站，本身没有快递服务，但是提供顺丰、中通等快递服务，至于你想用顺丰还是用中通，完全取决于你的想法。</p>
<p>使用slf4j：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line">Logger logger = LoggerFactory.getLogger(Test.class);</span><br><span class="line">logger.info(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用slf4j需要首先导入<strong>slf4j-api.jar</strong>，和log4j配合，需要导入<strong>log4j.jar</strong>，以及桥接包<strong>slf4j-log412.jar</strong>。</p>
<p>logback只需要导入<strong>logback-classic.jar</strong>和<strong>logback-core.jar</strong>即可，不需要桥接包。</p>
<h4 id="为什么使用桥接包？"><a href="#为什么使用桥接包？" class="headerlink" title="为什么使用桥接包？"></a>为什么使用桥接包？</h4><p>slf4j从LoggerFactory.getLogger()开始，原理就是就是让ClassLoader从classpath(依赖的jar)中找到<strong>StaticLoggerBinder</strong>这个类，然后利用他来返回log4j、logback中的Logger，然后打印日志。</p>
<p>所谓的桥接包，就是实现StaticLoggerBinder类，用来连接slf4j和日志框架。因为log4j和log4j2刚开始没有StaticLoggerBinder这个类，为了不改变程序结构，只能重新写一个新的jar来实现StaticLoggerBinder。而logback出现slf4j之后，于是在logback本身的jar中实现了StaticLoggerBinder，所以就不需要桥接包。</p>
<p>StaticLoggerBinder实现了使用底层日志框架创建Logger的功能，各自的StaticLoggerBinder为slf4j提供的Logger，再提供给用户打印日志。</p>
<p>log4j和log4j2桥接包及logback依赖里，都有StaticLoggerBinder类。</p>
<p>“Class path contains multiple SLF4J bindings.”在使用slf4j的时候会遇到以上的报告信息。究其根本是因为logback-classic、log4j-slf4j-impl、slf4j-log412、slf4j-jdk这些jar不能同时存在。他们都实现了StaticLoggerBinder类而导致冲突，slf4j无法确定到底用哪个日志框架。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>lombok是一个可以简化代码的jar包，需要导入依赖，添加插件，可以说是开发必备。跟日志没啥关系，只不过@Slf4j注解是lombok提供的，用来在方法中直接使用log。</p>
</li>
<li><p>slf4j是日志门面，一个日志接口，而不提供日志系统实现，方便日志系统与调用的分离，可以方便更换日志系统。相当于是提供了一种日志输出的规范，下面的日志系统都需要实现这些方法，统一了日志输出规范。它实现了日志框架一些通用的api，log4j和logback是具体的日志框架。</p>
</li>
<li><p>log4j就是一个日志实现系统，具体的配置文件log4j.properties怎么写，还得再看看。log4j在结合slf4j时需要使用一个适配类桥接包。使用Logger.getLogger。</p>
</li>
<li><p>logback时比log4j新的日志实现系统，直接实现了slf4j接口，使用LoggerFactory.getLogger。</p>
<p>他们可以单独的使用，也可以绑定slf4j一起使用。</p>
<p>单独使用，分别调用框架自己的方法来输出日志信息。绑定slf4j一起使用。调用slf4j的api来输入日志信息，具体使用与底层日志框架无关（需要底层框架的配置文件）。显然不推荐单独使用日志框架。假设项目中已经使用了log4j，而我们此时加载了一个类库，而这个类库依赖另一个日志框架。这个时候我们就需要维护两个日志框架，这是一个非常麻烦的事情。而使用了slf4j就不同了，由于应用调用的抽象层的api，与底层日志框架是无关的，因此可以任意更换日志框架。</p>
</li>
</ol>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1-maven项目"><a href="#1-maven项目" class="headerlink" title="1.maven项目"></a>1.maven项目</h4><p>很久没在这个电脑上新建maven项目，结果问题来了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.m2 ❯ mvn -v      </span><br><span class="line">zsh: command not found: mvn</span><br></pre></td></tr></table></figure>

<p>之前出现的问题又出现了，之前重新配置了一下就可以了，可是brew info maven 也找不到之前maven安装的路径，难道之前我不是通过brew安装的吗？</p>
<p>另外在资源库中也没找到，好吧，重新 brew install maven 😅。可是brew安装报错。</p>
<p>官网<a href="https://maven.apache.org/download.cgi%E4%B8%8B%E8%BD%BDapache-maven-3.8.5-bin.tar.gz%E3%80%82%E8%A7%A3%E5%8E%8B%E5%88%B0%E8%B5%84%E6%BA%90%E5%BA%93%E4%B8%AD%E3%80%82%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E5%BE%97%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%BE%93%E5%85%A5mvn%E8%83%BD%E5%A4%9F%E6%89%BE%E5%88%B0maven%E5%8C%85%EF%BC%9F%E5%B0%B1%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BA%86%E3%80%82">https://maven.apache.org/download.cgi下载apache-maven-3.8.5-bin.tar.gz。解压到资源库中。那么如何使得在命令行中输入mvn能够找到maven包？就需要配置环境变量了。</a></p>
<p>下载之后，需要配置环境变量，不经想起之前的疑问：jdk环境变量在/etc/profile中配置，而maven中的环境变量在~/.bash_profile，这是为什么？</p>
<p>我们常说的环境变量修改主要包含两类文件，分别是 profile 和 bashrc 文件。profile 文件又分为：”/etc/profile”，”<del>/.bash_profile”；bashrc 文件则又分为 “/etc/bashrc”，和 “</del>/.bashrc” 文件。</p>
<p>说到这儿，可能迷惑了，我在我电脑里没看到.bash_profile和.bashrc啊，但是看到.zshrc了，这是为啥？</p>
<blockquote>
<p>iterm2以及mac自带的terminal都是终端模拟器。最开始时候就用起了iterm2.</p>
<p>bash，zsh是shell，zsh兼容bash</p>
<p>shell：壳，用它表示“为使用者提供的操作界面”，Shell泛指所有为用户提供操作界面的程序，分为两类：命令行（CLI）与图形界面（GUI）。通常情况下，我们在聊shell的时候，其实都是聊的Linux的命令行界面。</p>
</blockquote>
<blockquote>
<p>sh和bash和zsh :</p>
<p>sh全称为Bourne Shell，来自于1977年底的Unix v7版。二进制文件位置为<code>/bin/sh</code>。 </p>
<p>bash全称为Bourne-Again Shell，是在1989年对sh的重写版，替代了sh。二进制文件位置为<code>/bin/bash</code>。 </p>
<p>现在的Linux系统以及macOS系统的shell都默认使用bash。</p>
<p>Zsh即Z shell，是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。 </p>
<p>所以说Zsh也是一个Shell，就是会比bash能好用很多。所以这也是2019年起，macOS的默认Shell从Bash改为Zsh的原因？</p>
<p>zsh拥有完善的插件机制以及丰富的生态，和oh my zsh一起食用更佳</p>
</blockquote>
<h5 id="查看本地Shell的命令"><a href="#查看本地Shell的命令" class="headerlink" title="查看本地Shell的命令"></a>查看本地Shell的命令</h5><ul>
<li><p>查看当前Linux的全部Shell：<code>cat /etc/shells</code></p>
</li>
<li><p>查看当前使用的Shell：<code>echo $SHELL</code>或者<code>echo $0</code></p>
</li>
<li><p>切换默认的Shell：<code>chsh -s [shell的二进制文件路径]</code>，之后要重新登陆Shell才能生效哈。例如：</p>
</li>
<li><ul>
<li>切换为Bash： <code>chsh -s /bin/bash</code></li>
<li>切换为Zsh：<code>chsh -s /bin/zsh</code></li>
</ul>
</li>
</ul>
<h5 id="Shell的各种配置文件"><a href="#Shell的各种配置文件" class="headerlink" title="Shell的各种配置文件"></a>Shell的各种配置文件</h5><p>无论是Bash还是Zsh，都是有各自的配置文件来完成自己的工作的。这些配置文件都是隐藏文件，也就是说，用户不需要知道这些配置。但是在这里也要给大家总结一下都有哪些配置文件，也许以后用的上呢。 </p>
<h5 id="Bash的配置文件"><a href="#Bash的配置文件" class="headerlink" title="Bash的配置文件"></a>Bash的配置文件</h5><ul>
<li>/etc/profile：为系统的<strong>每个用户</strong>设置环境信息，当用户第一次<strong>登录</strong>时会执行该文件里的命令。默认会直接调用/etc/bashrc。该文件的改动需要重启才能生效。用于设置系统级别的环境变量和启动程序，在这个文件下配置会对所有的用户生效。</li>
<li>/etc/bashrc：为每一个运行bash shell的用户执行此文件。当bash shell被打开时，会读取并执行该文件中的命令。所以修改该文件后，重新打开Shell即可生效。</li>
<li>~/.bash_profile：和/etc/profile类似，但是只对当前用户生效。只对单一用户生效，该文件是一个用户级别的设置，可以理解为某一用户下的profile</li>
<li>~/.bashrc：和/etc/bashrc类似，但是只对当前用户生效。</li>
<li>~/.bash_logout：当每次退出bash shell时，执行该文件。</li>
<li>~/.bash_history：保存了历史命令。在Shell为Bash时，每次敲击命令时，都会保存在这个文件里</li>
</ul>
<h5 id="Zsh的配置文件"><a href="#Zsh的配置文件" class="headerlink" title="Zsh的配置文件"></a>Zsh的配置文件</h5><ul>
<li>/etc/bashrc 对应 /etc/zshrc</li>
<li>~/.bash_profile 对应 ~/.zprofile</li>
</ul>
<p>加载顺序：zshenv、zprofile、zshrc、zlogin</p>
<hr>
<p>所以说，各种教程里说的配置都是默认bash的，bash的配置文件对标到zsh中就可以。</p>
<p><strong>/etc/profile 和 /etc/bashrc 这种在 /etc 目录下的配置则都属于全局配置，所有用户的shell都有权使用这些环境变量，～/ 则属于用户级别的</strong></p>
<h5 id="总结一下：各种配置文件可以按两种方式分类："><a href="#总结一下：各种配置文件可以按两种方式分类：" class="headerlink" title="总结一下：各种配置文件可以按两种方式分类："></a>总结一下：各种配置文件可以按两种方式分类：</h5><table>
<thead>
<tr>
<th></th>
<th>profile</th>
<th align="center">bashrc/zshrc</th>
</tr>
</thead>
<tbody><tr>
<td>全局</td>
<td>/etc/profile（无关哪个shell）</td>
<td align="center">/etc/bashrc</td>
</tr>
<tr>
<td>用户</td>
<td>~/.bash_profile （专用于哪个shell）</td>
<td align="center">~/.bashrc</td>
</tr>
</tbody></table>
<p>profile的bashrc区别?</p>
<p>要搞清bashrc与profile的区别，首先要弄明白什么是交互式shell和非交互式shell，即login shell 和non-login shell。</p>
<p>交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。 shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾，shell也就终止了。</p>
<p>bashrc 与 profile 都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。</p>
<ol>
<li><p>/etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.</p>
</li>
<li><p>/etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
</li>
<li><p>~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p>
</li>
<li><p>~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.</p>
</li>
<li><p>~/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件.</p>
</li>
</ol>
<p>另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是”父子”关系.</p>
<hr>
<p>当登入系统时候获得一个shell进程时，其读取环境设定档有三步</p>
<p>1、首先读入的是全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如<br>/etc/profile.d和/etc/inputrc</p>
<p>2、然后根据不同使用者帐号，去其家目录读取<del>/.bash_profile，如果这读取不了就读取</del>/.bash_login，这个也读取不了才会读取<br>~/.profile，这三个文档设定基本上是一样的，读取有优先关系</p>
<p>3、然后在根据用户帐号读取~/.bashrc</p>
<hr>
<p>总结：配置文件全局/用户—交互的/非交互的，jdk的配置就是在/etc/profile中，maven的配置在～/.bash_profile既然用的是zsh，就在 ~/.zprofile里面配置。</p>
<hr>
<p>在～/.zprofile文件中，添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export M=&quot;/usr/local/ApacheMaven&quot;</span><br><span class="line">export PATH=&quot;$M/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>source ～/.zprofile 即可。</p>
<p>然后配置一下阿里云仓库。在setting.xml文件中，要关注两个地方，<em><strong>localRepository</strong></em>和<em><strong>mirrors</strong></em>。第一个localRepository是你本地仓库所在的位置，你的包都会下载到这里，默认在你用户目录的.m2目录下，这里可以换成你想存放的地址。第二个mirror是你的包下载地址，因为有墙，所以建议增加阿里云仓库配置，来加速下载。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建maven-web项目"><a href="#2-创建maven-web项目" class="headerlink" title="2.创建maven web项目"></a>2.创建maven web项目</h4><p>新建maven项目时选中create from archetype，选择org.apache.maven.archetypes:maven-archetype-webapp。</p>
<p>选择自己maven的setting.xml。</p>
<p>配置tomcat服务器，选择tomcat-local，给服务器取名字，选版本端口号之类的。</p>
<p>deployment中artifact选择要部署的jar包，选exploded的。</p>
<p>选择热部署，在实际开发中是很管用的web开发，你后台，改了啥他就热部署，不用你重启tomcat，前台的也是，你修改jsp,css,js什么的都可以直接进行热部署，你只要自己刷新一下你的页面就行了。</p>
<h4 id="3-使用log4j集合slf4j"><a href="#3-使用log4j集合slf4j" class="headerlink" title="3.使用log4j集合slf4j"></a>3.使用log4j集合slf4j</h4><p>Apache Log4j是一个基于Java的日志记录工具，它的日志级别按下面顺序递减：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OFF</td>
<td>最高级别，用于关闭日志记录。</td>
</tr>
<tr>
<td>FATAL</td>
<td>将导致应用程序提前终止的严重错误的信息将立即呈现在日志上。</td>
</tr>
<tr>
<td>ERROR</td>
<td>将其他运行时错误或意外情况的信息呈现在日志上。</td>
</tr>
<tr>
<td>WARN</td>
<td>使用已过时的API，API的滥用，潜在错误，其他不良的或意外的运行时的状况（但不一定是错误的）</td>
</tr>
<tr>
<td>INFO</td>
<td>一些感兴趣的运行时事件（启动/关闭</td>
</tr>
<tr>
<td>DEBUG</td>
<td>一些详细信息，查看程序的运行状态</td>
</tr>
<tr>
<td>TRACE</td>
<td>最详细的信息。一般这些信息只记录到日志文件中。</td>
</tr>
</tbody></table>
<h5 id="第一步：引入依赖"><a href="#第一步：引入依赖" class="headerlink" title="第一步：引入依赖"></a>第一步：引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="第二步：配置log4j的配置文件"><a href="#第二步：配置log4j的配置文件" class="headerlink" title="第二步：配置log4j的配置文件"></a>第二步：配置log4j的配置文件</h5><p>其配置文件名为log4j.properties，<strong>需要手动在java/resources下创建</strong>，如果建在其他位置，idea这个工具将无法识别。该配置文件用来设置记录器的级别、存放器和布局的，它可接key=value格式的设置或xml格式的设置信息。通过配置，可以创建出Log4J的运行环境。</p>
<p>Log4J配置文件的基本格式如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### set log levels 配置根Logger###</span></span><br><span class="line"><span class="comment">### log4j.rootLogger  = [ level ] , appenderName1 , appenderName2 ,  … ###</span></span><br><span class="line"><span class="comment">###  level : 是日志记录的优先级 优先级从高到低分别是ERROR、WARN、INFO、DEBUG</span></span><br><span class="line"><span class="comment">###  比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来</span></span><br><span class="line"><span class="comment">### Appender 为日志输出目的地 这里 将debug层级及以上的信息输出到console和file，自己定义的名字  ###</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">DEBUG,Console,File</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">###  输出到控制台  ###</span></span><br><span class="line"><span class="meta">log4j.appender.Console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.Console.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.Console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.Console.layout.ConversionPattern</span>=<span class="string">[%d&#123;yy/MM/dd HH:mm:ss:SSS&#125;]-%l:%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="meta">log4j.appender.File</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.File.File</span>=<span class="string">$&#123;project&#125;src/main/resources/log/app.log</span></span><br><span class="line"><span class="meta">log4j.appender.File.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="meta">log4j.appender.File.Threshold</span>=<span class="string">ALL</span></span><br><span class="line"><span class="meta">log4j.appender.File.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.File.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#   %m   输出代码中指定的消息</span></span><br><span class="line"><span class="comment">#　　%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span></span><br><span class="line"><span class="comment">#　　%r   输出自应用启动到输出该log信息耗费的毫秒数</span></span><br><span class="line"><span class="comment">#　　%c   输出所属的类目，通常就是所在类的全名</span></span><br><span class="line"><span class="comment">#　　%t   输出产生该日志事件的线程名</span></span><br><span class="line"><span class="comment">#　　%n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</span></span><br><span class="line"><span class="comment">#　　%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss , SSS&#125;，输出类似：2002年10月18日  22 ： 10 ： 28 ， 921</span></span><br><span class="line"><span class="comment">#　　%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Appender 为日志输出目的地，Log4j提供的appender有以下几种：</span></span><br><span class="line"><span class="comment">#org.apache.log4j.ConsoleAppender（控制台），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.FileAppender（文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Layout：日志输出格式，Log4j提供的layout有以下几种</span></span><br><span class="line"><span class="comment">#org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span></span><br><span class="line"><span class="comment">#org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span></span><br></pre></td></tr></table></figure>

<p>当然，通过Threshold设置，可以把异常日志单独输出到一个文件中。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### set log levels ###</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">debug ,  stdout ,  D ,  E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到控制台 ###</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span> = <span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span> =  <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="meta">log4j.appender.D</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.D.File</span> = <span class="string">$&#123;project&#125;src/main/resources/log/app.log</span></span><br><span class="line"><span class="meta">log4j.appender.D.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.D.Threshold</span> = <span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.D.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.D.layout.ConversionPattern</span> = <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### 保存异常信息到单独文件 ###</span></span><br><span class="line"><span class="meta">log4j.appender.E</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.E.File</span> = <span class="string">$&#123;project&#125;src/main/resources/log/error.log</span></span><br><span class="line"><span class="meta">log4j.appender.E.Append</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.E.Threshold</span> = <span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.appender.E.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.E.layout.ConversionPattern</span> = <span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br></pre></td></tr></table></figure>

<h5 id="第三步：编写测试类"><a href="#第三步：编写测试类" class="headerlink" title="第三步：编写测试类"></a>第三步：编写测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//private static Logger logger = LoggerFactory.getLogger(Log4jTestDemo.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前项目的根目录</span></span><br><span class="line">        String relativelyPath=System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定properties文件位置</span></span><br><span class="line">        PropertyConfigurator.configure(relativelyPath+ <span class="string">&quot;/src/main/resources/conf/log4j.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录debug级别的信息</span></span><br><span class="line">        log.debug(<span class="string">&quot;This is debug message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录info级别的信息</span></span><br><span class="line">        log.info(<span class="string">&quot;This is info message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录error级别的信息</span></span><br><span class="line">        log.error(<span class="string">&quot;This is error message.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非配置文件在resources目录下，否则不能自己找到配置文件的位置，还需要在代码中指定位置，低效！</p>
<p>这个问题貌似在spring中得到解决，在web.xml中增加配置：</p>
<p><a href="https://blog.csdn.net/HenryMrZ/article/details/79258057">https://blog.csdn.net/HenryMrZ/article/details/79258057</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:/conf/log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="4-maven项目打包"><a href="#4-maven项目打包" class="headerlink" title="4.maven项目打包"></a>4.maven项目打包</h4><p>有个问题：web项目进行部署前，必须要将项目进行打包吗？</p>
<p>直接部署在tomcat，并没有在target文件夹下找到war包。</p>
<p>maven-web项目要使用servlet，就要导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入之后reimport一下pom.xml。</p>
<p>发现部署之后，原本的System.getProperty输出的项目目录变成了tomcat的bin目录。</p>
<h5 id="介绍一下System-getProperty"><a href="#介绍一下System-getProperty" class="headerlink" title="介绍一下System.getProperty()"></a>介绍一下System.getProperty()</h5><p>Java中给我们提供了System.getProperty()这个函数，这个函数可以获取到Java JVM以及操作系统的一些参数，可以供程序判断等。</p>
<p>System.getProperty()方法中需要传递一个字符串的参数，表示需要获取那个环境配置，获得结果为String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;java.vm.version&quot;</span>);<span class="comment">//java虚拟机版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.vendor.url&quot;</span>); <span class="comment">//java官方网站  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.vm.nam&quot;</span>); <span class="comment">//java虚拟机名称  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;user.country&quot;</span>); <span class="comment">//国家或地区  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;user.dir&quot;</span>); <span class="comment">//工程的路径  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.runtime.version&quot;</span>);<span class="comment">//java运行环境版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.arch&quot;</span>); <span class="comment">//操作系统位数（32或64）  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>); <span class="comment">//操作系统名称  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;sun.jnu.encoding&quot;</span>); <span class="comment">//编码格式  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;os.version&quot;</span>); <span class="comment">//操纵系统版本  </span></span><br><span class="line">System.getProperty(<span class="string">&quot;java.version&quot;</span>); <span class="comment">//java版本版本</span></span><br></pre></td></tr></table></figure>

<p>那么如何找到路径下的log4j.properties配置文件呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String filePath = req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(filePath); <span class="comment">// 文件存放的路径</span></span><br><span class="line"><span class="comment">// 指定properties文件位置</span></span><br><span class="line">PropertyConfigurator.configure(filePath + <span class="string">&quot;WEB-INF/classes/conf/log4j.properties&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="项目中target目录是什么？"><a href="#项目中target目录是什么？" class="headerlink" title="项目中target目录是什么？"></a>项目中target目录是什么？</h5><p>target是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，所有都是Maven构建时生成的。</p>
<p><a href="https://blog.51cto.com/zhangzhixi/5102490?b=totalstatistic">https://blog.51cto.com/zhangzhixi/5102490?b=totalstatistic</a></p>
<p>还有一个问题：tomcat运行之后，日志不保存在文件中了，难道是识别不了project目录了吗？</p>
<p>确实，log输出到了tomcat中的bin目录中。改成绝对目录。</p>
<h5 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h5><p>由于web项目没有写java文件没有main函数, 是无法直接运行的, 因此web项目需要放在一个容器里才能运行</p>
<p>这里就将web项目放在Tomcat这个web服务器里运行</p>
<p>基于maven的web项目 “ 打包、部署、使用” 操作步骤如下:</p>
<ol>
<li>打包：在IDEA主界面的右边找到maven, 在maven的生命周期Lifecycle下面找到package, 双击package命令进行运行。底下的控制台提示 BUILD SUCCESS 代表构建成功。构建成功之后, 根据控制台里提示的war包路径找到war的位置。</li>
<li>部署：”部署“ 操作      (部署就是手动把打包好的war包复制到tomcat-webapps下边)</li>
</ol>
<blockquote>
<p>不打jar包运行，tomcat文件夹下没有应用的痕迹啊。【todo】应该是把war包放在tomcat目录下和idea中启动不太一样。idea中需要idea一直在运行状态。但是idea中运行的也是tomcat？</p>
</blockquote>
<ol start="3">
<li><p>运行，首先将Tomcat加载到系统环境变量</p>
<blockquote>
<p>配置tomcat环境变量：</p>
<p>如果不配置的话，需要每次都进到tomcat的bin目录下运行startup.sh启动。</p>
<p>在 ～/.zprofile 文件中增加  export PATH=${PATH}:tomcat bin目录</p>
<p>​    语法：</p>
<p>​    ${}为占位符，${PATH} 和 $PATH等效</p>
<p>​    =前后不能有空格</p>
<p>​    : 为分隔符（等同于windows环境变量中的 ; ）</p>
<p>​    PATH=$PATH:xxx 可以理解为 “ PATH+=xxx “（当然不能这么写）<br>​    PATH=xxx:$PATH这种写法亦可，只是前后顺序的问题；</p>
<p>export -p 查看所有环境变量</p>
<ol>
<li>sudo su 申请权限</li>
<li>startup.sh            //启动tomacat</li>
<li>shutdown.sh          //关闭tomcat</li>
</ol>
</blockquote>
</li>
</ol>
<p>启动之后，好奇时一直在运行还是怎么的，应该是一直在运行。起个定时线程试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Thread &#123;&#125;, now &#123;&#125;.&quot;</span>, Thread.currentThread(), <span class="keyword">new</span> Date());</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>报不能用lambada表达式的错误，我改了level等级为8，打包时还报错。不用试了，只要tomcat开的，应用就一直是起的。每访问一次，log文件中就记录日志。</p>
<h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><h4 id="1-idea中使用maven插件打包"><a href="#1-idea中使用maven插件打包" class="headerlink" title="1.idea中使用maven插件打包"></a>1.idea中使用maven插件打包</h4><p>上面就是用此操作，应该先clean，再compile编译，再打包的。</p>
<p>mvn clean 清空class文件<br>mvn compile 编译<br>mvn package 打包<br>mvn test 测试<br>mvn install 打包并上传到本地仓库<br>mvn deploy 上传到远程仓库<br>mvn -Dmaven.test.skip=true 跳过测试</p>
<p>pom中的插件应该是自动给我加的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>log-maven-package<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种打包方式会有外部依赖包。</p>
<h4 id="2-直接使用mvn-package打包"><a href="#2-直接使用mvn-package打包" class="headerlink" title="2.直接使用mvn package打包"></a>2.直接使用mvn package打包</h4><p>不在 POM 中配置任何插件，直接使用 <code>mvn package</code> 进行项目打包，这对于没有使用外部依赖包的项目是可行的。但如果项目中使用了第三方 JAR 包，就会出现问题，因为 <code>mvn package</code> 打的 JAR 包中是不含有依赖包，会导致作业运行时出现找不到第三方依赖的异常。这种方式局限性比较大，因为实际的项目往往很复杂，通常都会依赖第三方 JAR。</p>
<p>大数据框架的开发者也考虑到这个问题，所以基本所有的框架都支持在提交作业时使用 <code>--jars</code> 指定第三方依赖包，但是这种方式的问题同样很明显，就是你必须保持生产环境与开发环境中的所有 JAR 包版本一致，这是有维护成本的。</p>
<p>基于上面这些原因，最简单的是采用 <code>All In One</code> 的打包方式，把所有依赖都打包到一个 JAR 文件中，此时对环境的依赖性最小。要实现这个目的，可以使用 Maven 提供的 <code>maven-assembly-plugin</code> 或 <code>maven-shade-plugin</code> 插件。</p>
<blockquote>
<p>我直接使用mvn package 报错误</p>
<p>[ERROR] No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</p>
<p>未解决</p>
</blockquote>
<h4 id="3-maven-assembly-plugin插件"><a href="#3-maven-assembly-plugin插件" class="headerlink" title="3.maven-assembly-plugin插件"></a>3.maven-assembly-plugin插件</h4><p><code>Assembly</code> 插件支持将项目的所有依赖、文件都打包到同一个输出文件中。目前支持输出以下文件类型：</p>
<ul>
<li>zip</li>
<li>tar</li>
<li>tar.gz (or tgz)</li>
<li>tar.bz2 (or tbz2)</li>
<li>tar.snappy</li>
<li>tar.xz (or txz)</li>
<li>jar</li>
<li>dir</li>
<li>war</li>
</ul>
<p><strong>基本使用</strong></p>
<p>在 POM.xml 中引入插件，指定打包格式的配置文件 <code>assembly.xml</code>(名称可自定义)，并指定作业的主入口类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定启动类 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.liuxuan.Log4jDemo<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>assembly.xml 文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/ASSEMBLY/2.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                              http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指明打包方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeBaseDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeBaseDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">useProjectArtifact</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useProjectArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unpack</span>&gt;</span>true<span class="tag">&lt;/<span class="name">unpack</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里以排除 storm 环境中已经提供的 storm-core 为例，演示排除 Jar 包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.apache.storm:storm-core<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>采用 maven-assembly-plugin 进行打包时命令如下：</p>
<p>mvn assembly:assembly </p>
<blockquote>
<p>问题：使用命令mvn compile 时，会报错 no compiler，但是idea中点击时没问题。所以得先点compile编译，再执行assembly命令。</p>
</blockquote>
<p>打包后会同时生成两个 JAR 包，其中后缀为 <code>jar-with-dependencies</code> 是含有第三方依赖的 JAR 包，后缀是由 <code>assembly.xml</code> 中 <code>&lt;id&gt;</code> 标签指定的，可以自定义修改。</p>
<h4 id="4-maven-shade-plugin插件"><a href="#4-maven-shade-plugin插件" class="headerlink" title="4.maven-shade-plugin插件"></a>4.maven-shade-plugin插件</h4><p><code>maven-shade-plugin</code> 比 <code>maven-assembly-plugin</code> 功能更为强大，比如你的工程依赖很多的 JAR 包，而被依赖的 JAR 又会依赖其他的 JAR 包，这样,当工程中依赖到不同的版本的 JAR 时，并且 JAR 中具有相同名称的资源文件时，shade 插件会尝试将所有资源文件打包在一起时，而不是和 assembly 一样执行覆盖操作。</p>
<p><strong>通常使用 <code>maven-shade-plugin</code> 就能够完成大多数的打包需求，其配置简单且适用性最广，因此建议优先使用此方式。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 指定启动类 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.ronz.community.CommunityApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">&lt;!-- 下面的配置仅针对存在同名资源文件的情况，如没有则不用配置--&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 有些项目包可能会包含同文件名的资源文件（例如属性文件）--&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 为避免覆盖，可以将它们的内容合并到一个文件中 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.handlers<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/spring.schemas<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 maven-shade-plugin 进行打包的时候，打包命令和普通打包一样</p>
<p>mvn package</p>
<h4 id="5-使用-maven-jar-plugin-和-maven-dependency-plugin-插件"><a href="#5-使用-maven-jar-plugin-和-maven-dependency-plugin-插件" class="headerlink" title="5.使用 maven-jar-plugin 和 maven-dependency-plugin 插件"></a>5.使用 maven-jar-plugin 和 maven-dependency-plugin 插件</h4><p>此种打包方式有一个比较明显的缺点：打包后会在 <code>target</code> 目录下生成 <code>lib</code> 目录（存放依赖 Jar）和项目 Jar。也就是说由于依赖都存在于 <code>lib</code> 目录中，所以要想运行 Jar 包，必须将 Jar 包和 <code>lib</code>目录放在同一个路径下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目最终打包成的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 会在 MANIFEST.MF 中生成 Class-Path 项 --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 系统会根据 Class-Path 项配置的路径加载依赖 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定依赖包所在目录，相对于项目最终 Jar 包的路径 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 指定 MainClass --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.ronz.community.CommunityApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置依赖包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 相当于执行 mvn 命令，将依赖打包到指定目录 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--将依赖打包至 target 下的 lib 目录--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个思想也比较简单。</p>
<p>首先说 maven-jar-plugin 插件，它的思想就是：指定启动类、指定依赖包相对于项目最终 Jar 包所在的路径、给 MANIFEST.MF 文件添加 Class-Path 属性（运行项目 Jar 包时会根据 Class-Path 属性来找到具体依赖 Jar 包的路径）。</p>
<p>接着是 maven-dependency-plugin 插件，它的主要思想就是：指定所有依赖被打包为 Jar 包后的存放路径。</p>
<p>pom.xml 文件配置完毕之后，就可以运行打包命令了：<br><em># 跳过测试用例执行 package 命令</em> mvn package -Dmaven.test.skip=true</p>
<p>这种方式打包出来的 Jar 包，在代码层面只包含了项目本身的代码。而项目的依赖都以 Jar 包的形式放在了项目 Jar 包同级别目录下的 <code>lib</code> 目录中，这些依赖 Jar 包的路径在 <code>MANIFEST.MF</code> 文件中都以路径的方式指明了。</p>
<h4 id="打包总结"><a href="#打包总结" class="headerlink" title="打包总结"></a>打包总结</h4><p>工作中用到的命令只是：mvn package -Dmaven.test.skip=true，但是看项目中貌似使用的是assembly。</p>
<p>推荐使用maven-shade-plugin插件，可以避免前面的资源文件被后面的覆盖掉。</p>
<p>只是mvn compile 这个问题还没解决，为什么idea中点击compile能够编译，终端执行命令却不行。</p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/jadeliuliu/log-maven-package/tree/master">https://github.com/jadeliuliu/log-maven-package/tree/master</a></p>
<p>摘自：</p>
<p>slf4j、log4j、logback：<a href="https://www.cnblogs.com/javalinux/p/15683735.html">https://www.cnblogs.com/javalinux/p/15683735.html</a></p>
<p>log发展史：<a href="https://juejin.cn/post/7033021644142542878">https://juejin.cn/post/7033021644142542878</a></p>
<p>idea中创建maven web项目：<a href="https://www.cnblogs.com/weiqingfeng/p/9494914.html">https://www.cnblogs.com/weiqingfeng/p/9494914.html</a></p>
<p>mac区分.bash_profile 和/etc/profile：<a href="https://blog.csdn.net/weixin_42214743/article/details/116133257">https://blog.csdn.net/weixin_42214743/article/details/116133257</a></p>
<p>bash和zsh：<a href="https://www.zhihu.com/question/20036548/answer/2345481001">https://www.zhihu.com/question/20036548/answer/2345481001</a></p>
<p>log4j配置文件：<a href="http://www.blogjava.net/zJun/archive/2006/06/28/55511.html">http://www.blogjava.net/zJun/archive/2006/06/28/55511.html</a></p>
<p>maven项目打包部署到tomcat：<a href="https://blog.csdn.net/asdx1020/article/details/104554811">https://blog.csdn.net/asdx1020/article/details/104554811</a>   &amp;&amp;   <a href="https://blog.csdn.net/Shangxingya/article/details/107295800">https://blog.csdn.net/Shangxingya/article/details/107295800</a></p>
<p>常用maven打包方式：<a href="https://juejin.cn/post/6844904067194437639#heading-1">https://juejin.cn/post/6844904067194437639#heading-1</a>   &amp;&amp; <a href="https://blog.csdn.net/zhuxian1277/article/details/119880760">https://blog.csdn.net/zhuxian1277/article/details/119880760</a></p>
<h3 id="log日志怎么传参"><a href="#log日志怎么传参" class="headerlink" title="log日志怎么传参"></a>log日志怎么传参</h3><p>不同于String.format和sout，log使用占位符传参，就是{}，前面用:还是=还是其他无所谓：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info(&quot;remind：orderInfo:&#123;&#125;&quot;, JSON.toJSONString(orderInfo));</span><br></pre></td></tr></table></figure>
<p>如果是log.error里面还有Exception对象，那么该怎么打印:<br>对于异常，是不需要占位符的，而且也不需要 e.getMessage()，直接打印出来即可.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#125; catch (Exeception e) &#123;</span><br><span class="line">    log.error(&quot;error in order:&#123;&#125;&quot;, JSON.toJSONString(orderInfo), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="log日志级别开关"><a href="#log日志级别开关" class="headerlink" title="log日志级别开关"></a>log日志级别开关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>maven与nexus</title>
    <url>/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/</url>
    <content><![CDATA[<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ol>
<li><p>优秀的构建工具<br>通过简单的命令，能够完成清理、编译、测试、打包、部署等一系列过程。同时，不得不提的是，Maven是跨平台的，无论是在Windows、还是在Linux或Mac上，都可以使用同样的命令。</p>
</li>
<li><p>依赖管理工具<br>项目依赖的第三方的开源类库，都可以通过依赖的方式引入到项目中来。代替了原来需要首先下载第三方jar，再加入到项目中的方式。从而更好的解决了合作开发中依赖增多、版本不一致、版本冲突、依赖臃肿等问题。<br>具体是怎么实现的呢？Maven通过坐标系统准确的定位每一个构件，即通过坐标找到对应的java类库。</p>
</li>
<li><p>项目信息管理工具<br>能够管理项目描述、开发者列表、版本控制系统地址、许可证等一些比较零散的项目信息。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，还能够轻松获得项目文档、测试报告、静态分析报告、源码版本、日志报告等非常具有价值的项目信息。</p>
</li>
</ol>
<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><p>maven的依赖管理功能，通过在Pom中指定坐标的形式将jar引入到项目中。jar包就存放在仓库中。</p>
<p>Maven的仓库分为本地仓库和远程仓库。远程仓库分为：中央仓库、私服、其他远程仓库。</p>
<p>当Maven根据坐标寻找构件时，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。</p>
<p>为什么需要私服？</p>
<p>1.一些无法从外部仓库下载的构件，例如内部的项目，可以部署到私服上，以便供其他依赖项目使用。</p>
<p>2.为了节省带宽和时间，在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。当本地Maven项目需要下载构件时，先去私服请求，如果私服没有，则再去远程仓库请求，从远程仓库下载构件后，把构件缓存在私服上。这样，即使暂时没有Internet链接，由于私服已经缓存了大量构件，整个项目还是可以正常使用的。同时，也降低了中央仓库的负荷。</p>
<p>如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。<br>————————————————</p>
<p>总而言之：私服在用户局域网内的特殊远程仓库，私服起到了maven用户与中央仓库的中间作用，私服从中央仓库缓存构件，maven用户从私服下载构件。</p>
<h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><p>nexus就是私服的一种。</p>
<p>nexus是一个强大的maven仓库管理器,它极大的简化了本地内部仓库的维护和外部仓库的访问.</p>
<p>nexus提供了强大的仓库管理功能,构件搜索功能,它基于REST,友好的UI是一个extjs的REST客户端,占用较少的内存,基于简单文件系统而非数据库.</p>
<p>节省外网带宽；加速Maven构建；部署第三方构件；提高稳定性，增强控制；降低中央仓库的负荷；控制和审计；建立本地内部公用仓库。</p>
<p>转载自：<a href="https://www.cnblogs.com/youngdeng/p/15098442.html">https://www.cnblogs.com/youngdeng/p/15098442.html</a></p>
<p>如何配置：<a href="https://www.jianshu.com/p/5b06b2541336">https://www.jianshu.com/p/5b06b2541336</a></p>
<h3 id="配置项目遇到的几个问题"><a href="#配置项目遇到的几个问题" class="headerlink" title="配置项目遇到的几个问题"></a>配置项目遇到的几个问题</h3><p>背景：把之前的包想移动到新创建的一个子包里。</p>
<p>✅父子工程引用的问题</p>
<p>1、Parent怎么能找到childA和childB呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">   &lt;module&gt;childA&lt;/module&gt;</span><br><span class="line">   &lt;module&gt;childB&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>2、pom”继承”的概念</p>
<p>如果分别去在各自的pom里引用包，就会导致pom文件引入的包重复。<br>父pom写好了，子pom就通过<code>&lt;parent&gt;</code>标签继承父pom的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">   &lt;groupId&gt;com.sang.main&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class="line">   &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;  &lt;!--本例中此处是可选的，不是在外层包下的话用--&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p>子pom中引入<code>&lt;parent&gt;</code>标签后，就会从父pom继承<code>&lt;version&gt;</code>等属性了,主pom中把依赖通过<code>&lt;dependecyManagement&gt;</code>引起来，表示子pom可能会用到的jar包依赖，子包引用的话，可以不加version属性，便于统一管理，加了的话表示子包单独用这个版本。</p>
<p>摘自：<a href="https://blog.csdn.net/SunFlowerXT/article/details/105531109">https://blog.csdn.net/SunFlowerXT/article/details/105531109</a></p>
<p>✅Junit找不到的问题，test放在main里，结构限定scope为test</p>
<p>✅class notFound 以及 找不到或无法加载主类</p>
<p>项目结构没有安排明白的原因，点project structure，父包下面的main包和test包下的java包啥的都不作为source和test，resource也不作为reesource。子包下面的模块选好。就可以了。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis实战</title>
    <url>/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>1、mybatis <code>&lt;if&gt;</code> 标签不是必须在<code>&lt;where&gt;</code>标签下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table</span><br><span class="line">&lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">        uid = #&#123;uid&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">where status = 0</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    and uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    where uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>

<p>2、mybatis中，<code>select * from in &lt;foreach&gt; #&#123;list&#125;</code>，中的list不能是空，不能为null，会报错。</p>
<p>3、mybatis查出的结果是list，如果结果是一条都没有，那么返回的是空list，而不是null。</p>
<p>4、mybatis sum 如果没有记录，返回的是null，所以要注意mybatis返回结果都用包装类型来接。</p>
<p>5.mybatis查出的Date类型，是毫秒时间戳，可以用String接Date类型，只不过是：2023-01-01 11:11:11.1，所以得用.substring(0,19)，注意该方法string是null不行，位数不够也会报错。</p>
<p>6.mybatis来select，in一个list，如果传入的list是null或者空会报错。<br>null会报错：org.mybatis.spring.MybatisSystemException<br>空list会error sql<br>如果加了<code>&lt;where&gt;</code>标签和<code>&lt;if&gt;</code>标签，会导出所有的。<br><code>&lt;if test=&quot;list != null and list.size() &gt; 0&quot;&gt;</code></p>
<h3 id="mybatis-error"><a href="#mybatis-error" class="headerlink" title="mybatis error"></a>mybatis error</h3><h4 id="✅Mybatis-Exception-Translator-translateExceptionIfPossible"><a href="#✅Mybatis-Exception-Translator-translateExceptionIfPossible" class="headerlink" title="✅Mybatis Exception Translator.translateExceptionIfPossible"></a>✅Mybatis Exception Translator.translateExceptionIfPossible</h4><p>原因：插入时找不到参数，批量插入时传的list为空也会报此问题。</p>
<h3 id="resultMap和resultType"><a href="#resultMap和resultType" class="headerlink" title="resultMap和resultType"></a>resultMap和resultType</h3><p>ResultType和ResultMap都是执行查询语句时返回的结果集。<br>ResultType相对与ResultMap而言更简单一点。只有满足ORM（Object Relational Mapping，对象关系映射）时，即数据库表中的字段名和实体类中的属性完全一致时，才能使用，否则会出现数据不显示的情况。<br>ResultMap和ResultType的功能类似，但是ResultMap更强大一点，ResultMap可以实现将查询结果映射为复杂类型的pojo。</p>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>1.java的基础类型及其包装类int,double和java.lang.Integer,java.lang.Double等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值为int，resultType为int ,java.lang.Integer也可以--&gt;</span><br><span class="line">&lt;select id=&quot;countUser&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">    select count(*) from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>2.自己定义的实体类,实体类和数据库字段需要一致，如果不一致需要使用resulMap自定义map，也可以直接使用map。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值为实体类，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.entity.User&quot;&gt;</span><br><span class="line">   select * from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.map类型，Dao层的返回类型为<code>Map&lt;String, Object&gt;</code>，key是对应的column值，value是数据中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 返回值为Map&lt;String,Object&gt;，resultType为map--&gt;</span><br><span class="line">&lt;select id=&quot;getUserSelective&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select name,address,salary from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.List集合，其中该集合的类型可以为1,2,3中提到的类型。Dao层的返回类型为<code>List&lt;User&gt;</code>，这里只展示了实体类集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值为List&lt;User&gt;，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集的映射是 MyBatis 最强大的特性,通过使用resultMap或resultType可以解决复杂映射问题。基础简单的使用resultType就可以了，但是如果出现table中列和实体类中的属性不一致或者多表级联。那么这时resultMap就可以发挥作用了。</p>
<p>TestDao.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.repository.TestDao&quot;&gt;</span><br><span class="line">    //定义映射</span><br><span class="line">    &lt;resultMap id=&quot;TestResultMap&quot; type=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    //定义返回栏目</span><br><span class="line">    &lt;sql id=&quot;all_colum_without_id&quot;&gt;</span><br><span class="line">        name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;all_colum&quot;&gt;</span><br><span class="line">        name,&lt;include refid=&quot;all_colum_without_id&quot;/&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    //插入语句</span><br><span class="line">    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values (#&#123;name&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //批量插入</span><br><span class="line">    &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;testDOList&quot; separator=&quot;,&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">            (#&#123;item.name&#125;,</span><br><span class="line">            #&#123;item.age&#125;)</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //查询</span><br><span class="line">    &lt;select id=&quot;findById&quot; resultMap=&quot;TestResultMap&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;all_colum&quot;/&gt; from table where id=#&#123;id&#125;</span><br><span class="line">        &lt;if test=&quot;age != null&quot;&gt;</span><br><span class="line">            and age=#&#123;age&#125;</span><br><span class="line">        &lt;if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>TestDao.java接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface TestDao &#123;</span><br><span class="line">    //插入</span><br><span class="line">    Integer insertOne(TestDO testDO);</span><br><span class="line">    //批量插入</span><br><span class="line">    Integer insertBatch(List&lt;TestDO&gt; testDOList);</span><br><span class="line">    //查询</span><br><span class="line">    TestDO findById(Long id, Integer age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdbcType告诉框架如何解析这个属性（对应数据库中的类型），column是数据库中table的列名，property是实体类中对应的属性名字，type是对应的实体类，id=”TestResultMap”是这个resultMap的一个引用标志。</p>
<p>这样使用resultMap就像用resultType对应实体类，在select出来的语句中直接对字段就行as，as为实体类属性名，或驼峰形式就行。</p>
<p>resultMap更复杂的用法：<a href="https://blog.csdn.net/wobuaizhi/article/details/83104464">https://blog.csdn.net/wobuaizhi/article/details/83104464</a></p>
<h3 id="返回映射下划线转驼峰"><a href="#返回映射下划线转驼峰" class="headerlink" title="返回映射下划线转驼峰"></a>返回映射下划线转驼峰</h3><p>意思是返回值对应到对象，mysql返回的字段名（app_id），直接映射到对象属性名（appId）。</p>
<p>第一种 Spring Boot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

<p>第二种 mybatis-config.xml配置中加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 全局配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!-- 是否开启自动驼峰命名规则映射</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt; </span><br></pre></td></tr></table></figure>

<h3 id="mybatis-useGeneratedKeys-keyProperty"><a href="#mybatis-useGeneratedKeys-keyProperty" class="headerlink" title="mybatis useGeneratedKeys keyProperty"></a>mybatis useGeneratedKeys keyProperty</h3><p>useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</p>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。</p>
<p>作用：在inset时，可以不用管主键插入多少，而且插入后，还能直接用对象里的值，因为自动返回了。建表时必须设置主键自增。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;</span><br><span class="line">    keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DUPLICATE"><a href="#DUPLICATE" class="headerlink" title="DUPLICATE"></a>DUPLICATE</h3><p>duplicate在mybatis中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">    insert into table (id, &lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">    values (0, #&#123;name&#125;)</span><br><span class="line">    ON DUPLICATE KEY UPDATE name=values(name), age=values(age)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">values后面就是插入要查哪些。</span><br><span class="line">update后面是更新要更新哪些</span><br><span class="line">什么时候更新要看表的主键索引和唯一索引</span><br><span class="line">id可选，加了id，就传0</span><br></pre></td></tr></table></figure>

<p>因为更新的时候是不会返回id的，所以要去掉：<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code><br>如果不去掉，会报<code>executorexception: error getting generated key or setting result to parameter object</code></p>
<h3 id="xml里面foreach标签里面的属性separator"><a href="#xml里面foreach标签里面的属性separator" class="headerlink" title="xml里面foreach标签里面的属性separator"></a>xml里面foreach标签里面的属性separator</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;if test=&quot;myList != null&quot;&gt;</span><br><span class="line">    AND dm in</span><br><span class="line">    &lt;foreach collection=&quot;myList &quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item , jdbcType=VARCHAR &#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
<p>渲染为sql：<code>AND dm in ( &#39;03&#39; , &#39;04&#39;)</code></p>
<p>如果separator属性为or，渲染为：<code>AND ( dm  = &#39;01&#39;or dm   = &#39;02&#39; or dm   = &#39;03&#39;) </code></p>
<h3 id="where标签的作用"><a href="#where标签的作用" class="headerlink" title="where标签的作用"></a>where标签的作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> WHERE</span><br><span class="line"> &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line"> state = #&#123;state&#125;</span><br><span class="line"> &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>如果state参数为空时，最终生成SQL语句为<br>SELECT * FROM hdc WHERE<br>执行会出错，可以在where 后加一个1=1，但是累赘</p>
<p>用<code>&lt;where&gt;...&lt;/where&gt;</code>标签就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectOne&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> &lt;where&gt;</span><br><span class="line">  &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line"> &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>总结：<code>&lt;where&gt;</code>标签，1、在后面if null都是空时，可以自动删除where。2、在后面多个if null，第一个为null时，会自动删掉后面有的and。</p>
<h3 id="trim实现动态sql"><a href="#trim实现动态sql" class="headerlink" title="trim实现动态sql"></a>trim实现动态sql</h3><p>场景：想使用having，having后面用if null标签，如果后面的if null都是null，having会留着，导致出错。</p>
<p>trim 在英语中有“点缀物”，修剪的意思。可以把‘’标签为一个装饰sql的标签。trim标签常用于动态生成sql的场景下。</p>
<p>基本格式：<br><code>&lt;trim prefix=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot;&gt;&lt;/trim&gt;</code><br>prefix：<br>表示在trim包裹的SQL语句前面添加的指定内容。<br>suffix：<br>表示在trim包裹的SQL末尾添加指定内容<br>prefixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定首部内容<br>suffixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定尾部内容</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/425922768">https://zhuanlan.zhihu.com/p/425922768</a></p>
<p>例子(查输入的list的元素是不是在查处的一个list字段里有)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group by id</span><br><span class="line">&lt;trim prefix=&quot;having&quot; prefixOverrides=&quot;and&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        and</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>


<h3 id="条件构造器QueryWrapper"><a href="#条件构造器QueryWrapper" class="headerlink" title="条件构造器QueryWrapper"></a>条件构造器QueryWrapper</h3><p>QueryWrapper是在使用Mybatis-plus中用到的一种技术，也叫作构造器，能简化sql的操作。MyBatisPlus 依赖：mybatis-plus-boot-starter</p>
<p>首先，Mapper接口需要继承<code>BaseMapper&lt;T&gt;</code>抽象类，加@Mapper注解。</p>
<p>LambdaQueryWrapper和QueryWrapper查询是一样的，但是使用Lambda语法更加方便，更容易理解</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public List&lt;Student&gt; list(Student student)&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Student&gt; lqw = new LambdaQueryWrapper&lt;Student&gt;();</span><br><span class="line">    lqw.eq(Student::getName, student.getName()); </span><br><span class="line">    //也可以：lqw.eq(&quot;name&quot;, student.getName());</span><br><span class="line">    lqw.like(Student::getClass,student.getClass());</span><br><span class="line">    lqw.between(&quot;age&quot;,student.getAge1(),student.getAge2());</span><br><span class="line">    lqw.orderByAsc(&quot;age&quot;);</span><br><span class="line">    List&lt;Student&gt; list = studentDao.list(lqw);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对应sql：<code>select * from student where name = &#39;?&#39; and class like &#39;%?%&#39; and age between &#39;?&#39; and &#39;?&#39; order by &#39;?&#39; asc</code></p>
<p>QueryWrapper其实可以理解成一个放查询条件的盒子，我们把查询条件放在里面，他就会自动按照对应的条件进行查询数据。</p>
<p>根据不同的查询要求，有不同的用法，常用到的比如：eq（相等）、like、and、or、isNull、isNotNull、ne（不相等）、likeRight、between、gt（大于）、lt（小于）等</p>
<h3 id="使用Map接收mybatis结果"><a href="#使用Map接收mybatis结果" class="headerlink" title="使用Map接收mybatis结果"></a>使用Map接收mybatis结果</h3><p>ResultSet是一个表示数据库结果集的接口，在java中用于表示从数据库查询的结果，允许通过行和列的方式访问数据，从而从数据库中检索和操作数据。</p>
<p>但是Mybatis不支持直接用ResultSet接收查询结果。因为Mybatis采用的是物理映射技术，而ResultSet只能获取行列数据，得不到物理映射的结果。</p>
<p>那么除了定义DO，还可以用什么接收mybatis返回的数据呢？ 用Map。</p>
<p>dao接口怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MaoKey(&quot;某字段名&quot;)</span><br><span class="line">Map&lt;String, Object&gt; selectAll();</span><br></pre></td></tr></table></figure>

<p>xml怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;java.util.Map&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>@MapKey 是MyBatis框架的注解，作用是将List结果集转换成key-value形式的Map结果集，方便快速从结果集中查询指定结果。</p>
<p>@MapKey(value=””) 是mybatis的注解，用来映射Map类型的联合查询结果。作用是指定从查询结果的某个字段映射到Map的Key，这个注解是必须的，必须指定一个字段为key。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserMapper()&#123;</span><br><span class="line"> </span><br><span class="line">    //使用list接收</span><br><span class="line">    //[&#123;id:1111,name:&quot;foo&quot;&#125;,&#123;id:2222,name:&quot;bar&quot;&#125;]</span><br><span class="line">    public List&lt;User&gt; useList();</span><br><span class="line"> </span><br><span class="line">    //使用带有@Mapkey(&quot;id&quot;)的Map&lt;Integer,User&gt;接收</span><br><span class="line">    //&#123;1111:&#123;id:1111,name:&quot;foo&quot;&#125;,2222:&#123;id:2222,name:&quot;bar&quot;&#125;&#125;</span><br><span class="line">    @Mapkey(&quot;id&quot;)</span><br><span class="line">    public Map&lt;Integer,User&gt; useMap();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不能用<code>List&lt;Object&gt;</code>接结果。<br>如果@MapKey中的value是null，会展示一个key为null的map。</p>
<hr>
<p>MyBatis中的动态SQL以及@ResultMap,@MapKey和@Options的使用：<br><a href="https://www.freesion.com/article/2930425356/">https://www.freesion.com/article/2930425356/</a></p>
<h3 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h3><p>ResultHandler，顾名思义，对返回的结果进行处理，最终得到自己想要的数据格式或类型。也就是说，可以自定义返回类型。可以迭代查询结果集，将其存储在集合中，或执行自定义处理。它是mybatis的一个接口，用来处理结果集，从而获取特定的数据或者操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ResultHandler&lt;T&gt; &#123;</span><br><span class="line">    void handleResult(ResultContext&lt;? extends T&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line">    public void selectGoods(ResultHandler resultHandler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;   </span><br><span class="line">&lt;!DOCTYPE mapper   </span><br><span class="line">PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;  </span><br><span class="line">&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.yht.mybatisTest.dao.GoodsDao&quot;&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;select id=&quot;selectGoods&quot; resultType=&quot;map&quot;&gt;  </span><br><span class="line">        select price,name from goods</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">                                                        </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>selectGoods方法的查询结果是<code>List&lt;Map&gt;</code>，假如现在有这么一个需求：想统计价格低于50的书籍有哪些，价格高于50的书籍有哪些，该怎么处理呢？这个时候就用到了ResultHandler，我们创建一个SelectGoodsResultHandler。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SelectGoodsResultHandler implements ResultHandler&#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, List&lt;String&gt;&gt; resultMap = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void handleResult(ResultContext context) &#123;</span><br><span class="line">        if(resultMap.get(&quot;lowPrice&quot;) == null &amp;&amp; resultMap.get(&quot;highPrice&quot;) == null)&#123;</span><br><span class="line">            List&lt;String&gt; lowList = new ArrayList&lt;String&gt;();</span><br><span class="line">            List&lt;String&gt; highList = new ArrayList&lt;String&gt;();</span><br><span class="line">            resultMap.put(&quot;lowPrice&quot;, lowList);</span><br><span class="line">            resultMap.put(&quot;highPrice&quot;, highList);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Map&lt;String,Object&gt; resultObject = (Map&lt;String, Object&gt;)context.getResultObject();</span><br><span class="line">        BigDecimal price = (BigDecimal) resultObject.get(&quot;price&quot;);</span><br><span class="line">        String name = (String) resultObject.get(&quot;name&quot;);</span><br><span class="line">        if(price.intValue() &lt; 50)&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;lowPrice&quot;)).add(name);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;highPrice&quot;)).add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Map&lt;String, List&lt;String&gt;&gt; getResults()&#123;</span><br><span class="line">        return resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GoodsDaoTest &#123;</span><br><span class="line">    </span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory = null;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectGoodsTest()&#123;</span><br><span class="line">        </span><br><span class="line">        SqlSession sqlSession = getSqlSessionFactory().openSession(true);</span><br><span class="line">        GoodsDao goodsMapper = sqlSession.getMapper(GoodsDao.class);</span><br><span class="line">        SelectGoodsResultHandler resultHandler = new SelectGoodsResultHandler();</span><br><span class="line">        goodsMapper.selectGoods(resultHandler);</span><br><span class="line">        System.out.println(resultHandler.getResults().toString());;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static SqlSessionFactory getSqlSessionFactory() &#123;</span><br><span class="line">        String resource = &quot;spring-ibatis.xml&quot;;</span><br><span class="line">        if(sqlSessionFactory == null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources</span><br><span class="line">                        .getResourceAsReader(resource));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转载自：<a href="https://www.cnblogs.com/51life/p/9633002.html">https://www.cnblogs.com/51life/p/9633002.html</a></p>
<p>mybatis之ResultHandler如何使用：<br><a href="https://www.jianshu.com/p/8773d0e786d8">https://www.jianshu.com/p/8773d0e786d8</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet入门</title>
    <url>/2022/03/19/myblog/JAVA/servlet/</url>
    <content><![CDATA[<h3 id="1-Http协议"><a href="#1-Http协议" class="headerlink" title="1.Http协议"></a>1.Http协议</h3><p>HTTP协议的特点<br>1.支持客户 / 服务器模式<br>2.简单快速<br>3.灵活<br>4.无连接，HTTP1.1 版本后支持可持续连接<br>5.无状态</p>
<p>HTTP url:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//host[:port]/[abs_path]</span></span><br><span class="line">http:<span class="comment">//IP(主机名/域名):端口/访问的资源路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>http 表示通过HTTP协议来定位网络资源</li>
<li>host 表示合法的 Internet 主机名或者 ip 地址</li>
<li>port 指一个端口号，为空则为 80</li>
<li>abs_path 指定请求的 URL</li>
</ul>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><ul>
<li>http请求由请求行、<strong>请求头</strong>、请求正文组成。<ul>
<li>请求体第一行就是请求行；请求行由请求方式，请求路径、请求协议版本三部分组成</li>
<li>请求头指一行一行的键值对</li>
<li>正文即是内容；GET请求没有正文，其内容直接跟在地址后面</li>
</ul>
</li>
</ul>
<h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><ul>
<li>在接收和解释请求消息后，服务器返回一个 HTTP 响应消息。HTTP 响应由状态行、消息报头、响应正文组成<ul>
<li>状态行由协议版本、状态码、请求结果组成</li>
<li>消息报头与请求头大致相同</li>
<li>响应正文就是浏览器呈现的内容</li>
</ul>
</li>
</ul>
<h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>  HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成，请求消息和响应消息都是由开始行（对于请求消息， 开始行就是请求行；响应消息则是状态行），消息报头，空行，消息正文（可选）组成</p>
<p>  每一个报头域都是由 名字+”:”+空格+值 组成，消息报头域的名字是大小写无关的</p>
<p>1.请求头：</p>
<p>  请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，无法通过参数来传递的用请求头。</p>
<ul>
<li><p>referer： 该请求头指明请求从哪里来</p>
<p> 此请求头后面接的值为上一个页面的URL地址，通常用来做统计、防盗链。如果是从浏览器地址栏直接输入进行访问的，都没有该请求头。例如百度的广告，搜一个东西，出现广告字样的连接，点击会记录是从百度搜索进来的。例如邀请好友，用来记录是谁邀请进来的。例如从a页面到d页面，必须要经过b页面和c页面，防盗链。</p>
</li>
</ul>
<p>2.响应头</p>
<p>  响应报头允许服务器传递不能放在状态行中的附加响应消息，以及关于服务器的信息和对Request-URL所标识的资源进行下一步访问的信息</p>
<ul>
<li>location（重定向）：location 响应报头域用于重定向接收者到一个新位置</li>
</ul>
<p>  location响应报头域，常用在服务器更换域名时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>refresh：第一种是定时自动跳转到 [url]指定的页面（单位为秒）（307重定向过来的），可以在html页面通过meta标签实现，也可以在后台实现；第二种是不带 [url] 是指每 [content] 秒刷新一次页面    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;3;url=http://www.baidu.com&quot;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-servlet概述"><a href="#2-servlet概述" class="headerlink" title="2.servlet概述"></a>2.servlet概述</h3><p>Servlet 是 Server 与 Applet 的缩写，是服务端小程序的意思。使用 Java 语言编写的服务器端程序，可以生成动态的 WEB 页，Servlet 主要运行在服务器端，并由服务器调用执行， 是一种按照 Servlet 标准来开发的类。 是 SUN 公司提供的一门用于开发动态 Web 资源的技术。（言外之意：要实现 web 开发，需要实现 Servlet 标准）</p>
<p>Servlet 本质上也是 Java 类，但要遵循 Servlet 规范进行编写，没有 main()方法，它的创建、使用、销毁都由 Servlet容器进行管理(如 Tomcat)。（言外之意：写自己的类，不用写 main 方法，别人自动调用）</p>
<p>Servlet 是和 HTTP 协议是紧密联系的，其可以处理 HTTP 协议相关的所有内容。这也是 Servlet 应用广泛的原因之一。<br>提供了 Servlet 功能的服务器，叫做 Servlet 容器，其常见容器有很多，如 Tomcat, Jetty, WebLogic Server, WebSphere, JBoss 等等。</p>
<p><strong>tomcat和servlet的关系</strong></p>
<p>Tomcat 是Web应用服务器,是一个Servlet/JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件。</p>
<h3 id="3-使用servlet"><a href="#3-使用servlet" class="headerlink" title="3.使用servlet"></a>3.使用servlet</h3><h4 id="3-1-新建web项目"><a href="#3-1-新建web项目" class="headerlink" title="3.1.新建web项目"></a>3.1.新建web项目</h4><p>创建web工程，java enterprise - web application，引入jdk、tomcat。</p>
<h4 id="3-2-实现servlet规范"><a href="#3-2-实现servlet规范" class="headerlink" title="3.2.实现servlet规范"></a>3.2.实现servlet规范</h4><p>实现 Servlet 规范，即继承 HttpServlet 类（tomcat里的jar包支持的），该类中已经完成了通信的规则，我们只需要进行业务的实现即可。</p>
<p><strong>重写 service 方法</strong><br>满足 Servlet 规范只是让我们的类能够满足接收请求的要求，接收到请求后需要对请求进行分析，以及进行业务逻辑处理，计算出结果，则需要添加代码，在规范中有一个叫做 service的方法，专门用来做请求处理的操作，业务代码则可以写在该方法中。</p>
<p><strong>通过注解设置路径</strong></p>
<p>在完成好了一切代码的编写后，还需要向服务器说明，特定请求对应特定资源。</p>
<p>开发servlet项目，使用@WebServlet将一个继承于javax.servlet.http.HttpServlet 的类定义为Servlet组件。在Servlet3.0 中 ， 可以使用@WebServlet注解将一个继承javax.servlet.http.HttpServlet的类标注为可以处理用户请求的Servlet。</p>
<blockquote>
<p>javax.servlet下面有两个servlet-api，一个是servlet-api，这个定义了servlet规范，一个是javax.servlet-api，这个是serlvet提供的api。<br>@WebServlet这个注解是在javax.servlet-api依赖包里</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name可写可不写，value过滤器会拦截，urlPatterns过滤器不会拦截</span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,value=&quot;/ser01&quot;)</span> </span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns = &quot;/ser01&quot;)</span></span><br><span class="line">也可以配置多个路径：</span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,value=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span> </span><br><span class="line"><span class="meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-19 17:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Servlet!&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-发布项目并启动服务"><a href="#3-3-发布项目并启动服务" class="headerlink" title="3.3.发布项目并启动服务"></a>3.3.发布项目并启动服务</h4><p>到此，需要编写和配置的地方已经完成，项目已经完整了，但是如果需要外界能够访问， 还需要将项目发布到服务器上并运行服务器。</p>
<p>设置tomcat配置，设置项目的站点名（项目对外访问路径）</p>
<p>配置中选deployment更改站点名。</p>
<p>然后启动就可以访问页面。</p>
<p><a href="http://localhost:8080/servlet_demo/ser01">http://localhost:8080/servlet_demo/ser01</a></p>
<p>tomcat有个绿点表示正在运行。</p>
<h3 id="4-servlet工作流程"><a href="#4-servlet工作流程" class="headerlink" title="4.servlet工作流程"></a>4.servlet工作流程</h3><p>1.通过请求头获知浏览器访问的是哪个主机</p>
<p>2.再通过请求行获取访问的是哪个一个web应用</p>
<p>3.再通过请求行中的请求路径获知访问的是哪个资源</p>
<p>4.通过获取的资源路径在配置中匹配到真实的路径</p>
<p>5.服务器会创建servlet对象，（如果是第一次访问时，创建servlet实例，并调用init方法进行初始化操作）</p>
<p>6.调用service（request， response）方法来处理请求和响应的操作</p>
<p>7.调用service完毕后返回服务器，由服务器将response缓冲区的数据取出，以http响应的格式发送给浏览器</p>
<h3 id="5-servlet工作模式"><a href="#5-servlet工作模式" class="headerlink" title="5.servlet工作模式"></a>5.servlet工作模式</h3><ul>
<li>客户端发送请求至服务器</li>
<li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li>
<li>服务器将响应返回客户端</li>
</ul>
<h3 id="6-servlet生命周期"><a href="#6-servlet生命周期" class="headerlink" title="6.servlet生命周期"></a>6.servlet生命周期</h3><p>Servlet没有 main()方法，不能独立运行，它的运行完全由 Servlet 引擎来控制和调度。 所谓生命周期，指的是servlet 容器何时创建 servlet 实例、何时调用其方法进行请求的处理、 何时并销毁其实例的整个过程。</p>
<ol>
<li>实例和初始化时机（类加载和实力化）<br>当请求到达容器时，容器查找该 servlet 对象是否存在，如果不存在，则会创建实例并进行初始化。</li>
<li>就绪/调用/服务阶段<br>有请求到达容器，容器调用 servlet 对象的 service()方法,处理请求的方法在整个生命周期中可以被多次调用；<br>HttpServlet 的 service()方法，会依据请求方式来调用 doGet()或者 doPost()方法。但是， 这两个 do 方法默认情况下，会抛出异常，需要子类去 override。</li>
<li>销毁时机<br>当容器关闭时（应用程序停止时），会将程序中的 Servlet 实例进行销毁。</li>
</ol>
<p>上述的生命周期可以通过 Servlet 中的生命周期方法来观察。在 Servlet 中有三个生命周 期方法，不由用户手动调用，而是在特定的时机由容器自动调用，观察这三个生命周期方法 即可观察到 Servlet 的生命周期。</p>
<p>1⃣️ init 方法，在 Servlet 实例创建之后执行（证明该 Servlet 有实例创建了）</p>
<p>2⃣️service 方法，每次有请求到达某个 Servlet 方法时执行，用来处理请求（证明该Servlet 进行服务了）</p>
<p>3⃣️destroy 方法，Servlet 实例销毁时执行（证明该 Servlet 的实例被销毁了）</p>
<p>Servlet 的生命周期，简单的概括这就分为四步：servlet 类加载–&gt;实例化–&gt;服务–&gt;销毁。<br>下面描述一下 Tomcat 与 Servlet 是如何工作的,看看下面的时序图：</p>
<p><img src="https://img-blog.csdnimg.cn/95e97377049b47058831a2b7cbfe442d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<ol>
<li>Web Client 向 Servlet 容器（Tomcat）发出 Http 请求</li>
<li>Servlet 容器接收 Web Client 的请求</li>
<li>Servlet 容器创建一个 HttpServletRequest 对象，将 Web Client 请求的信息封装到这个对象 中</li>
<li>Servlet 容器创建一个 HttpServletResponse 对象</li>
<li>Servlet 容器调HttpServlet 对象service 方法，把 Request 与 Response 作为参数，传给 HttpServlet</li>
<li>HttpServlet 调用 HttpServletRequest 对象的有关方法，获取 Http 请求信息</li>
<li>HttpServlet 调用 HttpServletResponse 对象的有关方法，生成响应数据</li>
<li>Servlet 容器把 HttpServlet 的响应结果传给 Web Client</li>
</ol>
<h3 id="7-形参：HttpServletRequest对象"><a href="#7-形参：HttpServletRequest对象" class="headerlink" title="7.形参：HttpServletRequest对象"></a>7.形参：HttpServletRequest对象</h3><p>HttpServletRequest 对象：主要作用是用来接收客户端发送过来的请求信息，例如：请求的参数，发送的头信息等都属于客户端发来的信息，service()方法中形参接收的HttpServletRequest 接口的实例化对象，表示该对象主要应用在 HTTP 协议上，该对象是由 Tomcat 封装好传递过来。</p>
<p>HttpServletRequest 是 ServletRequest 的子接口，ServletRequest 只有一个子接口，就是 HttpServletRequest。既然只有一个子接口为什么不将两个接口合并为一个？<br>从长远上讲：现在主要用的协议是 HTTP 协议，但以后可能出现更多新的协议。若以后想要支持这种新协议，只需要直接继承 ServletRequest 接口就行了。</p>
<p>在 HttpServletRequest 接口中，定义的方法很多，但都是围绕接收客户端参数的。但是怎么拿到该对象呢？不需要，直接在 Service 方法中由容器传入过来，而我们需要做的就是取出对象中的数据，进行分析、处理。</p>
<h4 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 09:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取请求时的完整路径（从http开始，到？前面结束）</span></span><br><span class="line">        String url = req.getRequestURL() +<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;url:&quot;</span>+url);</span><br><span class="line">        <span class="comment">// 获取请求时的部分路径（从项目的站点名称开始，到？前面结束）</span></span><br><span class="line">        String uri = req.getRequestURI();</span><br><span class="line">        System.out.println(<span class="string">&quot;uri:&quot;</span>+uri);</span><br><span class="line">        <span class="comment">// 获取请求时的参数字符串（从？开始）</span></span><br><span class="line">        String queryString = req.getQueryString();</span><br><span class="line">        System.out.println(<span class="string">&quot;queryString:&quot;</span>+queryString);</span><br><span class="line">        <span class="comment">// 获取请求方式</span></span><br><span class="line">        String method = req.getMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method);</span><br><span class="line">        <span class="comment">// 获取当前协议版本</span></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        System.out.println(<span class="string">&quot;protocol:&quot;</span>+protocol);</span><br><span class="line">        <span class="comment">// 获取项目的站点名</span></span><br><span class="line">        String webApp = req.getContextPath();</span><br><span class="line">        System.out.println(<span class="string">&quot;webApp:&quot;</span>+webApp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取请求的参数</span></span><br><span class="line"><span class="comment">         * http://localhost:8080/servlet_demo/ser03?uname=lili&amp;upwd=lslsls&amp;input=111&amp;input=222&amp;input=333</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取指定名称的参数值,返回字符串</span></span><br><span class="line">        String uname = req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        String upwd = req.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;uname:&quot;</span>+uname);</span><br><span class="line">        System.out.println(<span class="string">&quot;upwd:&quot;</span>+upwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定名称的参数的所有参数值,返回字符串数组（用于复选框传值）</span></span><br><span class="line">        String[] strings = req.getParameterValues(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(strings != <span class="keyword">null</span> &amp;&amp; strings.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s : strings)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;strings:&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h4><p>由于现在的 request 属于接收客户端的参数，所以必然有其默认的语言编码，主要是由于在解析过程中默认使用的编码方式为 ISO-8859-1(此编码不支持中文)，所以解析时一定会出现乱码。要想解决这种乱码问题，需要设置request 中的编码方式，告诉服务器以何种方式来解析数据。或者在接收到乱码数据以后，再通过相应的编码格式还原。<br>方式一：</p>
<p><code>String nuname = new String(request.getParameter(name).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); </code></p>
<p>借助了String 对象的方法，该种方式对任何请求有效，是通用的。但是原本不是乱码的，使用的话会出现乱码。<br>Tomcat8起，以后的GET方式请求是不会出现乱码的。POST请求是会乱码的。</p>
<p>用JSP进行post请求表单提交：新建login.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;ser03&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;upwd&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8080/servlet_demo/login.jsp">http://localhost:8080/servlet_demo/login.jsp</a></p>
<p>方式二：通过设置服务器解析编码的格式（只针对post请求）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置编码格式</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);	</span><br></pre></td></tr></table></figure>

<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>请求转发，是一种服务器的行为，当客户端请求到达后，服务器进行转发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务器端再将响应发送给客户端，从始至终只有一个请求发出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * 请求转发跳转</span></span><br><span class="line"><span class="comment"> * 可以让请求从服务端跳转到客户端即jsp（或跳转到指定Servlet）服务器行为</span></span><br><span class="line"><span class="comment"> * 特点：1。服务端行为 2。地址栏不会发生改变</span></span><br><span class="line"><span class="comment"> * 3。从始至终只有一个请求 4。request数据可以共享</span></span><br><span class="line"><span class="comment"> * 只能跳一次</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 接收客户端请求的参数</span></span><br><span class="line">        String uname = req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ser04 uname:&quot;</span>+uname);</span><br><span class="line">        <span class="comment">// 请求转发跳转到ser03</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;ser03&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a><strong>request作用域</strong></h4><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。（请求转发跳转时有效，直接访问跳转的url无效）。作用域在一次请求中，在请求转发过程中通过request来传输/共享数据。</p>
<p>Ser05，准备用来请求转发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * request作用域</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet5</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置域对象</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        <span class="comment">// 请求转发并跳转到Servlet6，共享同一个req对象</span></span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;ser06&quot;).forward(req, resp);</span></span><br><span class="line">        <span class="comment">// 一般是从客户端获取数据，所以跳转到jsp客户端</span></span><br><span class="line">        <span class="comment">// 请求转发跳转到jsp，并通过域对象传递数据</span></span><br><span class="line">        <span class="comment">// html就不行，因为是静态页面，而jsp是动态页面</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;attribute.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转到ser06</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-20 21:34</span></span><br><span class="line"><span class="comment"> * request作用域</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet6</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取域对象</span></span><br><span class="line">        String name = (String) req.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">        List&lt;String&gt; list = (List&lt;String&gt;) req.getAttribute(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转到jsp：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;attribute页面&lt;/h2&gt;</span><br><span class="line">&lt;%-- 如果要在jsp中写java代码，需要写在脚本段中 --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取域对象</span></span><br><span class="line">    String name = (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="8-形参：HttpServletResponse对象"><a href="#8-形参：HttpServletResponse对象" class="headerlink" title="8.形参：HttpServletResponse对象"></a>8.形参：<strong>HttpServletResponse对象</strong></h3><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的 request 对象和代表响应的 response 对象。<br>request 和 response 对象代表请求和响应：获取客户端数据，需要通过 request 对象；向客户端输出数据，需要通过 response 对象。</p>
<p>HttpServletResponse 的主要功能用于服务器对客户端的请求进行响应，将 Web 服务器处理后的结果返回给客户端。service()方法中形参接收的是 HttpServletResponse 接口的实例化对象，这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p>
<h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。有两种形式：</p>
<p>getWriter() 获取字符流(只能响应字符) </p>
<p>getOutputStream() 获取字节流(能响应一切数据)</p>
<p>响应回的数据到客户端被浏览器解析。<br>注意：两者不能同时使用。一个文件里只能用一个，因为response只有一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-22 08:50</span></span><br><span class="line"><span class="comment"> * getWriter() 字符输出流(输出字符串)</span></span><br><span class="line"><span class="comment"> * getOutputStream() 字节输出流(输出一切数据)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet7</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//        // getWrite获取字符输出流</span></span><br><span class="line"><span class="comment">//        PrintWriter writer = resp.getWriter();</span></span><br><span class="line"><span class="comment">//        // 输出数据</span></span><br><span class="line"><span class="comment">//        writer.write(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getOutputStream字节输出流</span></span><br><span class="line">        ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">        <span class="comment">// 输出数据</span></span><br><span class="line">        out.write(<span class="string">&quot;hi&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h4><p>在响应中，如果我们响应的内容中含有中文，则有可能出现乱码。这是因为服务器响应的数据也会经过网络传输，服务器端有一种编码方式，在客户端也存在一种编码方式，当两端使用的编码方式不同时则出现乱码。</p>
<p>getWriter()的字符乱码<br>对于 getWriter()获取到的字符流，响应中文必定出乱码，由于服务器端在进行编码时默认会使用 ISO-8859-1 格式的编码，该编码方式并不支持中文。</p>
<p>要解决该种乱码只能在服务器端告知服务器使用一种能够支持中文的编码格式，比如我们通常用的”UTF-8”。</p>
<p>客户端也要设置，字节输出流可以设置响应类型，默认是字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置服务端的编码格式</span></span><br><span class="line">resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 设置客户端的编码格式和响应类型</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);       </span><br></pre></td></tr></table></figure>

<p>字符输出流也一样。</p>
<p>也可以同时设置客户端和服务端的编码格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同时设置服务端和客户端的编码格式</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>总结：要想解决响应的乱码，只需要保证使用支持中文的编码格式。并且保证服务器端 和客户端使用相同的编码方式即可。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址（下次请求的地址 response.sendRedirect(url);），当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起第二个请求，服务器接收请求并作出响应，重定向完成。<br>从描述中可以看出重定向当中有两个请求存在，并且属于客户端行为。</p>
<p>特点：<br>服务端指导，客户端行为<br>存在两次请求<br> request对象不共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-22 08:50</span></span><br><span class="line"><span class="comment"> * 重定向 302</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet8</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ser08&quot;</span>);</span><br><span class="line">        String uname = req.getParameter(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ser08:&quot;</span>+uname);</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;ser07&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察浏览器我们发现第一次请求获得的响应码为 302，并且含有一个 location 头信息。并且地址栏最终看到的地址是和第一次请求地址不同的，地址栏已经发生了变化。</p>
<h4 id="请求转发与重定向的区别"><a href="#请求转发与重定向的区别" class="headerlink" title="请求转发与重定向的区别"></a><strong>请求转发与重定向的区别</strong></h4><p><img src="https://img-blog.csdnimg.cn/60cc937f78be4bff8e93f84aebea79f2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>对于请求转发，举个例子，前端页面输入用户名和密码，req.getAttribute获取参数，或是req.setAttribute设置参数，使用请求转发可以将参数传递到jsp页面，jsp页面使用req.getAttribute进行获取。</p>
<p>而重定向是返回一个新的页面，两个页面之间没有参数传递。</p>
<p>请求转发的地址只能是当前站点下（字符串参数就是加载项目根目录后面的字符串），重定向地址可以是任意地址。跨域跳转只能用重定向。</p>
<h3 id="9-cookie"><a href="#9-cookie" class="headerlink" title="9.cookie"></a>9.cookie</h3><p>web程序使用http协议传输，http无状态，导致每一次连接传输的数据量增大。服务器从网络连接中无法获得客户端身份，cookie相当于是服务端颁发给客户端的通行证。不同的服务器应用给客户端的cookie也不一样，是隔离的。</p>
<p>cookie是浏览器提供的一种技术，通过服务器的程序能将一些只须保存在客户端，或者在客户端进行处理的数据，放在本地的计算机上，不需要通过网络传输，因而提高网页处理的效率，并且能够减少服务器的负载，但是由于cookie是服务器保存在客户端的信息，所以其安全性也是很差的。例如常见的记住密码则可以通过cookie来实现，还有通常的推荐显示。</p>
<p>有一个专门操作Cookie的类javax.servlet.http.Cookie。随着服务器端的响应发送给客户端，保存在浏览器。当下次再访问服务器时把Cookie再带回服务器。</p>
<p>Cookie的格式：键值对用=连接，多个键值对间用;隔开。</p>
<h4 id="cookie的创建和发送"><a href="#cookie的创建和发送" class="headerlink" title="cookie的创建和发送"></a>cookie的创建和发送</h4><p>通过 new Cookie(“key”,“value”);来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie(cookie);此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的创建和发送</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建cookie name唯一</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送（响应）cookie</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mac浏览器检查cookie：右键检查元素–储存空间–点击cookie</p>
<h4 id="cookie的获取"><a href="#cookie的获取" class="headerlink" title="cookie的获取"></a>cookie的获取</h4><p>在服务器端只提供了一个 getCookies()的方法用来获取客户端回传的所有 cookie 组成的一个数组，如果需要获取单 个 cookie 则需要通过遍历，getName()获取 Cookie 的名称，getValue()获取 Cookie 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的返回，是数组</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie02</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取cookie数组</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 遍历cookie数组</span></span><br><span class="line">            <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                String value = cookie.getValue();</span><br><span class="line">                System.out.println(<span class="string">&quot;名称：&quot;</span>+name+<span class="string">&quot;--值：&quot;</span>+value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行就有上次传入浏览器的cookie。</p>
<h4 id="cookie设置到期时间"><a href="#cookie设置到期时间" class="headerlink" title="cookie设置到期时间"></a>cookie设置到期时间</h4><p>除了 Cookie 的名称和内容外，我们还需要关心一个信息，到期时间，到期时间用来指定该 cookie 何时失效。默认 为当前浏览器关闭即失效。我们可以手动设定 cookie 的有效时间（通过到期时间计算），通过 setMaxAge(int time);方法设定 cookie 的最大有效时间，以秒为单位。</p>
<p>到期时间的取值：</p>
<ul>
<li><p>负整数</p>
<p>若为负数，表示不在硬盘存储该 cookie。</p>
<p>cookie 的 maxAge 属性的默认值就是-1，表示只在浏览器内存中存活，一旦关闭浏览器窗口，那么 cookie 就会消失。</p>
</li>
<li><p>正整数</p>
<p>大于 0 的整数，表示存储的秒数。</p>
<p>表示 cookie 对象可存活指定的秒数。当生命大于 0 时，浏览器会把 Cookie 保存到硬盘上，就算关闭浏览器， 就算重启客户端电脑，cookie 也会存活相应的时间。</p>
</li>
<li><p>零(用于删除Cookie)</p>
<p>若为 0，表示删除该 cookie。</p>
<p>cookie 生命等于 0 是一个特殊的值，它表示 cookie 被作废！也就是说，如果原来浏览器已经保存了这个 Cookie，那么可以通过 Cookie 的 setMaxAge(0)来删除这个 Cookie。 无论是在浏览器内存中，还是在客户端 硬盘上都会删除这个 Cookie。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 11:04</span></span><br><span class="line"><span class="comment"> * cookie的到期时间</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/coo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie03</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 默认值-1，表示只在浏览器内存中</span></span><br><span class="line">        <span class="comment">// 创建Cookie对象</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Cookie 3天后失效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">3</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 发送Cookie对象 设置之后必需进行响应</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">        <span class="comment">// 删除之前的cookie</span></span><br><span class="line">        Cookie oldCookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kkk&quot;</span>);</span><br><span class="line">        oldCookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        resp.addCookie(oldCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="cookie的注意点"><a href="#cookie的注意点" class="headerlink" title="cookie的注意点"></a>cookie的注意点</h4><ul>
<li>Cookie保存在当前浏览器中。</li>
</ul>
<p>在一般的站点中常常有记住用户名这样一个操作，该操作只是将信息保存在本机上，换电脑以后这些信息就无 效了。而且 cookie 还不能跨浏览器。</p>
<ul>
<li>Cookie存中文问题 （一般不存中文）</li>
</ul>
<p>Cookie 中不能出现中文，如果有中文则通过 URLEncoder.encode()来进行编码，获取时通过 URLDecoder.decode()来进行解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">&quot;姓名&quot;</span>;</span><br><span class="line">String value = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="comment">// 通过 URLEncoder.encode()来进行编码</span></span><br><span class="line">name = URLEncoder.encode(name);</span><br><span class="line">value = URLEncoder.encode(value);</span><br><span class="line"><span class="comment">// 创建Cookie对象</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(name,value);</span><br><span class="line"><span class="comment">// 发送Cookie对象</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取时通过 URLDecoder.decode()来进行解码</span></span><br><span class="line">String name = URLDecoder.decode(cookie.getName());</span><br><span class="line">String value = URLDecoder.decode(cookie.getValue());</span><br></pre></td></tr></table></figure>

<ul>
<li>同名Cookie问题</li>
</ul>
<p>如果服务器端发送重复的Cookie那么会覆盖原有的Cookie。</p>
<ul>
<li>浏览器存放Cookie的数量</li>
</ul>
<p>不同的浏览器对Cookie也有限定，Cookie的存储有是上限的。Cookie是存储在客户端（浏览器）的，而且一般 是由服务器端创建和设定。后期结合Session来实现回话跟踪。Cookie的大小也是有限制的，一般是4kb以下。</p>
<h4 id="cookie的路径"><a href="#cookie的路径" class="headerlink" title="cookie的路径"></a>cookie的路径</h4><p>Cookie的setPath设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些cookie。</p>
<p><strong>情景一：当前服务器下任何项目的任意资源都可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/&quot;，表示在当前服务器下任何项目都可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景二：当前项目下的资源可获取Cookie对象 （默认不设置Cookie的path）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/s01&quot;，表示在当前项目下任何项目都可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_demo&quot;</span>); <span class="comment">// 默认情况，可不设置path的值</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景三：指定项目下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当前项目路径为：servlet_demo */</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/servlet_1&quot;，表示在s02项目下才可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_1&quot;</span>); <span class="comment">// 只能在servlet_1项目下获取Cookie，就算cookie是servlet_demo产生的，servlet_demo也不能获取它</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p><strong>情景四：指定项目的指定目录下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;XXX&quot;</span>);</span><br><span class="line"><span class="comment">// 设置路径为&quot;/servlet_demo/coo1&quot;，表示在servlet_demo/coo1目录下才可访问到Cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/servlet_demo/cook&quot;</span>); </span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p>如果我们设置path，如果当前访问的路径包含了cookie的路径（当前访问路径在cookie路径基础上要比cookie的范围小）cookie就会加载到request对象之中。</p>
<p>cookie的路径指的是可以访问该cookie的顶层目录，该路径的子路径也可以访问该cookie。</p>
<p>总结：当访问的路径包含了cookie的路径时，则该请求将带上该cookie；如果访问路径不包含cookie路径，则该请求不会携带该cookie。</p>
<h3 id="10-HttpSession对象"><a href="#10-HttpSession对象" class="headerlink" title="10.HttpSession对象"></a>10.HttpSession对象</h3><p>上面讲解了请求的概念，无状态，无法做到多个请求之间的数据共享。</p>
<p>HttpSession对象是javax.servlet.http.HttpSession的实例，该接口并不像HttpServletRequest或HttpServletResponse还存在一个父接口，该接口只是一个纯粹的接口。这因为Session本身就属于HTTP协议的范畴。</p>
<p>Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p>
<p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。<strong>一 个会话通常对应于一个用户，该用户可能多次访问一个站点</strong>。可以通过此接口查看和操作有关某个会话 的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。</p>
<p>session无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的session，因为每一个session只保存在当前的浏览器当中，并在相关的页面取得。</p>
<p>session的作用是为了标识一次会话，或者说确认一个用户；并且在<strong>一次会话（一个用户的多次请求）</strong>期间共享数据。可以通过request.getSession()方法，来获取当前会话的session对象。当获取session对象时，会先判断session对象是否存在，如果存在，则获取session对象，如果不存在，则创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-26 22:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/sess01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Session1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// session对象的获取,</span></span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">// 获取session的唯一标识--会话标识符</span></span><br><span class="line">        String id = session.getId();</span><br><span class="line">        System.out.println(<span class="string">&quot;唯一标识符号：&quot;</span>+id);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建时间：&quot;</span>+session.getCreationTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;最后一次访问时间(时间戳)：&quot;</span>+session.getLastAccessedTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是新的session对象：&quot;</span>+session.isNew());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="标识会话-JSESSIONID"><a href="#标识会话-JSESSIONID" class="headerlink" title="标识会话 JSESSIONID"></a><strong>标识会话 JSESSIONID</strong></h4><p>Session 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionId。</p>
<p>每当一次请求到达服务器，如果服务器开启了会话（访问了 session），服务器第一步会查看是否从客户端回传一个名为 JSESSION 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionId 为此次会话做一个标志，<strong>并且还会传对应的cookie在浏览器</strong>。如果有 JESSIONID 这个 cookie 回传，服务器则会 根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话，<strong>并会向浏览器响应一个新的cookie，浏览器更新这个cookie</strong>；如果找到了相应的 session 对象，则认为是之前标志过的一次会话，返回该 session 对象，数据达到共享。</p>
<blockquote>
<p>浏览器每一次访问服务器，都会将cookie传给后台，后台可以操作cookie再响应。</p>
<p>浏览器里可以将sessionid的cookie删掉。</p>
</blockquote>
<p>这里提到一个叫做 JSESSION 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSION，值为获取到的 session（无论是获取到的还是 新创建的）的 sessionId 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p>
<p>sessionid以cookie的形式存储； Session 的底层依赖 Cookie 来实现。一个服务器应用可以对应多个cookie，但是只能有一个session。</p>
<p>cookie是为了方便减少数据传输的，让服务端记住客户端身份的；session是为了多次访问记住状态的，也就是形成会话的。</p>
<p>cookie是有路径的，session就看是不是一次会话了。</p>
<h4 id="session域对象"><a href="#session域对象" class="headerlink" title="session域对象"></a>session域对象</h4><p>Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAttribute(String name, Object o); <span class="comment">// 设置域对象内容 </span></span><br><span class="line">getAttribute(String name); <span class="comment">// 获取域对象内容 </span></span><br><span class="line">removeAttribute(String name); <span class="comment">//删除域对象内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-27 09:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/sess02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Session2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;uname&quot;</span>, <span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        req.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求转发跳转到jsp页面，请求转发，一次请求，request可以拿到，session也可以拿到</span></span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;sess01.jsp&quot;).forward(req, resp);</span></span><br><span class="line">        <span class="comment">// 重定向跳转到jsp页面,两次请求，request失效，但是session可以拿到</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;sess01.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: mac</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">27</span></span><br><span class="line">  Time: 上午<span class="number">10</span>:<span class="number">00</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;获取域对象&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取session域对象</span></span><br><span class="line">    String uname = (String) request.getSession().getAttribute(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">    String pwd = (String) request.getSession().getAttribute(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取request域对象</span></span><br><span class="line">    String name = (String) request.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;session uname:&quot;</span>+uname);</span><br><span class="line">    System.out.println(<span class="string">&quot;session pwd:&quot;</span>+ pwd);</span><br><span class="line">    System.out.println(<span class="string">&quot;request name:&quot;</span>+ name);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>数据存储在 session 域对象中，当 session 对象不存在了，数据也就不能共享了。不同的服务器应用之间，session对象也是隔离的，两个不同的session对象间数据不能共享。</p>
<h4 id="session的销毁"><a href="#session的销毁" class="headerlink" title="session的销毁"></a><strong>session的销毁</strong></h4><p>1.默认到期时间</p>
<p>当客户端第一次请求servlet并且操作session时，session对象生成，Tomcat中session默认的存活时间为30min，即你不操作界面的时间，一旦有操作，session会重新计时。</p>
<p>session的默认时间可以在tomcat安装目录下的conf目录下的web.xml文件中进行修改。单位为分。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.设置到期时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过session.setMaxInactionInterval()可以自行设定存活时间，单位为秒</span></span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//10秒后销毁session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看session最大不活动时间，即存活时间</span></span><br><span class="line">System.out.println(session.getMaxInactiveInterval());</span><br></pre></td></tr></table></figure>

<p>3.立即销毁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.invalidate();</span><br><span class="line"><span class="comment">//session立即作废</span></span><br></pre></td></tr></table></figure>

<p>浏览器每次访问都是一个新的。</p>
<p>4.关闭浏览器</p>
<p>session底层以来cookie，cookie对象默认只在浏览器内存中存活，关闭浏览器即失效。</p>
<p>这个默认的优先级高，如果不关浏览器30分钟失效，关了浏览器立马失效。</p>
<p>5.关闭服务器</p>
<p>非正常关闭服务器时才会失效。      </p>
<p>如果是正常关闭服务器，session会被钝化到本地磁盘，下次访问时会从本地磁盘中活化出来。在 工作空间 work 目录下的 SESSION.ser 文件中。 </p>
<p>Session 失效则意味着此次会话结束，数据共享结束。</p>
<h3 id="11-ServletContext对象"><a href="#11-ServletContext对象" class="headerlink" title="11.ServletContext对象"></a>11.ServletContext对象</h3><h4 id="ServletContext对象的获取"><a href="#ServletContext对象的获取" class="headerlink" title="ServletContext对象的获取"></a>ServletContext对象的获取</h4><p>每一个web应用都有且仅有一个ServletContext对象，又称为Application对象，从名称中可知，该对象是与应用程序相关的。在web容器启动时，会为每一个web应用程序创建一个对应的ServletContext对象。</p>
<p>该对象有两大作用，第一、作为域对象来共享数据，此时数据在整个应用程序中共享；第二、该对象中保存了当前应用程序相关信息。例如可以通过getServerInfo()方法获取当前服务器信息，getRealPath(String path)获取资源的真实路径等。</p>
<p>ServletContext对象获取：</p>
<p>①.通过request对象获取</p>
<p>ServletContext servletContext = req.getServletContext();<br>(不能用了？)</p>
<p>②.通过session对象获取</p>
<p>ServletContext servletContext = request.getSession().getServletContext();</p>
<p>③.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法</p>
<p>ServletContext servletContext = getServletConfig().getServletContext();</p>
<p>④.直接获取 Servlet类中提供了直接获取ServletContext对象的方法</p>
<p>ServletContext servletContext = getServletContext();</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext servletContext = getServletContext();</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//获取当前服务器的版本信息</span></span><br><span class="line"><span class="comment">//Apache Tomcat/9.0.59</span></span><br><span class="line">String ServletInfo = servletContext.getServerInfo();</span><br><span class="line">System.out.println(<span class="string">&quot;服务器当前的版本信息：&quot;</span> + ServletInfo);</span><br><span class="line"><span class="comment">//获取项目的真实路径</span></span><br><span class="line">String realPath = servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);     <span class="comment">//表示获取根路径,项目的而不是应用的</span></span><br><span class="line"><span class="comment">///Users/liuxuan/MyProject/JavaProject/java/web/target/web/</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取项目的真实路径：&quot;</span> + realPath);</span><br></pre></td></tr></table></figure>



<h4 id="ServletContext域对象"><a href="#ServletContext域对象" class="headerlink" title="ServletContext域对象"></a>ServletContext域对象</h4><p>ServletContext也可以当做域对象来使用，通过ServletContext中存取数据，可以使得整个应用程序共享某些数据。当然不建议存放过多数据，因为ServletContext中的数据一旦存储进去没有手动移除的话，将会一直保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-29 09:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/con02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        ServletContext servletContext = getServletContext();</span><br><span class="line">        <span class="comment">// 设置域对象</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取域对象</span></span><br><span class="line">        String name = (String) servletContext.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">// 移除域对象</span></span><br><span class="line">        servletContext.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Servlet三大作用域</strong>：</p>
<p>1.request域对象<br>在一次请求中有效。请求转发有效,重定向失败。</p>
<p>2.session域对象<br>在一次会话中有效。请求转发和重定向都有效，session销毁后失效。</p>
<p>3.servletContext域对象<br>在整个应用程序中有效。服务器关闭销毁。</p>
<h3 id="12-文件上传和下载"><a href="#12-文件上传和下载" class="headerlink" title="12.文件上传和下载"></a>12.文件上传和下载</h3><p>servlet中如何实现文件的上传和下载。</p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>文件上传涉及到前台页面的编写和后台服务器端代码的编写，前台发送文件，后台接收并保存文件，这才是一个完整的文件上传。</p>
<h5 id="前台页面"><a href="#前台页面" class="headerlink" title="前台页面"></a>前台页面</h5><p>在做文件上传的时候，会有一个上传文件的界面，首先我们需要一个表单，并且表单的请求方式为 POST；其次我们的 form 表单的 enctype 必须设为”multipart/form-data”即 enctype=“multipart/form-data” 意思是设置表单的 MIME 编码。默认情况下这个编码格式是 ”application/x-www-form-urlencoded”，不能用于文件上传；只有使用了 multipart/form-data 才能完整地传递文件数据。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: mac</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">3</span>/<span class="number">29</span></span><br><span class="line">  Time: 下午<span class="number">9</span>:<span class="number">41</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;文件上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        <span class="number">1.</span>准备表单</span><br><span class="line">        <span class="number">2.</span>设置表单的提交类型 method=<span class="string">&quot;post&quot;</span></span><br><span class="line">        <span class="number">3.</span>设置表单类型为文件上传表单 enctype=<span class="string">&quot;multipart/form-data&quot;</span></span><br><span class="line">        <span class="number">4.</span>设置文件提交的地址 action=<span class="string">&quot;uploadServlet&quot;</span></span><br><span class="line">        <span class="number">5.</span>准备表单元素 <span class="number">1.</span>普通表单项 type=<span class="string">&quot;text&quot;</span> <span class="number">2.</span>文件项 type=<span class="string">&quot;file&quot;</span></span><br><span class="line">        <span class="number">6.</span>设置表单元素的name属性值，否则后台无法接收数据</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;uploadServlet&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">        姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uname&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myfile&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;!-- button 默认的 type 属性是 submit，做提交按钮可以不设置 type --&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;submit&quot;</span>&gt; 提交 &lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h5><p>使用注解 <code>@MultipartConfig</code>标识为支持文件上传， Servlet 将 <code>Multipart/form-data</code> 的post请求封装成 Part 通过part对上传文件进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-29 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/uploadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传......&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为保证数据正确性，首先设置编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取普通表单项参数</span></span><br><span class="line">        String uname = req.getParameter(<span class="string">&quot;uname&quot;</span>); <span class="comment">// 表单元素中 uname 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;uname：&quot;</span> + uname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Part 对象，上传的文件</span></span><br><span class="line">        Part part = req.getPart(<span class="string">&quot;myfile&quot;</span>); <span class="comment">// 表单中 file 文件域的 name 属性值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 part 对象得到上传的文件名</span></span><br><span class="line">        String fileName = part.getSubmittedFileName();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传的文件名：&quot;</span> + fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到文件要存放的路径--项目路径</span></span><br><span class="line">        String filePath = req.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        System.out.println(filePath); <span class="comment">// 文件存放的路径</span></span><br><span class="line">        <span class="comment">// /Users/liuxuan/MyProject/JavaProject/servletdemo/servlet-demo/out/artifacts/servlet_demo_war_exploded/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存文件到指定路径</span></span><br><span class="line">        part.write(filePath + <span class="string">&quot;/&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前端页面…/upload.jsp选择文件提交后，自动跳转至…/uploadServlet页面。</p>
<p>⚠️一个飘红问题</p>
<p>Servlet3.0新增了request.getParts()/getPart(String filename) api，用于获取使用multipart/form-data格式传递的http请求的请求体，通常用于获取上传文件。用于从请求中解析上传的文件。</p>
<p>request.getParts()  获取请求中全部文件<br>getPart(String filename)   获取请求中指定name的文件</p>
<p>所以getPart方法飘红的话，看一下用的servlet方法版本是不是3.0的。</p>
<p><code>InputStream is = part.getInputStream();</code> 获取输入流</p>
<p>需要注意的是，使用request.getParts()方法必须给servlet添加注解@MultipartConfig，否则虽然不会抛出异常，但是获取不到数据。</p>
<p>更多用法撒：<br><a href="https://blog.csdn.net/u012334071/article/details/50261063/">https://blog.csdn.net/u012334071/article/details/50261063/</a></p>
<p><a href="https://wenku.baidu.com/view/c66d20190a12a21614791711cc7931b765ce7b61.html">https://wenku.baidu.com/view/c66d20190a12a21614791711cc7931b765ce7b61.html</a></p>
<p><a href="https://www.cnblogs.com/sunyongxing/articles/2622891.html">https://www.cnblogs.com/sunyongxing/articles/2622891.html</a></p>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>即将服务器上的资源下载（拷贝）到本地，可以通过两种方式下载：通过超链接下载、通过代码下载。</p>
<p>项目内的文本或图片资源文件夹需要通过 Tomcat -&gt; Deployment 进行上传才能通过项目发布，进行访问。</p>
<h5 id="超链接下载"><a href="#超链接下载" class="headerlink" title="超链接下载"></a>超链接下载</h5><p>当我们在HTML或JSP页面中使用a标签时，原意是希望能够进行跳转，但当超链接遇到浏览器不识别的资源时会自动下载；当遇到浏览器能够直接显示的资源，浏览器就会默认显示出来，比如txt、png、jpg等。当然我们也可以通过download属性规定浏览器进行下载。但有些浏览器并不支持。</p>
<p>在web文件夹下新建一个download文件夹，准备图片、文本放在这个文件夹下，文件存放地址需要配置一下，点右上角configuration，再点deployment，再点加号external source，选到download文件夹下，再改一下application context：/servlet_demo/download。这样文件夹下的资源才能被浏览器访问到。（这个download是文件夹名字）</p>
<p>访问：<a href="http://localhost:8080/servlet_demo/download.html">http://localhost:8080/servlet_demo/download.html</a> （这个download是html名字）</p>
<p>download.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浏览器能够识别的资源，点击展示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/TacoCloud.jpeg&quot;</span>&gt;</span>图片文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/Taco.java&quot;</span>&gt;</span>文本文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加download点击下载,可不写属性名，表示文件名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/TacoCloud.jpeg&quot;</span> <span class="attr">download</span>=<span class="string">&quot;百度.jpeg&quot;</span>&gt;</span>图片文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;download/Taco.java&quot;</span> <span class="attr">download</span>=<span class="string">&quot;&quot;</span>&gt;</span>文本文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 浏览器不能够识别的资源,自动下载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>压缩文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="后台实现下载"><a href="#后台实现下载" class="headerlink" title="后台实现下载"></a>后台实现下载</h5><p>实现步骤：</p>
<p>得知道要下载的资源文件名，文件名传到后台代码之后：</p>
<ol>
<li>需要通过response.setContentType方法设置Content-type头字段的值，为浏览器无法使用某种方式或激活某个程序来处理的MIME类型，例如“application/octet-stream”或“application/x-msdownload‘等。</li>
<li>需要通过response.setHeader方法设置Content-Disposition头的值为“attachment;filename=文件名“</li>
<li>读取下载文件，调用response.getOutputStream方法向客户端写入附件内容。</li>
</ol>
<p>第一步：写html页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;文件下载&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;downloadServlet&quot;</span>&gt;</span><br><span class="line">        文件名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;fileName&quot;</span> placeholder=<span class="string">&quot;请输入要下载的文件名&quot;</span>&gt;</span><br><span class="line">        &lt;button&gt;下载&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：写一个servlet页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.servlet.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-31 21:59</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/downloadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写钥匙的</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件下载===&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置请求的编码格式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 乱码问题，设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取参数（得到要下载的文件名）</span></span><br><span class="line">        String fileName = req.getParameter(<span class="string">&quot;fileName&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数的非空判断  trim()去除字符串前后空格，中间的不管</span></span><br><span class="line">        <span class="keyword">if</span>(fileName == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(fileName.trim()))&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;请输入要下载的文件名！&quot;</span>);</span><br><span class="line">            resp.getWriter().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到图片存放的路径,文件放在配置好的download目录下的。</span></span><br><span class="line">        String path = req.getServletContext().getRealPath(<span class="string">&quot;/download/&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过路径得到file对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path + fileName);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件：&quot;</span>+ file);</span><br><span class="line">        <span class="comment">// 判断文件对象是否存在，并且是个标准文件</span></span><br><span class="line">        <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">            <span class="comment">// 1.设置响应类型，设置为浏览器无法使用某种方式或激活某个程序来处理的MIME类型</span></span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/x-msdownload&quot;</span>);</span><br><span class="line">            <span class="comment">// 2.设置响应头</span></span><br><span class="line">            resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName);</span><br><span class="line">            <span class="comment">// 3.得到file文件的输入流</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">// 4.得到字节输出流，字符输出流文件是不行的</span></span><br><span class="line">            ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">            <span class="comment">// 5.定义byte数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 6.定义长度</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 7.循环输出</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8.关闭资源</span></span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;文件不存在，请重试！&quot;</span>);</span><br><span class="line">            resp.getWriter().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/jadeliuliu/servletdemo/tree/master/servlet-demo">https://github.com/jadeliuliu/servletdemo/tree/master/servlet-demo</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>比较全的文章：<a href="https://blog.csdn.net/qq_19782019/article/details/80292110">https://blog.csdn.net/qq_19782019/article/details/80292110</a></p>
<p>实现：<a href="https://blog.csdn.net/Hello_zbs/article/details/108394660">https://blog.csdn.net/Hello_zbs/article/details/108394660</a></p>
<p>b站视频：<a href="https://www.bilibili.com/video/BV1Ta4y1H7Vc?p=26&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Ta4y1H7Vc?p=26&amp;spm_id_from=pageDriver</a></p>
<p>学习笔记：<a href="https://www.cnblogs.com/yuan-liu/p/15255326.html">https://www.cnblogs.com/yuan-liu/p/15255326.html</a></p>
<h3 id="servlet的get和post请求"><a href="#servlet的get和post请求" class="headerlink" title="servlet的get和post请求"></a>servlet的get和post请求</h3><p>get：将数据通过url附加数据现行的向服务器发送数据<br>post：将数据存放在请求体中隐性的向服务器发送数据</p>
<p>区别：<br>1.get常用于不包含敏感信息的查询功能 （不用输入密码）<br>2.post用于安全性较高的功能或者服务器的“写”操作 eg：用户登录、注册、更新账目</p>
<p>service()是请求处理的核心方法，无论是get或者是post都会被service()方法处理。<br>当采用无差别请求时，可以用service()方法。<br>request.getMethod()查看请求方式<br>doGet()方法处理get请求<br>doPost()方法处理post请求<br>response.setContentType(“text/html;charset=UTF-8”);解决中文乱码</p>
<p>参考：<a href="https://juejin.cn/post/6869979139164602382">https://juejin.cn/post/6869979139164602382</a></p>
<h3 id="WebServlet和-RequestMapping"><a href="#WebServlet和-RequestMapping" class="headerlink" title="@WebServlet和@RequestMapping"></a>@WebServlet和@RequestMapping</h3><p>都是用在Controller类里，用于拦截特定请求的。</p>
<p>@WebServlet注解作用在类上，用于标注在一个继承了HttpServlet类之上，属于类级别的注解，一般用于需要有HttpServletRequest请求中带了参数，或者需要filter等场景，这个是Servlet实现的路径映射逻辑。</p>
<p>@RequestMapping 在controller类上加，具体的方法上再加， 可以在控制器类的级别和/或其中的方法的级别上使用 处理普通的URI请求，或者http请求，这个是spring实现的DispatcherServlet的路径映射逻辑。</p>
<p>✅ 两种构造Controller的区别：</p>
<p>Controller是spring 的一个bean，由spring的IOC来管理的一个bean</p>
<p>Servlet是一个接口或者接口的实现（常见的是GenericServlet 和 HttpServlet）</p>
<p>Servlet实现方式：<br>有一个映射关系servlet-mapping，url的endpoint 对应的具体的servlet， 比如规定’/demo’ 映射到ServletDemo（继承自HttpServlet，重写doGet，doPost等方法）.<br>在浏览器地址栏输入localhost:8088/demo   , 这个请求就会执行到ServletDemo的doGet方法，经过一系列逻辑，最终将要返回给浏览器的数据写入HttpServletResponse，这样浏览器就能收到结果。</p>
<p>Controller实现方式：<br>只是一个bean，方法上可以加上注解GetMapping，PostMapping等，标注映射的url的endpoint。<br>Servlet容器（Tomcat等）接收到请求以后，将请求交给DispatcherServlet的service方法来处理，servlet会在doDispatch里面先找到mappedHandler ，然后找到HandlerAdapter。调用HandlerAdapter 的handle方法，其实应该是AbstractHandlerMethodAdapter，<br>然后调用到RequestMappingHandlerAdapter的handleInternal，最终调用到invokeAndHandle，反射调用controller的方法。找到endpoint对应的bean的方法，并调用。</p>
<p>总结：<br><em><strong>容器==》DispatcherServlet (service方法) ==》 doDispatcher ==》HandlerAdapter （handle）=》AbstractHandlerMethodAdapter==》RequestMappingHandlerAdapter ==》invokeAndHandle==》反射具体的controller方法</strong></em></p>
<p>转自：<a href="https://www.cnblogs.com/huainanyin/p/15936212.html">https://www.cnblogs.com/huainanyin/p/15936212.html</a></p>
<p>Spring提供的DispatcherServlet是怎么调用我们的Controller里的业务接口的：<a href="https://blog.csdn.net/caoyuanyenang/article/details/114401414">https://blog.csdn.net/caoyuanyenang/article/details/114401414</a></p>
<p>✅@RequestMaping参数<br>见java注解</p>
<h3 id="cookie-session-tocken的区别"><a href="#cookie-session-tocken的区别" class="headerlink" title="cookie session tocken的区别"></a>cookie session tocken的区别</h3><p>鉴权：鉴定权限</p>
<p>✅cookie</p>
<p>cookie是鉴权的方式之一，是客户端登录后，服务器端生成后发送给客户端的。cookie可以保存很多种数据，但是他只能保存字符串，且在安全性上有隐患。<br>在客户端发起请求后，服务器端生成一个cookie，并发送给客户端，保存在客户端本地，下次请求的时候带上cookie。</p>
<p>✅session</p>
<p>session是一种会话，比如我发起请求到关闭浏览器这个过程就是一个会话。session是鉴权的方式之二，在客户端发起请求后，服务器生成一个对应的session，并保存在服务器中，再把session id保存到cookie里面，通过cookie发送给客户端，客户端接收到cookie过后，下一次请求时就会把cookie带上，服务器收到请求中的session id后就会把它与之前保存的session做对比，如果是一样的，那就说明是已经登录过的，如果不一样，那就需要重新登录。</p>
<p>✅token</p>
<p>token是一个令牌，是鉴权方式之三，他是由一部分固定的header、以及body组成的，在body中可以放userid+电话号码，等用户的非隐秘信息，然后再通过某种加密方式，把这两部分加密形成一个秘钥。</p>
<p>在客户端发起请求后，服务器会生成一个token，可以通过cookie也可以直接发送给客户端，客户端接收到token后，会把它保存在本地，在下一次请求时，会带上，服务器端收到二次请求以及带上的token后，会再根据用户的信息去加密一个token，再把两次token进行比对，如果是相同的，那就不用再登录了，如果不一样就需要再重新登录。</p>
<p>第一次请求客户端发送的没有这个tocken，服务端生成tocken给客户端，客户端第二次发送带上tocken，就不用重新登陆了。服务端不保存tocken。</p>
<p>✅区别</p>
<p>cookie、session、token的区别<br>1.生成的位置相同：cookie、session、token都是在服务器端生成；<br>2.保存的位置不同：cookie、token保存在客户端本地，session保存在服务器；<br>3.鉴权过程不同：<br>cookie是将请求中携带的cookie与服务器记录的cookie做对比；<br>session是将请求中携带的session与服务器存储的session做对比；<br>token是将请求中携带的token与服务器通过请求中的信息（userid、签名）生成的token作对比。</p>
<p>摘自：<a href="https://blog.csdn.net/qq_43844012/article/details/124271258">https://blog.csdn.net/qq_43844012/article/details/124271258</a></p>
<p>cookie：用来保存一些信息在客户端的，比如记住密码和推荐显示。<br>session：是用来标识一次会话的，在一次会话期间共享数据。<br>token：用来作为密钥快捷登录的</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm是什么</title>
    <url>/2022/06/25/myblog/JAVA/ssm/</url>
    <content><![CDATA[<p>SSM框架：Spring + SpringMVC + MyBatis</p>
<p>Spring和SpringMVC是当前企业开发必用框架之一，MyBatis则是与数据库交互的持久层框架之一，由于易用性和轻便性，则被大多互联网公司所选用。SSM基础框架的掌握是当前企业开发最基本的要求，也是其他技术学习和进阶的必要基础。</p>
<p>b站视频地址：<a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42">https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42</a></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><p>MVC模式是什么？</p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p>SpringMVC概述？</p>
<p>SpringMVC是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。</p>
<p>SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Structs2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。web文件夹内servelet？</p>
<h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><p>持久层框架，方便数据库操作的。</p>
<p>原始比较繁琐的jdbc操作：注册驱动–获得连接–获得statement–执行查询–遍历结果集（封装实体，传递）–释放资源。</p>
<p>缺点：代码重复（比如获得连接资源），资源频繁连接关闭，消耗资源，sql语句比较死，得解耦合，用配置文件。</p>
<p>jdbc缺点：（1）数据库创建、释放资源造成系统资源浪费从而影响系统性能。（2）sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码，耦合性高。（3）查询操作时，需要手动将结果集中的数据手动封装到实体中，插入操作时，需要手动将实体的数据设置到sql语句的占位符位置。</p>
<p>应对上述问题给出的解决方案：（1）使用数据库连接池初始化连接资源。（2）将sql语句抽到xml配置文件中。（3）使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射。</p>
<p>MyBatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，</p>
<p>MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>MyBatis框架执行sql并将结果集映射为java对象并返回，采用ORM（对象关系映射）思想解决了实体和数据库映射的问题，对jdbc进行封装，屏蔽jdbc api底层访问细节，不与jdbc打交道就可以完成对数据库的持久化操作。</p>
<h3 id="mvc和servlet的关系"><a href="#mvc和servlet的关系" class="headerlink" title="mvc和servlet的关系"></a>mvc和servlet的关系</h3><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p>
<p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p>
<p>总结</p>
<p>1、servlet就是一个Java接口，是JavaEE规范的一种<br>2、Servlet容器也叫做Servlet引擎：全称server applet，意为服务程序。主要作用是给上级容器(Tomcat)提供doGet()和doPost()等方法。其生命周期实例化、初始化、调用、销毁受控于 Tomcat容器。<br>3、而Tcomcat、webLogic等web容器包含servlet容器。<br>4、Tomcat容器属于web容器的一种，web容器还包括weblogic容器、JBoss容器等。<br>5、web容器：可以部署多个WEB应用程序的环境。<br>6、Spring MVC （SpringBoot）其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情</p>
<p>转自：<a href="https://zhuanlan.zhihu.com/p/295173834">https://zhuanlan.zhihu.com/p/295173834</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>jar、war、tomcat、servlet</title>
    <url>/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="tomcat与servlet"><a href="#tomcat与servlet" class="headerlink" title="tomcat与servlet"></a>tomcat与servlet</h3><p>1.tomcat就是一个web应用服务器，相当于市存放java程序的容器。以便服务被访问。<br>2.servlet实际上是java类，java语言编写的服务器端程序，它用来处理http协议相关的所有内容，没有main方法，需要在servlet容器中进行管理，可以是tomact。如何使用：继承HttpServlet（tomcat里的jar包支持），它帮助我们完成通信的规则。<br>3.tomcat与servlet关系：tomcat是servlet/jsp容器，servlet时web应用开发的组件，tomcat负责处理客户请求，把请求传送给servlet，再将servlet的响应传送回给客户。<br>4.新建web工程时，如果不用maven，java enterprise - web application，再引入jdk、tomcat（tomcat的lib下有servlet包）。如果用maven，就选archetype-webapp。</p>
<h3 id="war包与jar包"><a href="#war包与jar包" class="headerlink" title="war包与jar包"></a>war包与jar包</h3><p>1.Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。<br>2.jar包是java打的包，一般只是包括一些编译后class文件和一些部署文件，在声明了Main_class之后是可以用java命令运行的。<br>3.jar包通常是开发时要引用通用类，打成包便于存放管理。<br>————————————————<br>1.War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对war文件进行封装，并把它作为小型服务程序（servlet）来访问。<br>2.war包可以理解为javaweb打的包，是一个web模块，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。<br>3.war包需要发布到一个容器里面，拿Tomcat来说,将war文件包放置它的\webapps\目录下，启动Tomcat,这个包可以自动进行解压，也就是你的web目录，相当于发布了。<br>4.WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（JavaBean）。另外还有META-INF目录，里面有MANIFEST.MF文件。存储了项目的元信息。其中文件manifest.mf仅此一份，描述了程序的基本信息、Main-Class的入口、jar依赖路径Class-Path。<br>————————————————</p>
<p>原文链接：<a href="https://blog.csdn.net/Sunny5319/article/details/90933532">https://blog.csdn.net/Sunny5319/article/details/90933532</a></p>
<p>jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件</p>
<hr>
<p>什么时候用jar、war?<br>当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p>
<h3 id="jar包打包"><a href="#jar包打包" class="headerlink" title="jar包打包"></a>jar包打包</h3><p>安装好JDK之后,jar.exe就已经安装好了。在命令行中键入jar命令之后，会有详细的用法介绍。</p>
<h4 id="✅单个文件打包"><a href="#✅单个文件打包" class="headerlink" title="✅单个文件打包"></a>✅单个文件打包</h4><p>将一个单独的java文件打包：<br><code>jar cvf /Users/liuxuan/MyProject/java/test.jar /Users/liuxuan/MyProject/java/jartest/hello.java</code><br>使用<code>java -jar test.jar</code> 提示没有主清单属性。</p>
<p>所以增加清单配置文件：MANIFEST.MF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: hello</span><br><span class="line"></span><br><span class="line">//注意：1. 冒号后面加一个空格，2. 最后必须回车到新的空行</span><br></pre></td></tr></table></figure>
<p>再打包：<code>jar cvfm test.jar ./*</code><br>java -jar运行，找不到或无法加载主类 hello。</p>
<p>所以在打包前先编译：<code>javac hello.java</code>，生成class文件，然后再打包，运行，可以执行。</p>
<blockquote>
<p>META-INF文件夹相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。这个文件夹和其中的 MANIFEST.MF文件，在用jar打包时自动生成。<br>执行jar文件的时候，这个jar里是需要具备 META-INF/MANIFEST.MF的，否则java -jar就找不到main class。</p>
</blockquote>
<p>多个文件也可以如此打包，首先应该javac编译，然后增加主清单配置文件，其中可以指示默认入口函数（其中有main方法）。如果打的包中有其他类，java -jar jar包 是运行默认类，运行其他类方法：<code>java -cp test.jar com.test.sum 3 9</code>。<br>main函数可以有输入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class sum&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length &lt; 2)&#123;</span><br><span class="line">            System.out.println(&quot;Paras: num1 num2&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final int num1 = Integer.valueOf(args[0]);</span><br><span class="line">        System.out.println(&quot;Num1: &quot; + num1);</span><br><span class="line">        final int num2 = Integer.valueOf(args[1]);</span><br><span class="line">        System.out.println(&quot;Num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">        final int sum = num1 + num2;</span><br><span class="line">        System.out.println(num1 + &quot; + &quot; + num2 + &quot; = &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/Xminyang/article/details/108059776">https://blog.csdn.net/Xminyang/article/details/108059776</a></p>
<h4 id="✅使用idea打包"><a href="#✅使用idea打包" class="headerlink" title="✅使用idea打包"></a>✅使用idea打包</h4><p>🤔不可以java -jar的打包：<br>1.点击intellij idea左上角的“File”菜单 -&gt; Project Structure<br>2.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; Empty<br>3. Name栏填入自定义的名字，Output ditectory选择jar包目标目录，Available Elements里双击需要添加到jar包的文件（添加java工程编译文件）<br>4. OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>5. 点击弹出框中待生成jar包下面的build即可</p>
<p>生成了jar包，直接java -jar执行，报<code>Error: Invalid or corrupt jarfile testjar.jar</code>.<br>需要用 -cp 指定类来执行，例如：<code>java -cp testjar.jar leecode.JianPanHang500</code></p>
<p>🤔可以直接java -jar的打包：<br>如果需要直接java -jar 执行的jar包：<br>1.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; from modules…<br>2.选择主类，选择META-INF位置<br>3.OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>4.点击弹出框中待生成jar包下面的build即可</p>
<p>注意：在选择主类时需要全路径，rebuild之后可以重新编译，<code>java -jar lee.jar</code>直接运行主类。</p>
<p>参考：<a href="https://blog.csdn.net/qq_42239765/article/details/123236019">https://blog.csdn.net/qq_42239765/article/details/123236019</a></p>
<h4 id="✅使用maven打包"><a href="#✅使用maven打包" class="headerlink" title="✅使用maven打包"></a>✅使用maven打包</h4><p>🤔不包含依赖包，也不指定入口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!-- 项目最终打包成的名字 --&gt;</span><br><span class="line">    &lt;finalName&gt;mylogmavenpackage&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔指定入口，将依赖的jar包输出到指定目录<br>指定了入口类，可以直接使用java -jar project.jar执行，但是第三方依赖存在一个指定的外部目录下，迁移时需将jar和依赖目录一起迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类 --&gt;</span><br><span class="line">            &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 在jar的MF文件中生成classpath属性 --&gt;</span><br><span class="line">            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- classpath前缀,即依赖jar包的路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;!-- 指定依赖包的输出路径，需与上方的classpathPrefix保持一致 --&gt;</span><br><span class="line">            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔将项目依赖和项目打成一个jar包（胖包）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">          &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;!-- jar包后缀，生成的jar包形式为：project-1.0-SNAPSHOT-jar-with-dependencies.jar --&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;!-- 添加此项后，可直接使用mvn package | mvn install --&gt;</span><br><span class="line">      &lt;!-- 不添加此项，需直接使用mvn package assembly:single --&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h3><p>上面打jar包，其实都有对应的打war包的方法：</p>
<p>✅手动打war包<br><code>jar cvf test.war ./*</code></p>
<p>✅idea打war包<br>artifact中选择web application，explode对于war explode，archive对应war。</p>
<p>✅maven打war包<br>pom.xml中指示<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>maven有多种打包方式。</p>
<h3 id="war包和war-explode包"><a href="#war包和war-explode包" class="headerlink" title="war包和war explode包"></a>war包和war explode包</h3><p>1.war模式<br>这种可以称之为是发布模式，就是先将WEB工程打成war包，然后再将其上传到服务器进行发布 。</p>
<p>2.war exploded模式<br>是将WEB工程以当前文件夹的位置关系上传到服务器，即直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。<br>（热部署，对于Java应用程序来说，热部署就是在运行时更新Java类文件。）</p>
<p>问题：<br>idea进行部署，会将war包移到tomcat webapp文件夹下吗？</p>
<h3 id="java-web工程目录结构"><a href="#java-web工程目录结构" class="headerlink" title="java web工程目录结构"></a>java web工程目录结构</h3><p>1.src文件夹：这是用来存放Java源文件。下面有main文件夹和test文件夹。<br>1.1.src/main/java：存放相应的Java代码，并根据对应的Java项目继续分层<br>1.2.src/main/resource：存放一些配置文件，例如application.properties、logback.xml<br>1.3.src/main/webapp：Web应用的网页，用来放静态资源比如HTML、CSS、图片等文件。WEB-INF目录所在。WEB-INF中存放网站配置文件目录，web.xml等配置信息。</p>
<p>2..idea文件夹：是存储IntelliJ IDEA项目的配置信息，主要内容有IntelliJ IDEA项目本身的一些编译配置、文件编码信息、jar包的数据源和相关的插件配置信息。一般用git做版本控制的时候会把.idea文件夹排除，因为这个文件下保存的都是个人本地Idea编译器的配置。</p>
<p>3.target文件夹：是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。存放的是单个module的编译结果。</p>
<p>4.out文件夹：存放该项目下所有module的编译结果。</p>
<p>5.pom.xml：项目对象模型</p>
<h3 id="新建个web工程并部署"><a href="#新建个web工程并部署" class="headerlink" title="新建个web工程并部署"></a>新建个web工程并部署</h3><p>1.new project，选maven，选maven-archetype-webapp<br>2.选择maven setting，新建工程<br>3.简单写个index.jsp，在webapp目录下（主页）<br>4.通过idea部署，生成war_explode包，热部署<br>5.lsof -i:8080 查看端口占用<br>6.target文件夹下有war包了，但是在tomcat-webapp文件夹下并没有该项目。<br>7.关闭idea，web也无法访问了，所以要想一直运行，得打jar包放在webapp目录下？<br>8.并且发现，没用servlet，不用导入servlet包。</p>
<h3 id="pom-xml结构"><a href="#pom-xml结构" class="headerlink" title="pom.xml结构"></a>pom.xml结构</h3><p>pom.xml 就是 maven 的配置文件，用以描述项目的各种信息。</p>
<p><code>&lt;project </code>  是 pom.xml 中描述符的根。</p>
<p><code>&lt;modelVersion&gt;</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</p>
<p>在 maven 中，根据 groupId、artifactId、version 组合来唯一识别一个 jar 包。<br><code>&lt;groupId&gt;</code> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。<br><code>&lt;artifactId&gt;</code> - 单独项目的唯一标识符。例如junit。不要在 artifactId 中包含点号(.)。<br><code>&lt;version&gt;</code> - 一个项目的特定版本。</p>
<blockquote>
<p>maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 1.0-SNAPSHOT。各个部分的含义和处理逻辑如下说明：<br>SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。<br>LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。<br>RELEASE ：指最后一个发布版。</p>
</blockquote>
<p><code>&lt;packaging&gt;</code> - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p>
<p><code>&lt;name&gt;</code> - 项目名字</p>
<p><code>&lt;url&gt;</code> - 项目网站</p>
<p><code>&lt;description&gt;</code> - 项目描述</p>
<p><code>&lt;parent&gt;</code> - maven 支持继承功能。子 POM 可以使用 parent 指定父 POM ，然后继承其配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;my-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">relativePath ： 在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。</span><br></pre></td></tr></table></figure>

<p><code>&lt;modules&gt;</code> - 子模块列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;my-project-api&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;my-project-repository&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;properties&gt;</code> - 属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;!-- Test --&gt;</span><br><span class="line">		&lt;junit.version&gt;1.16.1&lt;/junit.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencies&gt;</code> - 依赖配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupId, artifactId, version - 和基本配置中的 groupId、artifactId、version 意义相同。</span><br><span class="line"></span><br><span class="line">type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。</span><br><span class="line"></span><br><span class="line">scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：</span><br><span class="line">compile : 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</span><br><span class="line">provided : 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</span><br><span class="line">runtime : 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</span><br><span class="line">test : 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</span><br><span class="line">system : 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</span><br><span class="line"></span><br><span class="line">systemPath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如\$ &#123;java.home&#125; / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</span><br><span class="line"></span><br><span class="line">optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。</span><br><span class="line"></span><br><span class="line">exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencyManagement&gt;</code> - 是在<code>&lt;dependencies&gt;</code>外用的。表示依赖 jar 包的声明。即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被子 POM 继承。<br>它的一个使用案例是当有父子项目的时候，父项目中可以利用 <code>&lt;dependencyManagement&gt;</code> 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。<br><code>&lt;dependencyManagement&gt;</code> 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginManagement。</p>
<p><code>&lt;build&gt;</code> - 构建配置。<br><code>&lt;plugins&gt;</code> - 配置插件，在<code>&lt;build&gt;</code>下。<br><code>pluginManagement</code> - 与 dependencyManagement 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 groupId 和 artifactId 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。<br>它的目的在于统一所有子 POM 的插件版本。<br><code>&lt;extensions&gt;</code> - 扩展配置，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。</p>
<p>pom.xml解析：<a href="https://zhuanlan.zhihu.com/p/76874769">https://zhuanlan.zhihu.com/p/76874769</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》面向对象</title>
    <url>/2021/11/08/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B/</url>
    <content><![CDATA[<h2 id="Java开发入门"><a href="#Java开发入门" class="headerlink" title="Java开发入门"></a>Java开发入门</h2><p>Java是由Sun公司于1995年开发的可编写跨平台应用软件、完全面向对象的程序设计语言。2009年被Oracle公司收购。</p>
<h3 id="Java三个技术平台"><a href="#Java三个技术平台" class="headerlink" title="Java三个技术平台"></a>Java三个技术平台</h3><p>针对不同的开发市场，Sun公司将Java划分为三个技术平台。</p>
<p>（1）Java SE：（standard edition）Java平台标准版，为开发普通桌面和商务应用程序提供的解决方案，是三个平台中最核心的部分，Java EE和Java ME都是从Java SE的基础上发展而来，Java SE包括Java最核心的类库，如集合、IO、数据库连接及网络编程。</p>
<p>（2）Java EE：（enterprise edition）平台企业版，为开发企业级应用程序提供的解决方案，包括Servlet、JSP、JavaBean、EJB、Web Service等。用来做web开发的java框架。</p>
<p>（3）Java ME：（micro edition）平台微型版，为开发电子消费产品和嵌入式设备提供的解决方案，用于微型数字电子设备上软件程序的开发，例如家用电器增加智能化控制和联网功能，未手机增加游戏和通讯录管理功能。此外，还提供HTTP等协议，为移动电话提供Client/Server方式访问Internet，提供无线交流。</p>
<p>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。</p>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>简单易用：丢弃了c++中的：操作符重载、多继承、自动强制类型转换、不使用指针而是引用，提供自动分配和回收内存空间。</li>
<li>安全可靠：Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</li>
<li>跨平台：通过JVM虚拟机在不同的操作系统上允许Java程序。</li>
<li>面向对象：将一切事物都看成对象，类、接口、继承。只支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制（implements）。java全面支持动态绑定，c++只对虚函数使用动态绑定。</li>
<li>支持多线程：内置了多线程控制，可使用户程序并发执行。</li>
</ul>
<h3 id="JDK-gt-JRE-gt-JVM"><a href="#JDK-gt-JRE-gt-JVM" class="headerlink" title="JDK&gt;JRE&gt;JVM"></a><strong>JDK&gt;JRE&gt;JVM</strong></h3><p><strong>JVM</strong> ：（Java Virtual Machine）， Java 虚拟机。它只认识 xxx.class 类型的文件，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。jvm 是 Java 能够跨平台的核心。</p>
<p><strong>JRE</strong> ：（Java Runtime Environment），Java 运行时环境。主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。普通用户只需要JRE进行运行已经编译好的java程序，而不需要开发。</p>
<p><strong>JDK</strong> ：（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe（编译 java 源码的编译器 javac），java.exe（java运行工具），jar.exe（java打包工具），java文档生成工具 等很多 java 程序调试和分析的工具。</p>
<p>1996年推出jdk1.0，随后到1.5改变命名方式，jdk1.5=jdk5.2017年jdk9，2018年jdk10.但是并不稳定。目前最多运用jdk8.</p>
<p>安装jdk时，安装开发工具（包括javac.exe、java.exe等，以及一个专用JRE环境），源代码（Java所有核心类库的源代码），公共JRE相当于多装一个JRE在其他路径，所以不需要。</p>
<p>JDK=JRE(JVM+JAVA基本类库)+开发工具</p>
<h3 id="JDK目录"><a href="#JDK目录" class="headerlink" title="JDK目录"></a>JDK目录</h3><ul>
<li>bin目录：存放一些可执行程序，如javac.exe（java编译器）、java.exe（java运行工具）、jar.exe（打包工具）、javadoc.exe（文档生成工具）等。</li>
<li>db目录：纯java实现的支持JDBC4.0所有规范的小型数据库。</li>
<li>include目录：由于JDK是通过C和C++实现的，因此在启动时引入一些C语言的头文件，该目录就是存放这些头文件的。</li>
<li>jre目录：Java运行时环境的根目录，，包括java虚拟机、运行时的类包、java应用启动器以及一个bin目录，不包括开发环境中的开发工具。</li>
<li>lib目录：java类库或库文件，是开发工具使用的归档包文件。</li>
</ul>
<blockquote>
<p>javac.exe：编译器工具，将java文件编译成可执行的java字节码文件.class</p>
<p>java.exe：java运行工具，会启动一个java虚拟机进程，专门负责运行字节码文件</p>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>目的：在任何位置都能够编译和运行java程序。</p>
<p>配置：PATH：用于告知操作系统去指定路径寻找JDK，CLASSPATH：告知JDK去指定路径查找类文件(.class文件)</p>
<p>当在命令窗口中运行一个可执行文件时，操作系统首先会在当前目录下寻找是否存在该文件，如果不存在，会在PATH环境变量中定义的路径下寻找这个文件。</p>
<h3 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h3><p>.java文件，</p>
<p>使用javac.exe即java编译器进行编译，</p>
<p>.class文件，</p>
<p>使用java命令开启Java虚拟机运行程序，java虚拟机首先将编译好的字节码文件加载到内存（类加载，由类加载器完成），然后虚拟机通过java解析器对加载到内存中的java类进行解释执行，</p>
<p>机器码文件，</p>
<p>计算机运行机器码文件。</p>
<blockquote>
<p>java程序是由java虚拟机负责解释执行的，而不是操作系统，因此跨平台。</p>
</blockquote>
<h3 id="类包"><a href="#类包" class="headerlink" title="类包"></a>类包</h3><p>import导包：import 包名.类名  /  import 包名.*</p>
<p>java的核心类主要放在java包及其子包下。java扩展的大部分类在javax包及其子包下。</p>
<p>java.util：java的大量工具类、集合类，如Arrays、List、Set等</p>
<p>java.net：java网络编程相关的类和接口</p>
<p>java.io：java输入输出相关类和接口</p>
<p>java.awt：构建图形界面GUI的类和接口</p>
<p>java.sql：数据库编程</p>
<h2 id="Java编程基础"><a href="#Java编程基础" class="headerlink" title="Java编程基础"></a>Java编程基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行//  多行/*  */</p>
<p>文档注释：对某个类或类中的方法进行系统性解释说明。开发人员可使用JDK提供的javadoc工具将文档注释提取出来生成一份API帮助文档。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  content</span><br><span class="line">*  content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>包名：一律小写<br>类名、接口名：首字母大写<br>常量名：都大写下划线连接<br>变量名和方法名：一个单词首字母小写，后面首字母大写</p>
<h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>八种基本数据类型：<br>byte：是8位、有符号的，以二进制补码表示的整数；-128~127；<br>short：16位<br>int：32位<br>long：64位，所赋的值超过int的取值范围，则需要加L，long num=10000000L;<br>float：单精度32位，小数默认为double类型，因此定义float型需要在后面加f/F<br>double：双精度64位<br>boolean：布尔<br>char：字符，2个字节</p>
<p>引用数据类型：<br>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。<br>所有引用类型的默认值都是null，表示没有指向任何对象。</p>
<p><code>char c=&#39;a&#39;</code> 和 <code>char c=97</code>一样。因为可以将char变量赋值为0-65535范围内的整数，计算机将整数自动转化为对应的字符。</p>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>（1）自动类型转换（隐式类型转换）：将一个类型取值范围小的数值直接赋值给另一个取值范围大的数据类型变量。大壶装小壶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte b=3;</span><br><span class="line">int x=b;</span><br><span class="line">double y=x;</span><br></pre></td></tr></table></figure>

<p>（2）强制类型转换（显式类型转换）：目标类型取值范围小于源类型。小壶装大壶。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte a;</span><br><span class="line">int b=298;</span><br><span class="line">a=(byte)b;   //结果a会变成42</span><br></pre></td></tr></table></figure>

<p>强制类型转换中可能丢失精度，例如int占用4个字节，而byte占用1个字节，298变二进制后只留下最低的八位。</p>
<p>（3）表达式类型自动提升：byte、short、char类型的变量在运算期间类型会自动提示为int类型，然后进行运算，因此在最后获得结果时需要强制类型转换。</p>
<p>（4）在使用+=、-=、*=等运算符时，强制类型转换会自动完成。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>整形常量：二进制0b/0B开头，八进制0开头，十六进制0x/0X开头。</p>
<p>null：表示对象的引用为空。</p>
<p>需要用final关键字定义常量：<br><code>final int a=0</code></p>
<p>转义符<br>\r  回车符<br>\n  换行符<br>\t  制表符<br>\b  退格符，backspace<br>\后加&#39;或&quot;或\表示本身</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，可以不break而继续执行。</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选，最后才看</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义的三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">剖析：<span class="keyword">int</span>[] nums;  nums变量的类型是<span class="keyword">int</span>[]。</span><br><span class="line">nums会占用一块内存单元，nums=<span class="keyword">new</span> <span class="keyword">int</span>[]; 表示创建数组，并将数组的内存地址赋值给变量nums。在程序运行期间可以用变量nums来引用数组.</span><br></pre></td></tr></table></figure>

<p>多维数组：<code>String[][] str = new String[3][4];</code></p>
<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>对数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><p>面向对象是把构成问题的事物按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p>
<p>封装：将对象的属性和行为封装起来。</p>
<p>继承：描述类与类之间的关系，使得无须重新编写原有类的情况下对原有类的功能进行扩展。</p>
<p>多态：一个类中定义的属性和功能被其他类继承后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现出的多种不同行为特征。</p>
<p>类是对象的抽象，共同特征作为属性（成员变量），共同行为作为类的方法（成员方法）。对象是类的实例。</p>
<p>创建对象：<code>Person p=new Person();</code></p>
<p>第一步：<code>Person p;</code> 声明一个Person类型的变量p</p>
<p>第二步：<code>=new Person();</code>创建Person对象，并将Person对象在内存中的地址赋值给变量p，这样变量p便持有了对象的引用。</p>
<p>内存中，p变量存对象的地址，在栈内存，p是一个引用，指向真正的对象。对象创建在堆内存。</p>
<blockquote>
<p>栈内存：存放基本类型的变量和对象的引用变量。</p>
<p>堆内存：存放new创建的对象和数组。</p>
</blockquote>
<p>创建好对象后，可以通过对象的引用来访问对象的所有成员。对象引用.对象成员</p>
<p>也可以使用创建的对象本身来引用对象成员：<code>new Person().成员</code>。由于没有对象引用的存在，在完成一个对象成员的访问后，该对象变成垃圾对象。<strong>当对象没有被任何变量所引用就会变成垃圾。</strong></p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问控制级别由小到大：private→default→protected→public</p>
<ul>
<li>private（当前类访问级别）：该成员只能被该类的其他成员访问，其他类无法直接访问。</li>
<li>default（包访问级别）：不使用任何访问控制修饰符的话，就是default，表示这个类或者类的成员只能被本包中的其他类访问。</li>
<li>protected（子类访问级别）：成员能被同一包内的其他类访问，也能被不同包下该类的子类访问。</li>
<li>public（公共访问级别）：该类或类的成员能被所有的类访问，不管是否在同一包中。</li>
</ul>
<blockquote>
<p>如果一个java源文件中定义的所有类都没有public修饰符，那么这个源文件的文件名可以是一切合法的文件名。</p>
<p>如果java源文件中定义了一个public修饰的类，则源文件名必须与public修饰的类的类名一致。</p>
</blockquote>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类的封装，是指将对象的属性隐藏在对象内部，设为private级别，不允许外部程序直接访问对象的内部信息，而通过类内public的方法（setxxx，getxxx）实现对内部信息的操作及访问。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象的同时为这个对象的属性进行赋值，可以通过构造方法来实现。</p>
<p>构造方法需要满足的三个条件：方法名与类名相同、在方法名的前面没有返回值类型的声明、方法中不能使用return返回一个值但是可以单独return来结束方法。</p>
<p>构造方法的重载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中每个类都至少有一个构造方法，如果一个类中没有显示地定义构造方法，系统会自动为这个类创建一个无参构造方法。但是一旦自己定义了有参的构造方法，系统将不再提供无参的构造方法。</p>
<blockquote>
<p>疑问：构造方法用来在实例化对象的时候为对象的成员变量赋值，而在定义类的时候，可以声明变量（不赋值）也可以定义变量（赋值），那么定义了变量之后，实例化对象，是给对象的成员赋初值了吗？应该是吧</p>
</blockquote>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>关键字this用来指代当前对象，用来在方法中访问对象的其他成员。</p>
<ul>
<li>通过this关键字调用成员变量，解决与局部变量名称冲突的问题。</li>
<li>通过this关键字调用成员方法。</li>
<li>通过this关键字调用构造函方法，构造方法是在实例化对象时被java虚拟机自动调用的，但是可以<strong>在一个构造方法中</strong>用<code>this(参数);</code>的形式来调用其他的构造方法。注意：只能在构造方法中用，且必须是构造方法中的第一条语句，且只能出现一次，而且不能在两个构造方法中相互调用。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>（1）静态变量</p>
<p>类内的数据成员被一个类的所有实例对象所共享时使用，例如学校学生的学校名。不必要在每个对象占用的空间中都声明这个对象，而是在对象之外的空间中声明一个变量供所有对象来共享。</p>
<p>注意：static关键字只能用于修饰成员变量，不能用于修饰局部变量。</p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String schoolName;</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line">Student.schoolName=<span class="string">&quot;daxue&quot;</span>;</span><br><span class="line">Student stu1=<span class="keyword">new</span> Student();</span><br><span class="line">使用： stu1.schoolName</span><br></pre></td></tr></table></figure>

<p>（2）静态方法</p>
<p>希望在不创建对象的情况下就可以调用某个方法时使用。</p>
<p>访问方式：<code>类名.方法</code>    或    <code>实例对象名.方法</code></p>
<p>注意：在一个静态方法中只能访问用static修饰的成员，原因在于没有没sttaic修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。</p>
<blockquote>
<p>思考：一个文件中可以有多个类，文件名叫public的类的名字，类内可以有public static main函数，有main函数的类得是public的?</p>
<p>static 的成员函数，只能访问static的成员（函数或变量），public static main函数中可以创建其他类的对象，然后访问其他非static类的成员。</p>
</blockquote>
<p>（3）静态代码块</p>
<p>static{…}  在类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块也只执行一次。通常使用静态代码块对类的成员变量进行初始化。第一次实例化对象时会加载类。</p>
<h2 id="面向对象（下）"><a href="#面向对象（下）" class="headerlink" title="面向对象（下）"></a>面向对象（下）</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>is a的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承父类的时候，会自动拥有父类所有公共的成员。</p>
<p>java中只支持单继承，不允许多继承，一个类只能有一个直接父类。</p>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>不能使用比父类中重写的方法更严格的访问权限，如父类的访问权限是public，子类方法不能是private。</p>
<p>也可以重新定义父类的属性。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类重写父类方法或重新定义父类属性后，子类对象无法直接访问他们，因此，用super访问。<code>super.成员变量/成员方法</code></p>
<p>还可以用super关键字来调用父类的构造方法。<code>super([参数1,参数2]);</code>但是，只能出现在子类构造方法的第一行，且只能出现一次。</p>
<p>注意：子类的构造方法中一定会调用父类的某个构造方法，可以通过super指定。如果没有super，则会默认调用父类无参的构造方法。因此，如果父类只定义了有参的构造方法，系统不给默认无参构造方法，就会出错。因此需要在父类添加无参构造方法，或者子类指定调用父类有参构造方法。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java中的Object类是所有类的父类，每个类都直接或间接地继承自该类，称为超类、基类、或根类。Object类中有一些自定义的方法。</p>
<p><code>对象名.toString()  </code>返回对象的字符串表示。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>不可更改，最终的意思。</p>
<p>（1）修饰类：不能被继承。</p>
<p>（2）修饰方法：不能被子类重写</p>
<p>（3）修饰变量：常量，只能被赋值一次。</p>
<p>final修饰的成员变量，必须在声明的同时进行赋值。</p>
<p>final修饰的局部变量，可以先声明，再进行一次赋值。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>例如在定义Animal类时，shout()方法无法明确表示，java提供抽象方法来使得其无需提供方法的具体实现。</p>
<p>抽象方法：<code>public abstract void shout();</code>没有大括号</p>
<p>包含抽象方法的类一定是抽象类，class前加abstract，但是抽象类中可以不包含抽象方法。</p>
<p>抽象类不能被实例化，只能创建子类，并在子类中实现抽象类中的抽象方法。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的抽象类，它不包含普通方法，内部所有方法都是抽象方法。</p>
<p>JDK8中对接口进行了重新定义，接口中除了抽象方法外，可以有default修饰的默认方法，static修饰的静态方法，这两种方法都允许有方法体。</p>
<p>用interface修饰，可以extends多个接口。接口内部可以有final常量，定义常量时必须进行初始化赋值。</p>
<p>小提示：定义常量时<code>public static final</code>可省略，定义方法时<code>public abstract</code>可省略</p>
<p>调用静态方法：<code>接口名.方法名</code></p>
<p>调用抽象方法和默认方法需要通过接口实现类的实例对象来调用。默认方法不需要子类中实现。</p>
<p><code>public interface Hockey extends Sports, Event</code>   接口的多继承</p>
<p>一个类可以在继承一个类的同时实现多个接口：<code>public class 类名 extends 类名 implements 接口1，接口2</code>  ，extend需要在前面</p>
<blockquote>
<p>注意：如果一个类通过implement实现接口，如果该类是抽象类，则可以实现接口中的部分抽象方法，如果不是抽象类，则需要实现接口中的所有抽象方法。</p>
</blockquote>
<p>总结：类继承类（只能继承一个类，但同时可以实现多个接口），接口继承接口（可一次继承多个接口），类实现接口（可一次实现多个接口）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一方法所呈现的多种不同形态。</p>
<p>把子类对象直接赋值给父类引用变量时，程序只有在运行时才知道该引用变量具体代表哪个子类对象。</p>
<h3 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h3><p>子类对象当作父类类型使用：向上转型</p>
<p><code>Animal an1=new Cat();</code>   不需要任何显示声明，但是不能通过父类变量去调用子类特有的方法。</p>
<p>要想使用子类特有的方法，需要将本质为Cat类型的an1对象由Animal类型向下转型为Cat类型。</p>
<p><code>Cat cat=(Cat)an1;</code> 就可以用cat变量来调用子类特有方法了。</p>
<p><code>instanceof</code>关键字，用来判断一个对象是否为某个类或接口的实例或子类实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animal an1=new Cat();</span><br><span class="line">if(an1 instanceof Cat)&#123;</span><br><span class="line">    Cat cat=(Cat)an1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许一个类的内部定义类，这样的类叫内部类。内部类所在类叫外部类。根据内部类的位置、修饰符、定义方式的不同分为四种。</p>
<p>（1）成员内部类</p>
<p>像成员变量、成员方法一样的存在，在成员内部类中，可以访问外部类的所有成员。在外部类中，可以访问成员内部类的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类访问内部类的成员：</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.成员</span><br><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer out = new Outer();  创建外部类对象</span><br><span class="line">Outer.Inner in = new Inner();   创建内部类对象</span><br></pre></td></tr></table></figure>

<p>（2）局部内部类</p>
<p>也叫方法内部类，是定义在某个方法内的，有效范围仅限于方法内部。</p>
<p>局部内部类可以访问外部类所有成员，而只有在包含局部内部类的方法中才可以访问内部类的成员。</p>
<p>（3）静态内部类</p>
<p>使用static关键字修饰的成员内部类，静态内部类只能访问外部类的静态成员.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在与外部类平行的类中：</span><br><span class="line">Outer.Inner inner = new Outer.Inner();</span><br><span class="line">inner.成员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般在刷题时，定义Solution类，类内定义成员方法实现算法。测试时，定义另一个类，类内main函数中输入输出，然后定义对象<code>Solution s = new Solution();</code>通过对象访问算法方法。</p>
</blockquote>
<p>（4）匿名内部类</p>
<p>在java中调用某个方法时，如果该方法的参数是一个接口类型，除了可以传入一个参数接口实现类，还可以使用匿名内部类实现接口来作为该方法的参数。</p>
<p>匿名内部类就是没有名称的内部类，在调用包含有接口类型参数的方法时，通常为了简化代码，不会创建一个接口的实现类作为方法参数传入，而是直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义动物类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String name=<span class="string">&quot;maomao&quot;</span>;</span><br><span class="line">		<span class="comment">//定义匿名内部类作为参数传递给animalShout方法</span></span><br><span class="line">		animalShout(<span class="keyword">new</span> Animal()&#123;</span><br><span class="line">		    <span class="comment">//匿名内部类中实现shout方法</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">		    	<span class="comment">//JDK8开始，局部内部类、匿名内部类可以访问非final的局部变量</span></span><br><span class="line">		    	System.out.println(name+“喵喵”)；</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;)；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义静态方法animalShout(),接收接口类型参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalShout</span><span class="params">(Animal an)</span></span>&#123;</span><br><span class="line">		an.shout(); <span class="comment">//调用传入对象的shout()方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分两步：</p>
<p>第一步 <code>animalShout(new Animal()&#123;&#125;)</code> 参数位置创建一个实例对象，表示创建的对象为Animal的子类实例，该子类是匿名的。</p>
<p>第二步<code>&#123;&#125;</code>中编写匿名子类的实现代码。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为<strong>闭包</strong>，它是推动 Java 8 发布的最重要新特性。它使用一个清晰简洁的表达式来表达一个接口。</p>
<p>匿名内部类存在一个问题：如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然冗余。</p>
<p>Lambda表达式针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line">可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</span><br><span class="line">可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</span><br><span class="line">可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</span><br><span class="line">可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，return可省略</span><br></pre></td></tr></table></figure>

<p>上面的例子，用lambda表达式来做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animalShout(()-&gt;System.out.println(name+“喵喵”);)</span><br></pre></td></tr></table></figure>

<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda表达式可以实现匿名内部类的功能，但是局限在于接口中只有一个抽象方法时才能使用Lambda表达式代替匿名内部类。</p>
<p>因为Lambda表达式是基于函数式接口实现的，函数式接口就是只有一个抽象方法的接口。</p>
<p>JDK8中专门为函数式接口引入@FunctionalInterface注解，显示地标识接口是一个函数式接口，如果不是编译器就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		showSum(<span class="number">10</span>, <span class="number">20</span>, (x,y)-&gt;x+y);  <span class="comment">//实现方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建参数为接口的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span>+cu.sum(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式的引用形式"><a href="#Lambda表达式的引用形式" class="headerlink" title="Lambda表达式的引用形式"></a>Lambda表达式的引用形式</h3><p>Lambda表达式的主体只有一条语句时，程序可通过<code>：：</code>的语法格式来引用方法和构造器。本质是对Lambda表达式的主体部分已存在的方法进行直接引用。</p>
<p>相当于calc方法需要实现，而又现成的abs方法可以用。</p>
<p>（1）类名引用普通方法/静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含静态方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&lt;<span class="number">0</span>)  <span class="keyword">return</span> -num;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAbs</span><span class="params">(<span class="keyword">int</span> num, Calculate cu)</span></span>&#123;</span><br><span class="line">		System.out.println(cu.calc(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, n-&gt;Math.abs(n));</span><br><span class="line">		<span class="comment">//使用方法引用</span></span><br><span class="line">		printAbs(-<span class="number">10</span>, Math::abs);  类名::类静态方法/普通方法名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象名引用方法</p>
<p>也可以通过实例化对象的名称来对其方法进行引用。是普通方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math ma = new Math();</span><br><span class="line">printAbs(-10, n-&gt;ma.abs(n));</span><br><span class="line">printAbs(-10,ma::abs);</span><br></pre></td></tr></table></figure>

<p>（3）构造器引用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">buildPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类，并添加有参构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(String name, PersonBuilder bu)</span></span>&#123;</span><br><span class="line">		System.out.println(bu.buildPerson(name).getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//使用lambda表达式   ()-&gt;new 类名()</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, name-&gt;<span class="keyword">new</span> Person(name));</span><br><span class="line">		<span class="comment">//使用方法引用    类名::new</span></span><br><span class="line">		printAbs(<span class="string">&quot;张三&quot;</span>, Person::<span class="keyword">new</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>java语言引入了异常，以异常类的形式对正常情况进行封装。</p>
<p>异常类都继承自java.lang.Throwable类。</p>
<p>Throwable有两个直接子类Error和Exception。</p>
<p>其中Error称为错误类，代表Java运行时产生的系统内部错误或资源耗尽的错误，如系统崩溃、虚拟机错误。</p>
<p>Exception类称为异常类，标识程序本身可以处理的错误，异常处理都是针对该类及其子类。RuntimeException表示运行时异常，其他表示编译时异常。</p>
<p>Throwable类中常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getMessage()</span><br><span class="line">返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</span><br><span class="line">public void printStackTrace()</span><br><span class="line">打印toString()结果和栈层次到System.err，即错误输出流。</span><br><span class="line">public Throwable getCause()</span><br><span class="line">返回一个Throwable 对象代表异常原因。</span><br></pre></td></tr></table></figure>

<p>运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的。例如数组越界。</p>
<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在除法方法中：</span><br><span class="line">try&#123;</span><br><span class="line">   可能发生异常的语句</span><br><span class="line">&#125;catch(Exception类或其子类 e1)&#123;</span><br><span class="line">   对捕获的异常进行相应的处理</span><br><span class="line">   System.out.println(&quot;异常：&quot;+e1.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	无论程序是否异常都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try{}中的代码块发生异常，系统会将这个异常的信息封装成一个异常对象，传递给catch(){}代码块，catch代码块需要一个参数指明它所能接收的异常类型，必须是Exception类或其子类。</p>
<p>finally{}中的代码不受return语句和程序异常的影响，可以用来完成必须要做的事，例如释放系统资源、关闭线程池等。但是在try…catch…代码块中执行了<code>System.exit(0)</code>语句的话，finally不会执行，因为<code>System.exit(0)</code>表示退出当前的java虚拟机。</p>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><p>用于将异常从当前方法中抛出，throws写在方法声明的后面，后跟声明方法中发生异常的类型，这种做法叫做方法申明抛出一个异常。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int divide(int x, int y) throws Exception&#123;</span><br><span class="line">	int res=x/y;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了throws后，还需要再出现异常的代码（main中）处使用try…catch…代码块进行捕获处理。</p>
<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><p>throw用于方法体内，并且抛出的是一个异常类对象。</p>
<p>通过throw关键字抛出异常后，还需要try…catch…或throws关键字对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void deposit(double amount) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  if(判断)&#123;</span><br><span class="line">      throw new Exception(&quot;异常&quot;); //可以用来指示异常信息</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw抛出异常对象，然后通过throws关键字抛出异常，最后通过try…catch…语句捕获异常。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。在构造方法中使用super()语句调用Exception的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 	<span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();  <span class="comment">//调用无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);  <span class="comment">//调用有参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>java提供垃圾回收机制（Java GC），虚拟机会自动回收垃圾对象所占用的内存空间。</p>
<p>当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分为三种：</p>
<p>（1）可用状态：对象被创建后，有一个以上的引用变量引用它，那么这个对象在程序中将处于可用状态，程序可以通过引用变量来调用该对象的实例变量和方法。</p>
<p>（2）可恢复状态：程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。系统准备回收，回收之前会调用可恢复状态对象的<code>finalize()</code>方法进行资源清理。如果在调用<code>finalize()</code>方法之前重新使一个引用变量引用该对象，则这个对象会再次变为可用对象。</p>
<p>（3）不可用状态：调用<code>finalize()</code>方法后，对象进入不可用状态，内存被清理。</p>
<blockquote>
<p>一个对象在失去引用成为垃圾后，会暂时保存在内存中，垃圾堆积到一定程度时，java虚拟机会启动垃圾回收器将这些垃圾对象从内存中释放，也就说回收的时机无法把握。</p>
</blockquote>
<p>强制系统进行垃圾回收的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">或：</span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>当一个对象在内存中被释放时，它的<code>finalize()</code>方法会自动调用，<code>finalize()</code>方法是定义在Object类中的实例方法，方法原型：</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
<p>任何java类都可以重写Object类的<code>finalize()</code>方法，在该方法中清理对象占用的资源。重写实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">	public void finalize()&#123;</span><br><span class="line">		System.out.println(&quot;d&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之网络编程</title>
    <url>/2021/12/02/myblog/JAVA/%E3%80%8AJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="IP地址和端口号"><a href="#IP地址和端口号" class="headerlink" title="IP地址和端口号"></a>IP地址和端口号</h2><p>IPv4由四个字节大小的二进制数来表示，通常写成十进制形式，每个数在0-255之间。</p>
<p>IPv6使用16个字节表示IP地址。</p>
<p>最初设计互联网时，为了便于寻址以及层次化构造网络，每个IP地址由两部分组成，即”网络.主机”，网络部分表示其属于互联网的哪一个网络，是网络的地址编码，主机部分表示其属于该网络中的哪一台主机，是网络中一个主机的地址编码，二者是主从关系。</p>
<p>IP地址分为五类：常用的是A.B.C类：</p>
<p>①A类地址：第一段网络地址，其余三段主机地址，范围是1.0.0.0 – 127.255.255.255。</p>
<p>②B类地址：前两段网络地址，其余两段主机地址，范围是128.0.0.0 – 191.255.255.255。</p>
<p>③C类地址：前三段网络地址，最后一段主机地址，范围是192.0.0.0 – 223.255.255.255。</p>
<p>另外，还有一个本地回环地址127.0.0.1，指本机地址，改地址一般用来测试使用，例如：ping 127.0.0.1 用来测试本机TCP/IP协议是否正常。</p>
<p>端口号用来访问目标计算机中的某个应用程序。计算机中，不同的应用程序是通过端口号来区分的，端口号是用两个字节（16位二进制数）表示的，取值范围是：0 ~ 65535。其中，0 ~ 1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一些应用或服务所占用。</p>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>JDK中提供了一个与IP地址相关的InetAddress类，该类用于封装一个IP地址，并提供一系列与IP地址有关的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getByName(String host);  <span class="comment">//获取表示指定主机的InetAddress对象</span></span><br><span class="line">getLocalHost()      <span class="comment">//获取本机的InetAddress对象，InetAddress.getLocalHost()</span></span><br><span class="line">getHostName()     <span class="comment">//InetAddress对象.getHostName  获取主机名，返回String</span></span><br><span class="line">isReachable(<span class="keyword">int</span> timeout)   <span class="comment">//InetAddress对象.isReachable，判断在限定时间内指定的IP地址是否可以访问，返回boolean</span></span><br><span class="line">getHostAddress()    <span class="comment">//InetAddress对象.getHostAddress，获取字符串格式的原始IP地址，返回String</span></span><br></pre></td></tr></table></figure>

<p><code>getHostName</code>获取某个主机的域名，如果InetAddress对象是通过主机名创建的，则将返回该主机名；否则根据IP地址反向查找对应的主机名，如果找到则将其返回，否则返回IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: InetAddress类使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 12:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAdd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取本机InetAddress对象</span></span><br><span class="line">        InetAddress local = InetAddress.getLocalHost();  <span class="comment">//相当于 InetAddress.getByName(&quot;localhost&quot;);</span></span><br><span class="line">        <span class="comment">//获取主机名为&quot;www.baidu.com&quot;的InetAddress对象</span></span><br><span class="line">        InetAddress remote = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;InetAddress对象：&quot;</span>+local);</span><br><span class="line">        System.out.println(<span class="string">&quot;本机ip：&quot;</span>+local.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度ip：&quot;</span>+remote.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;3s内是否可访问百度：&quot;</span>+remote.isReachable(<span class="number">3000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;本机主机名：&quot;</span>+local.getHostName());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span>+remote.getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：为什么一定要throws异常。</p>
</blockquote>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p>UDP：user datagram protocol 用户数据报协议</p>
<p>TCP：transmission control protocol 传输控制协议</p>
<p>UDP：无连接通信协议，数据的发送端和接收端不建立逻辑连接。发送端不会确认接收端是否存在，接收端也不会向发送端反馈是否收到数据。消耗资源小，通信效率高，延迟小。用于音频、视频传输。但是不保证数据的完整性。</p>
<p>TCP：传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，必须明确客户端与服务端，保证两台计算机之间可靠无差错的数据传输。</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>UDP通信过程相当于在两个码头之间通过集装箱发送货物。JDK中提供一个DatagramPacket类，该类的实例对象相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。DatagramSocket类，该类的实例对象相当于码头，用于发送和接收DatagramPacket数据报。</p>
<h3 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h3><p>创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同。接收端的构造方法只需要接收一个字节数组来存放接收到的数据。发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定接收端IP地址和端口号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length)   用于接收端，指定字节数组和数据的大小</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)   增加一个偏移量，从该位置开始发送</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress add, <span class="keyword">int</span> port)   用于发送端，指定字节数组和数据的大小，必须的目标ip和端口</span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, InetAddress add, <span class="keyword">int</span> port)   增加一个偏移量，从该位置开始发送</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意传入的是InetAddress对象，而不是String形式的ip地址。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket对象.getAddress()  得到InetAddress对象，发送端的得到的是接收端的</span><br><span class="line">DatagramPacket对象.getPort()  返回<span class="keyword">int</span>端口号，发送端返回接收端的</span><br><span class="line">DatagramPacket对象.getData()  返回接收/发送的数据，发送的返回发送的，返回<span class="keyword">byte</span>[]类型</span><br><span class="line">DatagramPacket对象.getLength() 返回<span class="keyword">int</span>接收/发送的数据长度</span><br></pre></td></tr></table></figure>

<h3 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h3><p>用于创建发送端和接收端对象，创建发送端和接收端DatagramSocket对象时，使用的构造方法不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket(<span class="keyword">int</span> port)  用于发送端，在创建发送端DatagramSocket对象时，可以不指定端口号，系统进行分配，也可以指定。用于接收端，必须指定端口号。</span><br><span class="line">DatagramSocket(<span class="keyword">int</span> port, InetAddress addr)  指定端口号外，还指定了ip地址，用于计算机上有多块网卡，明确规定数据通过哪块网卡向外发送或接收。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket对象.receive(DatagramPacket p)   用于接收DatagramPacket数据报，在接收到数据之前会一直处于阻塞状态，如果发送消息的长度比数据报长，则消息会被截取。</span><br><span class="line">DatagramSocket对象.send(DatagramPacket p)   用于发送DatagramPacket数据报，其中应该包含发送的数据、长度、接收端ip、端口号</span><br><span class="line">DatagramSocket对象.close()   关闭当前socket，通知驱动程序释放为这个socket保留的资源。</span><br></pre></td></tr></table></figure>

<h3 id="UDP实现"><a href="#UDP实现" class="headerlink" title="UDP实现"></a>UDP实现</h3><p>通信时，需要接收端程序先运行，才能避免因发送端发送的数据无法接收而造成的数据丢失。</p>
<p>接收端程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDP接收端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 19:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个指定端口号为8900的接收端DatagramSocket对象</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">8900</span>);</span><br><span class="line">        <span class="comment">//定义一个长度为1024的字节数组，用于接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//定义一个DatagramPacket数据报对象，用于封装接收的数据</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;   <span class="comment">//使得一直循环接收</span></span><br><span class="line">            <span class="comment">//等待接收数据，在没有接收到之前处于阻塞状态</span></span><br><span class="line">            server.receive(packet);</span><br><span class="line">            <span class="comment">//调用DatagramPacket的方法获得接收到的信息，并转换成字符串形式</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">            System.out.println(packet.getAddress()+<span class="string">&quot;:&quot;</span>+packet.getPort()+<span class="string">&quot;发送消息：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送端程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDP发送端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 20:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个指定端口号3000的发送端DatagramSocket对象</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">3000</span>); <span class="comment">//可以不指定端口</span></span><br><span class="line">        <span class="comment">//定义要发送的数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        System.out.println(Arrays.toString(str.getBytes()));</span><br><span class="line">        <span class="comment">//定义一个DatagramPacket数据报对象，封装发送端信息以及发送地址</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(str.getBytes(),</span><br><span class="line">                str.getBytes().length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8900</span>);  <span class="comment">//这个一定要与接收端程序设置一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送数据...&quot;</span>);</span><br><span class="line">        client.send(packet);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>byte[]数组，里面存的是数字，编解码变为字符串。</p>
<p>疑问：byte是1字节，8bit，char是2字节，如何对应？</p>
<p>一个字符等于几个字节？</p>
<p>不同的字符所占的字节是不同的。</p>
<p>ASCII码：</p>
<p>一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。如一个ASCII码就是一个字节。</p>
<p>UTF-8编码：</p>
<p>一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。</p>
<p>Unicode编码：</p>
<p>一个英文等于两个字节，一个中文（含繁体）等于两个字节。</p>
<p>GBK编码：</p>
<p>中文占两个字节，英文占1个字节。</p>
</blockquote>
<p>UDP程序在发送数据时是一次性全部封装到<code>DatagramPacket</code>数据报中进行统一发送的，然而<code>DatagramPacket</code>数据报一次性允许封装的数据量是有限度的，理论最大值是：65507个字节（IP数据报的最大限制65535字节减去IP首部的20字节和UDP首部的8字节）。但是许多平台实际的最大限制是8192字节（8K）。</p>
<blockquote>
<p>检查计算机使用的端口：netstat -anb</p>
<p>报错：netstat: option requires an argument – p</p>
<p>在Mac上正确使用的方法是：即-f需要加上地址族，-p需要加上协议TCP或者UDP等</p>
<p>a）如果需要查询inet，netstat -anvf inet</p>
<p> b）如果需要查询TCP， netstat -anvp tcp</p>
<p> b）如果需要查询UDP，netstat -anvp udp   </p>
<p>netstat -anvp tcp |grep 10001</p>
</blockquote>
<h3 id="小项目-聊天程序"><a href="#小项目-聊天程序" class="headerlink" title="小项目-聊天程序"></a>小项目-聊天程序</h3><p>模拟qq中两个用户一对一聊天，通过多线程实现发送端和接收端功能。</p>
<p>主机程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 聊天程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入本机端口号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> serverPort = sc.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;输入目标计算机端口号：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> targetPort = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;聊天服务启动！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建聊天程序收发平台DatagramSocket对象</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(serverPort);</span><br><span class="line">            <span class="comment">//启动信息接收端和发送端程序</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatReceiver(socket), <span class="string">&quot;接收端服务&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatSender(socket, targetPort), <span class="string">&quot;发送服务&quot;</span>).start();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SocketException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 接收端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 22:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要有DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket server;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatReceiver</span><span class="params">(DatagramSocket server)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//定义一个DatagramPacket数据报对象，用于封装接收的数据</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;   <span class="comment">//使得一直循环接收</span></span><br><span class="line">                <span class="comment">//等待接收数据，在没有接收到之前处于阻塞状态</span></span><br><span class="line">                server.receive(packet);</span><br><span class="line">                <span class="comment">//调用DatagramPacket的方法获得接收到的信息，并转换成字符串形式</span></span><br><span class="line">                String str = <span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;收到&quot;</span>+packet.getAddress()+<span class="string">&quot;:&quot;</span>+packet.getPort()+<span class="string">&quot;发送的数据：&quot;</span>+str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 发送端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-02 22:14</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatSender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要有DatagramSocket对象</span></span><br><span class="line">    <span class="keyword">private</span> DatagramSocket client;</span><br><span class="line">    <span class="comment">//还需要目标端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> targetPort;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatSender</span><span class="params">(DatagramSocket client, <span class="keyword">int</span> targetPort)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.targetPort = targetPort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String data = sc.nextLine();</span><br><span class="line">                <span class="keyword">byte</span>[] buf = data.getBytes();</span><br><span class="line">                <span class="comment">//这里需要目标ip地址，以及目标端口号</span></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length,</span><br><span class="line">                        InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), targetPort);</span><br><span class="line">                <span class="comment">//127.0.0.1 和 localhost 一样，都是本机</span></span><br><span class="line">                client.send(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于端口号有点乱：</p>
<p>发送端：DatagramSocket中可指定也可不指定端口号。DatagramPacket一定要指定接收端的ip和接收端接收端口。</p>
<p>接收端：DatagramSocket一定要指定接收端口，DatagramPacket里面不需要ip和端口。</p>
<p>在上面的UDP实现中，发送和接收的端口号不同。是单向的。</p>
<p>这个聊天程序中，模拟两个主机，一个主机的发送和接收的端口是一样的，所以一个主机发送和接收的socket一样。但是两个目标主机的端口要对应上。是双向的。</p>
</blockquote>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>UDP只有发送端和接收端，不区分客户端和服务器端，计算机之间可以任意地发送数据。</p>
<p>TCP严格区分客户端和服务器端，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不会主动连接客户端。</p>
<p>JDK提供ServerSocket类表示服务器端，Socket类表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，开启一个服务，并等待客户端的连接；然后创建Socket对象代表客户端，向服务器端发出连接请求。服务器端响应请求，两者建立连接后正式进行通信。</p>
<h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>java.net包中，表示服务器端，需要自己端口号，构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>ServerSocket()   <span class="comment">//没有指定端口号，不能直接使用，需要bind(SocketAddress endpoint)方法将其绑定到指定端口号。</span></span><br><span class="line"><span class="number">2.</span>ServerSocket(<span class="keyword">int</span> port)   <span class="comment">//指定端口，如果参数是0，系统会分配一个未被占用的端口号，并不常用，因为客户端需要知道端口号。（最常用）</span></span><br><span class="line"><span class="number">3.</span>ServerSocket(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog)  <span class="comment">//backlog表示在服务器忙时，可与之保持连接请求的等待客户端数量。默认50。</span></span><br><span class="line"><span class="number">4.</span>ServerSocket(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)  <span class="comment">//在多网卡情况下使用，指定使用服务器的哪个ip</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket对象.accept()   <span class="comment">//等待与客户端的连接，与客户端连接之前一直处于阻塞状态，如果有连接就返回与之连接的客户端Socket对象</span></span><br><span class="line">ServerSocket对象.getInetAddress()   <span class="comment">//返回一个InetAddress对象，表示ServerSocket绑定的ip</span></span><br><span class="line">ServerSocket对象.isClosed()   <span class="comment">//返回boolean，判断ServerSocket对象是否为关闭状态</span></span><br><span class="line">ServerSocket对象.bind（SocketAddress endpoint）  <span class="comment">//无返回，将ServerSocket对象绑定到指定ip和端口</span></span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>用于实现TCP客户端程序，需要目标ip和端口号（本机端口号呢？），构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Socket()  <span class="comment">//没有指定ip和端口号，不能直接使用，需要调用connect(SocketAddress endpoint)方法完成与指定服务器端的连接，参数endpoint封装了ip地址和端口号。</span></span><br><span class="line"><span class="number">2.</span>Socket(String host, <span class="keyword">int</span> port)   <span class="comment">//host表示一个字符串类型的ip地址</span></span><br><span class="line"><span class="number">3.</span>Socket(InetAddress add, <span class="keyword">int</span> port)   <span class="comment">//add封装ip</span></span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Socket对象.getPort()  <span class="comment">//返回int，获得Socket连接的远程服务器的端口号</span></span><br><span class="line"><span class="number">2.</span>Socket对象.getLocalAddress()   <span class="comment">//返回Socket对象绑定的本地ip</span></span><br><span class="line"><span class="number">3.</span>Socket对象.close()  <span class="comment">//无返回，关闭Socket连接，关闭之前，先关闭所有输入输出流</span></span><br><span class="line"><span class="number">4.</span>Socket对象.getInputStream()  <span class="comment">//返回一个InputStream类型的输入流对象。服务器端的Socket调用，用于获取来自客户端发送的数据。客户端的Socket调用，用于获取来自服务端发送的数据。</span></span><br><span class="line"><span class="number">5.</span>Socket对象.getOutputStream()  <span class="comment">//返回一个OutputStream类型的输出流对象。服务器端的Socket调用，用于向客户端发送数据。客户端的Socket调用，用于向服务端发送数据。</span></span><br></pre></td></tr></table></figure>

<p>当客户端与服务端建立连接后，数据是以I/O流的形式进行交互的。</p>
<p>输入流和输出流的方法都是Socket对象调用的，无论客户端还是服务器端中，都有Socket对象。输入流用来获取输入到本机的数据，read方法。输出流用来向另一台输出数据，write方法。</p>
<h3 id="TCP实现"><a href="#TCP实现" class="headerlink" title="TCP实现"></a>TCP实现</h3><p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TCP服务器端实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 11:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建指定端口号的服务端ServerSocket对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">7788</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//调用accept方法开始接收数据</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;accept返回，连接成功。&quot;</span>);</span><br><span class="line">            <span class="comment">//向客户端发送数据，write方法</span></span><br><span class="line">            OutputStream os = client.getOutputStream();</span><br><span class="line">            <span class="comment">//向客户端发送数据，用客户端的输出流</span></span><br><span class="line">            os.write((<span class="string">&quot;我是服务端。&quot;</span>).getBytes());</span><br><span class="line">            <span class="comment">//模拟交互耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">            os.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client（Socket类型的对象）用于表示客户端，通过该对象可以获取与客户端关联的输出流并向客户端发送信息。</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SocketHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TCP客户端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 13:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Socket并连接到指定的服务端</span></span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">7788</span>);</span><br><span class="line">        <span class="comment">//获取输入到本机的数据，并打印，用read方法</span></span><br><span class="line">        InputStream is = client.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(buf);</span><br><span class="line">        <span class="keyword">while</span>(len!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">            len = is.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，一台主机两个端口分别服务端和客户端，服务端等待连接，客户端连接成功后，服务端知道了自己输出连接成功。然后服务端向客户端传输我是服务端，客户端并没有向服务端传输。服务端 –&gt; 客户端。   服务端需要指定端口号，客户端需要指定要连接的目标的ip和端口号（和服务端端口号一样）。客户端不需要自己的端口号？系统自己给客户端端口。</p>
<p>以上涉及到IO操作。</p>
<h3 id="多线程的TCP网络程序"><a href="#多线程的TCP网络程序" class="headerlink" title="多线程的TCP网络程序"></a>多线程的TCP网络程序</h3><p>上面的实现是：一个客户端程序请求服务器端时，服务器端会结束阻塞状态，完成程序的运行。实际上，服务器端程序允许多个应用程序访问，服务器端都是多线程的。</p>
<p>服务器端为每个客户端创建一个对应的Socket对象，并且开启一个新线程使两个Socket建立专线进行通信。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.threadtcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: webproject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多线程TCP服务端程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-03 20:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建指定端口号的服务端ServerSocket对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">7789</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//调用accept方法开始接收数据</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            <span class="comment">//针对每个客户端请求创建一个线程进行连接管理</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> port = client.getPort();</span><br><span class="line">                    System.out.println(<span class="string">&quot;与端口号为&quot;</span>+port+<span class="string">&quot;的客户端连接成功！&quot;</span>);</span><br><span class="line">                    OutputStream os = client.getOutputStream();</span><br><span class="line">                    <span class="comment">//向客户端发送数据，用输出流（不应该用服务端的输出流吗？）</span></span><br><span class="line">                    os.write((<span class="string">&quot;我是服务端，服务端向你问好。&quot;</span>).getBytes());</span><br><span class="line">                    <span class="comment">//模拟交互耗时</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束与客户端数据交互。&quot;</span>);</span><br><span class="line">                    <span class="comment">//关闭流和Socket连接</span></span><br><span class="line">                    os.close();</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//执行线程类，与客户端进行数据交互</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序没变，搞三个客户端进行测试。同样只是服务端向客户端发送数据。</p>
<h3 id="小项目-文件上传"><a href="#小项目-文件上传" class="headerlink" title="小项目-文件上传"></a>小项目-文件上传</h3><p>实现客户端向服务端发送图片，服务端接收图片并保存。略。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》类与集合</title>
    <url>/2021/11/17/myblog/JAVA/%E3%80%8AJava%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E3%80%8B%E7%B1%BB%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="java中的常用类"><a href="#java中的常用类" class="headerlink" title="java中的常用类"></a>java中的常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类的几种初始化方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用字符串常量直接初始化一个String对象</span><br><span class="line">String ss = <span class="keyword">null</span>;  初始化为空</span><br><span class="line">String ss = “”;  初始化为空字符串</span><br><span class="line">String ss = “abc”;  初始化为abc</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用String的构造方法初始化字符串对象</span><br><span class="line">String ss = <span class="keyword">new</span> String();  初始化为空字符串</span><br><span class="line">String ss = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  初始化为abc</span><br><span class="line"><span class="comment">//根据指定字符数组创建字符串</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String ss = <span class="keyword">new</span> String(ch);</span><br></pre></td></tr></table></figure>

<p>String类基本操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefghigk&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;字符串长度：&quot;</span>+s.length());</span><br><span class="line"><span class="comment">//字符串是.length()，数组是.length</span></span><br><span class="line">System.out.println(<span class="string">&quot;字符串第i个字符：&quot;</span>+s.charAt(i));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符c最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串第一次出现的位置：&quot;</span>+s.indexOf(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串最后一次出现的位置：&quot;</span>+s.lastIndexOf(<span class="string">&quot;ab&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>字符串的转换操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="comment">//字符串转换为字符数组：</span></span><br><span class="line"><span class="keyword">char</span>[] ch=s.toCharArray();</span><br><span class="line">System.out.println(<span class="string">&quot;int值转换为string类型：&quot;</span>+String.valueOf(<span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转换为大写：&quot;</span>+s.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>字符串的替换和去除空格操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;  a b &quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串两端空格后的结果：&quot;</span>+s.trim());</span><br><span class="line"><span class="comment">//用字符串替换操作完成去除空格</span></span><br><span class="line">System.out.println(<span class="string">&quot;去除字符串所有空格后的结果：&quot;</span>+s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>replace()方法是可以替换子字符串的。</p>
<p>字符串的判断操作：返回boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;Starter&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串St开头：&quot;</span>+s.startWith(<span class="string">&quot;St&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否以字符串er结尾：&quot;</span>+s.endWith(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否包含ar：&quot;</span>+s.contains(<span class="string">&quot;ar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否为空：&quot;</span>+s.isEmpty());</span><br><span class="line">System.out.println(<span class="string">&quot;判断是否相等：&quot;</span>+s.equals(<span class="string">&quot;St&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="和equals"><a href="#和equals" class="headerlink" title="==和equals()"></a>==和equals()</h4><p> ==对于基本类型和引用类型 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同</li>
<li>引用类型：比较的是引用（对象的内存地址）是否相同，string是引用类型。</li>
</ul>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，<strong>把它变成了值比较。</strong></p>
<p>在String类中，重写了父类Object中的equals()方法。把它变成了<strong>值比较</strong>。</p>
<p>==和equals()方法不同，equals方法用来比较两个字符串中的字符值是否相等，==方法用于比较两个字符串对象的内存地址是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">x==y  (<span class="keyword">true</span>)  x.equals(y)  (<span class="keyword">true</span>)</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">String m = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">z==m  (<span class="keyword">false</span>)  z.equals(m)  (<span class="keyword">true</span>)</span><br><span class="line">x==z  (<span class="keyword">false</span>)  x.equals(z)  (<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>字符串的截取与分割：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//结果为11-24  左闭右开原则，从下标5开始截取</span></span><br><span class="line">System.out.println(<span class="string">&quot;截取：&quot;</span>+s.substring(<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line"><span class="comment">//结果为11</span></span><br><span class="line">String[] sArray=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="comment">//将字符串按照某个字符进行分割，变为字符串数组</span></span><br></pre></td></tr></table></figure>

<p>java中，String类是final类型的，所以使用String类定义的字符串是一个常量，它一旦创建，内容和长度不可改变。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>类似一个字符容器，在其中添加和删除字符时，操作的都是这个字符容器，不会产生新的StringBuffer对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>);   <span class="comment">//添加字符串，始终是添加到缓冲区的末尾</span></span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">&quot;de&quot;</span>);   <span class="comment">//在3的前面插入，变为abcde</span></span><br><span class="line">sb.setCharAt(<span class="number">2</span>,<span class="string">&#x27;f&#x27;</span>);  <span class="comment">//修改指定位置字符，变为abfde</span></span><br><span class="line">sb.replace(<span class="number">3</span>,<span class="number">5</span>,<span class="string">&quot;gh&quot;</span>);  <span class="comment">//左闭右开替换指定位置字符串或字符</span></span><br><span class="line">System.out.println(sb.reverse());   <span class="comment">//字符串翻转结果</span></span><br><span class="line">sb.delete(<span class="number">3</span>,<span class="number">7</span>);   <span class="comment">//左闭右开删除</span></span><br><span class="line">sb.deleteCharAt(<span class="number">2</span>);   <span class="comment">//删除指定位置字符</span></span><br><span class="line">sb.delete(<span class="number">0</span>,sb.length());   <span class="comment">//清空缓冲区</span></span><br></pre></td></tr></table></figure>

<h3 id="String和StringBuffer区别"><a href="#String和StringBuffer区别" class="headerlink" title="String和StringBuffer区别"></a>String和StringBuffer区别</h3><p>（1）String类定义的字符串是常量，一旦创建后，内容和长度都是无法改变的。StringBuffer类表示字符容器，其内容和长度可以随时修改。</p>
<p>（2）String类重写了Object类的equals()方法，而StringBuffer类没有重写Object类的equals方法，依然表示内存地址相同？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2));   <span class="comment">//结果为true</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">StringBuffer sb2=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(sb1.equals(sb2));   <span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure>

<p>（3）String类对象可以用操作符+进行连接，而StringBuffer类对象之间不能。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>除了使用StringBuffer外，JDK1.5之后提供了StringBuilder类，同样可以操作字符串。</p>
<p>不同之处在于，StringBuffer是线程安全的，而StringBuilder没有实现线程安全功能，所以性能略高。因此，一般创建一个内容可变的字符串对象，应该优先考虑StringBuilder类。</p>
<p>StringBuilder类的方法和StringBuffer类一样。</p>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>System类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的，可以直接使用System类进行调用（不用创建对象进行调用）。</p>
<h4 id="getProperties-方法"><a href="#getProperties-方法" class="headerlink" title="getProperties()方法"></a>getProperties()方法</h4><p>用于获取当前系统的全部属性，该方法返回一个Properties对象，其中封装了系统的所有属性，这些属性以键值对的形式存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemPropertiesDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//获取系统所有属性</span></span><br><span class="line">		Properties pro = System.getProperties();</span><br><span class="line">		<span class="comment">//获取所有系统属性的key，返回set对象</span></span><br><span class="line">        Set&lt;String&gt;proName=pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span>(String key:proName)&#123;</span><br><span class="line">            <span class="comment">//获取key（属性名）对应的属性值</span></span><br><span class="line">            String value=System.getProperty(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;-&gt;&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h4><p>currentTimeMillis()方法返回一个long类型的值，表示当前时间与1970年1月1日0点0分0秒之间的时间差，单位毫秒。</p>
<h4 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy()方法"></a>arraycopy()方法</h4><p>用于将一个数组中的元素快速拷贝到另一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>,<span class="number">105</span>,<span class="number">106</span>&#125;;  <span class="comment">//源数组</span></span><br><span class="line"><span class="keyword">int</span>[] b=&#123;<span class="number">201</span>,<span class="number">202</span>,<span class="number">203</span>,<span class="number">204</span>,<span class="number">205</span>&#125;;   <span class="comment">//目标数组</span></span><br><span class="line">System.arraycopy(a,<span class="number">2</span>,b,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//最终b变为103，104，105，106，205</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，从a数组索引为2的元素开始拷贝，并且拷贝4个元素存放在目标数组中索引为0的位置。</p>
<p>注意：进行数组拷贝时，一定要保证源数组类型和目标数组类型一致，截取的长度不能超过源数组界限，也不能超过目标数组可以容纳的个数。</p>
<h4 id="gc-方法和exit-int-status-方法"><a href="#gc-方法和exit-int-status-方法" class="headerlink" title="gc()方法和exit(int status)方法"></a>gc()方法和exit(int status)方法</h4><p>gc()方法用于启动java的垃圾回收器，并对内存中的垃圾对象进行回收。</p>
<p>exit(int status)用于终止当前正在运行的java虚拟机，参数表示当前发生的异常状态，一般指定0，表示正常退出，否则表示异常终止。</p>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p>Runtime类用于表示Java虚拟机运行时的状态，用于封装Java虚拟机进程，因此可以通过该类的实例对象来获取当前虚拟机的相关信息。</p>
<p>每次使用java命令启动java虚拟机时都会对应一个Runtime实例，并且只有一个实例，应用程序会通过该实例与其运行时的环境相连。应用程序不能创建自己的Runtime实例，若想在程序中获得一个Runtime实例，可以通过getRuntime()方法获取与之相关的Runtime对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime(); <span class="comment">//获取java程序关联的运行时对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;处理器个数：&quot;</span>+rt.availableProcessors()); <span class="comment">//单位个</span></span><br><span class="line">System.out.println(<span class="string">&quot;空闲内存大小：&quot;</span>+rt.freeMemory()); <span class="comment">//单位字节</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大可用内存大小：&quot;</span>+rt.maxMemory()); <span class="comment">//单位字节</span></span><br></pre></td></tr></table></figure>

<h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec()方法"></a>exec()方法</h4><p>该方法用于执行一个DOS命令，实现和在终端中输入DOS命令同样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br></pre></td></tr></table></figure>

<p>exec()方法返回一个Process对象，该对象表示操作系统的一个进程，通过Process对象可对产生的新进程进行管理，如关闭destroy()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime rt=Runtime.getRuntime();</span><br><span class="line">Process pr = rt.exec(<span class="string">&quot;notepad.exe&quot;</span>)   <span class="comment">//打开记事本</span></span><br><span class="line"><span class="comment">//程序休眠3s</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">pr.destroy();   <span class="comment">//关闭进程</span></span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类是一个工具类，主要用于完成复杂的数学运算，如求绝对值，三角函数，指数运算等。其构造方法被定义为private，因此无法创建Math类的对象。</p>
<p>Math类的多有方法都是静态方法，可以直接通过类名来调用它们。</p>
<p>除静态方法外，Math类中还有两个静态常量PI和E，分别表示Π和e。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.abs(-1);</span><br><span class="line">Math.sin/tan/cos(2.0);</span><br><span class="line">Math.sqrt(4);  //求平方根</span><br><span class="line">Math.cbrt(9);  //求立方根</span><br><span class="line">Math.pow(2,2);  //幂次运算</span><br><span class="line">Math.ceil(1.2);  //大于参数的最小整数，返回double类型的数</span><br><span class="line">Math.floor(1.2);  //小于参数的最大整数，返回double类型的数</span><br><span class="line">Math.round(1.2);  //四舍五入的整数，返回int类型的数</span><br><span class="line">Math.max(1,2);</span><br><span class="line">Math.min(1,2);</span><br><span class="line">Math.random();   //生成一个大于等于0.0小于1.0的随机值</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>在JDK的java.util包中，有一个Random类，可以在指定的取值范围内随机产生数字。</p>
<p>Random类有两个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random()   无参构造，通过它创建的Random实例对象每次使用的种子随机，因此每个对象所产生的随机数不同。</span><br><span class="line">Random(<span class="keyword">long</span> seed)  有参构造，使用种子创建伪随机数生成器，当seed相同时，每次实例化Random对象会生成相同的随机数</span><br></pre></td></tr></table></figure>

<p>Random类的各种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextBoolean()    随机的<span class="keyword">boolean</span></span><br><span class="line">r.nextDouble()   <span class="keyword">double</span>类型的随机数</span><br><span class="line">r.nextFloat()  <span class="keyword">float</span>类型的随机数</span><br><span class="line">r.nextInt()   <span class="keyword">int</span>类型的随机数</span><br><span class="line">r.nextInt(<span class="number">10</span>)  <span class="number">0</span>到<span class="number">10</span>之间<span class="keyword">int</span>类型的随机数</span><br><span class="line">r.nextLong()   <span class="keyword">long</span>型随机数</span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>虽然Java是面向对象的编程语言，但它所包含的8种基本数据类型却不支持面向对象的编程机制（没有属性和方法）。Java之所以提供这8种基本数据类型，是为了方便常规数据的处理。但是在Java种，很多类的方法都需要接收引用类型的对象，此时就无法将一个基本数据类型的值传入。</p>
<p>为了解决这一问题，JDK提供了一系列的包装类，通过包装类可以将基本数据类型的值包装为引用数据类型的对象。</p>
<table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">Byte</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<p>包装类和基本数据类型在转换时，引入了自动装箱和自动拆箱</p>
<p>装箱：将基本数据类型的变量赋给对应的包装类变量（对象）。</p>
<p><code>int a=20;    Integer b=a;</code></p>
<p>拆箱：将包装类对象类型直接赋给一个对应的基本数据类型变量。</p>
<p><code>int c=b</code></p>
<p>此外，Java还提供了其他方法来支持基本数据类型、基本数据包装类以及字符串之间的相互转换。</p>
<p>（1）String类的valueOf()方法，将八种基本数据类型转化为字符串类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">String s=String.valueOf(num);</span><br></pre></td></tr></table></figure>

<p>（2）包装类的valueOf()方法，既可以实现装箱，也可以实现将内容匹配的字符串转换为对应的包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=Integer.valueOf(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=Integer.valueOf(s);</span><br></pre></td></tr></table></figure>

<p>（3）通过包装类的有参构造方法将基本数据类型转换为包装类（装箱），也可以将字符串转换为包装类（除Character包装类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=123;</span><br><span class="line">Integer in=new Integer(num);</span><br><span class="line">String s=&quot;123&quot;;</span><br><span class="line">Integer in2=new Integer(s);</span><br></pre></td></tr></table></figure>

<p>（4）通过包装类的静态方法parseXxx()方法将字符串转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s=&quot;123&quot;;</span><br><span class="line">int num=Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>凡是类名.方法名的，都是静态static方法</p>
</blockquote>
<p>（5）包装类都重写了Object类中的toString方法，将包装类转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer in=new Integer(123);</span><br><span class="line">//Integer in=Integer.valueOf(123);</span><br><span class="line">String s=in.toString();</span><br></pre></td></tr></table></figure>

<p>注意：包装类的<code>valueOf(String s)</code>和<code>parseInt(String s)</code> 中，参数s不能为null，而且需要和解析对应。</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>JDK中的java.util包中，提供了一个Date类用来表示日期和时间，该类在JDK1.0时已经开始使用。JDK8中有两个构造方法可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date()  <span class="comment">//用来创建当前日期时间的Date对象。</span></span><br><span class="line">Date date1=<span class="keyword">new</span> Date();  <span class="comment">//Sat Jan 11:09:21 CST 2021</span></span><br><span class="line">Date(<span class="keyword">long</span> date)  <span class="comment">//用于创建指定时间的Date对象，date是1970.1.1.0.0.0以来的毫秒数，即时间戳</span></span><br><span class="line">Date date2=<span class="keyword">new</span> Date(System.currentTimeMillis()+<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//Sat Jan 11:09:22 CST 2021</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>Calendar类用于完成日期和时间字段的操作，可以通过特定方法设置和读取日期的特定部分。</p>
<p>Calendar类是一个抽象类，不可以被实例化，在程序中需要调用静态方法getInstance()来得到一个Calendar对象，然后才能调用其相应的方法。</p>
<blockquote>
<p>疑问？抽象类创建对象，这是什么操作？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year=ca.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month=ca.get(Calendar.MONTH)+<span class="number">1</span>;  <span class="comment">//注意月份0-11，需要加1</span></span><br><span class="line"><span class="keyword">int</span> date=ca.get(Calendar.DATE);</span><br><span class="line"><span class="keyword">int</span> hour=ca.get(Calendar.HOUR);</span><br><span class="line"><span class="keyword">int</span> minute=ca.get(Calendar.MINUTE);</span><br><span class="line"><span class="keyword">int</span> second=ca.get(Calendar.SECOND);</span><br></pre></td></tr></table></figure>

<p>添加和修改时间的功能可以通过add和set方法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(2021.11.11);   //设置指定日期</span><br><span class="line">ca.add(Calendar.DATE,100);  //为指定日期增加时间</span><br><span class="line">输出时间依然需要用get方法来获取年月日。</span><br></pre></td></tr></table></figure>

<p>Calendar有两种解释日历字段的模式，容错模式和非容错模式，容错模式下，月是12是可以接受的。默认容错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //不会报错</span><br><span class="line">//开启non-lenient非容错模式</span><br><span class="line">ca.setLenient(false);</span><br><span class="line">ca.set(Calendar.MONTH, 13);  //会报错</span><br></pre></td></tr></table></figure>

<p>Date和Calendar对象之间的转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ca.getTime());  //Calendar的getTime方法返回一个表示Calendar时间值的Date对象。</span><br><span class="line">setTime(Date date)</span><br><span class="line">Calendar ca = setTime(date);  //Calendar的setTime方法接收一个Date对象，将Date对象表示的时间值设置给Calendar对象。</span><br></pre></td></tr></table></figure>

<h3 id="JDK8的日期和时间类"><a href="#JDK8的日期和时间类" class="headerlink" title="JDK8的日期和时间类"></a>JDK8的日期和时间类</h3><p>为了满足更多的需求，JDK8比之前的版本增加了一个java.time包，在该包下包含了更多日期和时间操作类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、Clock类</span><br><span class="line">Clock cl = Clock.systemUTC();</span><br><span class="line">获取UTC时区转换的当前时间： cl.instance()</span><br><span class="line">获取UTC时区转换的毫秒数： cl.millis()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Duration类</span><br><span class="line">Duration du = Duration.ofDays(<span class="number">1</span>);</span><br><span class="line">一天等于多少小时：  du.toHours()</span><br><span class="line">一天等于多少分钟：  du.toMinutes()</span><br><span class="line">一天等于多少秒：  du.toMillis()</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>Instant类</span><br><span class="line">Instant in = Instant.now();</span><br><span class="line">UTC时区的当前时间：in</span><br><span class="line">当前时间一小时后的时间：in.plusSeconds(<span class="number">3600</span>)</span><br><span class="line">当前时间一小时前的时间：in.minusSeconds(<span class="number">3600</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>LocalDate</span><br><span class="line">LocalDate lo = LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>LocalTime</span><br><span class="line">LocalDate lo = LocalDate.now();</span><br><span class="line">从默认时区的系统时钟获得当前时间：lo</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>LocalDateTime</span><br><span class="line">LocalDateTime lo = LocalDateTime.now();</span><br><span class="line">从默认时区的系统时钟获得当前日期和时间：lo</span><br><span class="line">当前的日期和时间加上<span class="number">1</span>天<span class="number">3</span>小时<span class="number">30</span>分钟：</span><br><span class="line">LocalDateTime time = LocalDateTime.plusDays(<span class="number">1</span>).plusHours(<span class="number">3</span>).plusMinutes(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>Year、YearMonth、MonthDay</span><br><span class="line">当前年份：Year ye = Year.now();</span><br><span class="line">当前年月：YearMonth ym = YearMonth.now();</span><br><span class="line">当前月日：MonthDay md = MonthDay.now();</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>获取系统默认时区</span><br><span class="line">ZoneId zi = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>

<p>注意，clock.instant()和Instant.now()获取的时间都是默认使用UTC时区（世界协调时间，世界标准时间），比中国标准时间CST早八小时。</p>
<h3 id="格式化类"><a href="#格式化类" class="headerlink" title="格式化类"></a>格式化类</h3><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><p>使用Date类时，程序打印Date对象所输出的当前时间都是英文格式输出的，要想以中文的格式输出，就需要DateFormat类。</p>
<p>DateFormat类专门用于将日期格式化为字符串或者将用特定格式显示的日期字符串转换为一个Date对象。</p>
<p>DateFormat类是一个抽象类，不能被直接实例化，但它提供了一系列的静态方法来获取DateFormat类的实例对象，并能调用其他相应的方法进行操作。</p>
<p>定义了四种静态方法用于获取DateFormat类的实例对象，它们分别对日期或者时间部分进行格式化。</p>
<blockquote>
<p>疑问。</p>
</blockquote>
<p>在DateFormat类中还定义了许多常量，其中四个常量值是用于作为参数传递给方法的，包括FULL、LONG、MEDIUM、SHORT。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Date对象</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//1.当前日期的完整格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat fullFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(fullFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.当前日期的长格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat longFormat = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(longFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.当前日期时间的普通格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat mediumFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(mediumFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.当前日期时间的短格式对象</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">DateFormat shortFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT);</span><br><span class="line"><span class="comment">//format将一个Date格式化为日期/时间字符串</span></span><br><span class="line">System.out.println(shortFormat.format(date));</span><br></pre></td></tr></table></figure>

<p>DateFormat类中还有parse(String source)方法，能够将一个字符串解析为Date对象，但是它要求字符串必须符合日期/时间的格式要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建普通格式的DateFormat对象</span></span><br><span class="line">DateFormat dt1 = DateFormat.getDateInstance();</span><br><span class="line"><span class="comment">//创建Long格式的DateFormat对象</span></span><br><span class="line">DateFormat dt2 = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义日期格式的字符串</span></span><br><span class="line">String s1 = <span class="string">&quot;2021-11-11&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;2021年11月11日&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出对应格式的字符串解析为Date对象后的结果</span></span><br><span class="line">System.out.println(dt1.parse(s1));</span><br><span class="line">System.out.println(dt2.parse(s2));</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>DateFormat类中parse方法将字符串解析为日期时，需要固定格式，不灵活。</p>
<p>SimpleDateFormat类是DateFormat类的子类，可以使用new关键字创建实例对象。在创建实例对象时，构造方法需要接收一个表示日期格式模板的字符串参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;Gyyyy年MM月dd日：今年时yyyy年的第D天，星期：E&quot;</span>);    <span class="comment">//创建对象</span></span><br><span class="line"><span class="comment">//按SimpleDateFormat对象的日期模板格式化Date对象</span></span><br><span class="line">System.out.println(sdf.format(<span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure>

<p>上面是将一个Date时间对象转换为指定格式字符串形式。</p>
<p>SimpleDateFormat类也可以将一个指定格式字符串解析为Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd&quot;</span>);    <span class="comment">//创建对象,并指定日期格式</span></span><br><span class="line">String s = <span class="string">&quot;2021/11/11&quot;</span>;</span><br><span class="line"><span class="comment">//将字符串解析为Date对象</span></span><br><span class="line">System.out.println(sdf.parse(s));</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter类"><a href="#DateTimeFormatter类" class="headerlink" title="DateTimeFormatter类"></a>DateTimeFormatter类</h4><p>除DateFormat类以及SimpleDateFormat类，JDK8在java.time.format包下还提供了一个DateTimeFormatter类，该类也是格式化类，相当于DateFormat类以及SimpleDateFormat类的合体，它不仅可以将日期时间类型转换为字符串，还可以将字符串解析成日期、时间对象。</p>
<p>1.字符串转换成日期时间类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringT0LocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String --&gt; LocalDate</span></span><br><span class="line">        <span class="comment">//使用模式字符串创建DateTimeFormatter格式器</span></span><br><span class="line">        LocalDate localDate = LocalDate.parse(<span class="string">&quot;2019-12-07&quot;</span>);</span><br><span class="line">　　　　　DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);		　　　　　　    </span><br><span class="line">　　　　　System.out.println(LocalDate.parse(<span class="string">&quot;2019-10-09&quot;</span>).format(pattern));</span><br><span class="line">　　　　　</span><br><span class="line">        <span class="comment">// String --&gt; LocalTime</span></span><br><span class="line">        LocalTime localTime = LocalTime.parse(<span class="string">&quot;07:43:53&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String --&gt;LocalDateTime</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>); <span class="comment">// 12小时</span></span><br><span class="line">　　　　 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="comment">// 24小时              LocalDate localDate = LocalDate.parse(&quot;2019-12-07 07:43:53&quot;,formatter);</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.日期时间类型转换成字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLocalDateToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//localDate --&gt; String </span></span><br><span class="line">        <span class="comment">//使用常量创建DateTimeFormatte</span></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        String format1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">//yyyyMMdd</span></span><br><span class="line">        String format2 = localDate.format(DateTimeFormatter.ISO_DATE);            <span class="comment">//yyyy-MM-dd</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.LocalTime  --&gt; String</span></span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        String format3 = localTime.format(DateTimeFormatter.ISO_TIME);            <span class="comment">//20:19:22.42</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;hh:mm:ss&quot;</span>);</span><br><span class="line">        String format4 = localTime.format(formatter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.LocalDateTime  --&gt; String        </span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        String format5 = localDateTime.format(formatter2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(format1);</span><br><span class="line">        System.out.println(format2);</span><br><span class="line">        System.out.println(format3);</span><br><span class="line">        System.out.println(format4);</span><br><span class="line">        System.out.println(format5);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>数组的长度不可变，因此为了保存数目不确定的对象，Java提供了一系列特殊的类，统称集合，集合可以存储任意类型的对象，并且长度可变。</p>
<h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>Java中的集合就像一个容器，专门用来存储Java对象（实际上是对象的引用），这些对象可以是任意的数据类型，并且长度可变。这些集合类都位于java.util包中。</p>
<p>集合类按照其存储结构可以分为两大类：单列集合Collection，双列集合Map。</p>
<p>（1）Collection：单列集合的根接口，用于存储一系列符合某种规律的元素。Collection集合有两个重要的子接口，分别是List和Set。List集合特点：元素有序，可重复。Set集合特点：元素无序，不可重复。List接口的主要实现类：ArrayList、LinkedList。Set接口的主要实现类：HashSet、TreeSet。</p>
<p>（2）Map：双列集合的根接口，用于存储具有键值映射关系的元素。Map接口的主要实现类：HashMap、TreeMap。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2017af8f90a9dff713a5fa908b990a05.png" alt="image-20211113111401531"></p>
<p>虚线是接口类型，实线是实现类。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地将实现了List接口的对象称为List集合。</p>
<p>在List集合中<strong>允许出现重复</strong>的元素，所有的元素以一种线性方式进行存储，在程序中可以通过索引来访问集合中的指定元素，另外，List集合<strong>元素有序</strong>，即元素的存入顺序和取出顺序一致。</p>
<h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p>ArrayList是程序中最常见的一种集合。在ArrayList内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此ArrayList可以看作是一个长度可变的数组。</p>
<p>正是由于ArrayList内部的数据存储结构是数组形式，在增加和删除指定位置的元素时，会创建新的数组，效率比较低，因此不适合做大量的增删操作。但是在遍历和查找元素时显得非常高效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">长度： lis.size();</span><br><span class="line">查询： lis.get(i);</span><br></pre></td></tr></table></figure>

<p>注意：在使用ArrayList集合时并没有显式地指定集合中存储什么类型的元素，会产生安全隐患，涉及到泛型安全机制的问题。</p>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p>ArrayList查询时速度很快，增删时效率较低，因此另一个实现类：LinkedList。</p>
<p>该集合内部包含两个Node类型的first和last属性维护一个双向循环链表，链表中的每一个元素都使用引用的方式记住它的前一个元素和后一个元素，从而可以将所有的元素彼此连接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList lik = <span class="keyword">new</span> LinkedList();</span><br><span class="line">lik.add(<span class="string">&quot;bb&quot;</span>);   <span class="comment">//添加元素</span></span><br><span class="line">lik.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">lik.offer(<span class="string">&quot;dd&quot;</span>);  <span class="comment">//向集合尾部追加元素</span></span><br><span class="line">lik.push(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//向集合头部添加元素</span></span><br><span class="line">System.out.println(lik);   <span class="comment">//输出集合中的元素</span></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">Object obj = lik.peek();   <span class="comment">//获取集合第一个元素</span></span><br><span class="line">System.out.println(obj);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">lik.removeFirst();   <span class="comment">//删除集合第一个元素</span></span><br><span class="line">lik.pollLast();   <span class="comment">//删除集合最后一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="Collection集合遍历"><a href="#Collection集合遍历" class="headerlink" title="Collection集合遍历"></a>Collection集合遍历</h3><h4 id="Iterator遍历集合"><a href="#Iterator遍历集合" class="headerlink" title="Iterator遍历集合"></a>Iterator遍历集合</h4><p>Iterator接口是Java集合框架中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用来存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被叫做迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ArrayList集合</span></span><br><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//获取Iterator对象</span></span><br><span class="line">Iterator it = lis.iterator();</span><br><span class="line"><span class="comment">//判断集合中是否存在下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object obj = it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p>
<p>在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，第一次调用迭代器的next()方法后，迭代器的索引指向第一个元素并将该元素返回。</p>
<p>注意：在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方法去删除元素，会出现异常。因为集合中删除了元素会导致迭代器预期的迭代次数发生变化，导致迭代器的结果不准确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object obj = it.next();  <span class="comment">//获取ArrayList集合中的元素</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&quot;aa&quot;</span>.equals(obj))&#123;</span><br><span class="line">		lis.remove(obj);  <span class="comment">//删除集合元素</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法一：在删除后用break退出。</p>
<p>解决方法二：使用迭代器本身的删除方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(&quot;aa&quot;.equals(obj))&#123;</span><br><span class="line">	it.remove();   //删除集合元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用迭代器对象的remove()方法删除元素导致的迭代次数变化，对迭代器对象本身来讲是可预知的。</p>
<h4 id="foreach遍历集合"><a href="#foreach遍历集合" class="headerlink" title="foreach遍历集合"></a>foreach遍历集合</h4><p>JDK5开始提供，是一种简洁的for循环，也称增强for循环，用于遍历数组或集合中的元素。会自动遍历容器中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(Object obj:lis)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String[] str = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s:str)&#123;</span><br><span class="line">	s=<span class="string">&quot;aa&quot;</span>;   <span class="comment">//改变对string数组没效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有效果是因为代码中<code>s=&quot;aa&quot;;</code>只是将临时变量s指向一个新的字符串，和数组中的元素没有关系。</p>
<p>而在普通的for循环中，可以通过索引来进行修改。</p>
<h4 id="JDK8的forEach遍历集合"><a href="#JDK8的forEach遍历集合" class="headerlink" title="JDK8的forEach遍历集合"></a>JDK8的forEach遍历集合</h4><p>在JDK8中，根据Lambda表达式特性，增加了一个<code>forEach(Consumer action)</code>方法来遍历集合，该方法需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">lis.forEach(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj))</span><br></pre></td></tr></table></figure>

<p>该方法传递的是一个Lambda表达式形式书写的函数式接口。forEach方法在执行时会自动遍历集合元素并将元素逐个传递给Lambda表达式的形参。</p>
<p>除此之外，JDK8还为Iterator迭代器对象增加了forEachRemaining(Consumer action)方法来进行遍历，同样需要一个函数式接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList lis = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Iterator it = lis.iterator();</span><br><span class="line">it.forEachRemianing(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：本节对lList集合遍历的方法，对单列集合Collection进行遍历，因此对Set集合也适用。</p>
</blockquote>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>习惯性地将实现了Set接口的对象称为Set集合。Set集合中的元素<strong>无序</strong>（指存入的顺序和一起输出的顺序是否一致），并且会以某种规则保证存入的<strong>元素不出现重复</strong>。Set接口主要有两个实现类：HashSet、TreeSet。</p>
<p>HashSet是根据对象的哈希值来确定元素在集合中的存储的位置，因此具有良好的存取和查找性能。</p>
<p>TreeSet是以二叉树的方式来存储元素，它可以实现对集合中的元素进行排序。</p>
<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><p>HashSet是Set接口的一个实现类，元素不可重复且无序。</p>
<p>保重不重复：当向HashSet集合中添加一个元素时，即调用HashSet集合的add()方法，首先调用当前存入元素的hashCode()方法获得对象的哈希值，然后根据对象的哈希值计算出一个存储位置：如果该位置上没有元素，则直接将元素存入；如果该位置上有元素存在，则会调用equals()方法让当前存入的元素依次和该位置上的元素进行比较。如果返回的结果为false就将该元素存入集合；返回的结果为true则说明有重复元素，就将该元素舍弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet se = <span class="keyword">new</span> HashSet();</span><br><span class="line">se.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">se.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="comment">//遍历输出Set集合的元素</span></span><br><span class="line">set.forEach(obj-&gt;System.out.println(obj));</span><br></pre></td></tr></table></figure>

<p>为了保证HashSet的正常工作，在存入对象时，需要重写Object类中的hashCode()和equals()方法。String类已经默认重写了<code>hashCode()</code>和<code>equals()</code></p>
<p>如果将开发者自定义的类型对象存入HashSet，需要重写<code>hashCode()</code>和<code>equals()</code>，改为值比较，否则没重写的<code>equals()</code>方法认为两个值相同的引用变量所引用的对象地址不同，认为是两个不同的对象，达不到去重的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id, String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id=id;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写toString()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id+<span class="string">&quot;:&quot;</span>+name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写hashCode方法，根据id判定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id.hashCode();  <span class="comment">//返回id属性的哈希值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写equals方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">//this表示该对象，判断是否为同一对象，如果是则true相同</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断对象是否为Student类型，如果不是，返回false</span></span><br><span class="line">		<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将对象强制转换为Student类型</span></span><br><span class="line">		Student stu = (Student)obj;</span><br><span class="line">		<span class="comment">//根据id值是否相等</span></span><br><span class="line">		<span class="keyword">boolean</span> b = <span class="keyword">this</span>.id.equals(stu.id);</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><p>TreeSet内部采用平衡二叉树存储元素，这样的结构保证TreeSet集合中没有重复的元素，并且可以对元素进行排序（和Set的无序无关）。左子树小于根节点，右子树大于根节点。当插入一个元素时，首先与顶层元素进行比较，小于左边，大于右边，直到最后一个叶子节点，如果和叶子节点一样，则将该重复元素去掉。否则小于左边，大于右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet ts = <span class="keyword">new</span> TreeSet();</span><br><span class="line">ts.add(<span class="number">3</span>);</span><br><span class="line">ts.add(<span class="number">9</span>);</span><br><span class="line">ts.add(<span class="number">1</span>);</span><br><span class="line">ts.add(<span class="number">21</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ts集合：&quot;</span>+ts);  <span class="comment">//输出为[1,3,9,21]有序</span></span><br><span class="line">首元素： ts.first()  <span class="comment">//1</span></span><br><span class="line">尾元素： ts.last()   <span class="comment">//21</span></span><br><span class="line"><span class="comment">//比较并获取元素</span></span><br><span class="line">ts.floor(<span class="number">9</span>)  <span class="comment">//集合中小于或等于9的最大一个元素 9</span></span><br><span class="line">ts.higher(<span class="number">10</span>)  <span class="comment">//集合中大于10的最小元素 21</span></span><br><span class="line">删除并返回第一个元素： </span><br><span class="line">Object first = ts.pollFirst();</span><br><span class="line">删除并返回最后一个元素： </span><br><span class="line">Object last = ts.pollLast();</span><br></pre></td></tr></table></figure>

<p>集合中元素添加顺序无论如何，最后都会按一定顺序排列。因为平衡二叉树，每次插入都会与其他元素进行比较，最后插入有序的对象序列中。</p>
<p>集合中的元素在进行比较时，都会调用<code>compareTo()</code>方法，该方法是<code>Comparable</code>接口中定义的，因此要想对集合中的元素进行排序，就必须实现<code>Comparable</code>接口。Java中大多数类都实现了<code>Comparable</code>接口，并默认实现接口中的<code>compareTo()</code>方法，如Integer、Double、String等。</p>
<p>实际开发中，对自定义类型的数据没有实现<code>Comparable</code>接口，无法直接在TreeSet集合中进行排序操作。因此，Java提供了两种TreeSet的排序规则：自然排序、定制排序。默认情况下采用自然排序。</p>
<p>（1）自然排序</p>
<p>自然排序要求向TreeSet集合中存储的元素所在类必须实现<code>Comparable</code>接口，并重写<code>compareTo()</code>方法。然后TreeSet集合就会对该类型元素使用<code>compareTo()</code>方法进行比较，默认升序排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Teacher类实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name+<span class="string">&quot;:&quot;</span>+age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写compareTo方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		Teacher s = (Teacher)obj;</span><br><span class="line">		<span class="comment">//定义比较方式，先比较年龄age，再比较name,升序</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age-s.age&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age-s.age==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）定制排序</p>
<p>通过在创建TreeSet集合时就自定义一个比较器来对元素进行定制排序。自定义的类型数据中无需实现Comparable接口，并且可以按照自己的想法进行排序。</p>
<p>例子：按照集合中字符串的长度进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="comment">//定义比较器实现Comparator接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span>&#123;</span><br><span class="line">		String s1=(String)obj1;</span><br><span class="line">		String s2=(String)obj2;</span><br><span class="line">		<span class="keyword">int</span> temp=s1.length()-s2.length();</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//法1.创建集合时，传入Comparator接口实现定制排序</span></span><br><span class="line">		TreeSet ts=<span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">		ts.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	<span class="comment">//法2.创建集合时，使用Lambda表达式定制排序，无序上面的MyComparator</span></span><br><span class="line">		TreeSet ts2=<span class="keyword">new</span> TreeSet((obj1,obj2)-&gt;&#123;</span><br><span class="line">			String s1=(String)obj1;</span><br><span class="line">			String s2=(String)obj2;</span><br><span class="line">			<span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">		&#125;);</span><br><span class="line">		ts2.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">		ts2.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">		System.out.println(ts2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map接口是一种双列集合，包含键对象key和值value，键和值对象之间存在一种映射，一对一的，一个key对应唯一一个value，键对象key不可重复。</p>
<h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><p>HahMap集合存储键值映射关系，该集合的键和值允许为空，但键不能重复，且集合中的元素是<strong>无序的</strong>。</p>
<p>HashMap底层：哈希表结构=数组+链表。数组是HashMap的主体结构，链表则是为了解决哈希值冲突而存在的分支结构。因此HashMap对元素的增删改查表现出的效率都很高。</p>
<p>水平方向上数组的长度称为HashMap集合的容量（capacity），竖直方向每个元素对应的链表结构称为一个桶（bucket），每个桶的位置在集合中都有对应的桶值，用于快速定位。每个链表结构是&lt;key,value&gt;的键值对。</p>
<p>当向HashMap集合添加元素时，首先调用键对象k的hash(k)方法，快速定位并寻址到该元素在集合中要存储的位置。在定位到存储元素键对象k的哈希值所对应桶位置后，会出现两种情况：<br>1.键对象k的hash值所在的桶位置为空，则直接向该桶插入元素对象。<br>2.键对象k的hash值所在的桶位置不为空，则继续通过键对象的equals(k)方法比较新插入的元素键对象k和已存在的元素键对象k是否相同：<br>1.如果相同，则会对原有元素的值对象v进行替换并返回原来的旧值。<br>2.如果都不相同，则在该桶的链表结构头部新增一个节点来插入新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);  <span class="comment">//put已存在的key，会进行覆盖</span></span><br><span class="line">System.out.println(m);  <span class="comment">//打印</span></span><br><span class="line"><span class="comment">//查看键是否存在</span></span><br><span class="line">m.containsKey(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键对应的值</span></span><br><span class="line">m.get(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">//获取键集合、值集合</span></span><br><span class="line">m.keySet()</span><br><span class="line">m.values()</span><br><span class="line"><span class="comment">//替换指定键的值</span></span><br><span class="line">m.replace(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">删除指定键值对</span><br><span class="line">m.remove(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，HashMap查找时，需要遍历链表，逐一通过equals方法进行比对，因此桶越多，HashMap中的链表越少，性能越好。属于空间换时间。</p>
<p>HashMap中，<strong>动态分配桶的数量</strong>：通过<code>new HashMap()</code>方法创建HashMap时，会默认集合容量capacity大小为16，加载因子loadFactor为0.75，此时集合桶的阈值为12，超过12个时，HashMap会默认增加一倍桶的数量。开发者也可以使用<code>new HashMap(int intialCapacity, float loadFactor)</code>构造方法，在创建HashMap集合时指定集合容量和加载因子。</p>
<h4 id="Map集合遍历"><a href="#Map集合遍历" class="headerlink" title="Map集合遍历"></a>Map集合遍历</h4><h5 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h5><p>使用Iterator迭代器遍历Map集合，需要先将Map集合转换为Iterator接口对象，然后进行遍历，有两种方法进行转换：</p>
<p>（1）keySet()方法</p>
<p>先将Map集合中所有键对象转换为Set单列集合，然后将Set集合转换为Iterator接口对象，遍历得到键，再获得值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">Set keySet = map.keySet();   <span class="comment">//获取键的集合</span></span><br><span class="line">Iterator it = keySet.iterator();  <span class="comment">//迭代键的集合</span></span><br><span class="line"><span class="keyword">while</span>(it.hashNext())&#123;</span><br><span class="line">	Object k = it.next();</span><br><span class="line">	Object v = m.get(key);</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）entrySet()方法</p>
<p>将原有Map集合中的键值对作为一个整体返回为Set集合，接着将Set转换为Iterator接口对象，然后获取键值对映射关系，取出键和值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">Set entrySet = m.entrySet();</span><br><span class="line">Iterator it = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Map.Entry en = (Map.Entry)(it.next());</span><br><span class="line">	Object k = en.getKey();</span><br><span class="line">	Object v = en.getValue();</span><br><span class="line">	System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是Map接口内部类，每个Map.Entry对象代表Map中的一个键值对。getKey和getValue是映射对象的方法。</p>
<h5 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h5><p>再JDK8中根据Lambda表达式特性新增了一个forEach方法来遍历Map集合，该方法需要的参数是一个函数式接口，可以用Lambda表达式书写这个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>); </span><br><span class="line">m.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br></pre></td></tr></table></figure>

<p>如果只想遍历value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection v = m.values();</span><br><span class="line">v.forEach(va-&gt;System.out.println(va));</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap无序，不保证集合元素存入和取出的顺序。</p>
<p>但是LinkedHashMap是HashMap的子类，和LinkedList一样使用双向链表来维护内部元素的关系，使得元素有序（存入和取出的顺序）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> LinkedHashMap();  <span class="comment">//创建</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap集合"><a href="#TreeMap集合" class="headerlink" title="TreeMap集合"></a>TreeMap集合</h4><p>Map接口的另一个实现类TreeMap，同样不允许重复的键。TreeMap内部是通过二叉树的原理来保证键的唯一性，这与TreeSet集合存储的原理一样，因此，TreeMap中所有的键是按照某种顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> TreeMap();</span><br><span class="line">m.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">m.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure>

<p>上面的键是String类型，String类实现了Comparable接口，因此默认会按照自然顺序从小到大进行排列。</p>
<p>桶TreeSet一样，TreeMap可以自定义比较器Comparator的方式对所有的键进行定制排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span>&#123;</span><br><span class="line">		String key1 = (String)obj1;</span><br><span class="line">		String key2 = (String)obj2;</span><br><span class="line">	    <span class="keyword">return</span> key2.compareTo(key1);  <span class="comment">//从大到小排列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map m = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> MyComparator());</span><br></pre></td></tr></table></figure>

<h4 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h4><p>Map接口还有一个实现来Hashtable，它和HashMap十分相似，区别在于Hashtable是线程安全的，因此在使用上Hashtable的效率不及HashMap。因此通常使用HashMap。</p>
<p>但是Hashtable有一个子类Properties，主要用来存储字符串类型的键值，在实际开发中，经常用来存取应用的配置项。</p>
<p>假设有一个配置文件：test.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color = red;</span><br><span class="line">size = 10;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.通过Properties进行属性文件读取操作</span></span><br><span class="line">	Properties pps = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//加载文件</span></span><br><span class="line">	pps.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.properties&quot;</span>));</span><br><span class="line">	<span class="comment">//遍历键值对信息</span></span><br><span class="line">	pps.forEach((k,v)-&gt;System.out.println(k+<span class="string">&quot;:&quot;</span>+v));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.通过Properties进行属性文件写入操作</span></span><br><span class="line">	<span class="comment">//指定写入操作的文件名称和位置</span></span><br><span class="line">	<span class="function">FileOutputStream out new <span class="title">FileOutputStream</span><span class="params">(<span class="string">&quot;test.properties&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//向Properties类文件进行写入键值对信息</span></span><br><span class="line">	pps.setProperty(<span class="string">&quot;charset&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="comment">//将此Properties集合中新增的键值对写入配置文件</span></span><br><span class="line">	pps.store(out, <span class="string">&quot;新增charset编码&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Properties的setProperty方法，用来新增一个键值对元素。store方法用来将新增信息写入到properties配置文件。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在之前创建集合，当把一个对象存入集合后，集合会忘记这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就会统一变成Object类型。也就是说，存入元素啥类型都行，但是取出元素后，进行强制转换容易出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList lis = new ArrayList();</span><br><span class="line">lis.add(&quot;aa&quot;);</span><br><span class="line">lis.add(&quot;bb&quot;);</span><br><span class="line">for(Object obj:lis)&#123;</span><br><span class="line">	String s = (String)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为解决该问题，Java引入“参数化类型”概念，即泛型。泛型可以限定操作的数据类型，在定义集合类时，可以使用“&lt;参数化类型&gt;”的形式指定集合中存储的数据类型。</p>
<p><code>ArrayList&lt;String&gt;lis = new ArrayList&lt;String&gt;();</code></p>
<p>这样限定了集合元素的数据类型，程序编译时类型不必配的话会编译不通过，避免运行时发生错误。遍历时<code>for(String s:lis)&#123;&#125;</code></p>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>Java提供的一个专门工具类用来操作集合，位于java.util包中。Collections类中提供了大量的静态方法用于对集合中的元素进行排序、查找、修改等操作。</p>
<h4 id="添加、排序"><a href="#添加、排序" class="headerlink" title="添加、排序"></a>添加、排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">//集合可以直接输出，而数组不可以，数组可以用forEach的Lambda表达式？</span></span><br><span class="line">System.out.println(lis);</span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line">Collections.reverse(lis);  <span class="comment">//反转</span></span><br><span class="line">Collections.shuffle(lis);  <span class="comment">//随机打乱集合顺序</span></span><br><span class="line">Collections.swap(lis,<span class="number">0</span>,lis.size()-<span class="number">1</span>);  <span class="comment">//交换元素</span></span><br></pre></td></tr></table></figure>

<h4 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">Collections.addAll(lis,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">最大元素： Collections.max(lis);</span><br><span class="line">最小元素： Collections.min(lis);</span><br><span class="line">Collections.replace(lis,<span class="number">2</span>,<span class="number">0</span>);  <span class="comment">//将集合中的2用0替换掉</span></span><br><span class="line">Collections.sort(lis);  <span class="comment">//排序</span></span><br><span class="line"><span class="comment">//通过二分查找查找元素3所在的角标，一定要先排序</span></span><br><span class="line"><span class="keyword">int</span> index = Collections.binarySearch(lis, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>java针对数组操作提供的数据工具类Arrays，提供大量静态方法。</p>
<h4 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">不能通过System.out直接打印数组，需要<span class="keyword">for</span>循环打印</span><br><span class="line">Arrays.sort(arr);  <span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr,<span class="number">1</span>,<span class="number">4</span>);  左闭右开</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> index=Arrays.binarySearch(arr,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>在不破坏原数组的情况下使用数组的部分元素，将指定范围的元素拷贝到一个新的数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] cop = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//结果cop：8，3，5，2，0，0，左闭右开共六个，没有的用默认0</span></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>将数组的所有元素替换为一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">8</span>);  <span class="comment">//全换为8</span></span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>Lambda表达式可以简化集合和数组的遍历、过滤和提取等操作。基于此特性，JDK8新增了聚合操作。</p>
<h4 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h4><p>JDK8提供，该接口将集合、数组中的元素转换为Stream流的形式，并结合Lambda表达式进一步简化集合、数组中元素的查找、过滤、转换操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt;lis <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lis.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">lis.add(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个Stream流对象</span></span><br><span class="line">Stream&lt;String&gt;stream = lis.stream();</span><br><span class="line"><span class="comment">//对Stream流中的元素进行过滤、截取</span></span><br><span class="line">Stream&lt;String&gt;stream2 = stream.filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">Stream&lt;String&gt;stream3 = stream.filter(i-&gt;i.length()&gt;<span class="number">1</span>);</span><br><span class="line">Stream&lt;String&gt;stream4 = stream2.limit(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//对Stream流中的元素进行终结操作</span></span><br><span class="line">stream4.forEach(j-&gt;System.out.println(j));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过链式表达式的形式完成聚合操作</span></span><br><span class="line">lis.stream().filter(i-&gt;i.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">			.limit(<span class="number">1</span>)</span><br><span class="line">			.forEach(j-&gt;System.out.println(j));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问：创建list时，最先的List和ArrayList有何区别？</p>
<p>List<int>可以吗？还是说元素必须为引用类型</int></p>
</blockquote>
<p>链式表达式：调用有返回值的方法时不获取返回值而是直接再调用另一个方法，实现聚合操作，也被称为操作管道流。</p>
<p>执行某个方法返回类型仍为stream流对象的方法归为中间操作，如过滤截取排序。</p>
<p>执行方法后返回类型不再是Stream流对象的方法归为终结操作，如遍历统计收集。</p>
<h4 id="创建Stream流对象"><a href="#创建Stream流对象" class="headerlink" title="创建Stream流对象"></a>创建Stream流对象</h4><p>聚合操作针对的是可迭代数据进行操作：如集合、数组。因此创建Stream流对象是将集合、数组通过一些方法转换为Stream流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Stream流对象的集中方法</span></span><br><span class="line">Integer[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//将数组转换为List集合</span></span><br><span class="line">List&lt;Integer&gt;lis=Arrays.asList(arr);</span><br><span class="line"><span class="comment">//1.使用集合对象的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream=lis.stream();</span><br><span class="line">stream.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用Stream接口的of()静态方法为基本类型包装类数组、引用类型数组、单个元素创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream2=Stream.of(arr);</span><br><span class="line">stream2.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用Arrays数组工具类的stream()静态方法创建stream流对象</span></span><br><span class="line">Stream&lt;Integer&gt;stream3=Arrays.stream(arr);</span><br><span class="line">stream3.forEach(i-&gt;System.out.print(i+<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意：集合对象的stream()静态方法只是针对单列集合Collection接口对象提供的，对Map集合首先通过Map集合的<code>keySet()  values()  entrySet()</code>方法转换为单列Set集合。</p>
<h4 id="map-映射"><a href="#map-映射" class="headerlink" title="map()映射"></a>map()映射</h4><p>Stream流对象的map()方法可以将流对象中的元素通过特定的规则进行修改然后映射为另一个流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt;stream=Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">stream.map(String::toUpperCase)  <span class="comment">//流中所有元素字母转为大写</span></span><br><span class="line">	  .sorted()</span><br><span class="line">	  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="截取limit"><a href="#截取limit" class="headerlink" title="截取limit()"></a>截取limit()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.skip(<span class="number">1</span>)   <span class="comment">//跳过流中的前一个元素</span></span><br><span class="line">      .limit(<span class="number">2</span>)   <span class="comment">//截取前2个元素</span></span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>forEach()操作无法将进行中间操作后的流元素作为我们熟悉的对象或是数据类型进行保存，为此JDK8为操作流对象增加了一个终结操作—-collect。</p>
<p>collect可以把Stream中的元素保存为另一种形式，如集合、字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存为List集合</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt;lis = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将流元素使用&quot;and&quot;连接，收集到一个字符串中</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String st = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.joining(<span class="string">&quot;and&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存为数组</span></span><br><span class="line">Stream&lt;String&gt;stre = Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">String[] arr = stre.filter(i-&gt;i,startWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">					  .collect(Collectors.toArray());</span><br></pre></td></tr></table></figure>

<p>注意：一个Stream可以进行多个中间操作，但只能进行一个终结操作，一旦进行了终结操作，流对象就不复存在了。因此，只能保存一次。</p>
<h4 id="Parrel-Stream并行流"><a href="#Parrel-Stream并行流" class="headerlink" title="Parrel Stream并行流"></a>Parrel Stream并行流</h4><p>JDK8针对大批量数据提供并行流，并行流是将源数据分为多个子流对象进行多线程操作（多个管道流），然后将处理的结果再汇总为一个流对象。</p>
<p>并行流可以提高程序执行效率，但是在多线程执行时会出现线程安全问题，需要保证源数据在并行执行时不会被改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建List集合数据源</span></span><br><span class="line">List&lt;String&gt;lis = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">//1.直接用Collection接口的parallelStream()创建并行流</span></span><br><span class="line">Stream&lt;String&gt;para = lis.parallelStream();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用BaseStream接口的parallel()方法将串行流转变为并行流</span></span><br><span class="line">Stream&lt;String&gt;str = Stream.of(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>.<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">Stream&lt;String&gt;para = str.parallel();</span><br><span class="line"><span class="comment">//判断是否为并行流</span></span><br><span class="line">System.out.println(para.isParallel());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》IO</title>
    <url>/2021/11/25/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BIO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="I-O流概述"><a href="#I-O流概述" class="headerlink" title="I/O流概述"></a>I/O流概述</h2><p>java中将不同输入输出设备之间的数据传输抽象表述为“流”。</p>
<p>分类1：根据操作的数据单位不同，分为字节流和字符流。</p>
<p>分类2：根据传输方向，分为输入流和输出流。输入流只能从流中读取数据，而不能写入数据；输出流只能向流中写入数据，而不能从中读取数据。</p>
<p>分类3：根据流的功能不同，分为节点流和处理流。节点流被称为低级流，指可以从一个特定的I/O设备读写数据的流，它只能直接连接数据源，进行数据的读写操作。处理流也被称为高级流，用于对一个已存在的节点流进行连接和封装，通过封装后的流来实现流的读写能力。当使用处理流时，程序不会直接连接到实际的数据源，而是连接在已存在的流之上。</p>
<p>java中的I/O流主要定义在java.io包中，该包有四个顶级类，都是抽象类，是所有流类型的父类。</p>
<p><img src="https://img-blog.csdnimg.cn/f17ecff43e2a4f498e1b845d0fe6c7f7.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>计算机中，所有文件都是二进制（字节）形式存在的。JDK提供了<code>InputStream</code>和<code>OutputStream</code>。字节输入流：从源设备经流中走向程序。字节输出流：从程序输出经流中走向目标。输入输出是相对程序而言的，输入到输出到的意思。</p>
<h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>针对文件的读写，有两个类：<code>FileInputStream</code>和<code>FileOutputStream</code>。</p>
<p><code>FileInputStream</code>是<code>InputStream</code>的子类，由于从文件读取数据是重复的操作，因此需要通过循环语句来实现数据的持续读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输入流来读取文件</span></span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义int变量</span></span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>; </span><br><span class="line">		<span class="comment">//通过循环读取文件，当返回值为-1结束循环</span></span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如内容为hello，字符占一个字节，因此显示的是这五个字节所对应的ASCII码值。</p>
<p><code>FileOutputStream</code>负责将数据写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个文件字节输出流来写文件</span></span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">		<span class="comment">//定义一个字符串</span></span><br><span class="line">		String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="comment">//将字符串转换为字节数组进行写入操作</span></span><br><span class="line">		out.write(str.getBytes());</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若文件已存在，则会首先将文件中内容擦空，再写入。</p>
<p>若想追加内容：<code>FileOutputStream out = new FileOutputStream(&quot;out.txt&quot;, true);</code></p>
<p>I/O流在进行数据读写时，会出现异常，上述代码使用throws将异常抛出。但是一旦遇到I/O异常，close方法无法执行，流对象所占用的系统资源将不能释放。因此通常将关闭流的操作写在finally代码块中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(in!=<span class="keyword">null</span>)  in.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(out!=<span class="keyword">null</span>)  out.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><p>通过输入流来读取文件中的数据，并通过输出流将数据写入新文件。</p>
<p>定义一次输出流创建一个文件，定义之后多次写入，都是追加的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>)</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节流的缓冲区"><a href="#字节流的缓冲区" class="headerlink" title="字节流的缓冲区"></a>字节流的缓冲区</h3><p>一个字节一个字节地拷贝，需要频繁操作文件，因此构建一个字节数组作为临时缓冲区。可以一次性读写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>);</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//通过变量len记住读入数组的字节数，len表示读取字节的数目</span></span><br><span class="line">			out.write(buffer, <span class="number">0</span>, len); <span class="comment">//从buffer的0位置开始写入len个字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>read方法内无东西时，表示从输入流读取一个8位的字节，把它转换为0-255的整数，并返回这个整数，当没有可用字节时，将返回-1。</p>
<p>read方法内是byte数组时，表示读取若干字节，并将其保存到指定的字节数组中，返回整数表示读取的字节的数目。</p>
<p>write方法内，一个int表示写入一个字节，一个字节数组表示写入字节数组中的所有字节，也可以写入指定数目字节。</p>
<p>输出流的flush()方法表示将输出缓冲区（通常是字节数组）中的数据强制写入目标设备，此过程称为刷新。</p>
</blockquote>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>I/O包中提供了两个带缓冲的字节流，分别为<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>，它们的构造方法中分别接收<code>InputStream</code>和<code>OutputStream</code>类型的参数作为对象。再读写数据时提供缓冲功能。</p>
<p>其实就像是上一节的系统实现。</p>
<p>关系：源设备—字节流—字节缓冲流—应用程序—字节缓冲流—字节流—目标设备</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;source/src.jpg&quot;</span>));</span><br><span class="line">		BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;target/src.jpg&quot;</span>));</span><br><span class="line">		<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">while</span>((len=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(len)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间为：&quot;</span>+(endTime-beginTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">		<span class="comment">//关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流对象内部都定义了一个大小为8192的字节数组。读写都是到一个字节数组中，充当缓冲。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>Reader是字符输入流，用于从某个源设备读取字符。Writer是字符输出流。用于向某个目标设备写入字符。</p>
<p>输入输出是相对程序而言的，输入到输出到的意思。读和写是读到程序和从程序中写出的意思。</p>
<h3 id="字符流操作文件"><a href="#字符流操作文件" class="headerlink" title="字符流操作文件"></a>字符流操作文件</h3><p>从文件读取字符用字符输入流FileReader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;reader.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((b=fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.print((<span class="keyword">char</span>)b)</span><br><span class="line">		&#125;</span><br><span class="line">		fileReader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read返回的是int类型，因此要获得字符需要强制类型转换。</p>
<p>向文件中写入字符用FileWriter类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;writer.txt&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;你好,\r\n&quot;</span>);</span><br><span class="line">		fileWriter.write(<span class="string">&quot;世界。\r\n&quot;</span>);</span><br><span class="line">		fileWriterr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入文件，如果文件已存在则先清空，项追加的话，则构造时后面加true。</p>
<p>与字节流类似，这里也可以加字符流缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] buff=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len=fileReader.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	fileWriter.write(buff, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符流也提供了带缓冲区的字符缓冲流，<code>BufferedReader</code>和<code>BufferedWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	    <span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">	    BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">	    <span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">	    BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;write.txt&quot;</span>));</span><br><span class="line">	    String str = <span class="keyword">null</span>;</span><br><span class="line">	    <span class="keyword">while</span>((str=in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	    	out.write(str);</span><br><span class="line">	    	out.newLine();</span><br><span class="line">	    &#125;</span><br><span class="line">	    in.close();</span><br><span class="line">	    out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BufferedReader</code>的readLine()方法，用于一次读取一行文本。</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>JDK中提供了两个类实现字节流转换为字符流。</p>
<p>字节输入流转变为字符输入流：<code>InputStreamReader</code></p>
<p>字节输出流转变为字符输出流：<code>OutputStreamWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字节输入流，获取源文件</span></span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输入流对象转换为字符输入流对象</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line"><span class="comment">//创建字符输入缓冲流对象</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字节输出流，指定目标文件</span></span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;write.txt&quot;</span>);</span><br><span class="line"><span class="comment">//将字节输出流对象转换为字符输出流对象</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamReader(out);</span><br><span class="line"><span class="comment">//创建字符输出缓冲流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问，不明白意义何在，文件时字节码文件，程序侧用字符流有何益处。</p>
</blockquote>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>通过I/O流可以对文件的内容进行读写操作，但是对文件本身进行一些常规操作，例如创建、删除、重命名等，JDK提供了一个File类。</p>
<p>File类用于封装一个路径，可以是绝对路径，也可以是相对路径。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String dirname = <span class="string">&quot;/java&quot;</span>;</span><br><span class="line">        File f1 = <span class="keyword">new</span> File(dirname);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹名称：&quot;</span>+f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/文件夹大小：&quot;</span>+f1.length()+<span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (f1.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Directory of &quot;</span> + dirname);</span><br><span class="line">            String s[] = f1.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(dirname + <span class="string">&quot;/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a directory&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; is a file&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirname + <span class="string">&quot; is not a directory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;是否成功删除：&quot;</span>+f1.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历某个目录下的所有文件，用list方法，除了上面的方法外，还可以采用数组工具类Arrays的stream方法进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">String[] fileNames = file.list();</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是想要获得指定类型的文件，例如.txt文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向list传入lambda表达式形式的参数，进行过滤。</span></span><br><span class="line">String[] fileNames=file.list((dir,name)-&gt;name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br><span class="line">Arrays.stream(fileNames).forEach(f-&gt;System.out.println(f));</span><br></pre></td></tr></table></figure>

<p>若是要遍历所有文件及目录，包括子目录下的文件。使用listFiles方法返回的是一个File对象数组。进行递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">        func(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历目录及其子目录方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        File[] listFiles=file.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File files:listFiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(files.isDirectory())&#123;</span><br><span class="line">                func(files);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：java中的删除文件是通过java虚拟机直接删除的，而不走回收站。</p>
</blockquote>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>不属于流类，但具有读写文件数据的功能，可以随机从文件的任何位置开始执行读写数据的操作。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>程序在运行过程中，需要将一些数据永久地保存到磁盘上，而数据在java中都是保存在对象当中的，如何将对象中的数据保存到磁盘上，就用java中的对象序列化。</p>
<p>对象的序列化（Serializable）是指将一个Java对象转换为一个I/O流中字节序列的过程。可以使内存中的Java对象转换成与平台无关的二进制流。</p>
<p>将I/O流中的字节序列恢复为Java对象的过程–反序列化。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>想让对象序列化，那么这个对象所在的类必须是可序列化的，必须实现Serializable或Externalizable两个接口之一。Externalizable性能好但是编程复杂，因此大部分采用Serializable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">      e.name = <span class="string">&quot;Reyan Ali&quot;</span>;</span><br><span class="line">      e.address = <span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;</span><br><span class="line">      e.SSN = <span class="number">11122333</span>;</span><br><span class="line">      e.number = <span class="number">101</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileOutputStream fileOut =</span><br><span class="line">         <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">         out.writeObject(e);</span><br><span class="line">         out.close();</span><br><span class="line">         fileOut.close();</span><br><span class="line">         System.out.printf(<span class="string">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">          i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/tmp/employee.ser&quot;</span>);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">         e = (Employee) in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line">         fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">         i.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">         c.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Deserialized Employee...&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);</span><br><span class="line">      System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address);</span><br><span class="line">      System.out.println(<span class="string">&quot;SSN: &quot;</span> + e.SSN);</span><br><span class="line">      System.out.println(<span class="string">&quot;Number: &quot;</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。</p>
<p>注意，readObject() 方法的返回值被转化成 Employee 引用。</p>
<p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>从JDK1.4开始，java提供了一系列改进的用于处理输入输出的新功能，被称为NIO（New I/O）。</p>
<p>NIO采用内存映射文件的方式来处理输入输出，将文件或文件的一段区域映射到内存中，像访问内存一样来访问文件。</p>
<p>标准的IO中使用字节流和字符流，NIO中，使用通道Channel和缓冲区Buffer。数据总是从通道读入缓冲区，或从缓冲区写入通道。</p>
<p>Buffer可以看成是一个容器，本质是一个数组缓冲区，读入或写出到Channel中的所有对象都先放在Buffer中。</p>
<p>Channel是对传统的输入输出的模拟，所有的数据都通过通道流的形式传输。</p>
<p>Selector选择器，用于监听多个通道的事件（例如连接打开、数据到达）主要用于多线程处理。</p>
<h2 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h2><p>JDK7引入新的I/O API，提供全面的文件输入输出以及文件系统的访问与支持，并且新增java.nio.file包及其子包，提供基于异步Channel的输入输出。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之GUI</title>
    <url>/2021/11/26/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BGUI/</url>
    <content><![CDATA[<p>GUI：Graphical User Interface 图形用户接口。用来提供给用户操作的图像界面的接口。</p>
<p>java针对GUI设计提供了一些基本的图形用户接口开发工具，如AWT、Swing、JavaFX。</p>
<p>AWT是sun公司最早推出的一套API，组件种类有限，无法实现GUI设计的全部功能。</p>
<h2 id="Swing概述"><a href="#Swing概述" class="headerlink" title="Swing概述"></a>Swing概述</h2><p>早期JDK1.0发布时，就为GUI开发提供了一套基础类库（AWT），即抽象窗口工具包。AWT需要牺牲功能来实现平台无关性。因此，Sun公司对AWT进行改进，提出Swing组件，提供更加丰富的组件和功能，来满足GUI设计的一切需求。</p>
<p>Swing是一组轻量级组件，由Java语言开发，同时底层以AWT为基础。Swing并不是AWT的替代品，而是在原有的AWT的基础上进行补充和改进。</p>
<p>Swing组件的所有类都继承自Container类，然后根据GUI开发的功能扩展了两个主要分支：容器分支（Window窗口和Panel面板）和组件分支。</p>
<p>容器分支是为了实现图形用户界面窗口容器而设计的。</p>
<p>组件分支是为了实现向容器中填充数据、元素以及人机交互组件等功能。</p>
<p>Swing组件类中常用的顶级容器类包括：JApplet、JFrame和JDialog。常用的组件类：AbstractButton类及其子类就是用来定义按钮常见行为的工具类，JTextComponent类及其子类就是用来定义文本内容编辑区域的工具类。</p>
<h2 id="JavaFX概述"><a href="#JavaFX概述" class="headerlink" title="JavaFX概述"></a>JavaFX概述</h2><p>JavaFX同Swing一样，都用于处理图形用户界面，是一个强大的图形和多媒体处理工具包集合，允许开发者设计、创建、测试、调试和部署富客户端程序，并且和Java一样具有跨平台特性。</p>
<p>Sun公司于2008年推出JavaFX，来弥补Java在桌面应用程序的缺陷。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之JDBC</title>
    <url>/2021/11/27/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8BJDBC/</url>
    <content><![CDATA[<p>实际开发中，项目中的数据是存储在数据库中的，Java对数据库的操作提供了一套可以执行SQL语句的API，即JDBC。</p>
<h2 id="JDBC概念"><a href="#JDBC概念" class="headerlink" title="JDBC概念"></a>JDBC概念</h2><p>JDBC（java database connectivity，Java数据库连接）是一套用于执行SQL语句的Java API。应用程序通过该API连接到关系型数据库，并使用SQL语句来完成对数据库中数据的增删改查。</p>
<p>JDBC要求各个数据库厂商按照统一的规范来提供数据库驱动，在程序中由JDBC和具体的数据库驱动联系，使得应用程序不必直接与底层数据库交互，使得代码的通用性更强。</p>
<p>JDBC在应用程序与数据库之间起到一个桥梁作用。当应用程序使用JDBC访问特定的数据库时，只需要通过不同的数据库驱动与其对应的数据库进行连接，连接后即可对该数据库进行相应的操作。</p>
<h2 id="JDBC常用API"><a href="#JDBC常用API" class="headerlink" title="JDBC常用API"></a>JDBC常用API</h2><p>JDBC的API主要位于java.sql包中，定义了一系列访问数据库的接口和类。</p>
<h3 id="Driver接口"><a href="#Driver接口" class="headerlink" title="Driver接口"></a>Driver接口</h3><p>是所有JDBC驱动程序必须实现的接口，专门提供给数据库厂商使用。</p>
<h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p>用于加载JDBC驱动并创建与数据库的连接。在加载数据库驱动时，通常使用Class类的静态方法forName()来实现。参数是数据库驱动类所对应的字符串。</p>
<h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p>代表Java程序和数据库的连接对象，只有获得该连接对象后，才能访问数据库，并操作数据表。</p>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>用于执行静态的SQL语句，并返回一个结果对象。</p>
<p>Statement接口对象可以通过Connection实例的createStatement()方法获得，该方法把静态的SQL语句发送到数据库中编译执行，然后返回数据库的处理结果。</p>
<h3 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h3><p>使用Statement接口操作SQL语句会过于繁琐，并且存在安全隐患，因此，JDBC提供了扩展的PreparedStatement接口。是Statement的子接口，用于执行预编译的SQL语句，可以使用占位符？来替代参数，然后通过setXXX()方法为SQL语句的参数赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;insert into users(is,name,email) values(?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement prestmt = conn.preparedStatement(sql);</span><br><span class="line">prestmt.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">prestmt.setString(<span class="number">2</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">prestmt.setObject(<span class="number">3</span>,<span class="string">&quot;111@1.com&quot;</span>);  <span class="comment">//通用方法？</span></span><br><span class="line">prestmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>用于保存JDBC执行查询时返回的结果集，结果集封装在一个逻辑表格中。接口内部有一个指向表格数据行的游标（或指针），ResultSet对象初始化时，游标在第一行之前。调用next()方法，游标移动到下一行，若下一行没有数据，则返回false。</p>
<p>应用程序中使用next方法作为while循环的条件来迭代ResultSet结果集。</p>
<p>getXXX方法用于获取指定的数据，可以用索引（从1开始）也可用字段的名称来获取。</p>
<p>例如第1列字段名为id，字段类型int，可以用getInt(“id”)或getInt(1)获得该列的值。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="第一步：加载数据库驱动"><a href="#第一步：加载数据库驱动" class="headerlink" title="第一步：加载数据库驱动"></a><em>第一步：加载数据库驱动</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <span class="comment">//加载mysql数据库的驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">//加载Oracle数据库的驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步：获取数据库连接"><a href="#第二步：获取数据库连接" class="headerlink" title="第二步：获取数据库连接"></a><em>第二步：获取数据库连接</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(String url, String user, String pwd);</span><br></pre></td></tr></table></figure>

<p>连接数据库的url需要遵循固定写法：</p>
<p><code>jdbc:mysql://hostname:port/databasename</code></p>
<p>mysql指MySQL数据库，hostname指主机的名称（如果数据库在本机上，hostname可以为localhost或127.0.0.1。如果在其他机器上，那么hostname为所要连接机器的IP地址。port指端口号，mysql默认端口号为3306，databasename指的是mysql中相应数据库的名字。</p>
<h3 id="第三步：通过Connection对象获取Statement对象"><a href="#第三步：通过Connection对象获取Statement对象" class="headerlink" title="第三步：通过Connection对象获取Statement对象"></a><em>第三步：通过Connection对象获取Statement对象</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement stmt = conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>也可以用PreparedStatement。</p>
<h3 id="第四步：使用Statement执行SQL语句"><a href="#第四步：使用Statement执行SQL语句" class="headerlink" title="第四步：使用Statement执行SQL语句"></a><em>第四步：使用Statement执行SQL语句</em></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execute(String sql);  用于执行任意sql语句</span><br><span class="line">executeQuery(String sql);   执行查询操作，返回一个ResultSet结果集对象</span><br><span class="line">executeUpdate(String sql);  执行insert、update、delete会返回受sql语句影响的行数，执行create、alter返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line">ResultSet rs=stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<h3 id="第五步：操作ResultSet结果集"><a href="#第五步：操作ResultSet结果集" class="headerlink" title="第五步：操作ResultSet结果集"></a><em>第五步：操作ResultSet结果集</em></h3><h3 id="第六步：关闭连接，释放资源"><a href="#第六步：关闭连接，释放资源" class="headerlink" title="第六步：关闭连接，释放资源"></a><em>第六步：关闭连接，释放资源</em></h3><p>顺序为：ResultSet、Statement、Connection。为了保证在异常情况下也能关闭资源，用try…catch的finally代码块统一关闭资源。</p>
<h2 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h2><h3 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database jdbc;</span><br><span class="line">show databases;</span><br><span class="line">use jdbc;</span><br><span class="line">create table test_table(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(40),</span><br><span class="line">    sex varchar(2),</span><br><span class="line">    birthday date</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看表结构： desc test_table;</span><br><span class="line">查看建表语句：show create table test_table;</span><br></pre></td></tr></table></figure>

<p>如果出现中文乱码的情况，是因为MySQL数据库默认使用UTF-8编码格式，而命令行窗口默认使用的是GBK编码格式，所以执行带有中文数据的插入语句会出现解析错误。需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set character_set_client=gbk;</span><br><span class="line">set character_set_results=gbk;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test_table(name, sex, birthday)</span><br><span class="line">values(&#x27;jade&#x27;,&#x27;男&#x27;,&#x27;2000-1-1&#x27;),(&#x27;marry&#x27;,&#x27;女&#x27;,&#x27;1999-2-21&#x27;),(&#x27;james&#x27;,&#x27;男&#x27;,&#x27;2010-2-3&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="新建项目，导入数据库驱动"><a href="#新建项目，导入数据库驱动" class="headerlink" title="新建项目，导入数据库驱动"></a>新建项目，导入数据库驱动</h3><p>IDE下正常创建一个项目，右键新建一个文件夹，取名libs。</p>
<p>下载Mysql驱动文件：<a href="https://dev.mysql.com/downloads/connector/j/%EF%BC%8C%E9%80%89%E6%8B%A9platform">https://dev.mysql.com/downloads/connector/j/，选择platform</a> independent，下载 <strong>ZIP Archive</strong>。直接No thanks, just start my download.  复制到libs文件夹下。</p>
<p>把jar包添加到项目里，类似eclipse的add to build path功能，file – project structure – modules – dependencies – 加号 – 第一项–添加jar包 – apply。</p>
<h3 id="编写JDBC程序"><a href="#编写JDBC程序" class="headerlink" title="编写JDBC程序"></a>编写JDBC程序</h3><p>src下新建包com.liuxuan.jdbc。创建类Test。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.parser.JSONParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: JDBCdemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: jdbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-27 22:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.加载数据库驱动 com.mysql.jdbc.Driver 多加了cj</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.通过DriverManager获取数据库连接</span></span><br><span class="line">            String url = <span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>;</span><br><span class="line">            String username = <span class="string">&quot;liuxuan&quot;</span>;</span><br><span class="line">            String password = <span class="string">&quot;jade&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//3.通过Connection对象获取Statement对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.使用Statement执行SQL语句</span></span><br><span class="line">            String sql = <span class="string">&quot;select * from test_table&quot;</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.操作ResultSet结果集</span></span><br><span class="line">            System.out.println(<span class="string">&quot;id  |  name  |  sex  &quot;</span></span><br><span class="line">                            +<span class="string">&quot;  birthday  &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String sex = rs.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                Date birthday = rs.getDate(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line">                System.out.println(id+<span class="string">&quot;  |  &quot;</span>+name+<span class="string">&quot;  |  &quot;</span></span><br><span class="line">                                +sex+<span class="string">&quot;  |  &quot;</span>+birthday);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//6.关闭连接，释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;rs.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;stmt.close();&#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;conn.close();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>BeanFactory、ApplicationContext</title>
    <url>/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/</url>
    <content><![CDATA[<h3 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h3><p>BeanFactory使管理不同类型的java对象成为可能，应用上下文ApplacationContext建立在BeanFactor基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。我们一般称BeanFactory为IOC容器，而称ApplicationContext为应用上下文。但有时为了行文方便，我们也称ApplicationContext为Spring容器。</p>
<p>对于二者的用途，可以进行简单的划分：BeanFactor是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p>
<p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<br>①继承MessageSource，因此支持国际化。<br>②统一的资源文件访问方式。<br>③提供在监听器中注册bean的事件。<br>④同时加载多个配置文件。<br>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>（2）BeanFactory通常是使用编程方式被创建的，而ApplicationContext可以用声明（就是用配置的方式）的方式创建，当然也可以使用ApplicationContext的实现类之一用编码方式来创建ApplicationContext的实例.</p>
<p>（3）BeanFactory采用的是延迟加载形式来注入bean的，只有在使用到getBean() 时，才对该bean进行加载实例化，这样我们就不能发现一些bean的配置问题。而ApplicationContext则相反，它是在容器启动的时候，一次性创建所有的bean，这样在容器启动时就能发现spring 中存在的配置错误。这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>（4）BeanFactory和ApplicationContext都支持BeanPostProcesser、BeanFactoryPostProcessor的使用，但两者的区别是：BeanFactory是手动注册的，ApplicationContext是自动注册的.</p>
<h3 id="ApplicationContext的创建方式"><a href="#ApplicationContext的创建方式" class="headerlink" title="ApplicationContext的创建方式"></a>ApplicationContext的创建方式</h3><h4 id="使用代码方式"><a href="#使用代码方式" class="headerlink" title="使用代码方式"></a>使用代码方式</h4><p>ApplicationContext接口常用实现类：</p>
<p>1.ClassPathXmlApplicationContext</p>
<p>a.加载单个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>b.加载多个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] configs = &#123;&quot;bean1.xml&quot;,&quot;bean2.xml&quot;,&quot;bean3.xml&quot;&#125;;</span><br><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(configs);</span><br></pre></td></tr></table></figure>

<p>2.ConfigurableApplicationContext接口</p>
<p>StartApplication中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 启动springboot应用，获取spring的ioc容器</span><br><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br></pre></td></tr></table></figure>

<h4 id="使用配置-声明"><a href="#使用配置-声明" class="headerlink" title="使用配置(声明)"></a>使用配置(声明)</h4><p>在javaee应用中向Servlet容器中注入Spring容器的方法</p>
<p>ContextLoader 接口，它有两个实现 :ContextLoaderListener 和 ContextLoaderServlet. 其中常用的是 ContextLoaderListener. 从 spring 文档上可以查到，他们二者实现的功能基本一样，只是 ContextLoaderListener 不能在与 Servlet2.2 兼容的 web 容器中使用。另外，因为 ContextLoaderLitener 是一个 servlet Listener ，因此，它是在 servlet context 建立后立即执行，也就以为这 servlet 已建立， spring 的 ApplicationContext 就得到了初始化，并且能够相应第一个请求，所以首选 ContextLoaderListener.</p>
<p>在web.xml中添加如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line"> &lt;! DOCTYPE web-app</span><br><span class="line">      PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line">      &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; </span><br><span class="line"> </span><br><span class="line"> &lt; web-app &gt; </span><br><span class="line">     &lt; display-name &gt; Baselib Application &lt;/ display-name &gt; </span><br><span class="line">    </span><br><span class="line">     &lt; context-param &gt; </span><br><span class="line">        &lt; param-name &gt; contextConfigLocation &lt;/ param-name &gt; </span><br><span class="line">        &lt; param-value &gt; </span><br><span class="line">        /WEB-INF/classes/spring-sup-middelbeans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-action.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-beans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-cm.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-hibernate.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-resource.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-sso.xml</span><br><span class="line">        /WEB-INF/classes/com/javaeye/jert/application_context.xml</span><br><span class="line">        &lt;/ param-value &gt; </span><br><span class="line">    &lt;/ context-param &gt; </span><br><span class="line"></span><br><span class="line">    &lt; listener &gt; </span><br><span class="line">        &lt; listener-class &gt; org.springframework.web.context.ContextLoaderListener &lt;/ listener-class &gt; </span><br><span class="line">    &lt;/ listener &gt; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; param-value &gt; /WEB-INF/classes/spring-*.xml &lt;/ context-param &gt; </span><br></pre></td></tr></table></figure>

<p>这里主要是配置了 spring 的监听器 ContextLoaderListener ，它检查 contextConfigLocation 这个参数。如果它不存在的话，它将用 /WEB-INF/applicationContext.xml 作为默认的配置文件。如果 contextConfigLocation 存在的话，它将根据该参数的值查找配置文件的位置，来一一读取 spring 参数。</p>
<p>contextConfigLocation 是被 spring 固定的，专门用来查  找配置文件位置的.</p>
<p>参考：<br><a href="https://blog.csdn.net/sole_ghost/article/details/1389664">https://blog.csdn.net/sole_ghost/article/details/1389664</a></p>
<h3 id="ApplicationContext-getBean"><a href="#ApplicationContext-getBean" class="headerlink" title="ApplicationContext.getBean"></a>ApplicationContext.getBean</h3><p>目的：获取Spring容器中已初始化的bean</p>
<p>第一种：getBean(String name)<br>参数name表示IOC容器中已经实例化的bean的id或者name,<br>在IOC容器中是唯一的不能重名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种：getBean(Class<T> type)<br>type表示要加载的Bean的类型。<br>如果该类型没有继承任何父类(Object类除外)和实现接口的话，那么要求该类型的bean在IOC容器中也必须是唯一的.(比如定义同一类的两个bean，但是property注入的属性不一样)<br>不需要类型转换。</T></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = ctx.getBean(Person.class);</span><br></pre></td></tr></table></figure>

<p>第三种：getBean(String name,Class<T> type)<br>这种方式比较适合接口/抽象类，有不同实现类或子类时，type写接口或父类，name写bean name。</T></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p = ctx.getBean(&quot;person&quot;,BasePerson.class);</span><br></pre></td></tr></table></figure>

<p>第四种： getBean(String name,Object[] args)<br>第二个参数Object[] args可以给bean的属性赋值，赋值的方式有两种：构造方法和工厂方法。但是通过这种方式获取的bean必须把scope属性设置为prototype，也就是非单例模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.构造方法方式：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.bean.Person&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br><span class="line"></span><br><span class="line">2.工厂注入方式：</span><br><span class="line">工厂类：</span><br><span class="line">public class PersonFactory &#123;</span><br><span class="line">//静态工厂注入</span><br><span class="line">public static Person getPersonInstance(String name,int age)throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  Person p = (Person)Class.forName(&quot;com.bean.Person&quot;).newInstance();</span><br><span class="line">   Method m = p.getClass().getMethod(&quot;setName&quot;, java.lang.String.class);</span><br><span class="line">   m.invoke(p, name);</span><br><span class="line">   m = p.getClass().getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">   m.invoke(p, age);</span><br><span class="line">   return p;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置bean：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.factory.PersonFactory&quot; factory-method=&quot;getPersonInstance&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;age&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_23927391/article/details/80625578">https://blog.csdn.net/qq_23927391/article/details/80625578</a></p>
<h3 id="ApplicationContext-getBeanWithAnnotation"><a href="#ApplicationContext-getBeanWithAnnotation" class="headerlink" title="ApplicationContext.getBeanWithAnnotation"></a>ApplicationContext.getBeanWithAnnotation</h3><p>spring中可以通过getBeansWithAnnotation来获取ioc容器中使用了某个注解的所有bean,这个方法底层原理：我们知道可以通过反射来获取一个类中所有的注解，然后通过遍历spring容器中所有bean就能获取需要的结果。返回Map&lt;String, Object&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自定义@Auditable注解</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">public @interface Auditable &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在person类中我们引入@Auditable，并通过@Component将其注入spring容器</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Auditable(&quot;person.sleep&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    void sleep()&#123;</span><br><span class="line">        System.out.println(&quot;睡觉了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TestApplicationContext implements ApplicationContextAware &#123;</span><br><span class="line"> </span><br><span class="line">    protected ApplicationContext applicationContext;</span><br><span class="line">	</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        Class aClass = Class.forName(&quot;com.yk.annotation.Auditable&quot;);</span><br><span class="line">        //boolean b = aClass.isAnnotation();</span><br><span class="line">        //System.out.println(b);</span><br><span class="line">        //Person person = applicationContext.getBean(Person.class);</span><br><span class="line">        Map beansWithAnnotation = applicationContext.getBeansWithAnnotation(aClass);</span><br><span class="line"></span><br><span class="line">        Iterator entries = beansWithAnnotation.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while (entries.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Map.Entry entry = (Map.Entry) entries.next();</span><br><span class="line">            System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/weixin_42374693/article/details/115374179">https://blog.csdn.net/weixin_42374693/article/details/115374179</a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>一个使用工厂模式管理多个类实现同一个接口的例子：<br><a href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<p><code>applicationContext.getBeansOfType(Sort.class);</code></p>
]]></content>
      <categories>
        <category>spring理解</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot入门教程</title>
    <url>/2022/03/07/myblog/spring/springboot%20b%E7%AB%99/</url>
    <content><![CDATA[<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>spring boot是一个快速开发框架，可以迅速搭建一套基于spring框架体系的应用，是spring cloud的基础。</p>
<p>springMVC虽然简化了配置，减少了很多类的数量，一个控制器当中多个方法可以对应不同的业务，但是SpringMVC的配置还是比较多，搭建工程有很多重复步骤，开发速度不够快。</p>
<p>spring boot开启了各种自动装配，从而简化代码的开发，不需要编写各种配置文件，只需要引入相关依赖就可以迅速搭建一个应用。</p>
<p>特点：</p>
<ul>
<li><p>不需要web.xml</p>
</li>
<li><p>不需要springmvc.xml</p>
</li>
<li><p>不需要tomcat，Spring Boot内嵌了tomcat</p>
</li>
<li><p>不需要配置json解析（fastjson），支持REST架构</p>
</li>
<li><p>个性化配置非常简单，至少需要端口啥的</p>
</li>
</ul>
<p>它是一个快速开发框架，不像mybatis是一个orm映射的应用。相当于一个脚手架，使得其他工种快速进行工作，搭建一个整体的环境。</p>
<h3 id="springboot概念"><a href="#springboot概念" class="headerlink" title="springboot概念"></a>springboot概念</h3><p>spring boot的设计目的是用来简化spring应用的初始搭建以及开发过程，该框架使用了特定的方式进行配置，从而使开发人员不再需要定义样板化的配置，</p>
<p>spring boot默认配置了很多框架的使用方式，就像Maven整合了所有的Jar包，spring boot整合了所有的框架，通过少量的代码就能创建一个独立的、产品级别的spring应用。</p>
<p>简而言之，spring boot是一个集成了spring各种组件的快速开发框架，作为一个用户和spring之间的连接者。</p>
<p>spring boot是基础，spring cloud是基于spring boot的，用来做分布式微服务的。</p>
<h4 id="spring-boot特点"><a href="#spring-boot特点" class="headerlink" title="spring boot特点"></a>spring boot特点</h4><ul>
<li>使用spring项目引导页面可以在几秒构建一个项目。</li>
<li>方便对外输出各种形式的服务，如REST API、WebSocket、Web、Streaming、Tasks</li>
<li>非常简洁的安全策略集成</li>
<li>支持关系数据库和非关系数据库</li>
<li>支持运行期内嵌容器，如tomcat、jetty</li>
<li>自动管理依赖</li>
</ul>
<h4 id="spring-boot与微服务"><a href="#spring-boot与微服务" class="headerlink" title="spring boot与微服务"></a>spring boot与微服务</h4><ul>
<li>spring boot的一系列特性有助于实现微服务架构的落地，从目前众多的技术栈对比来看它是java领域微服务架构最优落地技术，没有之一。</li>
<li>spring cloud依赖于spring boot。</li>
<li>spring boot专注于快速开发个体微服务，spring cloud是关注全局的微服务协调治理框架。spring boot提供组建，spring cloud来管理组件。</li>
</ul>
<h3 id="创建第一个工程"><a href="#创建第一个工程" class="headerlink" title="创建第一个工程"></a>创建第一个工程</h3><h4 id="第一步：创建maven工程，导入相关的依赖"><a href="#第一步：创建maven工程，导入相关的依赖" class="headerlink" title="第一步：创建maven工程，导入相关的依赖"></a>第一步：创建maven工程，导入相关的依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- dependencies下面再引相关的子包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web启动的jar包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步：创建实体类，加lombok"><a href="#第二步：创建实体类，加lombok" class="headerlink" title="第二步：创建实体类，加lombok"></a>第二步：创建实体类，加lombok</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 10:42</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第三步：创建StudentRepository"><a href="#第三步：创建StudentRepository" class="headerlink" title="第三步：创建StudentRepository"></a>第三步：创建StudentRepository</h4><p>之前，需要配置文件去扫dao实现类的包，但是springboot环境启动之后，会自动进行扫描。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.entity.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 10:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(Student stu)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.repository.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.repository.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 10:49</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用静态map代替数据库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Student&gt; studentMap;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        studentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        studentMap.put(<span class="number">1L</span>, <span class="keyword">new</span> Student(<span class="number">1L</span>, <span class="string">&quot;lili&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        studentMap.put(<span class="number">2L</span>, <span class="keyword">new</span> Student(<span class="number">1L</span>, <span class="string">&quot;mary&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        studentMap.put(<span class="number">3L</span>, <span class="keyword">new</span> Student(<span class="number">1L</span>, <span class="string">&quot;jade&quot;</span>, <span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentMap.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        studentMap.put(student.getId(), student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        studentMap.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步：创建control层（跳过了service层）"><a href="#第四步：创建control层（跳过了service层）" class="headerlink" title="第四步：创建control层（跳过了service层）"></a>第四步：创建control层（跳过了service层）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.liuxuan.demo.springboot.repository.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 11:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自动注入，dao实现类要加@Repository注解</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post请求，前端返回的是json格式的字符串对象，需要映射成对象</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sav&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span></span>&#123;</span><br><span class="line">        studentDao.saveOrUpdate(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用put方法</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span></span>&#123;</span><br><span class="line">        studentDao.saveOrUpdate(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        studentDao.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步：创建启动类"><a href="#第五步：创建启动类" class="headerlink" title="第五步：创建启动类"></a>第五步：创建启动类</h4><p>平常的web工程需要在tomcat部署。springboot有自己内置的tomcat，只需要创建一个启动类，作为整个springboot的入口.</p>
<p>application.java需要在其他组件包的父包下，要不然扫描不到。名字叫什么无所谓。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.demo.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022-03-12 11:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数是启动类的运行时类，还有main方法里的args</span></span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p> Tomcat started on port(s): 8080 (http) with context path ‘’</p>
<p>Started Application in 2.772 seconds (JVM running for 3.857)</p>
<p>表示部署成功，可以直接访问了。<a href="http://localhost:8080/student/findAll">http://localhost:8080/student/findAll</a></p>
<p>因为是基于rest的，所以可以用postman工具来测试。（post请求发json，选body–raw–json）</p>
<h4 id="第六步：如果想要更改端口号：在配置文件中更改。"><a href="#第六步：如果想要更改端口号：在配置文件中更改。" class="headerlink" title="第六步：如果想要更改端口号：在配置文件中更改。"></a>第六步：如果想要更改端口号：在配置文件中更改。</h4><p>resource里新建一个application.yml文件。文件名不能变。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>

<p>注意9090前有个空格。</p>
<h3 id="springboot整合JSP"><a href="#springboot整合JSP" class="headerlink" title="springboot整合JSP"></a>springboot整合JSP</h3><p>新建maven工程，选择archetype，选择webapp（web模版，用来访问JSP.）</p>
<p>上一个工程只展示了数据，但是没有视图view。</p>
<p>JSP（全称JavaServer Pages）是由Sun Microsystems公司主导创建的一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。</p>
<p>前后端分离，jsp更像前端的组件，略。</p>
<p>java程序的对象，序列化为json字符串，传递给html进行显示。jsp就是提供视图的。controller用ModeAndView。</p>
<h3 id="spring-boot-html"><a href="#spring-boot-html" class="headerlink" title="spring boot html"></a>spring boot html</h3><p>spring mvc采用异步的方式展示java对象，需要通过json字符串进行读取，但是spring boot可以在html中读取java对象。</p>
<p>spring boot可以结合thymeleaf模版来整合html，使用原生的html作为视图。</p>
<p>Thymeleaf模版是面向Web和独立环境的java模版引擎，能够处理html、xml、javascript、css等。</p>
<p>前端，略。</p>
<h3 id="spring-boot数据校验"><a href="#spring-boot数据校验" class="headerlink" title="spring boot数据校验"></a>spring boot数据校验</h3><p>用来确保客户端输入的数据是有效的。</p>
<p>为什么要用包装类类型？因为前台有可能没穿值，就会是null值，需要包装类类型来接收。</p>
<p>notnull是压根没穿值，notempty是传的空。</p>
<p>这些校验可以交给前端，但是后端有的原因是防止攻击。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 16,message = &quot;年龄必须大于16岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/validator&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validatorUser</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">  System.out.println(user);</span><br><span class="line">  <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">    List&lt;ObjectError&gt; list = bindingResult.getAllErrors();</span><br><span class="line">    <span class="keyword">for</span>(ObjectError objectError:list)&#123;</span><br><span class="line">      System.out.println(objectError.getCode()+<span class="string">&quot;-&quot;</span>+objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用@Valid表示自动去校验，将错误传给BindingResult。getCode是注解名称。</p>
<h3 id="spring-boot整合jdbc"><a href="#spring-boot整合jdbc" class="headerlink" title="spring boot整合jdbc"></a>spring boot整合jdbc</h3><ul>
<li>pom.xml：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">datasource:</span> <span class="string">//连接数据库相关</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>User</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 60,message = &quot;成绩必须大于60分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserRepository</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserRepositoryImpl，jdbcTemplate两种方法：query、update。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.repository.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.southwind.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(<span class="string">&quot;select * from user&quot;</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));</span><br><span class="line">    &#125;       <span class="comment">// 解析实体类，括号内传入要解析成为的实体类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from user where id = ?&quot;</span>,<span class="keyword">new</span> Object[]&#123;id&#125;,<span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;insert into user(name,score) values(?,?)&quot;</span>,user.getName(),user.getScore());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update user set name = ?,score = ? where id = ?&quot;</span>,user.getName(),user.getScore(),user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;delete from user where id = ?&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.southwind.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        userRepository.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="spring-boot整合mybatis"><a href="#spring-boot整合mybatis" class="headerlink" title="spring boot整合mybatis"></a>spring boot整合mybatis</h3><p>mybatis是半自动化的，意思是得自己写sql语句，也就是说需要mapper.xml</p>
<h4 id="第一步：新建maven工程"><a href="#第一步：新建maven工程" class="headerlink" title="第一步：新建maven工程"></a>第一步：新建maven工程</h4><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- dependencies下面再引相关的子包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web启动的jar包，不用写版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- mybatis跟springboot整合的，mybatis自己出的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步：创建数据表"><a href="#第二步：创建数据表" class="headerlink" title="第二步：创建数据表"></a>第二步：创建数据表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student&#123;</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">11</span>),</span><br><span class="line">	score <span class="keyword">double</span>,</span><br><span class="line">	birthday <span class="type">date</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步：创建实体类"><a href="#第三步：创建实体类" class="headerlink" title="第三步：创建实体类"></a>第三步：创建实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2,message = &quot;姓名长度不能小于2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 60,message = &quot;成绩必须大于60分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步：创建repository接口"><a href="#第四步：创建repository接口" class="headerlink" title="第四步：创建repository接口"></a>第四步：创建repository接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步：创建接口对应的mapper-xml"><a href="#第五步：创建接口对应的mapper-xml" class="headerlink" title="第五步：创建接口对应的mapper.xml"></a>第五步：创建接口对应的mapper.xml</h4><p>放在resource文件夹下的mapping文件夹下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.southwind.mapper.UserRepository&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user limit #&#123;param1&#125;,#&#123;param2&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(id) from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        insert into user(name,score) values(#&#123;name&#125;,#&#123;score&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        update user set name = #&#123;name&#125;,score = #&#123;score&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span>   //如果是包装类类型，“java.lang.Long”</span><br><span class="line">        delete from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第六步：创建controller层"><a href="#第六步：创建controller层" class="headerlink" title="第六步：创建controller层"></a>第六步：创建controller层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mapper.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>   <span class="comment">//视频中是 @RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findAll/&#123;page&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findAll</span><span class="params">(<span class="meta">@PathVariable(&quot;page&quot;)</span> <span class="keyword">int</span> page)</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="keyword">int</span> index = (page-<span class="number">1</span>)*limit;</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;list&quot;</span>,userRepository.findAll(index,limit));</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;page&quot;</span>,page);</span><br><span class="line">        <span class="comment">//计算总页数</span></span><br><span class="line">        <span class="keyword">int</span> count = userRepository.count();</span><br><span class="line">        <span class="keyword">int</span> pages = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count%limit == <span class="number">0</span>)&#123;</span><br><span class="line">            pages = count/limit;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pages = count/limit+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;pages&quot;</span>,pages);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deleteById/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/mapper/findAll/1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/findById&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findById</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> <span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;user&quot;</span>,userRepository.findById(id));</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userRepository.update(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/mapper/findAll/1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/mapper/findAll/1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/redirect/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">redirect</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@RequestBody是把请求里的json转换成java对象</p>
<p>@RequestBody是把java对象转成json</p>
<p>@PathVariable直接从对象中传数据的</p>
<p>@RequestParam也是从对象中取数据？</p>
</blockquote>
<h4 id="第七步：配置yml"><a href="#第七步：配置yml" class="headerlink" title="第七步：配置yml"></a>第七步：配置yml</h4><p>resource文件夹下application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapping/*.xml</span>   <span class="string">//注入mapper</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.southwind.entity</span>    <span class="string">//自动将包名提出来，所以mapper里不用写包名了。</span></span><br></pre></td></tr></table></figure>

<h4 id="第八步：创建启动类"><a href="#第八步：创建启动类" class="headerlink" title="第八步：创建启动类"></a>第八步：创建启动类</h4><p>在controller、entity的外部文件夹下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.demo.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-03-12 11:17</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(com.liuxuan.repository)  //因为mapper接口是mybatis的，所以加这个注解用来扫描，把它的实例化对象加到ioc容器中。</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 参数是启动类的运行时类，还有main方法里的args</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第九步：HTML"><a href="#第九步：HTML" class="headerlink" title="第九步：HTML"></a>第九步：HTML</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/mapper/save&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户成绩：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;score&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/mapper/update&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        用户ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span> <span class="attr">readonly</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户成绩：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;score&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;user.score&#125;&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/jquery-3.3.1.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#first&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).text();</span></span><br><span class="line"><span class="javascript">                page = <span class="built_in">parseInt</span>(page);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(page == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>.location.href=<span class="string">&quot;/mapper/findAll/1&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#previous&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).text();</span></span><br><span class="line"><span class="javascript">                page = <span class="built_in">parseInt</span>(page);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(page == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                page = page-<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>.location.href=<span class="string">&quot;/mapper/findAll/&quot;</span>+page;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#next&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).text();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> pages = $(<span class="string">&quot;#pages&quot;</span>).text();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(page == pages)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                page = <span class="built_in">parseInt</span>(page);</span></span><br><span class="line"><span class="javascript">                page = page+<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>.location.href=<span class="string">&quot;/mapper/findAll/&quot;</span>+page;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#last&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> page = $(<span class="string">&quot;#page&quot;</span>).text();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> pages = $(<span class="string">&quot;#pages&quot;</span>).text();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(page == pages)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>.location.href=<span class="string">&quot;/mapper/findAll/&quot;</span>+pages;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;user:$&#123;list&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.score&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/mapper/deleteById/&#123;id&#125;(id=$&#123;user.id&#125;)&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/mapper/findById(id=$&#123;user.id&#125;)&#125;&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;previous&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;page&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;page&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>/<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;pages&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pages&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;next&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;last&quot;</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/mapper/redirect/save&quot;</span>&gt;</span>添加用户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="spring-boot整合spring-data-jpa"><a href="#spring-boot整合spring-data-jpa" class="headerlink" title="spring boot整合spring data jpa"></a>spring boot整合spring data jpa</h3><p>JPA是一套持久层规范，定义了一系列orm接口，需要实现才能使用。</p>
<p>Hibernate框架就是一个jpa实现。</p>
<p>spring data jpa不是对jpa规范的具体实现，本身是一个抽象层，底层通过Hibernate实现。</p>
<h3 id="spring-boot整合spring-data-mongoDB"><a href="#spring-boot整合spring-data-mongoDB" class="headerlink" title="spring boot整合spring data mongoDB"></a>spring boot整合spring data mongoDB</h3><h3 id="spring-boot整合spring-data-redis"><a href="#spring-boot整合spring-data-redis" class="headerlink" title="spring boot整合spring data redis"></a>spring boot整合spring data redis</h3><h3 id="spring-boot整合spring-security"><a href="#spring-boot整合spring-security" class="headerlink" title="spring boot整合spring security"></a>spring boot整合spring security</h3><p>来源：<a href="https://www.bilibili.com/video/BV1v4411G72q?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v4411G72q?spm_id_from=333.999.0.0</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring aop总结</title>
    <url>/2022/04/09/myblog/spring/spring-aop/</url>
    <content><![CDATA[<p>工作中遇到个aop的问题，jdk代理换cglib代理还不过来，以及jdk代理存在的一个问题。总结并实战一下。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="aop相关术语"><a href="#aop相关术语" class="headerlink" title="aop相关术语"></a>aop相关术语</h4><ul>
<li>Target：代理的目标对象</li>
<li>Proxy：代理对象</li>
<li>Joinpoint：连接点，指那些被拦截到的点。在Spring中，这些点指方法，因为Spring只支持方法类型的连接点（可以被增强的方法）</li>
<li>Pointcut：切入点是指我们要对哪些Joinpoint进行拦截的定义</li>
<li>Advice：（通知/增强）是指拦截到Joinpoint之后要做的事情就是通知</li>
<li>Aspect：切面是切入点和通知（增强）的结合</li>
<li>Weaving：织入实质把将切点和增强结合的过程是织入过程，Spring是动态代理织入，AspectJ是采用编译期织入和类装载期织入</li>
</ul>
<p>*连接点是可以被增强的方法，切点是实际上被增强过的方法，连接点范围更大</p>
<h4 id="aop开发过程"><a href="#aop开发过程" class="headerlink" title="aop开发过程"></a>aop开发过程</h4><ol>
<li><p>编写核心业务代码（Target的目标方法-切点）</p>
</li>
<li><p>编写切面类，切面类中有通知（增强功能方法）</p>
</li>
<li><p>在配置文件/注解当中，配置织入关系，即将那些通知与哪些连接点进行结合</p>
</li>
</ol>
<p>AOP技术实现的内容：<br>Spring框架会监控切入点方法的执行–通过配置文件决定哪些方法是切点；一旦监控到切入点方法被运行，即使用代理机制，动态创建目标对象（切点）的代理对象。然后根据配置文件配置的增强类型（通知），在代理对象（切点）对应的位置，将通知对应的功能织入，完成完整的代码逻辑运行。<br>配置文件-执行切点方法-监控到并动态创建代理对象，调用代理对象同名方法-内部调用目标方法，进行增强方法的介入。</p>
<p>AOP底层使用哪种代理方式：<br>Spring会根据目标类是否实现了接口来决定采用哪种动态代理。</p>
<h3 id="实践-配置文件"><a href="#实践-配置文件" class="headerlink" title="实践-配置文件"></a>实践-配置文件</h3><p>新建个spring项目</p>
<ol>
<li><p>导入相关依赖：spring-context、spring-core、spring-beans，还有切面的包 Aspectjweaver</p>
</li>
<li><p>新建service接口，新建实现类Impl</p>
</li>
<li><p>新建切面类，定义切面方法</p>
</li>
<li><p>编写配置文件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启注解扫描  --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.aop.demo&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config proxy-target-class=&quot;false&quot;&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;userServiceImplPointcut&quot; expression=&quot;execution(* com.aop.demo.UserServiceImpl.addUser(..))&quot; /&gt;</span><br><span class="line">    &lt;aop:aspect id=&quot;aopClass&quot; ref=&quot;aopMethods&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;userServiceImplPointcut&quot; /&gt;</span><br><span class="line">        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;userServiceImplPointcut&quot; /&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AopTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testUserServiceAop()&#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-aop.xml&quot;);</span><br><span class="line">        // proxy-target-class=&quot;false&quot; 时，使用jdk代理</span><br><span class="line">        // 强制转换必须用父类接口来定义</span><br><span class="line">        UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">        userService.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>⚠️ proxy-target-class=”false” 或默认表示使用jdk代理，获取对象需要用父类接口，用实现类会报<code>java.lang.ClassCastException: com.sun.proxy.$Proxy* cannot be cast to***</code> 的错误。</p>
<p>⚠️ proxy-target-class=”true”时，使用cglib代理，使用父类接口也可以，使用实现类定义对象也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">UserServiceImpl userService = (UserServiceImpl)context.getBean(&quot;userServiceImpl&quot;);</span><br><span class="line">userService.addUser();</span><br></pre></td></tr></table></figure>

<p>⚠️ 另外，还有个现象是在jdk代理时存在的bug：<br>原本的： <code>UserService userService = (UserService)context.getBean(&quot;userServiceImpl&quot;);</code> 可以获得bean，没问题。<br>但是： <code>UserService userService = (UserService)context.getBean(UserServiceImpl.class);</code>  通过类的全路径获得bean就会出现<code>No qualifying bean of type</code> 的问题。<br>总结：jdk代理方式不用实现类，所以也不会用实现类的bean，即使配了实现类的bean，也不行。</p>
<p>原因：spring aop默认是使用jdk动态代理的，也就是我通过getBean(ServiceImpl.class)，表达出的意思是希望程序通过jdk动态代理给我一个ServiceImpl类。而jdk的动态代理是基于接口实现的，因为它本身要继承一个Proxy类，而java是单继承（接口可以多继承），所以它通过实现接口进行代理。它通过实现我们给它的接口和继承Proxy类实现jdk动态代理。而我们给它的是一个ServiceImpl类，这个时候jdk动态代理就没有办法了。<br>jdk动态代理产生的对象属于Proxy类型，属于给定的接口（Service）类型，但不属于我们要代理的那个对象的类型，也就是本代码中ServiceImpl类型<br>因此，使用接口的类路径：<code>UserService userService = (UserService)context.getBean(UserService.class);</code> 也是可以的。这也解释了工作中遇到的问题。<br>但是，换成cglib，实现类/父类接口，获取bean的方式：id/类路径，都可以，没解释工作中为什么不能直接换成cglib的问题。</p>
<p>总结：<br>jdk代理：必须父类接口获得bean，括号内可以是实现类的bean id，也可以是父类接口的全路径。<br>cglib代理：怎么都行。</p>
<h3 id="实践-注解"><a href="#实践-注解" class="headerlink" title="实践-注解"></a>实践-注解</h3><ol>
<li><p>使用@Aspect注解，出了aspectweaver包之外，还需要aspectjrt包</p>
</li>
<li><p>新建service接口，新建实现类Impl</p>
</li>
<li><p>新建切面类，定义切面方法</p>
</li>
<li><p>编写配置类</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;com.aop.demo.zhujie&quot;&#125;)</span><br><span class="line">@EnableAspectJAutoProxy(proxyTargetClass = false)</span><br><span class="line">public class SpringCfg &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(SpringCfg.class);  //加载配置类</span><br></pre></td></tr></table></figure>

<p>效果和配置文件一样。</p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/jadeliuliu/aop-demo">https://github.com/jadeliuliu/aop-demo</a></p>
<p>参考：<br>知识点：<br><a href="https://www.cnblogs.com/Zhang-DevelopingPlatform/p/14723490.html">https://www.cnblogs.com/Zhang-DevelopingPlatform/p/14723490.html</a></p>
<p>jdk代理找不到bean：<a href="https://blog.csdn.net/qq_32080243/article/details/90261768">https://blog.csdn.net/qq_32080243/article/details/90261768</a></p>
<p>cglib实现：<a href="https://blog.csdn.net/shaoweijava/article/details/76474652">https://blog.csdn.net/shaoweijava/article/details/76474652</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot学习</title>
    <url>/2022/12/22/myblog/spring/springboot%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="springboot创建工程"><a href="#springboot创建工程" class="headerlink" title="springboot创建工程"></a>springboot创建工程</h2><p>微服务体系下不可或缺。<br>ssm(spring+springMvc+mybatis) -&gt; springboot -&gt; springcloud</p>
<p>springboot：约定优于配置，不用专注于配置。2014年发布。</p>
<p>springboot的位置：是spring的顶级项目，和springFramework(ioc、aop)是同等级的。</p>
<p>springboot使用最小配置快速构建spring项目。springboot不是spring功能上的增强，而是提供一种快速开发spring项目的方式。</p>
<p>spring缺点：<br>&lt;1&gt; 写配置文件，繁琐<br>&lt;2&gt; 依赖繁琐，maven坐标版本问题</p>
<p>springboot提供的优点：<br>&lt;1&gt; 自动配置，应用程序启动时的过程<br>&lt;2&gt; 起步依赖，坐标pom打包到一起，对其他库的依赖传递<br>&lt;3&gt; 其他：嵌入式服务器，安全，健康检测</p>
<hr>
<p>✅ 用springboot搭建一个web项目：<br>&lt;1&gt; 创建maven项目<br>&lt;2&gt; 引入起步依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--springboot工程需要继承的父工程   --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  web开发的起步依赖  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 写一个controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:28</span><br><span class="line"> **/</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/h&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; 写引导类，springboot项目入口，然后运行main方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-12-22 23:38</span><br><span class="line"> **/</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 快速构建</p>
<p>用idea，选Spring Initializr，选maven project，选jar打包方式，勾选依赖。</p>
<h2 id="springboot起步依赖"><a href="#springboot起步依赖" class="headerlink" title="springboot起步依赖"></a>springboot起步依赖</h2><p>spring-boot-starter-parent，往里看源码，最终是spring-boot-dependency包，其中pom文件中<code>&lt;dependencyManagement&gt;</code> 是版本锁定，父工程中定义的版本信息，自己工程中就可以不写版本号。</p>
<p>spring-boot-starter-web，往里看，发现引入了spring-web、spring-webmvc。</p>
<p>总结：<br>1.在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。<br>2.在各种starter中，定义了完成该功能的坐标合集，其中大部分版本信息来自于父工程。<br>3.我们工程继承自parent，引入starter，通过依赖传递，就可以简单方便获取需要的jar包，并且不会存在版本冲突问题。</p>
<h2 id="springboot配置"><a href="#springboot配置" class="headerlink" title="springboot配置"></a>springboot配置</h2><p>配置文件分类：properties文件、yaml/yml文件。<br>profile文件，三种环境动态切换。</p>
<p>springboot基于约定，配置有默认值，替换的话，用application.properties/application.yml文件来配置。resource根目录下，application.properties/yml/yaml 文件里面放程序自动识别的内容，也可以写自己定义的内容。</p>
<p>同一级目录下，配置文件的加载顺序：properties &gt; yml &gt; yaml</p>
<p>yaml：不是一个标记语言，是直观的能被电脑识别的数据序列化格式，以数据为核心，比xml更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xml:</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">yml:</span><br><span class="line">server:</span><br><span class="line">    port: 8080</span><br><span class="line"></span><br><span class="line">properties:</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure>

<p>yaml语法：大小写敏感、数据值前必须有空格（至少一个）、缩进表示层级关系，缩进空格个数不重要，但要左对齐、#注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line"></span><br><span class="line">person:</span><br><span class="line">  name: liu</span><br><span class="line">  address: [beijing, shanghai]</span><br><span class="line"></span><br><span class="line">msg1: &quot;hello \n world&quot;  #双引号识别转义字符</span><br><span class="line">msg2: &#x27;hello \n world&#x27;  #单引号原样输出</span><br><span class="line"></span><br><span class="line">参数引用：$&#123;name&#125;</span><br></pre></td></tr></table></figure>


<p>读取配置文件内容：</p>
<p>1.@Value方法，单个属性注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;person.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;person.address[0]&#125;&quot;)</span><br><span class="line">private String address;</span><br></pre></td></tr></table></figure>

<p>2.Environment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;    </span><br><span class="line"></span><br><span class="line">env.getProperty(&quot;person.name&quot;)</span><br></pre></td></tr></table></figure>

<p>3.@ConfigurationProperties，对象和配置的绑定</p>
<p>在实体类Person上加注解 <code>@ConfigurationProperties(prefix=&quot;person&quot;)</code></p>
<hr>
<p>profile：一套程序通常需要部署在不同的环境下，开发测试生产，如果每次打包都要修改配置文件，麻烦，profile提供进行动态配置切换的方式。</p>
<p>配置方式：<br>1.多profile文件方式：提供多个配置文件，每个代表一个环境<br>application-dev.properties/yml<br>application-test.properties/yml<br>application-pro.properties/yml</p>
<p>2.yml单文件方式<br>用—分割不同环境配置</p>
<p>激活方式：<br>1.配置方式：<br><code>spring.profiles.active=dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: dev</span><br></pre></td></tr></table></figure>

<p>2.虚拟机参数<br>在VM option中输入：<code>-Dspring.profiles.active=test</code></p>
<p>3.命令行参数<br>先package打包<br><code>java -jar ...jar --spring.profiles.active=test</code></p>
<hr>
<p>打包过程中，遇到：jar中没有主清单属性</p>
<p>原因：打包后的jar文件中的MANIFEST.MF缺少项目启动项，即没有Main-Class</p>
<p>解决方案：<br>1、指定MANIFEST.MF路径<br>项目打包前：<br>第一步 file–&gt;project structure 弹框后选中Atifacts—&gt; + —-&gt;jar—-&gt;from module with dependenceis<br>第二步 选择一个Main Class，选的StartApplication文件</p>
<p>2、项目pom.xml文件中添加插件spring-boot-maven-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>内部配置加载顺序：</p>
<p>1.项目根目录下的config文件夹下<br>2.项目根目录（idea点project files的根目录）下<br>3.classPath（resource目录下）的config文件夹下<br>4.classPath（resource目录下）下</p>
<p>前两个不会打进jar包里</p>
<hr>
<p>外部配置加载顺序：</p>
<p>1.命令行指定端口号：<code>java -jar spring-boot-study-api-1.0-SNAPSHOT.jar --server.port=8086</code><br>指定默认前缀路径：<code>--server.servlet.context-path=/default</code><br>2.指定外部配置文件路径：<code>--spring.config.location=路径</code><br>3.在jar包同目录下（target文件夹下），加一个配置文件<code>application.properties</code>，同样生效，外部配置优先生效</p>
<h2 id="springboot整合其他框架"><a href="#springboot整合其他框架" class="headerlink" title="springboot整合其他框架"></a>springboot整合其他框架</h2><h3 id="springboot整合Junit"><a href="#springboot整合Junit" class="headerlink" title="springboot整合Junit"></a>springboot整合Junit</h3><p>1.引入spring-boot-starter-test 起步依赖<br>2.在测试类上加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class) //springboot2不用加</span><br><span class="line">@SpringBootTest(classes = StartApplication.class) //如果与StartApplication在一个包下，可以不加括号里的</span><br></pre></td></tr></table></figure>


<h3 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h3><p>1.引入spring-boot-starter-data-redis依赖<br>2.连接本地的redis，不需要任何配置<br>3.直接用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;liu&quot;);</span><br><span class="line">Object o = redisTemplate.boundValueOps(&quot;name&quot;).get();</span><br></pre></td></tr></table></figure>
<p>4.其他ip的，需要配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>


<h3 id="spring整合mybatis"><a href="#spring整合mybatis" class="headerlink" title="spring整合mybatis"></a>spring整合mybatis</h3><p>1.引入mybatis起步依赖 <code>mybatis-spring-boot-starter</code> （不同于其他，这个是mybatis提供的，用3.0.1的有点问题，改用2.1.0），添加mysql驱动 <code>mysql-connector-java</code><br>2.配置datasource和mybatis</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:///test?serverTimezone=UTC</span><br><span class="line">    #db.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: liuxuan</span><br><span class="line">    password: jade</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>3.创建表，并编写实体类<br>4.纯注解开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from student&quot;)</span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 .xml映射文件形式开发<br>Mapper接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">@Repository</span><br><span class="line">public interface StudentXmlMapper &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.liuxuan.repository.mapper.StudentXmlMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.liuxuan.repository.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>增加mybatis配置(不在spring下)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # Mapper映射文件路径</span><br><span class="line">  mapper-locations: classpath:mapper/*Mapper.xml</span><br><span class="line">  # 包扫描</span><br><span class="line">  type-aliases-package: com.liuxuan.repository.domain</span><br></pre></td></tr></table></figure>


<h2 id="springboot原理分析"><a href="#springboot原理分析" class="headerlink" title="springboot原理分析"></a>springboot原理分析</h2><h3 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h3><p>Condition是spring4.0增加的条件判断功能，可以实现选择性地创建Bean操作。</p>
<h4 id="✅需求1-创建bean增加条件"><a href="#✅需求1-创建bean增加条件" class="headerlink" title="✅需求1:创建bean增加条件"></a>✅需求1:创建bean增加条件</h4><p>1.自定义条件类，继承Condition接口，实现matches方法，方法中进行逻辑判断，参数context可以获取上下文容器等，metadata可以获取注解属性。<br>2.判断条件，初始化bean时使用@Conditional(条件类.class)注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要加注解@Conditional：</span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @Conditional(ClassCondition.class)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">自己定义一个实现了Condition接口的类，里面实现条件判断matches方法：</span><br><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取bean：</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅需求2-用自定义注解实现动态Condition"><a href="#✅需求2-用自定义注解实现动态Condition" class="headerlink" title="✅需求2:用自定义注解实现动态Condition"></a>✅需求2:用自定义注解实现动态Condition</h4><p>定义自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Conditional(ClassCondition.class)</span><br><span class="line">public @interface ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Config中加注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">//    @Conditional(ClassCondition.class)</span><br><span class="line">    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)</span><br><span class="line">    public User user() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Condition接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassCondition implements Condition &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param context  上下文对象。用于获取环境、Ioc容器、classLoader对象</span><br><span class="line">     * @param metadata 注解元对象，可以用于获取注解定义的属性值</span><br><span class="line">     * @return boolean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        // 需求1：写创建bean的条件：导入jedis坐标后创建bean</span><br><span class="line">//        try &#123;</span><br><span class="line">//            Class cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);</span><br><span class="line">//        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//            return false;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return true;</span><br><span class="line"></span><br><span class="line">        // 需求2：通过注解属性值value指定坐标后创建bean</span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());</span><br><span class="line">        String[] value = (String[])map.get(&quot;value&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看包spring-boot-anto-configuration中，springboot已经定义好了很多condition注解，例如：@ConditionalOnClass。</p>
<hr>
<h4 id="✅切换内置服务器"><a href="#✅切换内置服务器" class="headerlink" title="✅切换内置服务器"></a>✅切换内置服务器</h4><p>spring-boot-starter-web</p>
<p>spring-boot-autoconfiguration 包的web的embedded中内置了四种服务器，包括jetty、netty、tomcat、undertom。</p>
<p>里面还有个类负责选择web服务器，原理也是用了@ConditionalOnClass注解，看导入了什么坐标来选择服务器。</p>
<p>用<exclusions> 把spring-boot-starter-web 中的 spring-boot-starter-tomcat 排除掉。再引入jetty的依赖，就会切换为jetty服务器。</exclusions></p>
<hr>
<h4 id="✅-Enable-注解"><a href="#✅-Enable-注解" class="headerlink" title="✅ @Enable*注解"></a>✅ @Enable*注解</h4><p>SpringBoot提供了很多@Enable开头的注解，用于动态启动某些功能(获取一些bean)，其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<p>看注解 @SpringBootApplication</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration --内部@Configuration可配置bean</span><br><span class="line">@EnableAutoConfiguration --重点</span><br><span class="line">@ComponentScan(   --包扫描</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication</span><br><span class="line"></span><br><span class="line">其中Enable注解下：</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">重要的是Import注解</span><br></pre></td></tr></table></figure>

<p>⚠️启动子模块的启动类，无法启动父工程的controller。</p>
<p>springboot工程不可以直接获取其他jar包中定义的bean，比如redisTemplate。</p>
<p>原因：@ComponentScan 包扫描的范围是：当前引导类所在包及其子包，其他项目配置Bean的包不在该范围内。</p>
<p>尝试：另外创建一个子模块，子模块引入另一个子模块的pom，然后尝试获取另一个子模块的bean。<br>报错：NoSuchBeanDefinitionException。</p>
<p>如何获取Bean：<br>1.在启动类上加@ComponentScan注解，扫描要引入Bean的包。<br>缺点：要写包太累赘<br>2.使用@Import注解加载要导入bean的配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value中的这些类会被spring创建并放入IOC容器中。<br>缺点：要记类的名字<br>3.对Import注解进行封装<br>自定义一个Enable注解，把Import注解封装进去，要想用这个bean的时候，直接用Enable注解就可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(UserConfig.class)</span><br><span class="line">public @interface EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除此类的AutoConfig</span><br><span class="line">//@ComponentScan(&quot;com.liuxuan.condition&quot;)</span><br><span class="line">//@Import(UserConfig.class)</span><br><span class="line">@EnableUser</span><br><span class="line">public class StartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 启动springboot应用，获取spring的ioc容器</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line"></span><br><span class="line">        // 获取bean</span><br><span class="line">        Object user = context.getBean(&quot;user&quot;);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>😊<code>@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</code></p>
<p>exclude，排除此类的AutoConfig，即禁止 SpringBoot 自动注入数据源配置。</p>
<p>DataSourceAutoConfiguration.class 会自动查找 application.yml 或者 properties 文件里的 spring.datasource.* 相关属性并自动配置单数据源「注意这里提到的单数据源」。</p>
<p>那么问题来了，排除了自动配置，Spring还怎么识别到数据库配置呢？</p>
<p>答：显然接下来就需要手动配置，如果你发现项目中存在这个排除的操作，可以在项目中搜一下Java关键字@ConfigurationProperties(“spring.datasource)，你可能会发现手动配置数据源的类。</p>
<p>再来回答为何要手动配置数据源，因为要配置多数据源，上边有提到DataSourceAutoConfiguration.class默认会帮我们自动配置单数据源，所以，如果想在项目中使用多数据源就需要排除它，手动指定多数据源。</p>
<p>@SpringBootApplication注解中exclude参数使用及原理:<br><a href="https://blog.csdn.net/csdn_20150804/article/details/116104742">https://blog.csdn.net/csdn_20150804/article/details/116104742</a></p>
<h4 id="✅-Import注解"><a href="#✅-Import注解" class="headerlink" title="✅ @Import注解"></a>✅ @Import注解</h4><p>@Enable*底层依赖@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中，@Import提供四种用法：</p>
<p>1.导入Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StartApplication上：</span><br><span class="line">@Import(User.class)</span><br><span class="line"></span><br><span class="line">StartApplication中：</span><br><span class="line">// 根据类型获取bean</span><br><span class="line">Object user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">// 获取bean名称</span><br><span class="line">Map&lt;String, User&gt; map = context.getBeansOfType(User.class);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>2.导入配置类<br>这种方式，配置类上的@Configuration注解可以不加</p>
<p>3.导入ImportSelect实现类。一般用于加载配置文件中的类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(MyImportSelector.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;&quot;com.liuxuan.condition.User&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.导入ImportBeanDefinitionRegistrar实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(&quot;beanName&quot;, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="✅-EnableAutoConfiguration注解"><a href="#✅-EnableAutoConfiguration注解" class="headerlink" title="✅@EnableAutoConfiguration注解"></a>✅@EnableAutoConfiguration注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"></span><br><span class="line">AutoConfigurationImportSelector中：</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">核心代码：getAutoConfigurationEntry</span><br><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">意思是：从spring-boot-autoconfiguration的jar包下面的META-INF/spring.factories文件中加载。</span><br><span class="line">看到这个文件中可以看到：</span><br><span class="line"> # Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">有很多配置文件类</span><br></pre></td></tr></table></figure>

<p>总结：<br>@EnableAutoConfiguration 如何实现自动配置<br>1.@EnableAutoConfiguration注解内部使用@Import({AutoConfigurationImportSelector.class}) 来加载配置类<br>2.配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当springboot应用启动时，会自动加载这些配置类，初始化bean<br>3.并不是所有的bean都会被初始化，在配置类中使用Condition来加载满足条件的bean</p>
<h4 id="✅自定义starter实现"><a href="#✅自定义starter实现" class="headerlink" title="✅自定义starter实现"></a>✅自定义starter实现</h4><p>看mybatis-spring-boot-starter如何实现：<br>1.看到mybatis-spring-boot-starter包下没什么，只有一个pom文件，里面引入mybatis-spring-boot-autoconfigure包<br>2.mybatis-spring-boot-autoconfigure包的META-INF/spring.factories文件中定义了MybatisAutoConfiguration<br>3.@EnableAutoConfiguration会自动识别到META-INF/spring.factories文件，从而识别到MybatisAutoConfiguration，模块中初始化的bean就创建出来</p>
<p>需求：自定义redis-starter，当导入redis-starter坐标时，springboot自动创建jedis的bean。</p>
<p>1.创建一个redis-autoconfiguration模块，在里面提供jedis的bean，并实现自动配置。</p>
<p>⚠️亲测，一个模块的配置了8082端口，另一个模块没配置端口，但是运行该模块的StartApplication，要用的是8082端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RedisAutoConfiguration.class:</span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class) //RedisProperties被spring识别，创建bean</span><br><span class="line">@ConditionalOnClass(Jedis.class)  //疑问：没有Jedis坐标则不配置，创建之前不是没这个Bean吗？导入坐标和有bean的关系？</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(name = &quot;jedis&quot;)  //已经定义了就不定义</span><br><span class="line">    public Jedis getJedisBean(RedisProperties redisProperties) &#123;</span><br><span class="line">        System.out.println(&quot;RedisAutoConfiguration...&quot;);</span><br><span class="line">        return new Jedis(redisProperties.getIp(), redisProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisProperties.class:</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ConfigurationProperties(prefix = &quot;redis&quot;) //与配置文件中对应</span><br><span class="line">public class RedisProperties &#123;</span><br><span class="line">    private String ip = &quot;localhost&quot;; //没提供时给默认值</span><br><span class="line">    private Integer port = 6379;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建META-INF/spring.factories文件，其中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">    com.liuxuan.redis.configuration.RedisAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>3.创建redis-starter模块，pom文件中引入redis-configuration依赖。</p>
<p>4.在另一个模块中，pom文件中引入redis-starter依赖。在StartApplication中尝试获取bean。这个模块中导入了Jedis依赖，但是并没有Jedis的bean的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br><span class="line">Jedis jedis = context.getBean(Jedis.class);</span><br><span class="line">System.out.println(jedis);</span><br><span class="line"></span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;hi&quot;);</span><br><span class="line">System.out.println(jedis.get(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>5.可以在使用的模块中进行配置redis的ip和host</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis.port=6379</span><br><span class="line">redis.ip=localhost</span><br></pre></td></tr></table></figure>

<p>总结：StartApplication上的@SpringBootApplication注解中的@EnableAutoConfiguration中的@Import({AutoConfigurationImportSelector.class})中会自动去找jar包中的META-INF/spring.factories文件，识别到需要加载的配置类，再获取配置类创建的bean，从而实现自动配置bean。</p>
<p>看spring-boot-autoconfiguration包下的data下的redis下的文件中，就定义了RedisAutoConfiguration，和上面实现类似。</p>
<h3 id="springboot监听机制"><a href="#springboot监听机制" class="headerlink" title="springboot监听机制"></a>springboot监听机制</h3><p>springboot的监听机制，其实是对java提供的事件监听机制的封装。</p>
<p>java中的事件监听机制定义了以下几个角色：<br>1.事件：Event，继承java.util.EventObject类的对象<br>2.事件源：Source，任意对象Object<br>3.监听器：Listener，实现java.util.EventListener接口的对象</p>
<p>springboot不需要这么麻烦，springboot在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<p>1 .继承这些接口，重写方法，并打印对应操作，@Component注册bean。</p>
<p>2 .启动发现只有后两个有打印。<br>CommandLineRunner、ApplicationRunner在项目启动后执行run方法，可以帮助做一些事情，比如：缓存预热(提前把数据库的数据加到缓存)<br>打印这两个方法的args，发现是空数组，在配置中的environment中的program arguments中添加hello world，就会返回[hello, world]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyCommandLineRunner args:&quot; + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner run...&quot;);</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner args:&quot; + Arrays.asList(args.getSourceArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 .其他两个监听器怎么用：在META-INF/spring.factories（固定的写法，工程启动时会被自动扫描到）中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">  com.liuxuan.listener.MyApplicationContextInitializer</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.liuxuan.listener.MySpringApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>MyApplicationContextInitializer的initialize方法：项目还没有准备ioc容器之前，可以检测一些资源是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationContextInitializer project start..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MySpringApplicationRunListener 报错：<code>java.lang.NoSuchMethodException: com.liuxuan.listener.MySpringApplicationRunListener.&lt;init&gt;(org.springframework.boot.SpringApplication, [Ljava.lang.String;)</code><br>表示需要一个构造方法。<br>看一下代码中提供的一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//入参SpringApplication表示项目启动时的事件源</span><br><span class="line">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123;</span><br><span class="line">    private final SpringApplication application;</span><br><span class="line">    private final String[] args;</span><br><span class="line">    private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        Iterator var3 = application.getListeners().iterator();</span><br><span class="line"></span><br><span class="line">        while(var3.hasNext()) &#123;</span><br><span class="line">            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var3.next();</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，加一个构造方法，并把@Component去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 环境对象开始准备中(还不能获取配置信息)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始准备(还没加载ioc容器)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 上下文对象开始加载(创建springboot启动的bean)...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 加载完成...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动完成开始运行...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;MySpringApplicationRunListener 项目启动失败...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看spring-boot包下的context下的event包下的一些定义好的事件Event，往里看都是继承自java的util包下的EventObject的。所以说springboot的事件监听是对java事件监听的封装。</p>
<h3 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h3><p>观察者模式：观察者和被观察者，被观察者：事件和事件源，观察者：监听器。</p>
<h4 id="✅初始化"><a href="#✅初始化" class="headerlink" title="✅初始化"></a>✅初始化</h4><p>debug一下启动类StartApplication中的<code>SpringApplication.run</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">    return (new SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个SpringApplication对象（事件源对象）。</p>
<p>SpringApplication构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">    this.sources = new LinkedHashSet();</span><br><span class="line">    this.bannerMode = Mode.CONSOLE;</span><br><span class="line">    this.logStartupInfo = true;</span><br><span class="line">    this.addCommandLineProperties = true;</span><br><span class="line">    this.addConversionService = true;</span><br><span class="line">    this.headless = true;</span><br><span class="line">    this.registerShutdownHook = true;</span><br><span class="line">    this.additionalProfiles = Collections.emptySet();</span><br><span class="line">    this.isCustomEnvironment = false;</span><br><span class="line">    this.lazyInitialization = false;</span><br><span class="line">    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    this.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));  //有没有主类</span><br><span class="line">    this.webApplicationType = WebApplicationType.deduceFromClasspath();   //是否是web环境</span><br><span class="line">    this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));  //从springfactory文件中加载initializers</span><br><span class="line">    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));  //从springfactory配置文件中加载listener（放到set集合中）</span><br><span class="line">    this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/27f0e960c09249a2b0f0b87ce9e8fe40.png"></p>
<h4 id="✅run方法"><a href="#✅run方法" class="headerlink" title="✅run方法"></a>✅run方法</h4><p>StartApplication的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    long startTime = System.nanoTime();  //监控耗时，也可以用StopWatch</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = null;  //定一个容器</span><br><span class="line">    this.configureHeadlessProperty();  //加载东西</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);  //获取RunListener</span><br><span class="line">    listeners.starting(bootstrapContext, this.mainApplicationClass);  //调用runListener的starting方法</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);  //准备环境，回调runListener的prepareEnvironment方法，环境对象Environment就有信息了</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);  //打印spring图标，可以替换banner.txt</span><br><span class="line">        context = this.createApplicationContext();  //创建ioc容器</span><br><span class="line">        context.setApplicationStartup(this.applicationStartup);</span><br><span class="line">        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  //加载ioc容器</span><br><span class="line">        // 可以看context里的beanFactory里的beanDefinitionMap，里面是真正的bean，这时还没加载bean</span><br><span class="line">        this.refreshContext(context);  //这里从配置文件里找，创建bean（耗时操作）</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);  //项目启动成功，加载成功</span><br><span class="line">        this.callRunners(context, applicationArguments);  //commandLineRunner和applicationRunner 回调执行</span><br><span class="line">    &#125; catch (Throwable var12) &#123;</span><br><span class="line">        this.handleRunFailure(context, var12, listeners);</span><br><span class="line">        throw new IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var11) &#123;</span><br><span class="line">        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>以上，通过debug源码的方式，探索了springboot启动流程，看了监听器方法在哪里执行回调。</p>
<p><img src="https://img-blog.csdnimg.cn/7991a5a5b71c4f619127a34f49bbc2c8.png"></p>
<p><img src="https://img-blog.csdnimg.cn/241dcd724eae42a092a878316a759959.png"></p>
<p><img src="https://img-blog.csdnimg.cn/a3dcdc0f1916448cb25d7fc5d4b455a8.png"></p>
<h2 id="springboot监控"><a href="#springboot监控" class="headerlink" title="springboot监控"></a>springboot监控</h2><h3 id="url方式"><a href="#url方式" class="headerlink" title="url方式"></a>url方式</h3><p>SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、配置属性 、日志信息等。</p>
<p>使用步骤</p>
<p>① 导入依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>② 访问<a href="http://localhost:8080/actuator">http://localhost:8080/actuator</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;:&#123;</span><br><span class="line">        &quot;self&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health/&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;:&#123;</span><br><span class="line">            &quot;href&quot;:&quot;http://localhost:8082/actuator/health&quot;,</span><br><span class="line">            &quot;templated&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径	描述</span><br><span class="line">/beans	描述应用程序上下文里全部的Bean，以及它们的关系</span><br><span class="line">/env	获取全部环境属性</span><br><span class="line">/env/&#123;name&#125;	根据名称获取特定的环境属性值</span><br><span class="line">/health	报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</span><br><span class="line">/info	获取应用程序的定制信息，这些信息由info打头的属性提供</span><br><span class="line">/mappings	描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</span><br><span class="line">/metrics	报告各种应用程序度量信息，比如内存用量和HTTP请求计数</span><br><span class="line">/metrics/&#123;name&#125;	报告指定名称的应用程序度量值</span><br><span class="line">/trace	提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info:</span><br><span class="line">  name: hello</span><br><span class="line">  age: 23</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  #开启健康检查的完整信息</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  #将所有的监控endPoints暴漏出来</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h3><p>监控的可视化界面，只不过需要自己再起个监控服务。</p>
<p>Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。</p>
<p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息.</p>
<p>使用步骤：</p>
<p>admin-server（监控服务）</p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 在引导类上启用监控功能@EnableAdminServer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class SpringbootAdminServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootAdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>admin-client（被监控服务）</p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>③ 配置相关信息：server地址等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定admin.server地址，server在9000端口号，相当于向server注册</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9000</span><br><span class="line">展示健康检查详细详细展示出来</span><br><span class="line">management.endpoint.health.show-details=always</span><br><span class="line">开启所有配置</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>

<p>④ 启动server和client服务，访问server<br><a href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<hr>
<p>出现问题：<br>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p>
<p>原因：当前项目没有配置DataSource相关配置。springboot自动配置时，检测到添加了mysql的依赖包，但是配置文件中却没添加数据库的相关配置。<br>该案例中：mysql依赖在父pom中引入，该子工程不用mysql。</p>
<p>解决办法：@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) 排除自动注入数据库配置</p>
<hr>
<p>不知道是不是包的版本不对，有的版本报错，有的版本运行了却没显示。<br>idea中点EndPoins就可以图形化界面的方式来监控，不用那么麻烦，</p>
<h2 id="springboot项目部署"><a href="#springboot项目部署" class="headerlink" title="springboot项目部署"></a>springboot项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<p>① jar包(官方推荐) 用内置的tomcat启动</p>
<p>② war包</p>
<h3 id="jar打包方式"><a href="#jar打包方式" class="headerlink" title="jar打包方式"></a>jar打包方式</h3><p>将当前模块打包：idea右边maven中选择要打包的模块，点lifecycle，点package。</p>
<p>打好的jar包在项目的target目录下。直接<code>java -jar .\jar包名称</code>，启动成功。</p>
<h3 id="war打包方式"><a href="#war打包方式" class="headerlink" title="war打包方式"></a>war打包方式</h3><p>pom.xml里更改打包方式：<code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>如果想改war包的名字：<code>&lt;finalName&gt;</code>标签</p>
<p>在引导类继承SpringBootServletInitializer类，并重写configure方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootDeployApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(SpringBootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，打好的war包可以被外部tomcat识别，将其放在tomcat目录下的webapps目录下，启动tomcat即可（startup.bat），浏览器访问需要加项目的包名称，因为WEB-INF文件在其之下。并且，内置项目的端口号配置就不生效了。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架@Bean注解、拦截器、监听器</title>
    <url>/2022/04/22/myblog/spring/spring%E6%A1%86%E6%9E%B6%E4%B9%8Bbean%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Bean注解"><a href="#Bean注解" class="headerlink" title="@Bean注解"></a>@Bean注解</h3><p>作用在方法上的注解，Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。(和xml配置中的bean标签的作用是一样的)</p>
<p>@Bean主要用在@Configuration注解的类中，也可以用在@Component注解的类中。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"> </span><br><span class="line">    // 使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">    // 未指定bean 的名称，默认采用的是方法名的配置方式</span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean buildMyBean()&#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class MyBean &#123;</span><br><span class="line"> </span><br><span class="line">    public MyBean()&#123;</span><br><span class="line">        System.out.println(&quot;MyBean Initializing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个测试类SpringBeanApplicationTests，测试上述代码的正确性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringBeanApplicationTests &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        context.getBean(&quot;buildMyBean&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Bean的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value：bean别名和name是相互依赖关联的，value,name如果都使用的话值必须要一致；</span><br><span class="line"></span><br><span class="line">name：bean名称，如果不写会默认为注解的方法名称；</span><br><span class="line"></span><br><span class="line">autowire：自定装配默认是不开启的，建议尽量不要开启，因为自动装配不能装配基本数据类型、字符串、数组等，这是自动装配设计的局限性，并且自动装配不如依赖注入精确；</span><br><span class="line"></span><br><span class="line">initMethod：bean的初始化之前的执行方法，该参数一般不怎么用，因为完全可以在代码中实现；</span><br><span class="line"></span><br><span class="line">destroyMethod：默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法，如果你不想执行该方法，则添加@Bean(destroyMethod=&quot;&quot;)来防止出发销毁方法；</span><br></pre></td></tr></table></figure>

<p>Spring中的@Bean注解：<a href="https://blog.csdn.net/weixin_36380516/article/details/119194065">https://blog.csdn.net/weixin_36380516/article/details/119194065</a></p>
<h3 id="Bean和-Component"><a href="#Bean和-Component" class="headerlink" title="@Bean和@Component"></a>@Bean和@Component</h3><ul>
<li>@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</li>
<li>@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</li>
</ul>
<p>相同点：两者的结果都是为spring容器注册Bean.<br>不同点：@Component 通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。<br>　　　　@Bean 注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</p>
<blockquote>
<p>@Component （@Controller @Service @Respository）作用于类上，只有在我们的SpringBoot应用程序启用了组件扫描并且包含了被注解的类时才有效。通过组件扫描，Spring将扫描整个类路径，并将所有@Component注释类添加到Spring Context，这里有的不足就是会把整个类当成bean注册到spring 容器上，如果这个类中并不是所有方法都需要注册为bean的话，会出现不需要的方法都注册成为bean，这时候必须确保这些不需要的方法也能注册为bean或者在扫描中加filter 过滤这些不需要的bean,否者spring将无法成功启动。</p>
</blockquote>
<blockquote>
<p>@Bean相对来说就更加灵活了，它可以独立加在方法上，按需注册到spring容器，而且如果你要用到第三方类库里面某个方法的时候（或者类？），你就只能用@Bean把这个方法注册到spring容器，因为用@Component你需要配置组件扫描到这个第三方类路径而且还要在别人源代码加上这个注解，很明显是不现实的。</p>
</blockquote>
<p>❤️当我们引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现<br>总结：@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。特别是二方库或三方库的类装配为bean，只能用@Bean。</p>
<h3 id="实现FactoryBean接口"><a href="#实现FactoryBean接口" class="headerlink" title="实现FactoryBean接口"></a>实现FactoryBean接口</h3><p>org.springframework.beans.factory中</p>
<p>FactoryBean是一个工厂Bean，可以生成某一个类型Bean实例，它最大的一个作用是：可以让我们自定义Bean的创建过程。BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //返回的对象实例</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    //Bean的类型</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    //true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FactoryBean中定义了一个Spring Bean的很重要的三个特性：是否单例、Bean类型、Bean实例。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//FactoryBean接口的实现类</span><br><span class="line">@Component</span><br><span class="line">public class FactoryBeanLearn implements FactoryBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject() throws Exception &#123;</span><br><span class="line">        //这个Bean是我们自己new的，这里我们就可以控制Bean的创建过程了</span><br><span class="line">        return new FactoryBeanServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return FactoryBeanService.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接口</span><br><span class="line">public interface FactoryBeanService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试FactoryBean</span><br><span class="line">     */</span><br><span class="line">    void testFactoryBean();</span><br><span class="line">&#125;</span><br><span class="line">//实现类</span><br><span class="line">public class FactoryBeanServiceImpl implements FactoryBeanService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 测试FactoryBean</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void testFactoryBean() &#123;</span><br><span class="line">        System.out.println(&quot;我是FactoryBean的一个测试类。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//单测</span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">        ClassPathXmlApplicationContext cac = new ClassPathXmlApplicationContext(&quot;classpath:com/zkn/spring/learn/base/applicationContext.xml&quot;);</span><br><span class="line">        FactoryBeanService beanService = cac.getBean(FactoryBeanService.class);</span><br><span class="line">        beanService.testFactoryBean();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>❤️FactoryBean是自定义了一种注入Bean的方法，在类中没有加注解，也没有xml中配置，但是实现FactoryBean接口，重写getObject方法来返回对象，表示注入了bean，重写getObjectType表示获取bean时bean的类型。然后就可以通过getBean(类型.class)获取bean实例了。<br>至于，如何通过ApplicationContext.getBean()，见：<a href="https://blog.csdn.net/zknxx/article/details/79572387">https://blog.csdn.net/zknxx/article/details/79572387</a></p>
<h3 id="ApplicationContextAware接口"><a href="#ApplicationContextAware接口" class="headerlink" title="ApplicationContextAware接口"></a>ApplicationContextAware接口</h3><p>org.springframework.context中</p>
<p>当一个类实现了这个接口之后，这个类就可以方便的获得ApplicationContext对象（spring上下文），Spring发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContext（参数）方法，调用该方法时，会将容器本身ApplicationContext对象作为参数传递给该方法。</p>
<p>❤️之前获取ApplicationContext需要加载配置文件从而创建应用上下文，但是实现了ApplicationContextAware接口，spring自动将容器本身ApplicationContext对象传递给其中的方法setApplicationContext。实现它的类，可以在类中创建私有的ApplicationContext变量，在setApplicationContext中this. = 进行传递。</p>
<p>实现ApplicationContextAware接口可以方便获取ApplicationContext，即spring容器，获取容器之后就可以方便获取bean。</p>
<p>例子：<br>获取一个排序工厂：</p>
<p>排序接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Sort &#123;</span><br><span class="line">    SortType getSortType();</span><br><span class="line">    int[] sorting(int[] sourceArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序算法实现接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SelectionSort implements Sort &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public SortType getSortType() &#123;</span><br><span class="line">        return SortType.SELECTION;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int[] sorting(int[] sourceArray) &#123;</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> </span><br><span class="line">        // 总共要经过 N-1 轮比较</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"> </span><br><span class="line">            // 每轮需要比较的次数 N-i</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">            if (i != min) &#123;</span><br><span class="line">                int temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举排序类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum SortType &#123;</span><br><span class="line">    SELECTION,</span><br><span class="line">    BUBBLE,</span><br><span class="line">    INSERT,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序工厂，实现 ApplicationContextAware 接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SortFactory implements ApplicationContextAware &#123;</span><br><span class="line">    private static Map&lt;SortType, Sort&gt; sortBeanMap = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        Map&lt;String, Sort&gt; map = applicationContext.getBeansOfType(Sort.class);</span><br><span class="line">        map.forEach((key, value) -&gt; sortBeanMap.put(value.getSortType(), value));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int[] sorting(SortType sortType, int[] sourceArray) &#123;</span><br><span class="line">        Sort sort = sortBeanMap.get(sortType);</span><br><span class="line">        return sort.sorting(sourceArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class SortController &#123;</span><br><span class="line"> </span><br><span class="line">    private final SortFactory sortFactory;</span><br><span class="line"> </span><br><span class="line">    public SortController(SortFactory sortFactory) &#123;</span><br><span class="line">        this.sortFactory = sortFactory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostMapping(value = &quot;factory/sort&quot;)</span><br><span class="line">    public Object sortFactory(SortType sortType, int[] sourceArr) &#123;</span><br><span class="line">        return sortFactory.sorting(sortType, sourceArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自：<a href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<h3 id="InitialzingBean接口"><a href="#InitialzingBean接口" class="headerlink" title="InitialzingBean接口"></a>InitialzingBean接口</h3><p>当一个类实现这个接口之后，Spring启动后，初始化Bean时，若该Bean实现InitialzingBean接口，会自动调用afterPropertiesSet()方法，完成一些用户自定义的初始化操作。</p>
<p>同样配置Bean的时候使用init-method也可以实现类似的操作。（不需要实现InitialzingBean接口）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id = &quot;springBeanInit02&quot; class = &quot;com.lyj.studySpringBoot.init.SpringBeanInit&quot; init-method=&quot;testInit&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;#&#123;1111111&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;$&#123;test.springEL&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;#&#123;10+8&#125;&quot; /&gt; // SpringEL表达式</span><br><span class="line">	&lt;property name=&quot;sex&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">系统是先调用afterPropertiesSet方法，然后在调用init-method中指定的方法。</span><br></pre></td></tr></table></figure>

<p>Spring是通过反射来调用init-method指定方法，而实现InitializingBean接口是直接调用afterPropertiesSet方法，所以后者效率高，但使用init-method方式减少了对Spring的依赖。</p>
<p>参考：<a href="https://blog.csdn.net/qq_40093255/article/details/117318760">https://blog.csdn.net/qq_40093255/article/details/117318760</a></p>
<h3 id="MethodInterceptor接口-拦截器"><a href="#MethodInterceptor接口-拦截器" class="headerlink" title="MethodInterceptor接口-拦截器"></a>MethodInterceptor接口-拦截器</h3><p>org.aopalliance.intercept中<br>MethodInterceptor接口继承了Interceptor接口，Intercepto接口又继承了Advice接口，因此我个将这拦截器称为一个通知。</p>
<p>实现MethodInterceptor 接口，在调用目标对象的方法时，就可以实现在调用方法之前、调用方法过程中、调用方法之后对其进行控制。</p>
<p>拦截器就像是建立了一个通知。用切面做增强一样。</p>
<p>简单的例子：<a href="https://blog.csdn.net/u012834750/article/details/71773887">https://blog.csdn.net/u012834750/article/details/71773887</a><br>1.实现接口重写invoke方法，做增强<br>2.写一个简单方法<br>3.测试中，用代理工厂设置代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestMethodInterceptor  &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 初始化一个代理工厂</span><br><span class="line">        ProxyFactory proxyFactory=new ProxyFactory();</span><br><span class="line"></span><br><span class="line">        // 设置目标类，以便于Cglib工具包动态生成目标类的子类，即我们所需的代理类</span><br><span class="line">        // 最好把实现类单独写，这里设置的是实现类（业务）</span><br><span class="line">        proxyFactory.setTarget(new TestMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        // 设置拦截器，而拦截器的&quot;public Object invoke(MethodInvocation mi)&quot;定义了代理类（实际是UserDaoImpl的子类）的方法生成策略。</span><br><span class="line">        proxyFactory.addAdvice(new adviseMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        // 获取代理类</span><br><span class="line">        Object proxy = proxyFactory.getProxy();</span><br><span class="line">         // 向上转型，转型为父类类型</span><br><span class="line">        TestMethodInterceptor methodInterceptor = (TestMethodInterceptor) proxy;</span><br><span class="line"></span><br><span class="line">        methodInterceptor.doSomeThing(&quot;通过代理工厂设置代理对象，拦截代理方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class adviseMethodInterceptor implements MethodInterceptor&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">            Object result=null;</span><br><span class="line">            try&#123;</span><br><span class="line">                System.out.println(&quot;方法执行之前：&quot;+methodInvocation.getMethod().toString());</span><br><span class="line"></span><br><span class="line">                result= methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;方法执行之后：&quot;+methodInvocation.getMethod().toString());</span><br><span class="line">                System.out.println(&quot;方法正常运行结果：&quot;+result);</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line"></span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                System.out.println(&quot;方法出现异常:&quot;+e.toString());</span><br><span class="line">                System.out.println(&quot;方法运行Exception结果：&quot;+result);</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String doSomeThing(String someThing)&#123;</span><br><span class="line"></span><br><span class="line">        //int i=5/0;</span><br><span class="line">        return &quot;执行被拦截的方法：&quot;+someThing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AOP都是基于（Cglib）代理模式实现的，其中的关键点在于实现MethodInterceptor接口，在其“public Object invoke(MethodInvocation mi)”方法中制定代理方法的生成策略，而从此方法的MethodInvocation类型参数mi中可以获得目标对象、目标方法、方法的参数等信息，根据这些信息可以精确地控制增强效果。</p>
<p>invoke方法的传参是MethodInvocation，表示方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取方法名</span><br><span class="line">String methodName = mi.getMethod().getName();</span><br><span class="line">if (methodName.startsWith(&quot;add&quot;))</span><br><span class="line"></span><br><span class="line">// 执行目标方法</span><br><span class="line">result= methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">// 获取方法参数</span><br><span class="line">Object[] args = methodInvocation.getArguments();</span><br></pre></td></tr></table></figure>

<p>另一个比较复杂的例子：<br><a href="https://www.cnblogs.com/gocode/p/aop-in-spring.html">https://www.cnblogs.com/gocode/p/aop-in-spring.html</a></p>
<p>❤️总结：拦截器，可以以动态代理的方式执行方法，另一个作用是创建一个切面，具体的通知在invoke中加，传入参数可以获取目标对象、方法、方法参数，从而选择对不同切入点进行不同的通知/增强。也可以不加通知，只是proceed执行本方法。</p>
<h3 id="ApplicationListener接口-监听器"><a href="#ApplicationListener接口-监听器" class="headerlink" title="ApplicationListener接口-监听器"></a>ApplicationListener接口-监听器</h3><p>ApplicationContext事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理。</p>
<p>如果容器中有一个ApplicationListener Bean，每当ApplicationContext发布ApplicationEvent时，ApplicationListener Bean将自动被触发。这种事件机制都必须需要程序显示publish的触发。</p>
<p>事件可以自定义、监听也可以自定义，完全根据自己的业务逻辑来处理。</p>
<p>1.定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EmailEvent extends ApplicationEvent&#123;</span><br><span class="line">　　 private String address;</span><br><span class="line">　　 private String text;</span><br><span class="line">　　 public EmailEvent(Object source, String address, String text)&#123;</span><br><span class="line">　　 super(source);</span><br><span class="line">　　　　　 this.address = address;</span><br><span class="line">　　　　　 this.text = text;</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 public EmailEvent(Object source) &#123;</span><br><span class="line">　　　　　super(source);</span><br><span class="line">　　 &#125;</span><br><span class="line">　　 //......address和text的setter、getter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.监听事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EmailNotifier implements ApplicationListener&#123;</span><br><span class="line">    // 监听后事件处理的方法，可以对事件做一些判断</span><br><span class="line">　　 public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">　　　　　if (event instanceof EmailEvent) &#123;</span><br><span class="line">　　　　　　　 EmailEvent emailEvent = (EmailEvent)event;</span><br><span class="line">　　　　　　　 System.out.println(&quot;邮件地址：&quot; + emailEvent.getAddress());</span><br><span class="line">　　　　　　　 System.our.println(&quot;邮件内容：&quot; + emailEvent.getText());</span><br><span class="line">　　　　　&#125; else &#123;</span><br><span class="line">　　　　　　　 System.our.println(&quot;容器本身事件：&quot; + event);</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.触发事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringTest &#123;</span><br><span class="line">　　 public static void main(String args[])&#123;</span><br><span class="line">　　　　　ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">　　　　　//创建一个ApplicationEvent对象</span><br><span class="line">　　　　　EmailEvent event = new EmailEvent(&quot;hello&quot;,&quot;abc@163.com&quot;,&quot;This is a test&quot;);</span><br><span class="line">　　　　　//主动触发该事件</span><br><span class="line">　　　　　context.publishEvent(event);</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在拦截器中做增强触发。</p>
<p>不管是内置监听还是外部自定义监听一定要把实现ApplicationListener的类定义成一个bean才行，可以是通过注解@Component等也可以通过xml的方式去执行。</p>
<p>监听器实现类实现的ApplicationListener接口中，可以加范型，事件类型。</p>
<h3 id="接口防刷"><a href="#接口防刷" class="headerlink" title="接口防刷"></a>接口防刷</h3><p>写一个通用类用redis锁来实现，需要前段传一个东西来表示redis的key：<br><a href="https://blog.csdn.net/qq_32871365/article/details/122113652">https://blog.csdn.net/qq_32871365/article/details/122113652</a></p>
<p>在前段访问前，先从后端申请一个token，然后拿这tocken访问，后端校验tocken：<br><a href="https://blog.csdn.net/weixin_42071874/article/details/90402099">https://blog.csdn.net/weixin_42071874/article/details/90402099</a></p>
<p>自定义注解+redis+拦截器的方法：<br><a href="https://blog.csdn.net/weixin_40918145/article/details/108734614">https://blog.csdn.net/weixin_40918145/article/details/108734614</a><br><a href="https://blog.csdn.net/qq_45637260/article/details/127692497">https://blog.csdn.net/qq_45637260/article/details/127692497</a><br>1.写一个自定义注解传可访问次数<br>2.写一个拦截器，获取自定义注解，并且获取HttpServletRequest，从中获取ip，然后redis记录访问次数<br>3.配置拦截器WebMvcConfigurerAdapter<br>4.controller接口方法上加自定义注解</p>
<p>同样是以ip为维度，拦截器/aop：<br><a href="https://www.jb51.net/article/205093.htm">https://www.jb51.net/article/205093.htm</a></p>
<p>自定义注解：切面aop：<br><a href="https://blog.csdn.net/qq_34033209/article/details/118601590">https://blog.csdn.net/qq_34033209/article/details/118601590</a></p>
<p>tocken：<a href="https://www.cnblogs.com/LilLazy/p/14708539.html">https://www.cnblogs.com/LilLazy/p/14708539.html</a></p>
]]></content>
      <categories>
        <category>spring理解</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring B站学习笔记</title>
    <url>/2022/01/12/myblog/spring/Spring%20b%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><p>理念：IOC（inversion of control）AOP（aspect oriented programming）控制反转、面向切面编程。</p>
<p>1 、JavaBean：一种java语言写成的可重用组件，更多是一种规范，可以被其它的程序员或者框架使用，包含一组set和get方法的java对象，可以使应用程序更加面向对象，把数据封装起来，把应用的业务逻辑和显示逻辑分开，降低了开发的复杂性和维护成本。</p>
<p>2.pojo：plain ordinary java object，简单的java对象，那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。不允许有业务方法，也不能携带connection之类的方法，实际就是普通JavaBeans。</p>
<p>pojo类和Bean均用于定义Java对象，以提高其可读性和可重用性。pojo没有其他限制，而bean是具有某些限制的特殊pojo。</p>
<p>SpringBean是受Spring管理的对象，所有能受Spring容器管理的对象都可以成为SpringBean。Spring中的bean，是通过配置文件、javaconfig等的设置，由Spring自动实例化，用完后自动销毁的对象。</p>
<p>3.entity： Entity Bean是域模型对象，用于实现O/R映射，负责将数据库中的表记录映射为内存中的Entity对象，事实上，创建一个Entity Bean对象相当于新建一条记录，删除一个 Entity Bean会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。</p>
<h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>里面装的是java对象，像一个农贸市场。</p>
<p>不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交给spring框架来管理。</p>
<p>以往的思想是：若要使用某个对象，自己去负责对象的创建。</p>
<p>反转的思想：若要使用某个对象，只需要从spring容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了spring框架。</p>
<p>具体例子：要做一个青椒肉丝，原本是需要种青椒和养猪的，而有了spring，只需要去农贸市场买青椒和猪肉，就可以。</p>
<p>spring官网：<a href="https://spring.io/">https://spring.io</a></p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>maven仓库：<a href="https://mvnrepository.com/">https://mvnrepository.com</a></p>
<p>release稳定版本。 </p>
<h3 id="spring框架概念"><a href="#spring框架概念" class="headerlink" title="spring框架概念"></a>spring框架概念</h3><p>spring是一个轻量级的开源的JavaEE框架。</p>
<p>轻量级：体积比较小，里面的jar包比较少。解决企业应用开发的复杂性。</p>
<p>spring有两个核心内容：IOC控制反转，原始需要new个类来创建对象，而ioc将创建对象的过程交给spring。AOP面向切面，程序中扩展个功能，原始需要修改源代码来实现，而spring不需要修改代码进行功能增强。当然还有事务、mvc等操作。</p>
<p>spring框架的相关特点：1.方便解耦，简化开发，ioc创建对象包括调用通过spring实现，使得耦合度降低。2.Aop编程支持。3.方便程序测试。4.方便集成各种优秀框架：hibernate、struts、mybatis。5.降低javaEE API的使用：jdbc等。6.方便进行事务操作。</p>
<p>下载官网：spring.io，后跟GA的是稳定版本。</p>
<p><a href="https://repo.spring.io/ui/native/release/org/springframework/spring/">https://repo.spring.io/ui/native/release/org/springframework/spring/</a> 5.2.6版本。下载spring-5.2.6.RELEASE-dist.zip。docs文件夹下是一些文档、libs是一些jar包、schema是一些配置文件。jar包中每一种都有三个：jar包、文档、源代码。</p>
<h3 id="spring5模块"><a href="#spring5模块" class="headerlink" title="spring5模块"></a>spring5模块</h3><p>从下往上</p>
<p>test相关测试</p>
<p>Core Container：包含beans、core（前两个对应IOC）、context、expression。基本功能至少要有这四个jar包。commons-logging包日志相关的jar包。</p>
<p>再往上是Aop，再往上是数据访问部分和网络部分。</p>
<h3 id="导入jar包，ioc-xml案例"><a href="#导入jar包，ioc-xml案例" class="headerlink" title="导入jar包，ioc+xml案例"></a>导入jar包，ioc+xml案例</h3><p>不用maven的情况下，工程下新建lib文件夹，将要用的jar包（只要jar包）复制到这个目录下，再在file-project structure中，选择module，加+号导入相关的jar包。</p>
<p>探究ioc，创建一个普通的类，类内创建一个普通的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通的创建对象是通过new来实现，用spring创建对象，可以通过配置文件做到，可以通过注解做到。</p>
<p>因此，创建spring配置文件，在配置文件中配置创建的对象。<br>（1）spring配置文件使用xml格式，bean1.xml，用bean标签进行配置，id是别名，class是类路径+名字。（导了包才可以新建xml时出现spring config）</p>
<blockquote>
<p>Create project from template 是是否创建模板的意思，会多一些内容。</p>
<p>打包jar包：<a href="https://blog.csdn.net/weixin_45760579/article/details/114777280">https://blog.csdn.net/weixin_45760579/article/details/114777280</a></p>
<p>如何获取jar包，<a href="https://mvnrepository.com/">https://mvnrepository.com</a> 搜索即可</p>
</blockquote>
<p>在src文件夹下创建xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-配置User对象创建--&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.company.User&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（2）进行测试代码编写，加载spring配置文件，获取配置创建的对象。</p>
<p>com.company下创建testdemo包，包下新建TestXML类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXML</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7d4472b3d6674ef698ade89c5bf40865.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><h3 id="IOC容器-1"><a href="#IOC容器-1" class="headerlink" title="IOC容器"></a>IOC容器</h3><p>控制反转，是面向对象编程的一种设计原则，降低代码耦合度。通过控制反转，对象在被创建时，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它，也叫依赖注入DI。</p>
<p>通俗：创建对象，原始方法new对象，IOC把对象的创建和对象之间的调用过程都交给Spring进行管理。使用IOC来使得耦合度降低。</p>
<p>两种方式进行Bean管理：1.基于xml配置文件  2.基于注解方式</p>
<h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>（1）xml解析、工厂模式、反射</p>
<p>原始方式：一个类内调用另一个类的方法，需要在类A中创建一个类B的对象，再通过类B的对象调用类B的方法。这样做的缺点：耦合度太高，类B的路径和方法如果改变的话，类A也要跟着该，不利于程序扩展。</p>
<p>工厂模式进行解耦合：除了类A和类B，还新建一个工厂类，里面public static方法中：return new B()； 返回类B的对象，因此在类A中调用类B的方法时，调用工厂类的方法来创建类B的对象，然后调用类B的方法。降低类A和类B之间的耦合度。总结来说，通过工厂类来创建对象，实现解耦。</p>
<p>（2）IOC过程：xml解析、工厂模式、反射</p>
<p>第一步：xml配置文件，配置创建的对象</p>
<p><code>&lt;bean id=&quot;dao&quot; class=&quot;UserDao&quot;&gt;&lt;/bean&gt; </code></p>
<p>第二步：有service类（A类）和dao类（B类），创建工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title">getDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String classValue = <span class="class"><span class="keyword">class</span>属性值</span>; <span class="comment">//1.xml解析，多种方式，可以用dom4j实现</span></span><br><span class="line">      	Class clazz = Class.forName(classValue); <span class="comment">//2.用反射技术创建对象，得到类的字节码文件</span></span><br><span class="line">      	<span class="keyword">return</span> (UserDao)clazz.newInstance();  <span class="comment">//3.得到对象，强转一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步解耦，例如当dao类路径改了，这里不需要修改service类，只需要修改配置文件里的类路径。</p>
<h3 id="IOC接口（BeanFactory）"><a href="#IOC接口（BeanFactory）" class="headerlink" title="IOC接口（BeanFactory）"></a>IOC接口（BeanFactory）</h3><p>IOC是一个容器，思想中基于容器来完成，容器本质上就是<strong>对象工厂</strong>，在里面可以读取配置文件，通过反射创建对象。因此，IOC思想基于IOC容器，IOC容器，底层本质是对象工厂。</p>
<p>工厂需要实例化，Spring提供IOC容器实现的两种方式，也就是两个重要的接口：都能实现加载配置文件，通过工厂创建对象。</p>
<p>（1）BeanFactory：IOC容器基本实现，Spring里面内部的使用接口，一般开发人员不使用。<br>*加载配置文件时不会创建对象，在获取对象（使用）时才去创建对象。</p>
<p>（2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用。<br>*加载配置文件时就会把配置文件对象进行创建</p>
<p>这两种，哪种更好，虽然第一种节约资源，但是一般spring框架结合web项目，用tomcat进行启动，因此耗时好资源的工作都在服务器启动时进行操作。</p>
<hr>
<p>ApplicationContext接口有不同的实现类（control+h打开，）</p>
<p>例如：一个文件路径，一个类路径。</p>
<p><img src="https://img-blog.csdnimg.cn/c9c28cbc9a81449ea73c442cf5b4e847.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="IOC操作Bean管理（基于XML）"><a href="#IOC操作Bean管理（基于XML）" class="headerlink" title="IOC操作Bean管理（基于XML）"></a>IOC操作Bean管理（基于XML）</h3><p> 什么是Bean管理？：1.Spring创建对象，2.用Spring注入属性（创建对象时向变量设置值，最普通的话用set方法设置值，但是现在用spring做到）</p>
<p>（1）基于xml方式创建对象</p>
<p>做法：在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建。<code>&lt;bean id=&quot;dao&quot; class=&quot;UserDao&quot;&gt;&lt;/bean&gt;</code></p>
<p>在bean标签中有很多属性：<br>*id属性：给对象取一个别名，唯一标识<br>*class属性：类全路径（包含路径）<br>*name属性：和id一样作用，id属性中不能加特殊符号，name属性中可以加特殊符号，name属性比较早期，用得少。</p>
<p>Xml创建对象时，默认执行无参数的构造方法完成对象创建。因此，如果类里创建了有参构造但是没有声明无参构造，就会报错。</p>
<blockquote>
<p>IDEA为一个类创建构造方法、set方法、get方法快捷键：alt+insert（Windows）command+n（Mac）</p>
</blockquote>
<p>（2）基于xml方式注入属性</p>
<p>DI：依赖注入，就是注入属性。</p>
<p>&lt;1&gt;第一种注入属性方式：使用set方法进行注入。</p>
<p>首先在类中定义属性，并定义对应的set方法，一个属性对应一个set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBname</span><span class="params">(String bname)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(bname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次在spring配置文件中配置对象创建，配置属性注入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property完成属性注入</span></span><br><span class="line"><span class="comment">    	name：类里属性名称</span></span><br><span class="line"><span class="comment">    	value：向属性注入的值</span></span><br><span class="line"><span class="comment">    	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;西游记&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后写一个测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXML</span> </span>&#123;</span><br><span class="line">  <span class="comment">//一个类下就行</span></span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//ApplicationContext也可以换为BeanFactory</span></span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        Book book = context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        book.testDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;第二种注入属性方式：有参构造进行注入</p>
<p>首先在类中定义属性，并定义有参构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String mname;</span><br><span class="line">		<span class="keyword">private</span> String mauthor;</span><br><span class="line">		<span class="comment">//有参构造</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Music</span><span class="params">(String mname, String mauthor)</span></span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.mname = mname;</span><br><span class="line">				<span class="keyword">this</span>.mauthor = mauthor;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(mname+<span class="string">&quot;::&quot;</span>+mauthor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在Spring配置文件中进行配置，使用有参构造创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;music&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.Music&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用有参构造进行注入</span></span><br><span class="line"><span class="comment">    	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;倾城&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mauthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;陈奕迅&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name是使用名称，也可以使用索引值index，index=&quot;0&quot; 表示第一个参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，写一个测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMusic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">    <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//ApplicationContext也可以换为BeanFactory</span></span><br><span class="line">    <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">    Music music = context.getBean(<span class="string">&quot;music&quot;</span>, Music.class);</span><br><span class="line">    System.out.println(music);</span><br><span class="line">    music.testDemo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><h3 id="使用P名称空间注入"><a href="#使用P名称空间注入" class="headerlink" title="使用P名称空间注入"></a>使用P名称空间注入</h3><p>针对set方法进行属性注入，可以使用p名称空间注入，来简化xml配置方式。</p>
<p>第一步：添加p名称空间在配置文件中。</p>
<p><code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
<p>第二步：进行属性注入，在bean标签里进行操作</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.Book&quot;</span> <span class="attr">p:bname</span>=<span class="string">&quot;红楼梦&quot;</span> <span class="attr">p:bauthor</span>=<span class="string">&quot;曹雪芹&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IOC操作Bean管理（xml注入其他类型属性）"><a href="#IOC操作Bean管理（xml注入其他类型属性）" class="headerlink" title="IOC操作Bean管理（xml注入其他类型属性）"></a>IOC操作Bean管理（xml注入其他类型属性）</h3><p>1.字面量：不特殊的属性</p>
<p>（1）null值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;bname&quot;&gt;</span><br><span class="line">   &lt;null/&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>（2）属性值包含特殊符号</p>
<p>可以将特殊符号进行转义</p>
<p><code>&lt;property name=&quot;bname&quot; value=&quot;&amp;lt;&amp;gt;《西游记》&quot;&gt;&lt;/property&gt;</code></p>
<p>也可以把带有特殊符号内容写到CDATA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;bname&quot;&gt; </span><br><span class="line">  &lt;value&gt;&lt;![CDATA[《南京》]]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>2.注入属性-外部bean</p>
<p>web层调用service层，service调用dao层</p>
<p>（1）创建两个类service类和dao类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserService&#123;</span><br><span class="line">	public void add()&#123;</span><br><span class="line">		System.out.println(&quot;service add.....&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserDao&#123;</span><br><span class="line">	public void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在service调用dao里面的方法</p>
<p>原始方式：service中创建UserDao对象，再调用类中方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">userDao.update();</span><br></pre></td></tr></table></figure>

<p>现在：用spring的xml配置方法进行调用</p>
<p>首先配置文件中创建两个对象，然后将Dao对象注入到Service对象中。set注入或有参注入都行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserService类中创建UserDao类型属性，生成set方法</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.service.UserService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ref属性：创建userDao对象bean标签id值，完成外部bean注入</p>
<p>写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span>   <span class="comment">//单元测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        <span class="comment">//创建应用上下文，不在src下，需要路径+名称</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//ApplicationContext也可以换为BeanFactory</span></span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        System.out.println(userService);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.注入属性-内部bean和级联赋值</p>
<p>（1）一对多关系：部门和员工</p>
<p>（2）在实体之间表示一对多关系，写部门类和员工类，员工表示所属部门，使用对象类型属性进行表示。</p>
<p>（3）在spring配置文件中进行配置</p>
<p>在emp对象创建时，有一个属性是dept，可以用ref外部bean的方式，也可以用内部bean的方式。相当于是嵌套bean了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--内部bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;研发部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）测试方法</p>
<p>4.注入属性–级联赋值</p>
<p>级联赋值指的是一个类内有其他类的对象作为属性，可以用外部bean的方法ref，也可以内部bean的方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;测试部门&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出测试部门，而不是财务部。</p>
<h3 id="IOC操作Bean管理（xml注入集合属性）"><a href="#IOC操作Bean管理（xml注入集合属性）" class="headerlink" title="IOC操作Bean管理（xml注入集合属性）"></a>IOC操作Bean管理（xml注入集合属性）</h3><p>1.注入数组类型属性，注入List集合类型属性，注入Map集合类型属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 数组类型属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] course;</span><br><span class="line">    <span class="comment">//2 list集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line">    <span class="comment">//3 map集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt;maps;</span><br><span class="line">    <span class="comment">//4 set集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt;sets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourse</span><span class="params">(String[] course)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.course = course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lists = lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在spring配置文件进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 集合类型属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;course&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组如果直接输出，不是值，而是地址值，需要Arrays.toString()</p>
</blockquote>
<p>3.集合中设置对象类型值</p>
<p> bean配置中，创建多个course对象，然后用ref注入到stu对象的集合属性中。</p>
<p>注意：这里Course类中没有重写toString类的话，输出clist中的值是对象地址，只有重写Course类中的toString方法，输出才能是对象中的各种属性值。</p>
<p>4.把集合注入部分提取出来作为公共部分</p>
<p>（1）在Spring配置文件中引入名称空间util</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）提取list集合属性注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提取list集合属性注入,多个bean都可使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;stulist&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>课程1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>课程2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用公共list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lists&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;stulist&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IOC操作Bean管理（FactoryBean）"><a href="#IOC操作Bean管理（FactoryBean）" class="headerlink" title="IOC操作Bean管理（FactoryBean）"></a>IOC操作Bean管理（FactoryBean）</h3><p>1.Spring中有两种类型bean，一种普通bean，另外一种FactoryBean。</p>
<p>2.普通bean，在配置文件中定义bean类型就是返回类型。</p>
<p>3.工厂bean：在配置文件定义bean类型可以和返回类型不一样。</p>
<p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p>
<p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型。</p>
<h3 id="IOC操作Bean管理（Bean的作用域）"><a href="#IOC操作Bean管理（Bean的作用域）" class="headerlink" title="IOC操作Bean管理（Bean的作用域）"></a>IOC操作Bean管理（Bean的作用域）</h3><p>1.在Spring中，可以设置创建bean实例是单实例还是多实例。</p>
<blockquote>
<p>所谓单例就是所有的请求都用一个对象来处理，比如我们常用的service和dao层的对象通常都是单例的，而多例则指每个请求用一个新的对象来处理，比如action;</p>
</blockquote>
<p>2.在Spring中，默认情况下，创建的bean是单实例对象。</p>
<p>测试类中创建多个对象，输出地址，可以发现多个对象的地址相同。也就是多个请求用一个对象处理。</p>
<p>3.如何设置单实例还是多实例</p>
<p>（1）在spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例</p>
<p>（2）scope属性值：默认值singleton，表示单实例对象。prototype，表示多实例对象。</p>
<p>其他不常用的：<br>request表示一次请求<br>session表示一次会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.company.bean.Emp&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>再看多个对象的地址，不一样，多实例对象。</p>
<p>（3）singleton和prototype区别</p>
<p>第一 singleton单实例  prototype多实例</p>
<p>第二 singleton在加载spring配置文件时就会创建单实例对象，prototype不是在加载spring配置文件时创建对象，而是在调用getBean方法时创建多实例对象。</p>
<h3 id="IOC操作Bean管理（bean生命周期）"><a href="#IOC操作Bean管理（bean生命周期）" class="headerlink" title="IOC操作Bean管理（bean生命周期）"></a>IOC操作Bean管理（bean生命周期）</h3><p>1.生命周期：从对象创建到对象销毁的过程</p>
<p>2.bean生命周期</p>
<p>（1）通过构造器创建bean实例（xml调用无参构造）<br>（2）为bean中的属性设置值和对其他bean引用（调用set方法）<br>（3）调用bean的初始化方法（需要进行配置）<br>（4）bean可以使用（对象获取到）<br>（5）当容器关闭时，调用bean的销毁方法（需要进行配置）</p>
<p>3.演示bean生命周期：见程序order相关</p>
<p>4.加上bean的后置处理器：bean的生命周期有七步。</p>
<p>第三步之前：把bean实例传递bean后置处理器的方法before</p>
<p>第三步之后：把bean实例传递bean后置处理器的方法after</p>
<p>创建类实现BeanPostProcessor接口，创建后置处理器。配置文件中进行配置。</p>
<h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><h3 id="IOC操作Bean管理（xml自动装配）"><a href="#IOC操作Bean管理（xml自动装配）" class="headerlink" title="IOC操作Bean管理（xml自动装配）"></a>IOC操作Bean管理（xml自动装配）</h3><p>1.什么是自动装配？<br>property注入属性，name-value值，这是手动装配。根据指定装配规则（属性名称或者属性类型），spring自动将匹配的属性值进行注入。</p>
<p>2.演示自动装配<br>外部bean手动装配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;deport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;deport&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Deport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自动装配：bean标签属性autowire，配置自动装配，autowire属性常用两个值：byName根据属性名称注入（注入值bean的id值和类属性名字一样），byType根据属性类型注入（相同类型的bean不能定义多个，不然会报错）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.company.autowire.Deport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IOC操作Bean管理（外部属性文件）"><a href="#IOC操作Bean管理（外部属性文件）" class="headerlink" title="IOC操作Bean管理（外部属性文件）"></a>IOC操作Bean管理（外部属性文件）</h3><p>如果一个类的属性很多，需要很多property，并且类发生变化时，需要修改xml配置文件，改起来麻烦。将固定的值放在外部文件中。场景应用在操作数据库中，数据库的值放在property文件中，引用进来，进行读取。</p>
<p>1.直接配置数据库信息</p>
<p>（1）配置德鲁伊druid连接池</p>
<p>（2）引入德鲁伊连接池依赖jar包</p>
<p><a href="https://mvnrepository.com/artifact/com.alibaba/druid/1.1.9%EF%BC%88%E6%89%BE%E5%88%B0durid1.9%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%AF%BC%E5%85%A5lib%EF%BC%89">https://mvnrepository.com/artifact/com.alibaba/druid/1.1.9（找到durid1.9下载，导入lib）</a></p>
<p>（3）配置文件中进行配置（bean10），几个属性：驱动名称、数据库地址、用户、密码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>2.引入外部属性文件配置数据库连接池</p>
<p>（1）创建外部属性文件，properties格式文件，写数据库信息。等号左边的名字可以随便写。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/userDb</span></span><br><span class="line"><span class="meta">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">prop.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>（2）把外部properties属性文件引入到spring配置文件中。</p>
<p>第一步：引入context名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：在spring配置文件中使用标签引入外部属性文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部属性文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span>   <span class="comment">&lt;!--文件在本地写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是基于xml方式进行bean管理，最重要的：创建对象、注入属性</p>
</blockquote>
<h3 id="IOC操作Bean管理（基于注解方式）"><a href="#IOC操作Bean管理（基于注解方式）" class="headerlink" title="IOC操作Bean管理（基于注解方式）"></a>IOC操作Bean管理（基于注解方式）</h3><p>1.什么是注解？<br>注解是代码中特殊的标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)<br>注解可以作用在类上面，方法上面，属性上面。<br>使用注解的原因：为了简化xml配置</p>
<p>2.Spring针对Bean管理中创建对象提供注解</p>
<p>（1）@Component</p>
<p>（2）@Service：业务逻辑层service层</p>
<p>（3）@Controller：web层</p>
<p>（4）@Repository：dao持久层</p>
<p>*上面的四个注解功能是一样的，都可以用来创建bean实例，可以不同层混用的。</p>
<p>3.基于注解方式实现对象创建</p>
<p>重新搞一个工程。</p>
<p>第一步：引入依赖，aop。</p>
<p>第二步：开启组件扫描，看有没有注解，扫描哪个包中的哪个类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.dao,com.company.service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三步：创建类，在类上添加创建对象的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">//类似于&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;, value属性可以省略，默认为类名首字母小写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestZhujie</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZhujie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext con = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        UserService userService = con.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class); <span class="comment">//打后面的，然后.var会出现前面的匹配类型</span></span><br><span class="line">        System.out.println(userService);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.上面是扫描一个包下的所有类，也可以不扫描所有类</p>
<p>示例1 ：<br><code>user-default-filters=&quot;false&quot; </code>表示现在不使用默认filter，自己配置filter。<br><code>context:include-filter</code>，设置扫描哪些内容，<code>type=&quot;annotation&quot;</code>根据注解来扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.dao,com.company.service&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只扫描<code>@component</code>注解的类。</p>
<p>示例2：<br><code>context：exclude-filter</code> 设置哪些内容不扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.dao,com.company.service&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.基于注解方式实现属性注入</p>
<p>（1）@Autowired：根据属性类型进行自动装配</p>
<p>第一步：把service和dao对象都创建，也就是在类上都添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDapImpt</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao add ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在service中注入dao对象，在service内的dao对象属性上添加注入属性注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">//类似于&lt;bean id=&quot;&quot; class=&quot;&quot;/, value属性可以省略，默认为类名首字母小写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userdao;  <span class="comment">//UserDao是接口也可以啊</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add ......&quot;</span>);</span><br><span class="line">        userdao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*Autowired标注了UserDao类型的，根据类型自动找到它的实现类</p>
<p>（2）@Qualifier：根据属性名称进行注入</p>
<p>需要个上面的@Autowired一起进行使用。和上面的bytype自动注入类似，如果一个接口有不同实现类，就会有多个可匹配的，这时需要根据名称（@component括号里的value）进行装配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span>  <span class="comment">//类似于&lt;bean id=&quot;&quot; class=&quot;&quot;/, value属性可以省略，默认为类名首字母小写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;hh&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userdao;  <span class="comment">//UserDao是接口也可以啊</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add ......&quot;</span>);</span><br><span class="line">        userdao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）@Resource：可以根据类型注入，也可以根据名称注入</p>
<p>直接@Resource是根据类型，@Resource(name=”hh”)根据名称。</p>
<p>Resource是java扩展包javax中的，上面两个是spring中的。</p>
<p>（4）@Value：注入普通类型属性</p>
<p>上面三个都是注入对象类型数据，这个注入普通类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;liu&quot;)</span>  <span class="comment">//liu注入到sname中，相当于xml的property</span></span><br><span class="line"><span class="keyword">private</span> String sname;</span><br></pre></td></tr></table></figure>

<p>6.完全注解开发</p>
<p>使用注解方式管理Bean的目的是，简化xml配置，目前只有一行开启组件扫描，其他的都用注解来替代。</p>
<p>（1）创建配置类，替代xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.company&quot;&#125;)</span>  <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写测试方法，除了第一步加载配置类不同，其他都一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZhujie2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext con = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);  <span class="comment">//加载配置类</span></span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    UserService userService = con.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class); <span class="comment">//打后面的，然后.var会出现前面的匹配类型</span></span><br><span class="line">    System.out.println(userService);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种开发，在实际开发中用springboot，springboot本质上还是spring，对spring做了简化开发。</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><h3 id="AOP-基本概念"><a href="#AOP-基本概念" class="headerlink" title="AOP 基本概念"></a>AOP 基本概念</h3><p>什么是AOP：面向切面编程，是OOP延续，可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发的效率。</p>
<p>例如：在用户登录功能基础上添加功能–权限判断</p>
<p>原始方式：修改源代码实现 if else</p>
<p>AOP：不通过修改源代码方式在主干功能里添加新功能，将权限判断模块通过配置方式添加。</p>
<h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><p>AOP底层使用动态代理</p>
<p>有两种情况的动态代理：</p>
<p>第一种：有接口情况，使用JDK动态代理</p>
<p>定义UserDao接口，定义一个UserDaoImpl实现类，类内重写登录函数实现登录功能。第一步，创建UserDao接口实现类代理对象，通过代理对象增强类的方法。</p>
<p>第二种：没有接口情况，使用CGLIB动态代理</p>
<p>有一个User类，可以定义一个子类来继承User类，重写方法扩展功能增强逻辑。CGLIB动态代理：创建一个当前类之类的代理对象，增强类的方法。</p>
<h3 id="AOP（有接口情况JDK动态代理实现）"><a href="#AOP（有接口情况JDK动态代理实现）" class="headerlink" title="AOP（有接口情况JDK动态代理实现）"></a>AOP（有接口情况JDK动态代理实现）</h3><p>1.概念：使用JDK动态代理，使用Proxy类里面的方法创建代理对象。</p>
<p>API文档：<a href="https://www.matools.com/api/java8%EF%BC%88java.lang.reflect.Proxy%EF%BC%89">https://www.matools.com/api/java8（java.lang.reflect.Proxy）</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h)    //静态方法</span><br></pre></td></tr></table></figure>

<p>返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</p>
<p>newProxyInstance方法的三个参数：类加载器；增强方法要增强的接口实现类，支持多个接口；写个类实现InvocationHandler接口，创建代理对象，里面写增强的方法（可以写匿名内部类，也可以写个类实现这个接口）。 </p>
<p>2.编写JDK动态代理代码</p>
<p>（1）创建接口，定义方法</p>
<p>代码中的UserDao接口</p>
<p>（2）创建接口实现类，实现方法</p>
<p>代码中的UserDaoImpl类</p>
<p>（3）使用Proxy类创建接口代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: SpringAop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-27 21:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="comment">//1.函数式接口方法</span></span><br><span class="line"><span class="comment">//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//                return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">//2.外面写个类方法</span></span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        <span class="comment">//做一个强转，创建接口实现类的代理对象</span></span><br><span class="line">        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="comment">//int res = dao.add(1,2);</span></span><br><span class="line">        String res = dao.update(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line">    <span class="comment">//有参构造传递</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//可以对要增强的方法作出判断，增强哪个，用getName()方法</span></span><br><span class="line">        <span class="comment">//方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;哪个方法之前执行：&quot;</span>+method.getName()+<span class="string">&quot;；传递的参数：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法</span></span><br><span class="line">        Object res= method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;哪个方法之后执行：&quot;</span>+method.getName()+<span class="string">&quot;；传递的参数：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP-操作术语"><a href="#AOP-操作术语" class="headerlink" title="AOP-操作术语"></a>AOP-操作术语</h3><p>1.连接点</p>
<p>类中有若干方法，这些方法都可以被增强，在一个类中哪些方法可以被增强，这些方法就叫做连接点。</p>
<p>2.切入点</p>
<p>实际被真正增强的方法，叫做切入点。</p>
<p>3.通知（增强）</p>
<p>（1）实际增强的逻辑部分称为通知或是增强。</p>
<p>（2）通知有多种类型<br>*前置通知：方法之前会执行<br>*后置通知：方法之后会执行<br>*环绕通知：方法的前后都执行<br>*异常通知：方法出现异常执行<br>*最终通知：类似try-catch-finally，不管有没有异常都执行</p>
<p>4.切面</p>
<p>是动作，把通知应用到切入点的过程叫做切面。</p>
<h3 id="AOP操作-准备工作"><a href="#AOP操作-准备工作" class="headerlink" title="AOP操作-准备工作"></a>AOP操作-准备工作</h3><p>1.Spring框架中一般基于AspectJ实现AOP操作。</p>
<p>（1）什么是AspectJ？</p>
<p>*AspectJ是独立的框架，不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作。</p>
<p>2.基于AspectJ实现AOP操作</p>
<p>（1）基于xml配置文件实现</p>
<p>（2）基于注解方式实现（一般用这个）</p>
<p>3.在项目工程中引入AOP相关依赖。</p>
<p>需要添加一个aspect的依赖包。在<a href="https://mvnrepository.com中搜索aspectj、cglib、aopalliance依赖包./">https://mvnrepository.com中搜索aspectj、cglib、aopalliance依赖包。</a></p>
<p>4.切入点表达式</p>
<p>（1）切入点表达式的作用：知道对哪个类里面的哪个方法进行增强。</p>
<p>（2）语法结构：<code>execution([权限修饰符][返回类型][类全路径][方法名称][参数列表])</code></p>
<p>举例1：对com.company.dao.BookDao类里面的add进行增强<br><code>execution(* com.company.dao.BookDao.add(...))</code></p>
<p>举例2：对com.company.dao.BookDao类里面的所有进行增强<br><code>execution(* com.company.dao.BookDao.*(...))</code></p>
<p>举例3：对com.company.dao包里面所有类的所有方法进行增强<br><code>execution(* com.company.dao.*.*(...))</code></p>
<h3 id="AOP-AspectJ注解操作"><a href="#AOP-AspectJ注解操作" class="headerlink" title="AOP-AspectJ注解操作"></a>AOP-AspectJ注解操作</h3><p>1.创建类，在类中定义方法</p>
<p>创建User类</p>
<p>2.创建增强类（编写增强逻辑）</p>
<p>在增强类UserProxy中，创建方法，让不同方法代表不同通知类型。</p>
<p>3.进行通知的配置</p>
<p>（1）在spring配置文件中，开启注解扫描（可以写配置类，也可以写配置文件）首先是名称空间，再开启组件扫描</p>
<p>（2）使用注解创建User和UserProxy对象，用@Component</p>
<p>（3）在增强类上面添加注解@Aspect</p>
<p>（4）在spring配置文件中开启生成代理对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描,扫描多个包用,隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.company.aopdemo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.配置不同类型的通知</p>
<p>在增强类的里面，在作为通知方法上面添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: SpringAop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-29 21:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Before注解表示作为前置通知，切入点表达式表示增强哪个方法</span></span><br><span class="line">    <span class="meta">@Before(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知，方法之前和方法之后都执行</span></span><br><span class="line">    <span class="meta">@Around(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before around......&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();  <span class="comment">//表示执行被增强的方法，有异常处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after around......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>//after表示方法执行之后执行</strong>，最终通知，不管有没有异常</p>
<p><strong>//afterreturning表示在方法返回值之后执行</strong>，后置通知，返回通知，有异常不执行</p>
<p><strong>//如果异常了，afterReturning和环绕之后不执行</strong></p>
<p>5.相同切入点抽取，@Pointcut注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointdemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Before注解表示作为前置通知，切入点表达式表示增强哪个方法</span></span><br><span class="line"><span class="comment">//@Before(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.有多个增强类对同一个方法进行增强，可以设置增强类优先级</p>
<p>在增强类上面添加注解@Order(数字类型值)，值越小优先级越高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相同切入点抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointdemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Before注解表示作为前置通知，切入点表达式表示增强哪个方法</span></span><br><span class="line">    <span class="comment">//@Before(value=&quot;execution(* com.company.aopdemo.User.add(..))&quot;)</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person before,order1,高优先级......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><h3 id="AOP操作-基于AspectJ配置文件"><a href="#AOP操作-基于AspectJ配置文件" class="headerlink" title="AOP操作-基于AspectJ配置文件"></a>AOP操作-基于AspectJ配置文件</h3><p>创建一个基本类，再创建一个增强类，然后配置文件中用<code>&lt;bean&gt;</code>创建两个对象，再在spring配置文件中配置切入点，使用<code>&lt;aop:config&gt;</code>注解，使用切入点表达式<code>&lt;aop:pointcut ...</code>，再配置切面，配置增强作用在哪个地方。</p>
<p><img src="https://img-blog.csdnimg.cn/340e68569bac47c6b2772ec3c24a0490.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类，不需要写xml配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.company&quot;&#125;)</span>  <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass=true)</span>  <span class="comment">//代替配置切入点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate-概述和准备工作"><a href="#JDBCTemplate-概述和准备工作" class="headerlink" title="JDBCTemplate-概述和准备工作"></a>JDBCTemplate-概述和准备工作</h3><p>1.什么是JDBCTemplate？</p>
<p>Spring框架对JDBC进行封装，使用JDBCTemplate可以方便实现对数据库的操作。</p>
<p>2.准备工作</p>
<p>（1）引入相关的jar包</p>
<p>需要mysql包、druid德鲁伊包、spring中的jdbc包、spring中的tx的事务相关、spring中的orm包用来整合其他框架。</p>
<p>（2）在spring配置文件中配置数据库的连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>（3）配置JDBCTemplate对象，注入DataSource，用的set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 注入DataSource --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（4）创建service类，创建dao类，完成注入，在dao注入jdbcTemplate对象。</p>
<p>开启组件扫描，用注解创建对象，service中注入dao，dao中注入jdbcTemplate对象。</p>
<h3 id="JDBCTemplate操作数据库（添加）"><a href="#JDBCTemplate操作数据库（添加）" class="headerlink" title="JDBCTemplate操作数据库（添加）"></a>JDBCTemplate操作数据库（添加）</h3><p>1.mac安装数据库可视化工具，最终装了DataGrip，见帖子《Mac安装mysql》</p>
<p>2.建库建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uliuxuan -p</span><br><span class="line">create database b_jdbc;</span><br><span class="line">show databases;</span><br><span class="line">use b_jdbc;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `user_db`(</span><br><span class="line">   `user_id` bigint unsigned NOT NULL,</span><br><span class="line">   `username` varchar(100) NOT NULL,</span><br><span class="line">   `ustate` varchar(50) NOT NULL,</span><br><span class="line">   PRIMARY KEY(`user_id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;biao&#x27;;</span><br><span class="line"></span><br><span class="line"> CREATE TABLE `kiss_share_idproducer` (</span><br><span class="line">  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">  `app_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;产品线id&#x27;,</span><br><span class="line">  `init_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;初始化id&#x27;,</span><br><span class="line">  `max_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;当前id&#x27;,</span><br><span class="line">  `setp` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;每次分配数&#x27;,</span><br><span class="line">  `mix_id` smallint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;启用个位混淆因子&#x27;,</span><br><span class="line">  `desc` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;desc&#x27;,</span><br><span class="line">  `mtime` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_app` (`app_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;发号器&#x27;;</span><br></pre></td></tr></table></figure>

<p>3.entity包里对应数据库创建实体类</p>
<p>4.编写serveic和dao</p>
<p>（1）在dao中操作数据库添加方法</p>
<p>（2）调用JdbcTemplate对象里面update方法实现添加操作：两个参数：第一个参数是sql语句，第二个参数是可变参数，设置sql语句值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  <span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入Dao</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//使用注解方式实现注入</span></span><br><span class="line">    <span class="keyword">private</span> BookDao userDao;  <span class="comment">//使用dao中的方法得创建BookDao（接口？）的对象，疑惑：为什么是接口？？？</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userDao.add(user);  <span class="comment">//用dao里的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>  <span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入JDBCTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">//注入配置文件中的JdbcTemplate</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库添加方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建sql语句</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into user_db values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="comment">//2.调用方法实现</span></span><br><span class="line">        <span class="comment">//可变参数就是一个数组型，可以用Object</span></span><br><span class="line">        Object[] args = &#123;user.getUserId(), user.getUserName(), user.getUstate()&#125;;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, args);  <span class="comment">//update表示影响行数</span></span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.加载spring配置文件</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">        BookService service = context.getBean(<span class="string">&quot;bookService&quot;</span>, BookService.class);</span><br><span class="line">        <span class="comment">//getBean的第一个参数表示bean的名称，xml配置文件中的id，如果是注解创建，则小写第一位</span></span><br><span class="line">        <span class="comment">//新建一个User对象</span></span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setUserId(<span class="number">2</span>);</span><br><span class="line">        u.setUserName(<span class="string">&quot;lucky&quot;</span>);</span><br><span class="line">        u.setUstate(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">        <span class="comment">//调用service中的方法</span></span><br><span class="line">        service.addUser(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.发生错误：</p>
<p><code>严重: create connection SQLException, url: jdbc:mysql://localhost:3306/b_jdbc, errorCode 1251, state 08004</code></p>
<p>mysql-connector的jar包版本太低，原来是5.几，改为8.几，改过之后，需要加jc，<code>value=&quot;com.mysql.cj.jdbc.Driver</code>，以及，url后面要加时区，<code>value=&quot;jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC&quot;</code></p>
<p>后来又发生错误：<code> create connection SQLException, url: jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC, errorCode 1045, state 28000</code> 这个是因为用户名和密码都是root，连接不上。root的密码为空，是可以的连接成功的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个jdbc连接数据库的方法（通过配置文件），和《java开发入门jdbc》里面的连接数据库方法不同。</p>
</blockquote>
<h2 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h2><h3 id="JDBCTemplate操作数据库（修改、删除）"><a href="#JDBCTemplate操作数据库（修改、删除）" class="headerlink" title="JDBCTemplate操作数据库（修改、删除）"></a>JDBCTemplate操作数据库（修改、删除）</h3><p>1.首先dao接口创建两个方法，dao实现类里重写这两个方法。</p>
<p>2.service层里创建dao实现类对象，创建方法，里面调用对象的dao层方法。service和dao的方法传入必要参数，user对象或是id之类的。</p>
<p>3.重点写dao层内操作数据库的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update user_db set username=?, ustate=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> update = jdbcTemplate.update(sql, user.getUserName(), user.getUstate(), user.getUserId());</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;delete from user_db where user_id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> update = jdbcTemplate.update(sql, id);</span><br><span class="line">    System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试方法</p>
<h3 id="JDBCTemplate操作数据库（查询返回某个值）"><a href="#JDBCTemplate操作数据库（查询返回某个值）" class="headerlink" title="JDBCTemplate操作数据库（查询返回某个值）"></a>JDBCTemplate操作数据库（查询返回某个值）</h3><p>例如返回多少行数据。<code>select count(*) from user_db;</code></p>
<p>例如：查询表里有多少条记录。</p>
<p>首先写一个service方法findCount，调用dao里的方法，写dao方法。dao方法里写select语句，并返回。使用jdbc方法queryForObject(sql语句, 返回类型的class例如Integer.class)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select count(*) from user_db&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> nums = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（查询返回对象）"><a href="#JDBCTemplate操作数据库（查询返回对象）" class="headerlink" title="JDBCTemplate操作数据库（查询返回对象）"></a>JDBCTemplate操作数据库（查询返回对象）</h3><p>例如：查询用户的详情页面。</p>
<p>根据id返回一个对象，service写一个findUser方法，dao写一个find方法。dao内采用jdbc模版中的queryForObject方法，第一个参数：sql语句；第二个参数：RowMapper接口，spring提供，做到一些封装，使用这个接口里面的实现类可以完成数据的封装；第三个参数：sql语句?值。</p>
<p>第二个参数：<code>new BeanPropertyRowMapper&lt;返回类型的名字&gt;(返回类型的class)</code> 。提供好的实现类，直接用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    String sql= <span class="string">&quot;select * from user_db where user_id=?&quot;</span>;</span><br><span class="line">    User u = jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class), id);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了显示User对象，重写里面的tostring方法。</p>
<h3 id="JDBCTemplate操作数据库（查询返回集合）"><a href="#JDBCTemplate操作数据库（查询返回集合）" class="headerlink" title="JDBCTemplate操作数据库（查询返回集合）"></a>JDBCTemplate操作数据库（查询返回集合）</h3><p>场景：查询用户列表，返回一个集合。返回<code>List&lt;User&gt;</code></p>
<p> 首先service调用dao的方法，编写dao方法。dao内用query方法操作数据库。query三个参数，第一个参数sql语句；第二个参数和上面一样；第三个可有可无？参数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select * from user_db&quot;</span>;</span><br><span class="line">    List&lt;User&gt;res = jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（批量添加操作）"><a href="#JDBCTemplate操作数据库（批量添加操作）" class="headerlink" title="JDBCTemplate操作数据库（批量添加操作）"></a>JDBCTemplate操作数据库（批量添加操作）</h3><p>批量操作指操作表里的多条记录</p>
<p>批量添加，使用 jdbc的<code>batchUpdate(sql语句, List&lt;Object[]&gt;batchArgs)</code>方法。返回的是int[]类型。底层是对集合进行遍历，挨个添加。数组输出要用Arrays.toString(数组名)。</p>
<p>service层建一个batchAdd方法，传入List&lt;Object[]&gt;batchArgs。dao中创建方法，实现操作数据库，<code>insert into user_db values(?,?,?)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAdd</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;insert into user_db values(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span>[] update = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(<span class="string">&quot;影响行数：&quot;</span>+ Arrays.toString(update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（批量修改操作）"><a href="#JDBCTemplate操作数据库（批量修改操作）" class="headerlink" title="JDBCTemplate操作数据库（批量修改操作）"></a>JDBCTemplate操作数据库（批量修改操作）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdate</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update user_db set username=?,ustate=? where user_id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span>[] update = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(<span class="string">&quot;批量更新影响行数：&quot;</span>+ Arrays.toString(update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自建List</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;on&quot;</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Object[] o4 = &#123;<span class="string">&quot;c++&quot;</span>, <span class="string">&quot;off&quot;</span>, <span class="number">2</span>&#125;;</span><br><span class="line">batchArgs2.add(o3);</span><br><span class="line">batchArgs2.add(o4);</span><br><span class="line">service.batchUpdate(batchArgs2);</span><br></pre></td></tr></table></figure>

<h3 id="JDBCTemplate操作数据库（批量删除操作）"><a href="#JDBCTemplate操作数据库（批量删除操作）" class="headerlink" title="JDBCTemplate操作数据库（批量删除操作）"></a>JDBCTemplate操作数据库（批量删除操作）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchDelete</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;delete from user_db where user_id=?&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span>[] update = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    System.out.println(<span class="string">&quot;批量删除影响行数：&quot;</span>+ Arrays.toString(update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自建List</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Object[] o5= &#123;<span class="number">17</span>&#125;;</span><br><span class="line">Object[] o6 = &#123;<span class="number">18</span>&#125;;</span><br><span class="line">batchArgs3.add(o5);</span><br><span class="line">batchArgs3.add(o6);</span><br><span class="line">service.batchDelete(batchArgs3);</span><br></pre></td></tr></table></figure>

<h2 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h2><h3 id="事务操作-事务概念"><a href="#事务操作-事务概念" class="headerlink" title="事务操作-事务概念"></a>事务操作-事务概念</h3><p>1、什么是事务？</p>
<p>事务是数据库操作的最基本单元，逻辑上的一组操作，要么都成功，要么都失败。</p>
<p>2、事务的四个特性：ACID：原子性、一致性、隔离性、持久性。</p>
<h3 id="事务操作-搭建事务操作环境"><a href="#事务操作-搭建事务操作环境" class="headerlink" title="事务操作-搭建事务操作环境"></a>事务操作-搭建事务操作环境</h3><p>场景：转账环境</p>
<p>javaee有三层：web层、service业务逻辑层、dao对数据库操作层不写业务操作。</p>
<p>dao层创建两个方法：（1）少钱的方法（2）多钱的方法。</p>
<p>service层创建方法：转账方法中调用dao的两个方法。</p>
<p>1.创建数据库表，添加记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `acount`(</span><br><span class="line">   `id` int unsigned NOT NULL,</span><br><span class="line">   `username` varchar(100) NOT NULL,</span><br><span class="line">   `money` bigint NOT NULL,</span><br><span class="line">   PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;acount&#x27;;</span><br><span class="line"></span><br><span class="line">insert into acount values(1, &quot;liu&quot;, 1000);</span><br><span class="line">insert into acount values(2, &quot;hao&quot;, 1000);</span><br></pre></td></tr></table></figure>

<p>2.创建service，搭建dao，完成对象创建和注入关系。</p>
<p>service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource。</p>
<p>service类，使用注解@Service方式创建对象，@Autowired注入dao。同样在dao用@Autowired注入jdbc。</p>
<p>3.在dao中创建两个方法，多钱addMoney和少钱reduceMoney的方法，在service中创建方法，转账的方法。dao中用update方法。</p>
<p>4.测试</p>
<p>5.发现问题，如果先执行完dao中的第一个方法，发生异常，第二个方法将不执行，产生数据异常。如何解决？使用事务。</p>
<p>在service的方法中，try catch捕获异常。首先开启事务，然后进行事务操作，没有发现异常则提交事务，出现异常则事务回滚。</p>
<h3 id="事务操作-Spring事务管理介绍"><a href="#事务操作-Spring事务管理介绍" class="headerlink" title="事务操作-Spring事务管理介绍"></a>事务操作-Spring事务管理介绍</h3><p>1.事务管理加到哪个层？建议加到业务逻辑层service。</p>
<p>2.在Spring进行事务管理操作</p>
<p>（1）有两种方式：编程式事务管理和声明式事务管理（一般使用声明式）</p>
<p>编程式指的是用代码实现第一步第二步第三步。。。try catch捕获异常之类的。</p>
<p>3.声明式事务管理两种方式</p>
<p>（1）基于注解方式（使用）</p>
<p>（2）基于xml配置文件方式</p>
<p>4.在Spring进行声明式事务管理，底层使用AOP。</p>
<p>5.Spring事务管理API</p>
<p>提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类。</p>
<p>PlatformTransactionManager接口。DatasourceTransactionManager实现类针对jdbc。</p>
<h3 id="事务操作-注解声明式事务管理"><a href="#事务操作-注解声明式事务管理" class="headerlink" title="事务操作-注解声明式事务管理"></a>事务操作-注解声明式事务管理</h3><p>1.在spring配置文件中配置事务管理器。本质上就是创建PlatformTransactionManager接口实现类的对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入DataSource数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在spring配置文件中，开启事务注解</p>
<p>（1）在Spring配置文件中引入名称空间tx. <code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code></p>
<p>（2）开启事务注解</p>
<p><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;</code></p>
<p>3.在service类上面（或者service类里面的方法上面）添加注解 @Transactional</p>
<p>如果添加到类上面，表示这个类里的所有方法都添加事务。</p>
<h3 id="事务操作-声明式事务管理参数配置"><a href="#事务操作-声明式事务管理参数配置" class="headerlink" title="事务操作-声明式事务管理参数配置-"></a>事务操作-声明式事务管理参数配置-</h3><p>1.在service类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数。</p>
<p><strong>第一个参数</strong>：propagation 表示事务传播行为，多事务方法直接进行调用，这个过程中事务是如何进行管理的。</p>
<p>事务方法：对数据库表数据进行变化的操作。</p>
<p>Spring框架事务传播行为有七种，列出最常见的两种：<br>（1）required：add方法中有事务，update没有，add方法内调用update方法，则update方法使用add方法内的事务。如果add方法没有事务，调用update方法之后，add创建一个新的事务，并在事务内运行。也是默认的传播行为。</p>
<p>（2）required_new：使用add方法调用update方法，无论add方法是否有事务，add方法都会新建一个事务。</p>
<p><strong>第二个参数</strong>：ioslation 表示事务隔离级别</p>
<p>事务的隔离性：多事务操作之间不会产生影响。有三个读的问题：脏读、不可重复读、虚（幻）读。</p>
<p>脏读：多个事物之间，一个未提交的事务读取到另一个未提交的事务。例如两个人都要操作一条记录，原来1000，事务a改了这条记录，变为2000，事务b读取到事务a修改的2000，但是事务a回滚了。算是一个致命问题，不能出现。</p>
<p>不可重复读：一个未提交的事务读取到另一个提交事务修改的数据。例如，事务a读取到原数据100，事务b读取到原数据100，并将其修改为200，事务b提交，事务a读取到数据200，这样事务b对事务a产生了影响。是一种现象，不能算作问题。</p>
<p>幻读：一个未提交事务读取到另一个提交事务添加数据。</p>
<p>通过设置隔离级别可以解决上述问题。read uncommitted 读未提交；read committed 读已提交；repeatable read 可重复读（默认的）；serializable 串行化。</p>
<p><strong>第三个参数</strong>：timeout 表示事务超时时间，事务需要在一定时间内提交，超时不提交则进行回滚。默认值是 -1，不超时。设置时间是以秒为单位。</p>
<p><strong>第四个参数</strong>：readOnly 是否只读，读是查询操作，readOnly默认为false，表示可以查询可以添加修改删除，设置为true，则只能查询。</p>
<p><strong>第五个参数</strong>：rollbackFor 回滚，设置出现哪些异常进行事务回滚。</p>
<p><strong>第六个参数</strong>：noRollbackFor 不回滚，设置出现哪些异常不进行事务回滚。</p>
<h3 id="事务操作-xml声明式事务管理"><a href="#事务操作-xml声明式事务管理" class="headerlink" title="事务操作-xml声明式事务管理"></a>事务操作-xml声明式事务管理</h3><p>1.在Spring配置文件中进行配置。</p>
<p>第一步 配置事务管理器</p>
<p>第二步 配置通知，aop中增强的那部分，这里就是事务。</p>
<p>第三步 配置切入点和切面，要将事务加到哪个类的哪个方法中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.创建事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入DataSource数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启事务注解， xml方式中 不需要了</span></span><br><span class="line"><span class="comment">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务的一些相关参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定哪种规则的方法上面添加事务，例如 add* 表示add开头的添加事务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;jiaoyi&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3.配置切入点和切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;qierudiansname&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.company.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点, 将事务的通知设置到上面的切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;qierudiansname&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，事务的底层使用aop实现。</p>
<p>测试时，把注解注释掉。</p>
<h3 id="事务操作-完全注解声明式事务管理"><a href="#事务操作-完全注解声明式事务管理" class="headerlink" title="事务操作-完全注解声明式事务管理"></a>事务操作-完全注解声明式事务管理</h3><p>1.创建配置类，使用配置类替代xml配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.company&quot;)</span>  <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">//开启事务注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//配置文件中就是在ioc容器中创建一个bean实例 写方法返回一个DataSource德鲁伊连接池对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDuridDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/b_jdbc?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//创建jdbc模版对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate =<span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">        <span class="comment">//需要注入datasSurce, xml中是使用set方法进行配置注入的</span></span><br><span class="line">        <span class="comment">//set方法里面如果用上面的getDuridDataSource方法，就会创建两个对象</span></span><br><span class="line">        <span class="comment">//使用参数方法，可以在ioc容器中根据类型找到对象进行注入，就像@autowired根据类型自动装配</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        DataSourceTransactionManager dataSourceTransactionManager =<span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">        dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.测试时，开启注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wanquanzhujietrans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.加载配置类</span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(TxConfig.class);</span><br><span class="line">    <span class="comment">//2.获取配置创建的对象</span></span><br><span class="line">    UserService service = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">    <span class="comment">//getBean的第一个参数表示bean的名称，xml配置文件中的id，如果是注解创建，则小写第一位</span></span><br><span class="line">    service.jiaoyi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，用springboot进行开发，替代spring基础上的完全注解开发，springboot是对spring做的封装。</p>
<h2 id="总结-amp-amp-未完"><a href="#总结-amp-amp-未完" class="headerlink" title="总结&amp;&amp;未完"></a>总结&amp;&amp;未完</h2><p>1.Spring框架概述</p>
<p>（1）轻量级开源JavaEE框架，为了解决企业复杂性。两个核心组成部分：ioc、aop。</p>
<p>（2）Spring5.2.6版本</p>
<p>2.IOC容器</p>
<p>（1）IOC底层原理：xml配置文件、工厂、反射等</p>
<p>（2）IOC接口（BeanFactory）</p>
<p>（3）bean管理操作：基于xml进行对象创建注入属性；基于注解进行对象创建注入属性</p>
<p>3.AOP</p>
<p>（1）AOP底层原理：动态代理，有接口（JDK动态代理），没有接口（CGLIB动态代理）</p>
<p>（2）术语：切入点、增强（通知）、切面</p>
<p>（3）基于AspectJ实现AOP操作：基于注解方式；基于配置文件</p>
<p>4.JdbcTemplate</p>
<p>（1）使用JdbcTemplate对数据库的curd操作</p>
<p>（2）使用JdbcTemplate实现数据库批量操作</p>
<p>5.事务操作</p>
<p>（1）事务概念</p>
<p>（2）重要概念（传播行为和隔离级别）</p>
<p>（3）基于注解实现声明式事务管理</p>
<p>（4）基于xml配置文件实现事务管理</p>
<p>（5）完全注解方式实现事务管理</p>
<p>6.Spring5新特性：</p>
<p>（1）整合日志框架</p>
<p>（2）@Nullable注解</p>
<p>（3）函数式注册对象</p>
<p>（4）整合JUnit5单元测试框架</p>
<p>（5）SpringWebflux使用</p>
<p><a href="https://www.bilibili.com/video/BV1Vf4y127N5?p=49&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Vf4y127N5?p=49&amp;spm_id_from=pageDriver</a></p>
<h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p>b_study中。</p>
<p>xml：基于xml配置文件实现控制反转，管理bean对象，创建对象，依赖注入（注入属性）。</p>
<p>zhujie：基于注解的bean管理。</p>
<p>aop：面向切面编程</p>
<p>jdbc：操作数据库</p>
<p>transaction：事务相关</p>
<hr>
<p><em><strong>学习笔记，侵权请联系，一定立刻删除。</strong></em></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring实战》笔记</title>
    <url>/2021/12/23/myblog/spring/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="springboot在idea的RunDashboard如何显示出来"><a href="#springboot在idea的RunDashboard如何显示出来" class="headerlink" title="springboot在idea的RunDashboard如何显示出来"></a>springboot在idea的RunDashboard如何显示出来</h3><p>运用spring cloud框架基于spring boot构建微服务，一般需要启动多个应用程序，在idea开发工具中，多个同时启动的应用需要在RunDashboard运行仪表盘中可以更好的管理，但有时候idea中的RunDashboard窗口没有显示出来，也找不到直接的开启按钮。</p>
<p>选择Edit Configurations，在运行配置窗口，选择一条springboot的运行配置，然后点击上方的复制按钮进行复制副本，复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示，点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run configurations in Run Dashboard，在Run Dashboard中可以看到当前所有的启动配置，直接点击可以方便的启动和停止。</p>
<p>以上方法还没有显示出来的话，则可以通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口。</p>
<p>打开workspace.xml文件之后，找到component为RunDashboard的节点处，然后在component标签里添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;option name=&quot;configurationTypes&quot;&gt;</span><br><span class="line">   &lt;set&gt;</span><br><span class="line">​    &lt;option value=&quot;SpringBootApplicationConfigurationType&quot; /&gt;</span><br><span class="line">   &lt;/set&gt;</span><br><span class="line">  &lt;/option&gt;</span><br></pre></td></tr></table></figure>

<p>最后保存即可，保存完成之后立即自动弹出Run Dashboard窗口了。</p>
<h3 id="Taco商店"><a href="#Taco商店" class="headerlink" title="Taco商店"></a>Taco商店</h3><p>路径、领域类、控制器、控制器返回的是表单。控制器也可重定向到另一个路径。每个控制器类处理一个路径，一个路径可以处理get、post，一次可以有不同的方法。表单post请求到控制器。</p>
<p>目前的领域类：taco、order、ingredient</p>
<p>控制类：designcontrol、ordercontrol</p>
<p>表单：home、design、order</p>
<h3 id="第二章调试"><a href="#第二章调试" class="headerlink" title="第二章调试"></a>第二章调试</h3><p>1.只有home，只显示主页。</p>
<p>2.有design，显示design页面，没有表单验证，配料是自己写的，点了submit错误了，405 Request method ‘POST’ not supported。</p>
<p>3.加post方法，重定向（跳转）到订单处理控制器，显示order页面，注意ordercontrol里也是一个get一个post。</p>
<p>4.添加表单验证，两个领域类添加规则，两个控制类的post提交表单方法进行验证，两个表单也要做相应变化，加span。（不加@ModelAttribute(“design”) 是错的，只是designcontrol，另外，空白框旁的true/false不知道哪来的，）。</p>
<p>5.使用视图控制器，删除homecontrol，修改homecontroltest。</p>
<h3 id="第三章中"><a href="#第三章中" class="headerlink" title="第三章中"></a>第三章中</h3><p>两个方法3.1和3.2是并列的，可以用这个两种方法，JDBC和JPA，JPA比JDBC简单。</p>
<p>3.1中，ingredient库插入数据比较简单，只插入一个库，但是taco和order比较难，都有两个库要插入，插入一个库之后需要获得一个id才能插入第二个库，3.1.4具体持久化方法中提供了两种方法，第二种比第一种简单。</p>
<p>对于ingredient，需要预插入数据。</p>
<p>对designcontrol、ordercontrol的修改，第一在于构造方法将数据库注入到控制器中，第二在于post方法提交表单需要将数据存入数据库。</p>
<p>其中涉及到session，用于保存在会话中的 order 属性，并且可以<strong>跨多个请求使用</strong>。因为存入order数据库的数据里有taco相关的数据，需要session暂存一下。</p>
<h3 id="第三章第一节JDBC调试"><a href="#第三章第一节JDBC调试" class="headerlink" title="第三章第一节JDBC调试"></a>第三章第一节JDBC调试</h3><p><code>lsof -i:8080</code>查看端口占用   关闭进程 <code>kill pid</code></p>
<p>1.为领域类taco、order添加id和日期。</p>
<p>2.pom.xml里添加jdbc、h2依赖</p>
<p>3.关于ingredient的改变：data文件夹下ingredientrepo接口和jdbcingredientrepo类，类下find方法和save方法。改造DesignTacoController的构造方法和showDesignForm，将固定配料改为从数据库中读取配料。</p>
<p>4.写表，预加载数据，schema.sql  data.sql</p>
<p>5.设置TacoRepository、OrderRepository接口</p>
<p>6.关于taco，jdbc实现的JdbcTacoRepository类。designtacocontrol中持久化的过程，构造函数为post方法添加一个参数。改造post函数，添加持久化到数据库的过程。还要一个taco和order方法。order领域类内添加一个adddesign方法。</p>
<p>7.关于order的改变，使用SimpleJdbcInsert方法，实现JdbcOrderRepository类，ordercontrol中的持久化过程，构造函数和post函数做改变。</p>
<h3 id="错误记录1"><a href="#错误记录1" class="headerlink" title="错误记录1"></a>错误记录1</h3><p>错误输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">&#x27;debug&#x27;</span> enabled.</span><br><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">13</span>:<span class="number">46</span>:<span class="number">56.526</span> ERROR <span class="number">1306</span> --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed</span><br></pre></td></tr></table></figure>

<p>这个问题是因为在pom文件里面加入了mybatis（某）模块 却没有在config配置里面增加mybatis（它）的上下文导致启动报错的<br>starting ApplicationContext. To display the conditions report re-run your application with ‘debug’ enabled（这句话其实已经说得很明白了 在启动的时候 上下文错误 导致启动失败）<br>在配置文件里面加上mybatis的配置就行了</p>
<p>但是不知道说的配置文件是什么，尝试注释掉不用的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>没用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;jdbcIngredientRepository&#x27;</span><br></pre></td></tr></table></figure>

<p> 这个问题一般是mapper里面的SQL语句写错了。可能是本来select，却写成了insert</p>
<p>找了半天，原来是schema.sql文件中语句的错误。</p>
<p>干！！！是因为复制过来有无效空格，没显示错误。</p>
<h3 id="错误记录2"><a href="#错误记录2" class="headerlink" title="错误记录2"></a>错误记录2</h3><p>也不知哪一步有问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">12</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">40</span>:<span class="number">36.800</span> ERROR <span class="number">1822</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">6</span>] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.NullPointerException: <span class="keyword">null</span></span><br><span class="line">	at tacos.data.JdbcTacoRepository.saveTacoInfo(JdbcTacoRepository.java:<span class="number">51</span>) ~[classes/:na]</span><br><span class="line">	at tacos.data.JdbcTacoRepository.save(JdbcTacoRepository.java:<span class="number">28</span>) ~[classes/:na]</span><br></pre></td></tr></table></figure>

<p>在提交taco的时候，就会有500错误。</p>
<p>表单html文件就需要修改的，tomorrow看下表单做啥变化了。再换一下外面的文件，看是不是就能正常。</p>
<p>只是有一个design变成了taco，从数据库中拿配料种类，难道表单不需要连接数据库或者是控制器吗？？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to convert property value of type java.lang.String to required type java.util.List for property ingredients; nested exception is java.lang.IllegalStateException: Cannot convert value of type java.lang.String to required type tacos.Ingredient for property ingredients[0]: no matching editors or conversion strategy found</span><br><span class="line"></span><br><span class="line">将java.lang.String类型的属性值转换为所需类型java.util.List属性成分失败;java.lang.IllegalStateException:不能转换java.lang.String类型的值到所需类型tacos。属性成分[0]的成分:没有找到匹配的编辑器或转换策略</span><br></pre></td></tr></table></figure>

<p>1.designcontrol和ordercontrol两个控制器，需要加session，<code>@SessionAttributes(&quot;order&quot;)</code></p>
<p>2.原来的pom.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Taco Cloud Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xml-apis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xml-apis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.04<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.bytebuddy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>byte-buddy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>替换了视图控制器、表单、pom文件，才变对的。</p>
<h3 id="第三章第二节JPA调试"><a href="#第三章第二节JPA调试" class="headerlink" title="第三章第二节JPA调试"></a>第三章第二节JPA调试</h3><p>1.在pom.xml中添加依赖starter<br>疑问：add … to classpath 是什么意思，往pom里添加依赖吗？</p>
<p>问题：</p>
<p><img src="https://img-blog.csdnimg.cn/4da10c38ab5a41329f7d2cebdc2e1e93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><code>Dependency &#39;org.springframework.boot:spring-boot-starter-data-jpa:2.6.1&#39; not found </code></p>
<p>案例中的代码无configuration。<code>错误: 找不到或无法加载主类 tacos.TacoCloudApplication</code></p>
<p>2.库接口定义</p>
<p>3.可自动实现，可自定义实现</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU缓存实现</title>
    <url>/2021/08/19/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LFU%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="LFU-缓存"><a href="#LFU-缓存" class="headerlink" title="LFU 缓存"></a>LFU 缓存</h3><p>回顾一下LRU：最近最久未使用。实现时采用双向链表+哈希表使得每次查询O1复杂度，哈希表中（key，双向链表节点（value）），查到之后，双向链表可以实现快速的删除操作，以及双向链表实现队列的效果。哈希就是为了get(key）快一些，而双向链表是为了put(key,value)的时候，调整顺序，以及满的时候淘汰，双向链表中存的只是value。</p>
<p>最不经常使用LFU：缓存满了之后，需要删除使用频率最小的内存，并且如果使用频率相同，需要删除插入时间最早的。</p>
<p>实现 LFUCache 类：<br>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象<br>int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。<br>void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。</p>
<p>实现：双向链表+哈希表，原则：内存标记即key是唯一的，所以第一个哈希map：key–双向链表节点，第二个map：使用次数–第一次使用的节点</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>用链表顺序记录是用最少的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get：查询</span></span><br><span class="line"><span class="comment">put：插入、删除</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">哈希表，维护 key，node</span></span><br><span class="line"><span class="comment">哈希表，维护 cnt，firstnode  //cnt是使用次数，firstnode是最久未使用的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于多个节点的cnt可能相同，因此记录每个cnt的最前方元素节点，保证最久不用的节点依次位于后方</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表node&lt;cnt, value&gt;</span></span><br><span class="line"><span class="comment">其中，cnt需要降序排列，</span></span><br><span class="line"><span class="comment">- 有新的key时，插入到cnt=1的最前面，保证最后一位是“最不常用&amp;&amp;cnt=1中最久没使用“的。</span></span><br><span class="line"><span class="comment">更新 cnt，node，firstnode</span></span><br><span class="line"><span class="comment">- 删除时，删除cnt最小的，即，最后一位</span></span><br><span class="line"><span class="comment">更新 cnt，node，firstnode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line">	list&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; nodeList; <span class="comment">//node&lt;cnt, value, key&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator&gt; keyNodeMap;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator&gt; cntFirstNodeMap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印 list 和 map</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllData</span><span class="params">(string action)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = nodeList.<span class="built_in">begin</span>(); it != nodeList.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			<span class="keyword">auto</span> vec = *it;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#125;,  &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = keyNodeMap.<span class="built_in">begin</span>(); it != keyNodeMap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			<span class="keyword">int</span> key = it-&gt;first;</span><br><span class="line">			<span class="keyword">auto</span> vec = *(it-&gt;second);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#125;,  &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = cntFirstNodeMap.<span class="built_in">begin</span>(); it != cntFirstNodeMap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = it-&gt;first;</span><br><span class="line">			<span class="keyword">auto</span> vec = *(it-&gt;second);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;cnt: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#125;,  &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!keyNodeMap.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">auto</span> currNode = keyNodeMap[key];</span><br><span class="line">		<span class="keyword">int</span> currCnt = (*currNode)[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> value = (*currNode)[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">auto</span> firstNode = cntFirstNodeMap[currCnt];</span><br><span class="line">		<span class="keyword">int</span> newCnt = currCnt + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//若newCnt已存在，则放到全部newCnt之前，否在放到全部currCnt之前</span></span><br><span class="line">		<span class="keyword">if</span> (cntFirstNodeMap.<span class="built_in">count</span>(newCnt)) &#123; firstNode = cntFirstNodeMap[newCnt]; &#125;</span><br><span class="line">		<span class="comment">//更新list：插入</span></span><br><span class="line">		<span class="keyword">auto</span> newNode = nodeList.<span class="built_in">insert</span>(firstNode, &#123; newCnt, value, key &#125;);</span><br><span class="line">		<span class="comment">//更新keyNodeMap：替换</span></span><br><span class="line">		keyNodeMap[key] = newNode;</span><br><span class="line">		<span class="comment">//新的cnt，更新cntFirstNodeMap：替换</span></span><br><span class="line">		cntFirstNodeMap[newCnt] = newNode;</span><br><span class="line">		<span class="comment">//老的cnt，更新cntFirstNodeMap：若恰好为currNode，则更新or删除，否则不用动</span></span><br><span class="line">		<span class="keyword">if</span> (cntFirstNodeMap[currCnt] == currNode) &#123;</span><br><span class="line">			<span class="keyword">auto</span> it = currNode;</span><br><span class="line">			it++;</span><br><span class="line">			<span class="keyword">if</span> (it == nodeList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				cntFirstNodeMap.<span class="built_in">erase</span>(currCnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((*it)[<span class="number">0</span>] == currCnt) &#123;</span><br><span class="line">				cntFirstNodeMap[currCnt] = it;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//cnt变了，说明currCnt下，已经没有任何节点了</span></span><br><span class="line">				cntFirstNodeMap.<span class="built_in">erase</span>(currCnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新list：删除</span></span><br><span class="line">		nodeList.<span class="built_in">erase</span>(currNode);</span><br><span class="line">		<span class="comment">//printAllData(&quot;get&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">			(*keyNodeMap[key])[<span class="number">1</span>] = value;</span><br><span class="line">			<span class="comment">//printAllData(&quot;put(update)&quot;);</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//溢出删除</span></span><br><span class="line">		<span class="keyword">if</span> (nodeList.<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">			<span class="keyword">auto</span> lastNode = --nodeList.<span class="built_in">end</span>();</span><br><span class="line">			<span class="keyword">int</span> cnt = (*lastNode)[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> value = (*lastNode)[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> key = (*lastNode)[<span class="number">2</span>];</span><br><span class="line">			<span class="comment">//keyNodeMap：删除这个key</span></span><br><span class="line">			keyNodeMap.<span class="built_in">erase</span>(key);</span><br><span class="line">			<span class="comment">//cntFirstNodeMap：相同则删除，否则不变</span></span><br><span class="line">			<span class="keyword">if</span> (cntFirstNodeMap[cnt] == lastNode) cntFirstNodeMap.<span class="built_in">erase</span>(cnt);</span><br><span class="line">			<span class="comment">//nodeList：删除链表最后一个节点</span></span><br><span class="line">			nodeList.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入到 cnt=1 的最前面</span></span><br><span class="line">		<span class="keyword">auto</span> currNode = nodeList.<span class="built_in">end</span>();</span><br><span class="line">		<span class="keyword">if</span> (cntFirstNodeMap.<span class="built_in">count</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">			currNode = cntFirstNodeMap[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> newNode = nodeList.<span class="built_in">insert</span>(currNode, &#123; <span class="number">1</span>, value, key &#125;);</span><br><span class="line">		cntFirstNodeMap[<span class="number">1</span>] = newNode;</span><br><span class="line">		keyNodeMap[key] = newNode;</span><br><span class="line">		<span class="comment">//printAllData(&quot;put(add)&quot;);</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//LFUCache a; </span></span><br><span class="line">	<span class="comment">//定义了构造函数就没有默认构造函数里，在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。用.调用方法</span></span><br><span class="line">	LFUCache *lFUCache = <span class="keyword">new</span> <span class="built_in">LFUCache</span>(<span class="number">2</span>); <span class="comment">//定义对象</span></span><br><span class="line">	<span class="comment">//通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//因为上面定义的指针对象，所以-&gt;，不是指针对象用.</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//key2对应的是1</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl;  <span class="comment">//1已经被淘汰</span></span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>或是可以维护一个最小频次，每次移除一个节点的时候，需要移除最小频次的节点，每次增加时，也需要更新节点的频次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">get：查询</span></span><br><span class="line"><span class="comment">put：插入、删除</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">哈希表，维护 key，node</span></span><br><span class="line"><span class="comment">哈希表，维护 cnt，firstnode  //cnt是使用次数，firstnode是最久未使用的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于多个节点的cnt可能相同，因此记录每个cnt的最前方元素节点，保证最久不用的节点依次位于后方</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个链表不需要相连，只是用它的节点</span></span><br><span class="line"><span class="comment">维护一个最小频次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> frenquency;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value, <span class="keyword">int</span> _frequency) :<span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">frenquency</span>(_frequency)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">		capacity = _capacity;</span><br><span class="line">		minfreq = <span class="number">0</span>;</span><br><span class="line">		frequency_table.<span class="built_in">clear</span>();</span><br><span class="line">		key_table.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">		<span class="keyword">int</span> val = node-&gt;value;</span><br><span class="line">		<span class="keyword">int</span> freq = node-&gt;frenquency;</span><br><span class="line">		<span class="comment">//删除操作</span></span><br><span class="line">		frequency_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">		<span class="keyword">if</span> (frequency_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//记录freq频率的双链表没结点了</span></span><br><span class="line">			frequency_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">			<span class="keyword">if</span> (minfreq == freq) minfreq++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//添加结点</span></span><br><span class="line">		frequency_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">		key_table[key] = frequency_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="comment">//key表中找不到值，分缓存满和不满两种情况</span></span><br><span class="line">		<span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//缓存已经满的情况</span></span><br><span class="line">			<span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> it2 = frequency_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">				key_table.<span class="built_in">erase</span>(it2.key);</span><br><span class="line">				frequency_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">				<span class="keyword">if</span> (frequency_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					frequency_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//两种情况都要添加操作，所以合并在一起</span></span><br><span class="line">			frequency_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">			key_table[key] = frequency_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			minfreq = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//如果表中存在，需要更新frequency的值</span></span><br><span class="line">			<span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">			<span class="keyword">int</span> freq = node-&gt;frenquency;</span><br><span class="line">			<span class="comment">//删除操作</span></span><br><span class="line">			frequency_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">			<span class="keyword">if</span> (frequency_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//记录freq频率的双链表没结点了</span></span><br><span class="line">				frequency_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">				<span class="keyword">if</span> (minfreq == freq) minfreq++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//添加结点</span></span><br><span class="line">			frequency_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">			key_table[key] = frequency_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> minfreq;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt;frequency_table;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt;key_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//LFUCache a; </span></span><br><span class="line">	<span class="comment">//定义了构造函数就没有默认构造函数里，在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。用.调用方法</span></span><br><span class="line">	LFUCache *lFUCache = <span class="keyword">new</span> <span class="built_in">LFUCache</span>(<span class="number">2</span>); <span class="comment">//定义对象</span></span><br><span class="line">	<span class="comment">//通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//因为上面定义的指针对象，所以-&gt;，不是指针对象用.</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//key2对应的是1</span></span><br><span class="line">	lFUCache-&gt;<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl;  <span class="comment">//1已经被淘汰</span></span><br><span class="line">	cout &lt;&lt; lFUCache-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>python语言</title>
    <url>/2022/07/03/myblog/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/python/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>✅计算机组成：<br>硬件：中央处理器CPU（处理指令、运算数据的）、存储器（内存（存临时数据读写速度快）、外存（硬盘、U盘））、输入设备、输出设备<br>软件：应用软件、系统软件（操作系统）</p>
<p>✅编译型语言和解释型语言：</p>
<ul>
<li><p>编译型语言：在执行之前要先经过编译过程，编译成为一个可执行的机器语言的文件，比如exe。因为翻译只做一遍，以后都不需要翻译，所以执行效率高。<br>  代表：C、C++<br>  优缺点：执行速度快、跨平台差（操作一步，与操作系统联系紧密）、不便调试。</p>
</li>
<li><p>解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。执行时才翻译执行。程序每执行一次就要翻译一遍。解释一句，执行一句，直至结束。<br>  代表：Java、C#、Python、JavaScript<br>  优缺点：速度较慢、跨平台好（操作两步，跨平台有优势，可在windows上运行，也可在linux上运行）、易于调试</p>
</li>
</ul>
<p>怎么选：<br>编译型语言由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言。</p>
<p>而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、MATLAB等等。</p>
<p>一个比较好的例子：编译型语言就像炒菜吃饭，只有将全部的菜炒好了才能吃饭，解释型语言就像吃火锅，边放菜边吃，不需要将菜全部放在火锅里面。</p>
<p>✅java是解释型语言，javac编译成.class字节码文件是？<br>java的编译器（javac.exe）先将java文件编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；<br>所以很多地方都说“java是一种半编译、半解释执行”的语言；</p>
<p>java是解释型的语言，因为虽然java也需要编译，编译成.class文件，<br>但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释（逐行解释为特定平台机器码），才能在各个平台执行，这同时也是java跨平台的原因。<br>所以可以说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。</p>
<p>✅编译器和解释器之间的主要区别<br>1、编译器将一个程序作为一个整体进行翻译，而解释器则一条一条地翻译一个程序<br>2、在编译器的情况下生成中间代码或目标代码。而解释器不创建中间代码<br>3、编译器比解释器要快得多，因为编译器一次完成整个程序，而解释器则是依次编译每一行代码<br>4、由于要生成目标代码，编译器比解释器需要更多的内存<br>5、编译器同时显示所有错误，很难检测错误，而解释器则逐个显示每条语句的错误，更容易检测错误<br>6、在编译器中，当程序中出现错误时，它会停止翻译，并在删除错误后重新翻译整个程序。相反，当解释器中发生错误时，它会阻止其翻译，在删除错误后，翻译将继续<br>7、在编译器中，这个过程需要两个步骤，首先将源代码翻译成目标程序，然后执行。而在解释器中，这是一个一次性的过程，源代码在编译的同时执行<br>8、编译器用于编程语言，如C、c++、c#、Scala等。解释器用于PHP、Ruby、Python等语言。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/CodeHouse/article/details/121846119">https://blog.csdn.net/CodeHouse/article/details/121846119</a></p>
<p>✅脚本语言（动态语言）和静态语言</p>
<p>脚本语言:又被称为扩建的语言，或者动态语言，用来控制软件应用程序，脚本通常以文本保存，只 在被调用时进行解释或编译。脚本语言有:PHP、Python、JavaScript、Lua、Scala、VBScript， ActionScript，MAXScript，ASP，JSP，SQL，Perl，Shell，Ruby，JavaFX，AutoIt等 脚本语言是一种解释性的语言，它不象c/c++等可以编译成二进制代码，以可执行文件的形式存在，脚本 语言不需要编译，可以直接用，由解释器来负责解释。在运行时才确定数据类型的语言。</p>
<p>静态语言:要求在使用变量之前必须声明数据类型。 例如:C、C++、Golang、Java、C#等。 </p>
<p>so：脚本语言一定是解释型语言，解释型语言不一定是脚本语言。</p>
<p>✅Python解释器：<br>CPU不能直接处理 Python 语言，只能直接处理机器指令语言，那是一种由0和1数字组成的语言。.py结尾的文件需要解释器去运行执行。解释器就是能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般偏低，但是解释器的实现较为简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。</p>
<p>常见的Python解释器：</p>
<p>　　1、CPython：这个解释器是用C语言开发的，所以叫CPython。在命令行下运行Python就是启动CPython解释器。CPython是使用最广的Python解释器。</p>
<p>2、IPython：IPython是基于CPython之上的一个交互解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p>
<p>　　3、PyPy：PyPy是另一个解释器，它的目标是执行速度。采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。</p>
<p>　　4.Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h3 id="mac安装python环境"><a href="#mac安装python环境" class="headerlink" title="mac安装python环境"></a>mac安装python环境</h3><p>终端输入python，跳出的是2.7版本<br>终端输入python3，跳出的是3.9版本<br>就没安装了，要找解析器去官网下载安装</p>
<p>终端执行.py文件：<br>1、写文件，前面要加个注释<br><code>#!/usr/bin/env python3</code><br><code>print(&quot;hello!&quot;)</code><br>2、给文件以执行权限<br><code>chmod a+x hi.py</code><br>3、运行文件<br><code>./hi.py</code></p>
<p>✅安装pycharm<br>官网下载：<a href="https://www.jetbrains.com.cn/en-us/pycharm/download">https://www.jetbrains.com.cn/en-us/pycharm/download</a><br>下载的社区版本。破解太费劲。<br>新建工程，选择解析器，不选虚拟的那个，选previously configured nterpret.<br>警告：PEP 8: W292 no newline at end of file，因为没有换行，换个行就好了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《Spring实战》</title>
    <url>/2021/12/15/myblog/spring/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B/</url>
    <content><![CDATA[<p>本书介绍如何使用Spring和Spring Boot开发基于Web、数据库作为后端的Java应用。如何与其他应用进行集成，使用反应式类型进行编程，以及将应用拆分成离散的微服务。最后如何准备应用的部署。</p>
<p>Spring5.0和Spring Boot2.0</p>
<h1 id="第一章-Spring起步"><a href="#第一章-Spring起步" class="headerlink" title="第一章 Spring起步"></a>第一章 Spring起步</h1><h2 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring"></a>什么是spring</h2><p>spring支持：面向云的由微服务组成的应用，反应式编程，致力于通过非阻塞操作提供更好的扩展性并提升性能。通过spring boot简化自己的开发模型。</p>
<p>Spring 的核心是一个 <em>容器（container）</em>，通常称为 <em>Spring 应用程序上下文</em>，用于创建和管理应用程序组件。这些组件（或 bean）在 Spring 应用程序上下文中连接在一起以构成一个完整的应用程序，就像将砖、灰浆、木材、钉子、管道和电线绑在一起以组成房屋。</p>
<p>将 bean 连接在一起的行为是基于一种称为 <em>依赖注入</em>（dependency injection，DI）的模式。组件不会再去创建它所依赖的组件并管理它们的生命周期，使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件，并将其注入到需要它们的bean中。通常通过构造函数参数或属性访问器方法完成此操作。总结：应用组件通过Spring的应用上下文来进行管理并实现互相注入。</p>
<p>距离：商品服务需要依赖于库存服务，库存服务需要注入到商品服务。</p>
<p>①从历史上看，引导 Spring 应用程序上下文将 bean 连接在一起的方式是使用一个或多个 XML 文件，这些文件描述了组件及其与其他组件的关系。例如，以下 XML 声明两个 bean，一个 <code>InventoryService bean</code> 和一个 <code>ProductService bean</code>，然后通过构造函数参数将 <code>InventoryService</code> 注入到 <code>ProductService</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;inventoryService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.example.InventoryService&quot;</span> /&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;productService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.example.ProductService&quot;</span> &gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">&quot;inventoryService&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>②但是，在最新版本的 Spring 中，基于 Java 的配置更为常见。以下基于 Java 的配置类等效于 XML 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InventoryService <span class="title">inventoryService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InventoryService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductService <span class="title">productService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductService(inventoryService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Configuration</code> 注释向 Spring 表明这是一个配置类，它将为 Spring 应用程序上下文提供 beans。 配置的类方法带有 <code>@Bean</code> 注释，指示它们返回的对象应作为 beans 添加到应用程序上下文中（默认情况下，它们各自的 bean IDs 将与定义它们的方法的名称相同）。</p>
<p>与基于 XML 的配置相比，基于 Java 的配置具有多个优点，包括更高的类型安全性和改进的可重构性。即使这样，仅当 Spring 无法自动配置组件时，才需要使用 Java 或 XML 进行显式配置。</p>
<p>③自动配置起源于 Spring 技术，即 <em>自动装配</em> 和 <em>组件扫描</em>。借助组件扫描，Spring 可以自动从应用程序的类路径中发现组件，并将其创建为 Spring 应用程序上下文中的 bean。通过自动装配，Spring 能够自动为组件注入它们所依赖的其他bean。</p>
<p>最近，随着 Spring Boot 的推出，自动配置的优势已经远远超出了组件扫描和自动装配。Spring Boot 是 Spring 框架的扩展，它提供了多项生产力增强功能。这些增强功能中最著名的就是 <em>自动配置</em>，在这种配置中，Spring Boot 可以根据类路径中的条目、环境变量和其他因素，合理地猜测需要配置哪些组件，并将它们装配在一起。</p>
<p>Spring Boot 自动配置大大减少了构建应用程序所需的显式配置（无论是 XML 还是 Java）的数量。</p>
<h2 id="初始化Spring应用程序"><a href="#初始化Spring应用程序" class="headerlink" title="初始化Spring应用程序"></a>初始化Spring应用程序</h2><p>使用 Spring、Spring Boot 以及各种相关的库和框架，创建一个在线应用程序。</p>
<p>依靠 Spring Initializr 来引导应用程序的创建。Spring Initializr 既是一个基于浏览器的 Web 应用程序，又是一个 REST API，它们可以生成一个基本的 Spring 项目结构，可以使用所需的任何功能充实自己。 使用 Spring Initializr 的几种方法如下：</p>
<p>1.从 Web 应用程序 <a href="http://start.spring.io/">http://start.spring.io</a> 创建<br>2.使用 curl 命令从命令行创建<br>3.使用 Spring Boot 命令行接口从命令行创建<br>4.使用 Spring Tool Suite 创建一个新项目的时候<br>5.使用 IntelliJ IDEA 创建一个新项目的时候<br>6.使用 NetBeans 创建一个新项目的时候</p>
<h3 id="使用Intellij-IDEA初始化项目"><a href="#使用Intellij-IDEA初始化项目" class="headerlink" title="使用Intellij IDEA初始化项目"></a>使用Intellij IDEA初始化项目</h3><p>File -&gt; new -&gt; Project -&gt; Spring Initializr -&gt; next。</p>
<p>type选Maven Project -&gt; next。（和maven的构建规范有关，Maven pom.xml）</p>
<p>展示项目依赖页，依赖是按照分类来组织的，已经选中的依赖将会在最右侧。选择依赖：devtools、lombok、web、thymeleaf -&gt; next。</p>
<p>输入项目名称和存放位置。finish</p>
<p>项目从Initializr下载并加载到工作空间中。加载和构建完成，就可以开发应用功能了。</p>
<h3 id="Spring项目目录"><a href="#Spring项目目录" class="headerlink" title="Spring项目目录"></a>Spring项目目录</h3><p>典型的Maven或Gradle项目结构，应用源码在src/main/java中，测试代码在src/test/java中，非java资源在src/main/resources。</p>
<p><code>mvnw</code> 和 <code>mvnw.cmd</code> —— 这些是 Maven 包装器脚本。即使你的计算机上没有安装 Maven，也可以使用这些脚本构建项目。</p>
<p><code>pom.xml</code> —— 这是 Maven 构建规范。</p>
<p><code>TacoCloudApplication.java</code> —— 这是引导项目的 Spring Boot 主类。稍后，我们将在这节详细介绍。</p>
<p><code>application.properties</code> —— 该文件最初为空，但提供了一个可以指定配置属性的地方。我们将在本章中对此文件进行一些修改，但在第 5 章中将详细介绍配置属性。</p>
<p><code>static</code> —— 在此文件夹中，可以放置要提供给浏览器的任何静态内容（图像、样式表、JavaScript 等），最初为空。</p>
<p><code>templates</code> —— 在此文件夹中，放置用于向浏览器呈现内容的模板文件。最初为空，但很快会添加 Thymeleaf 模板。</p>
<p><code>TacoCloudApplicationTests.java</code> —— 这是一个简单的测试类，可确保成功加载 Spring 应用程序上下文。开发应用程序时，将添加更多的测试。</p>
<h4 id="构建规范pom-xml"><a href="#构建规范pom-xml" class="headerlink" title="构建规范pom.xml"></a>构建规范pom.xml</h4><p>填写 Initializr 表单时，指定使用 Maven 构建项目。因此，Spring Initializr 给了一个 pom.xml 文件，该文件已经填充了所做的选择。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring boot插件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;</span><br><span class="line">                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                    &lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packaging&gt;</code>选择将应用程序构建为可执行的 JAR 文件，而不是 WAR 文件。毕竟，传统的 Java web 应用程序被打包为 WAR 文件，而 JAR 文件是库和偶尔使用的桌面 UI 应用程序的首选打包方式。虽然 WAR 文件非常适合部署到传统的 Java 应用服务器，但是它们并不适合大多数云平台。尽管一些云平台（如 Cloud Foundry）能够部署和运行 WAR 文件，但是所有的 Java 云平台都能够运行可执行的 JAR 文件。因此，Spring Initializr 默认为 JAR 打包。</p>
<p><code>&lt;parent&gt;</code> 元素，指定项目将 <code>spring-boot-starter-parent</code> 作为它的父 POM。除此之外，这个父 POM 还为 Spring 项目中常用的几个库提供依赖项管理。对于父 POM 覆盖的那些库，不必指定版本，因为它是从父 POM 继承的。</p>
<p><code>&lt;dependencies&gt;</code> 元素下声明了三个依赖项。前两个看起来应该比较熟悉。它们直接对应于在单击 Spring Tool Suite 新建项目向导中的 Finish 按钮之前选择的 Web 和 Thymeleaf 依赖项。第三个依赖项提供了许多有用的测试功能，你不必选中包含它的方框，因为 Spring Initializr 假定你将编写测试。</p>
<p>Spring Boot starter 依赖项的特殊之处在于，它们本身通常没有任何库代码，而是间接地引入其他库。这些 starter 依赖提供了三个主要的好处：</p>
<ul>
<li>构建的文件将会小得多，也更容易管理，因为不需要对每一个可能需要的库都声明一个依赖项。</li>
<li>可以根据它们提供的功能来考虑需要的依赖关系，而不是根据库名来考虑。如果正在开发一个 web 应用程序，那么将添加 web starter 依赖项，而不是一个编写 web 应用程序的各个库的清单。</li>
<li>不用担心 library 版本问题。可以相信的是，对于给定版本的 Spring Boot，可间接地引入的库的版本将是兼容的，只需要考虑使用的是哪个版本的 Spring Boot。</li>
</ul>
<p>最后，构建规范以 Spring Boot 插件结束。这个插件执行一些重要的功能：</p>
<ul>
<li>提供了一个 Maven 编译目标，让你能够使用 Maven 运行应用程序。</li>
<li>确保所有的依赖库都包含在可执行的 JAR 文件中，并且在运行时类路径中可用。</li>
<li>在 JAR 文件中生成一个 manifest 文件，将引导类（在本书例子中是 <code>TacoCloudApplication</code>）声明为可执行 JAR 的主类。</li>
</ul>
<h4 id="引导应用TacoCloudApplication"><a href="#引导应用TacoCloudApplication" class="headerlink" title="引导应用TacoCloudApplication"></a>引导应用TacoCloudApplication</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoCloudApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code> 注释清楚地表明这是一个 Spring 引导应用程序。<code>@SpringBootApplication</code> 是一个组合了其他三个注释的复合应用程序：</p>
<p>（1）<code>@SpringBootConfiguration</code> —— 指定这个类为配置类。尽管这个类中还没有太多配置，但是如果需要，可以将 Javabased Spring Framework 配置添加到这个类中。实际上，这个注释是<code>@Configuration</code> 注释的一种特殊形式。</p>
<p>（2）<code>@EnableAutoConfiguration</code> —— 启用 Spring 自动配置。稍后我们将详细讨论自动配置。现在，要知道这个注释告诉 Spring Boot 自动配置它认为需要的任何组件。</p>
<p>（3）<code>@ComponentScan</code> —— 启用组件扫描。这允许你声明其他带有 <code>@Component</code>、<code>@Controller</code>、<code>@Service</code> 等注释的类，以便让 Spring 自动发现它们并将它们注册为 Spring 应用程序上下文中的组件。</p>
<p><code>TacoCloudApplication</code> 的另一个重要部分是 <code>main()</code> 方法。这个方法将在执行 JAR 文件时运行。在大多数情况下，这种方法是样板代码；编写的每个 Spring 引导应用程序都有一个类似或相同的方法（尽管类名不同）。</p>
<p><code>main()</code> 方法调用 SpringApplication 类上的静态 <code>run()</code> 方法，该方法执行应用程序的实际引导，创建<code>Spring</code> 应用程序上下文。传递给 <code>run()</code> 方法的两个参数是一个配置类和命令行参数。虽然传递给 <code>run()</code> 的配置类不必与引导类相同，但这是最方便、最典型的选择。</p>
<p>你可能不需要更改引导类中的任何内容。对于简单的应用程序，你可能会发现在引导类中配置一两个其他组件很方便，但是对于大多数应用程序，最好为任何没有自动配置的东西创建一个单独的配置类。</p>
<h4 id="测试应用TacoCloudApplicationTests"><a href="#测试应用TacoCloudApplicationTests" class="headerlink" title="测试应用TacoCloudApplicationTests"></a>测试应用TacoCloudApplicationTests</h4><p>测试是软件开发的一个重要部分。认识到这一点后，Spring Initializr 提供了一个测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoCloudApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的一个测试方法是空的。尽管如此，这个测试类确实执行了必要的检查，以确保 Spring 应用程序上下文能够成功加载。如果做了任何阻止创建 Spring 应用程序上下文的更改，则此测试将失败，这样你就可以通过解决问题来应对。</p>
<p>还要注意用 <code>@RunWith(SpringRunner.class)</code> 注释的类。<code>@RunWith</code> 是一个 JUnit 注释，提供了一个测试运行器来引导 JUnit 运行测试用例。请将清单 1.3 看作是对它的基准应用程序测试，即将插件应用到 JUnit 以提供自定义测试行为。在本例中，JUnit 被赋予了 SpringRunner，这是一个由 Spring 提供的测试运行程序，它提供了创建一个 Spring 应用程序上下文的功能，以供测试运行。</p>
<p>尽管 <code>@RunWith(SpringRunner.class)</code> 和 <code>@SpringBootTest</code> 的任务是加载用于测试的 Spring 应用程序上下文，但是如果没有任何测试方法，它们将没有任何事情要做。即使没有任何断言或任何类型的代码，这个空的测试方法也会调用两个注释完成它们的工作，并加载 Spring 应用程序上下文。如果运行过程中有任何问题，测试就会失败。</p>
<h2 id="编写Spring应用程序"><a href="#编写Spring应用程序" class="headerlink" title="编写Spring应用程序"></a>编写Spring应用程序</h2><p>添加到 Taco Cloud 应用程序的第一个功能是主页，当添加主页，将创建两个代码构件：</p>
<ul>
<li>一个处理主页请求的控制器类</li>
<li>一个视图模板，定义了主页的外观</li>
</ul>
<p>因为测试很重要，所以还将编写一个简单的测试类来测试主页。但首先…来写这个控制器。</p>
<h3 id="处理web请求"><a href="#处理web请求" class="headerlink" title="处理web请求"></a>处理web请求</h3><p>Spring 附带了一个强大的 web 框架，称为 Spring MVC。Spring MVC 的核心是控制器的概念，这是一个处理请求并使用某种信息进行响应的类。对于面向浏览器的应用程序，控制器的响应方式是可选地填充模型数据并将请求传递给视图，以生成返回给浏览器的 HTML。</p>
<p>现在，将编写一个简单的控制器类来处理根路径的请求（例如 <code>/</code>），并将这些请求转发到主页视图，而不填充任何模型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Controller</code> 注释的主要目的是将该类识别为组件扫描的组件。由于 <code>HomeController</code> 是用 <code>@Controller</code> 注释的，因此 Spring 的组件扫描会自动发现它，并在 Spring 应用程序上下文中创建一个 <code>HomeController</code> 实例作为 bean。</p>
<p>实际上，其他一些注释（包括 <code>@Component</code>、<code>@Service</code> 和 <code>@Repository</code>）的用途与 <code>@Controller</code> 类似。你可以用任何其他的注解来有效地注释 <code>HomeController</code>，它仍然可以工作。但是，选择 <code>@Controller</code> 更能描述该组件在应用程序中的角色。</p>
<p><code>home()</code> 方法与控制器方法一样简单。它使用 <code>@GetMapping</code> 进行注释，以指示如果接收到根路径 <code>/</code> 的 HTTP GET 请求，则此方法应该处理该请求。除了返回 <code>home</code> 的 <code>String</code> 值外，它什么也不做。此值被解释为视图的逻辑名称。如何实现该视图取决于几个因素，但是因为 Thymeleaf 在类路径中，所以可以使用 Thymeleaf 定义该模板。</p>
<h3 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h3><p>为什么不是 JSP？为什么不是 FreeMarker？</p>
<p>模板名称由逻辑视图名称派生而来，它的前缀是 /templates/，后缀是 .html。模板的结果路径是 /templates/home.html。因此，需要将模板放在项目的 /src/main/resources/templates/home.html 中。</p>
<p>为了保持主页简洁，它做的只是欢迎用户访问网站。程序显示了定义 Taco Cloud 主页的基本 Thymeleaf 模板。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span><br><span class="line">      xmlns:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Taco Cloud&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Welcome to...&lt;/h1&gt;</span><br><span class="line">        &lt;img th:src=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;img&gt;</code> 标记使用一个 Thymeleaf 的 th:src 属性和一个 @{…} 表达式引用具有上下文相对路径的图片。这意味着 Taco Cloud 标志图片也必须驻留在项目的 /src/main/resources/static/images/TacoCloud.png 中。</p>
<h3 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h3><p>在对 HTML 页面的内容进行断言时，测试 web 应用程序可能比较棘手。幸运的是，Spring 提供了一些强大的测试支持，使测试 web 应用程序变得很容易。就主页而言，将编写一个与主页本身复杂度相当的测试。你的测试将对根路径 <code>/</code> 执行一个 HTTP GET 请求并期望得到一个成功的结果，其中视图名称为 home，结果内容包含短语 “Welcome to…”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.containsString;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(HomeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHomePage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(view().name(<span class="string">&quot;home&quot;</span>))</span><br><span class="line">            .andExpect(content().string(containsString(<span class="string">&quot;Welcome to...&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HomeControllerTest</code> 使用 <code>@WebMvcTest</code> 注释，而不是 <code>@SpringBootTest</code> 标记。这是 Spring Boot 提供的一个特殊测试注释，它安排测试在 Spring MVC 应用程序的上下文中运行。更具体地说，在本例中，它安排 <code>HomeController</code> 在 Spring MVC 中注册，这样你就可以对它进行请求。</p>
<p><code>@WebMvcTest</code> 还为测试 Spring MVC 提供了 Spring 支持。虽然可以让它启动服务器，但模拟 Spring MVC 的机制就足以满足你的目的了。测试类被注入了一个 <code>MockMvc</code> 对象中，以此用来测试来驱动模型。</p>
<p><code>testHomePage()</code> 方法定义了要对主页执行的测试。它从 <code>MockMvc</code> 对象开始，执行针对 <code>/</code>（根路径）的 HTTP GET 请求。该请求规定了下列期望值：</p>
<ul>
<li>响应应该有一个HTTP 200（OK）状态。</li>
<li>视图应该有一个合理的主页名称。</li>
<li>呈现的视图应该包含 “Welcome to…”</li>
</ul>
<p>如果在 <code>MockMvc</code> 对象执行请求之后，这些期望中的任何一个都没有满足，那么测试就会失败。但是控制器和视图模板是为了满足这些期望而编写的，所以测试应该能够通过，或者至少能够通过一些表示测试通过的绿色提示。</p>
<p>控制器写好了，视图模板创建好了，测试通过了。看来你已经成功地实现了主页。</p>
<h3 id="构建并运行应用"><a href="#构建并运行应用" class="headerlink" title="构建并运行应用"></a>构建并运行应用</h3><p>Spring Boot Dashboard 的便利功能可以帮助你在 IDE 中运行应用程序。<strong>Spring Boot Dashboard</strong> （指示板，仪表盘）显示为一个选项卡，通常位于 IDE 窗口的左下方。</p>
<blockquote>
<p>如何在idea中启动Spring Boot Dashboard：<a href="https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html">https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html</a></p>
</blockquote>
<p>当应用程序启动时，将在控制台中看到一些 Spring ASCII 图飞过，然后看到一些日志条目描述应用程序启动时的步骤。在停止日志记录之前，将看到一个日志条目，其中说 Tomcat 在 port(s): 8080 (http) 上启动，这意味着已经准备好将 web 浏览器指向主页，以查看结果。</p>
<p>等一下，Tomcat 启动？何时将应用程序部署到 Tomcat？</p>
<p>Spring Boot 应用程序倾向于裹挟所有需要的东西，而不需要部署到某个应用服务器。你从未将应用程序部署到 Tomcat… 其实 Tomcat 是应用程序的一部分！(将在 1.3.6 小节中详细描述 Tomcat 如何成为应用程序的一部分的。)</p>
<p>现在应用程序已经启动，将 web 浏览器指向 <a href="http://localhost:8080/">http://localhost:8080</a>（或单击 Spring Boot Dashboard 中地球仪样子的按钮)。</p>
<p>同一共有网下，可以通过ip访问到。<code>ifconfig en0</code></p>
<p><img src="https://img-blog.csdnimg.cn/15e1c5c2492e4dbdb6f01e76bdd87b00.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h3 id="Spring-Boot-DevTools"><a href="#Spring-Boot-DevTools" class="headerlink" title="Spring Boot DevTools"></a>Spring Boot DevTools</h3><p>在初始化项目时将其作为依赖项进行选择。Spring Boot DevTools作为一个依赖项出现在生成的 pom.xml 文件中。Spring Boot Dashboard 甚至显示项目已经启用了 DevTools。但是什么是 DevTools，它能为您做什么？</p>
<p>DevTools 为 Spring 开发人员提供了一些方便的开发同步工具。这些是：</p>
<ul>
<li>当代码更改时自动重启应用程序</li>
<li>当以浏览器为目标的资源（如模板、JavaScript、样式表等）发生变化时，浏览器会自动刷新</li>
<li>自动禁用模板缓存</li>
<li>如果 H2 数据库正在使用，则在 H2 控制台中构建</li>
</ul>
<p>（1）自动重启应用程序</p>
<p>（2）自动刷新浏览器和禁用模板缓存</p>
<p>（3）内置的H2控制台</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>以下是构建基于 Spring 的 Taco Cloud 应用程序的步骤：</p>
<ol>
<li>使用 Spring Initializr 创建了一个初始项目结构。</li>
<li>写了一个控制器类来处理主页请求。</li>
<li>定义了一个视图模板来呈现主页。</li>
<li>写了一个简单的测试类来检验上诉工作。</li>
</ol>
<p>控制器类中的两行代码，而视图模板中没有 Spring 的特定代码。尽管测试类的大部分都使用了 Spring 的测试支持，但是在测试上下文中，它的侵入性似乎要小一些。</p>
<p>这是使用 Spring 开发的一个重要好处。可以关注于满足应用程序需求的代码，而不是满足框架的需求。尽管确实需要不时地编写一些特定于框架的代码，但这通常只是代码库的一小部分。如前所述，Spring （以及 Spring Boot）可以被认为是 <em>无框架的框架</em>。</p>
<p>这到底是怎么回事？Spring 在幕后做了什么来确保您的应用程序需求得到满足？为了理解 Spring 在做什么，让我们从构建规范开始。</p>
<p>在 pom.xml 文件中，声明了对 Web 和 Thymeleaf 启动器的依赖。这两个依赖关系带来了一些其他的依赖关系，包括：</p>
<ul>
<li>Spring MVC 框架</li>
<li>嵌入式 Tomcat</li>
<li>Thymeleaf 和 Thymeleaf 布局方言</li>
</ul>
<p>它还带来了 Spring Boot 的自动配置库。当应用程序启动时，Spring Boot 自动配置自动检测这些库并自动执行：</p>
<ul>
<li>在 Spring 应用程序上下文中配置 bean 以启用 Spring MVC</li>
<li>将嵌入式 Tomcat 服务器配置在 Spring 应用程序上下文中</li>
<li>为使用 Thymeleaf 模板呈现 Spring MV C视图，配置了一个 Thymeleaf 视图解析器</li>
</ul>
<p>简而言之，自动配置完成了所有繁重的工作，让你专注于编写实现应用程序功能的代码。</p>
<h2 id="俯瞰Spring风景线"><a href="#俯瞰Spring风景线" class="headerlink" title="俯瞰Spring风景线"></a>俯瞰Spring风景线</h2><p>Spring Initializr Web表单里提供了100多个可选的依赖项。</p>
<h3 id="Spring核心框架"><a href="#Spring核心框架" class="headerlink" title="Spring核心框架"></a>Spring核心框架</h3><p>Spring 核心框架是 Spring 领域中其他一切的基础。它提供了核心容器和依赖注入框架。但它也提供了一些其他的基本特性。</p>
<p>其中包括 Spring MVC 和 Spring web 框架。已经了解了如何使用 Spring MVC 编写控制器类来处理 web 请求。但是，还没有看到的是，Spring MVC 也可以用于创建产生非 HTML 输出的 REST API。将在第 2 章深入研究 Spring MVC，然后在第 6 章中讨论如何使用它来创建 REST API。</p>
<p>Spring 核心框架还提供了一些基本数据持久性支持，特别是基于模板的 JDBC 支持。将在第 3 章中看到如何使用 JdbcTemplate。</p>
<p>在 Spring 的最新版本（5.0.8）中，添加了对响应式编程的支持，包括一个新的响应式 web 框架 —— Spring WebFlux，它大量借鉴了 Spring MVC。将在第 3 部分中看到 Spring 的响应式编程模型，并在第 10 章中看到 Spring WebFlux。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>已经看到了 Spring Boot 的许多好处，包括启动依赖项和自动配置。在本书中我们确实会尽可能多地使用 Spring Boot，并避免任何形式的显式配置，除非绝对必要。但除了启动依赖和自动配置，Spring Boot 还提供了一些其他有用的特性：</p>
<ul>
<li>Actuator 提供了对应用程序内部工作方式的运行时监控，包括端点、线程 dump 信息、应用程序健康状况和应用程序可用的环境属性。</li>
<li>灵活的环境属性规范。</li>
<li>在核心框架的测试辅助之外，还有额外的测试支持。</li>
</ul>
<p>此外，Spring Boot 提供了一种基于 Groovy 脚本的替代编程模型，称为 Spring Boot CLI（命令行界面）。使用 Spring Boot CLI，可以将整个应用程序编写为 Groovy 脚本的集合，并从命令行运行它们。我们不会在 Spring Boot CLI 上花太多时间，但是当它适合我们的需要时，我们会接触它。</p>
<p>Spring Boot 已经成为 Spring 开发中不可或缺的一部分；我无法想象开发一个没有它的 Spring 应用程序。因此，本书采用了以 Spring Boot 为中心的观点，当我提到 Spring Boot 正在做的事情时，你可能会发现我在使用 Spring 这个词。</p>
<h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>尽管 Spring 核心框架提供了基本的数据持久性支持，但 Spring Data 提供了一些非常惊人的功能：将应用程序的数据存储库抽象为简单的 Java 接口，同时当定义方法用于如何驱动数据进行存储和检索的问题时，对方法使用了命名约定。</p>
<p>更重要的是，Spring Data 能够处理几种不同类型的数据库，包括关系型（JPA）、文档型（Mongo）、图型（Neo4j）等。在第 3 章中，将使用 Spring Data 来帮助创建 Taco Cloud 应用程序的存储库。</p>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>应用程序安全性一直是一个重要的主题，而且似乎一天比一天重要。幸运的是，Spring 在 Spring security 中有一个健壮的安全框架。</p>
<p>Spring Security 解决了广泛的应用程序安全性需求，包括身份验证、授权和 API 安全性。尽管 Spring Security 的范围太大，本书无法恰当地涵盖，但我们将在第 4 章和第 12 章中讨论一些最常见的用例。</p>
<h3 id="Spring-Integration-和-Spring-Batch"><a href="#Spring-Integration-和-Spring-Batch" class="headerlink" title="Spring Integration 和 Spring Batch"></a>Spring Integration 和 Spring Batch</h3><p>在某种程度上，大多数应用程序将需要与其他应用程序集成，甚至需要与同一应用程序的其他组件集成。为了满足这些需求，出现了几种应用程序集成模式。Spring Integration 和 Spring Batch 为基于 Spring 的应用程序提供了这些模式的实现。</p>
<p>Spring Integration 解决了实时集成，即数据在可用时进行处理。相反，Spring Batch 解决了批量集成的问题，允许在一段时间内收集数据，直到某个触发器（可能是一个时间触发器）发出信号，表示该处理一批数据了。将在第 9 章中研究 Spring Batch 和 Spring Integration。</p>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p>在我写这篇文章的时候，应用程序开发领域正在进入一个新时代，在这个时代中，我们不再将应用程序作为单个部署单元来开发，而是将由几个称为 <em>微服务</em> 的单个部署单元组成应用程序。</p>
<p>微服务是一个热门话题，解决了几个实际的开发和运行时问题。然而，在这样做的同时，他们也带来了自己的挑战。这些挑战都将由 Spring Cloud 直接面对，Spring Cloud 是一组用 Spring 开发云本地应用程序的项目。</p>
<p>Spring Cloud 覆盖了很多地方，这本书不可能涵盖所有的地方。我们将在第 13、14 和 15 章中查看 Spring Cloud 的一些最常见的组件。关于 Spring Cloud 的更完整的讨论，我建议看看 John Carnell 的 Spring Microservices in Action（Manning, 2017, <a href="http://www.manning.com/books/spring-microservices-in-action%EF%BC%89%E3%80%82">www.manning.com/books/spring-microservices-in-action）。</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>Spring 的目标是让开发人员轻松应对挑战，比如创建 web 应用程序、使用数据库、保护应用程序和使用微服务。</p>
</li>
<li><p>Spring Boot 构建在 Spring 之上，简化了依赖管理、自动配置和运行时监控，让 Spring 变得更加简单。</p>
</li>
<li><p>Spring 应用程序可以使用 Spring Initializr 进行初始化，它是基于 web 的，并且在大多数 Java 开发环境中都支持它。</p>
</li>
<li><p>在 Spring 应用程序上下文中，组件（通常称为 bean）可以用 Java 或 XML 显式地声明，可以通过组件扫描进行发现，也可以用 Spring Boot 进行自动配置。</p>
</li>
</ul>
<h1 id="第二章-开发Web应用"><a href="#第二章-开发Web应用" class="headerlink" title="第二章 开发Web应用"></a>第二章 开发Web应用</h1><p>使用 Spring 构建的应用程序将执行各种操作，包括处理数据、从数据库中读取信息以及与其他应用程序进行交互。但是应用程序用户得到的第一印象来自于用户界面。在许多应用程序中，UI 界面是在浏览器中显示的 web 应用程序。</p>
<p>在第 1 章中，创建了第一个 Spring MVC 控制器来显示应用程序主页。但是 Spring MVC 能做的远不止简单地显示静态内容。在本章中，将开发 Taco Cloud 应用程序的第一个主要功能 —— 设计自定义 Taco 的能力。在此过程中，将深入研究 Spring MVC，并了解如何显示模型数据和处理表单输入。</p>
<h2 id="展示信息"><a href="#展示信息" class="headerlink" title="展示信息"></a>展示信息</h2><p>在 Spring web 应用程序中，获取和处理数据是控制器的工作。视图的工作是将数据渲染成 HTML 并显示在浏览器中。将创建以下组件来支持 Taco 创建页面，使得用户可以自选配料：</p>
<ul>
<li>一个定义玉米卷成分特性的领域类</li>
<li>一个 Spring MVC 控制器类，它获取成分信息并将其传递给视图</li>
<li>一个视图模板，在用户的浏览器中呈现一个成分列表</li>
</ul>
<h3 id="构建领域类"><a href="#构建领域类" class="headerlink" title="构建领域类"></a>构建领域类</h3><p>在编写控制器和视图之前，让我们先确定表示配料的域类型。这将为开发 web 组件奠定基础。</p>
<p>应用程序的域是它所处理的主题领域 —— 影响应用程序理解的思想和概念。在 Taco Cloud 应用程序中，领域包括 Taco 设计、组成这些设计的成分、客户和客户下的 Taco 订单等对象。首先，我们将关注玉米饼配料。</p>
<p>在领域中，玉米饼配料是相当简单的对象。每一种都有一个名称和一个类型，这样就可以在视觉上对其进行分类（蛋白质、奶酪、酱汁等）。每一个都有一个 ID，通过这个 ID 可以轻松、明确地引用它。下面的成分类定义了需要的域对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个普通的 Java 域类，定义了描述一个成分所需的三个属性。对于程序 中定义的 <code>Ingredient</code> 类，最不寻常的事情可能是它似乎缺少一组常用的 getter 和 setter 方法，更不用说像 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 等有用的方法。</p>
<p>在清单中看不到它们，部分原因是为了节省空间，但也因为使用了一个名为 Lombok 的出色库，它会在运行时自动生成这些方法。实际上，类级别的 <code>@Data</code> 注释是由 Lombok 提供的，它告诉 Lombok 生成所有缺少的方法，以及接受所有<code>final</code>属性作为参数的构造函数。通过使用 Lombok，可以让 <code>Ingredient</code> 的代码保持整洁。</p>
<p>Lombok 不是一个 Spring 库，但是它非常有用，没有它我很难开发。当我需要在一本书中保持代码示例简短明了时，它就成了我的救星。</p>
<p>要使用 Lombok，需要<strong>将其作为依赖项添加到项目</strong>中。如果正在使用 Spring Tool Suite，只需右键单击 pom.xml 文件并从 Spring 上下文菜单选项中选择 Edit Starters 即可。在第 1 章（图 1.4）中给出的依赖项的相同选择将出现，这样就有机会添加或更改所选的依赖项。找到 Lombok 选项，确保选中，然后单击 OK；Spring Tool Suite 将自动将其添加到构建规范中。</p>
<p>或者，可以使用 pom.xml 中的以下条目手动添加它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="keyword">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此依赖项将在开发时提供 Lombok 注释（如 <code>@Data</code>），并在运行时提供自动方法生成。但是还需要<strong>在 IDE 中添加 Lombok 作为扩展</strong>，否则 IDE 将会报错缺少方法和没有设置的最终属性。请访问 <a href="https://projectlombok.org/%EF%BC%8C%E4%BB%A5%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%9C%A8">https://projectlombok.org/，以了解如何在</a> IDE 中安装 Lombok。</p>
<p>你会发现 Lombok 非常有用，但它是可选的。如果不希望使用它，或是不需要它来开发 Spring 应用程序，那么请随意手动编写那些缺少的方法。继续……我将等待。完成后，将添加一些控制器来处理应用程序中的 web 请求。</p>
<blockquote>
<p>笔记：IDEA如何为pom.xml导入依赖？</p>
<p><a href="https://www.jb51.net/article/193912.htm">https://www.jb51.net/article/193912.htm</a></p>
<p>虽然项目里本身就有，不知道reimport是不是真的有效果，没有找到重新选择依赖的方法。</p>
</blockquote>
<blockquote>
<p>笔记：在 IDE 中添加 Lombok 作为扩展？</p>
<p>Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p>
<p>1.plugin中下载lombok插件  <a href="https://www.jb51.net/article/214041.htm">https://www.jb51.net/article/214041.htm</a></p>
<p>2.配置一下，enable annotation processing 启用注释处理  <a href="https://blog.csdn.net/xiaoxiamimm/article/details/113882655">https://blog.csdn.net/xiaoxiamimm/article/details/113882655</a></p>
<p>3.pom.xml中添加lombok依赖</p>
</blockquote>
<h3 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h3><p>控制器是 Spring MVC 框架的主要参与者。它们的主要工作是处理 HTTP 请求，或者将请求传递给视图以呈现 HTML（浏览器显示），或者直接将数据写入响应体（RESTful）。在本章中，将重点讨论使用视图为 web 浏览器生成内容的控制器的类型。在第 6 章中，我们将讨论如何在 REST API 中编写处理请求的控制器。</p>
<p>对于 Taco Cloud 应用程序，需要一个简单的控制器来执行以下操作，一个显示配料的控制器：</p>
<ul>
<li>处理请求路径为 <code>/design</code> 的 HTTP GET 请求</li>
<li>构建成分列表</li>
<li>将请求和成分数据提交给视图模板，以 HTML 的形式呈现并发送给请求的 web 浏览器</li>
</ul>
<p>下面的 DesignTacoController 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient.Type;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDesignForm</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;FLTO&quot;</span>, <span class="string">&quot;Flour Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;COTO&quot;</span>, <span class="string">&quot;Corn Tortilla&quot;</span>, Type.WRAP),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;GRBF&quot;</span>, <span class="string">&quot;Ground Beef&quot;</span>, Type.PROTEIN),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;CARN&quot;</span>, <span class="string">&quot;Carnitas&quot;</span>, Type.PROTEIN),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;TMTO&quot;</span>, <span class="string">&quot;Diced Tomatoes&quot;</span>, Type.VEGGIES),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;LETC&quot;</span>, <span class="string">&quot;Lettuce&quot;</span>, Type.VEGGIES),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;CHED&quot;</span>, <span class="string">&quot;Cheddar&quot;</span>, Type.CHEESE),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;JACK&quot;</span>, <span class="string">&quot;Monterrey Jack&quot;</span>, Type.CHEESE),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;SLSA&quot;</span>, <span class="string">&quot;Salsa&quot;</span>, Type.SAUCE),</span><br><span class="line">            <span class="keyword">new</span> Ingredient(<span class="string">&quot;SRCR&quot;</span>, <span class="string">&quot;Sour Cream&quot;</span>, Type.SAUCE)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;design&quot;</span>, <span class="keyword">new</span> Taco());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provided by &#x27;aexiaosong&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Ingredient&gt; <span class="title">filterByType</span><span class="params">(List&lt;Ingredient&gt; ingredients, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ingredients.stream().filter(x -&gt; x.getType().equals(type)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Slf4j，它是 Lombok 提供的注释，在运行时将自动生成类中的 SLF4J（Java 的简单日志门面，<a href="https://www.slf4j.org/%EF%BC%89%E8%AE%B0%E5%BD%95%E5%99%A8%E3%80%82%E8%BF%99%E4%B8%AA%E9%80%82%E5%BD%93%E7%9A%84%E6%B3%A8%E9%87%8A%E5%85%B7%E6%9C%89%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%9C%B0%E5%9C%A8%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A5%E4%B8%8B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9A">https://www.slf4j.org/）记录器。这个适当的注释具有与显式地在类中添加以下行相同的效果：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log = </span><br><span class="line">       org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);</span><br></pre></td></tr></table></figure>

<p>@Controller。此注释用于将该类标识为控制器并将其标记为组件扫描的候选对象，以便 Spring 将发现该类并在 Spring 应用程序上下文中自动创建 DesignTacoController 实例作为 bean。</p>
<p>@RequestMapping 注释在类级应用时，指定该控制器处理的请求的类型。在本例中，它指定 DesignTacoController 将处理路径以 <code>/design</code> 开头的请求。</p>
<p>@GetMapping 与类级别的 @RequestMapping 配对使用，指定何时接收 <code>/design</code> 的 HTTP GET 请求，showDesignForm() 将用来处理请求。@GetMapping 是一个相对较新的注释，是在 Spring 4.3 中引入的。在 Spring 4.3 之前，可能使用了一个方法级别的 @RequestMapping 注释作为替代<code>@RequestMapping(method=RequestMethod.GET) </code>。</p>
<p>showDesignForm() 方法将处理请求，让我们来看看方法体，看看它是如何工作的。该方法的大部分构造了一个成份对象列表。这个列表现在是硬编码的。当我们讲到第 3 章的时候，你会从数据库中找到玉米饼的原料列表。一旦准备好了原料列表，接下来的几行 showDesignForm() 将根据原料类型过滤该列表。然后将成分类型列表作为属性添加Model对象上，这个对象是以参数的形式传递给 showDesignForm() 方法的。Model 是一个对象，它在控制器和负责呈现数据的视图之间传输数据。最后，放置在 Model 类属性中的数据被复制到 servlet 响应属性中，视图可以在其中找到它们。showDesignForm() 方法最后返回 “design”，这是将用于向浏览器呈现 Model 的视图的逻辑名称。</p>
<p>DesignTacoController 真的开始成形了。如果您现在运行应用程序并将您的浏览器指向 <code>/design</code> 路径，DesignTacoController 的 showDesignForm() 将被占用，它从存储库中获取数据并将其放在 Model 中，然后将请求传递给视图。但是因为还没有定义视图，所以请求会发生可怕的转变，导致 HTTP 404（Not Found）错误。为了解决这个问题，让我们将注意力转移到视图上，其中的数据将用 HTML 进行修饰，并在用户的 web 浏览器中显示。</p>
<h3 id="设计视图"><a href="#设计视图" class="headerlink" title="设计视图"></a>设计视图</h3><p>控制器创建完成后，就该开始设计视图了。Spring 为定义视图提供了几个很好的选项，包括 JavaServer Pages（JSP）、Thymeleaf、FreeMarker、Mustache 和基于 Groovy 的模板。现在，我们将使用 Thymeleaf，这是我们在第 1 章开始项目时所做的选择。</p>
<p>像 Thymeleaf 这样的视图库被设计成与任何特定的 web 框架解耦。因此，他们不知道 Spring 的模型抽象，并且无法处理控制器放置在模型中的数据。但是它们可以处理 servlet 请求属性。因此，在 Spring 将请求提交给视图之前，它将模型数据复制到请求属性中，而 Thymeleaf 和其他视图模板选项可以随时访问这些属性。</p>
<p>Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Taco Cloud<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/styles.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Design your taco!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;design&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wraps&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Designate your wrap:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;wrap&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;proteins&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Pick your protein:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;protein&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cheeses&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Choose your cheese:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;cheese&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;veggies&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Determine your veggies:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;veggies&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ingredient-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sauces&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Select your sauce:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;ingredient : $&#123;sauce&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;ingredients&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;ingredient.id&#125;&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ingredient.name&#125;&quot;</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Name your taco creation:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>Submit your taco<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于每种类型的配料，都要重复 <code>&lt;div&gt;</code> 片段。还包括一个提交按钮和一个字段，用户可以在其中命名他们的创建。</p>
<p>值得注意的是，完整的模板包括 Taco Cloud 图标图片和一个指向样式表的 <code>&lt;link&gt;</code> 引用。在这两种情况下，Thymeleaf 的 <code>@&#123;&#125;</code> 操作符被用来产生一个上下文相关路径的静态工件，它们正在引用。正如在第 1 章中了解到的，Spring 启动应用程序中的静态内容是从类路径根目录的 /static 目录提供的。</p>
<p>现在控制器和视图已经完成，可以启动应用程序了。运行 Spring Boot 应用程序有许多方法。在第 1 章中，展示了如何运行这个应用程序，首先将它构建到一个可执行的 JAR 文件中，然后使用 <code>java -jar</code> 运行这个 JAR。展示了如何使用 <code>mvn spring-boot:run</code> 从构建中直接运行应用程序。</p>
<p>无论如何启动 Taco Cloud 应用程序，一旦启动，使用浏览器访问 <a href="http://localhost:8080/design%E3%80%82%E5%BA%94%E8%AF%A5%E7%9C%8B%E5%88%B0%E7%B1%BB%E4%BC%BC%E5%9B%BE">http://localhost:8080/design。应该看到类似图</a> 2.2 的页面。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote>
<p>笔记：IDEA自动import？</p>
<p>打开 IDEA 的首选项，找到 Editor | General | Auto Import。勾选上 <code>Add unambiguous imports on the fly</code> 和 <code>Optimize imports on the fly (for current project)</code>。</p>
</blockquote>
<p>出现问题：Springboot项目javax.validation找不到：</p>
<p>使用方法：<a href="https://www.jb51.net/article/185660.htm">https://www.jb51.net/article/185660.htm</a></p>
<p>找不到包：<a href="https://www.cnblogs.com/keadd/p/13652629.html">https://www.cnblogs.com/keadd/p/13652629.html</a></p>
<p>未解决，注释Taco类部分行。</p>
<p>运行不正确，应该是design.html中代码的问题，无法显示网页。</p>
<p>添加了一个webconfig.java文件，依然不行。</p>
<p>运行网上代码，是可以的。</p>
<h2 id="处理表单提交"><a href="#处理表单提交" class="headerlink" title="处理表单提交"></a>处理表单提交</h2><p>第一章显示taco首页，第二章显示配料选取页/design，服务端指定可选的配料，传递给客户端，客户端访问design页面通过get请求。客户端选择之后，需要进行表单提交，post请求，传递回服务端，路径相同，都是design。</p>
<p>需要在该 POST 请求的接收端上有一个控制器处理程序方法。需要在 DesignTacoController 中编写一个新的处理程序方法来处理 <code>/design</code> 接口的 POST 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processDesign</span><span class="params">(Taco design)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Save the taco design...</span></span><br><span class="line">    <span class="comment">// We&#x27;ll do this in chapter 3</span></span><br><span class="line">    log.info(<span class="string">&quot;Processing design: &quot;</span> + design);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当应用到 processDesign() 方法时，@PostMapping 与类级别 @RequestMapping 相协调，以表明 processDesign() 应该处理 <code>/design</code> 接口的 POST 请求。这正是需要处理的一个玉米饼艺术家提交的作品。</p>
<p>该方法需要传递一个Taco对象，里面包含了配料和名字等，方法中对taco对象进行处理。在第 3 章中，将添加一些持久性逻辑，将提交的 Taco 保存到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Taco 是一个简单的 Java 域对象，具有两个属性。与 Ingredient 类似，Taco 类也使用 @Data 进行注释，以便在运行时自动生成基本的 JavaBean 方法。</p>
<p>与 showDesignForm() 方法一样，processDesign() 通过返回一个 String 结束。与 showDesignForm() 类似，返回的值指示将显示给用户的视图。但是不同的是，从 processDesign() 返回的值的前缀是 “redirect:”，表示这是一个重定向视图。更具体地说，它表明在 processDesign() 完成之后，用户的浏览器应该被重定向到相对路径 /order/current。</p>
<p>意思是重定向到另一个路径？ /order/current 相当于是/design一样的路径，因此需要用 @Controller、@RequestMapping 和 @GetMapping创建一个控制器。</p>
<p>展现订单表单的控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tacos.web;</span><br><span class="line">​</span><br><span class="line">import javax.validation.Valid;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.validation.Errors;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import tacos.Order;</span><br><span class="line">​</span><br><span class="line">@Slf4j</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/orders&quot;)</span><br><span class="line">public class OrderController &#123;</span><br><span class="line">    @GetMapping(&quot;/current&quot;)</span><br><span class="line">    public String orderForm(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;order&quot;, new Order());</span><br><span class="line">        return &quot;orderForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lombok 的 @Slf4j 注释在运行时创建一个 SLF4J Logger 对象。稍后，将使用这个 Logger 来记录提交的订单的详细信息。</p>
<p>类级别的 @RequestMapping 指定该控制器中的任何请求处理方法都将处理路径以 /orders 开头的请求。当与方法级 @GetMapping 结合使用时，它指定 orderForm() 方法将处理 /orders/current 的 HTTP GET 请求。</p>
<p>至于 orderForm() 方法本身，它非常简单，只返回 orderForm 的逻辑视图名。在第 3 章中，一旦有了把创建的 taco 持久化到数据库的方法，将重新访问该方法并修改它，以使用 taco 对象的列表填充模型，这些对象将按顺序放置。</p>
<p>orderForm 视图由一个名为 orderForm.html 的 Thymeleaf 模板提供，如下面显示的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Taco Cloud<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/styles.css&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/orders&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;order&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Order your taco creations!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/TacoCloud.png&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/design&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;another&quot;</span>&gt;</span>Design another taco<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#fields.hasErrors()&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;validationError&quot;</span>&gt;</span></span><br><span class="line">                    Please correct the problems below and resubmit.</span><br><span class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Deliver my taco masterpieces to...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;street&quot;</span>&gt;</span>Street address: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;street&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;city&quot;</span>&gt;</span>City: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;city&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;state&quot;</span>&gt;</span>State: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;state&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zip&quot;</span>&gt;</span>Zip code: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;zip&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Here&#x27;s how I&#x27;ll pay...<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccNumber&quot;</span>&gt;</span>Credit Card #: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccExpiration&quot;</span>&gt;</span>Expiration: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccExpiration&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ccCVV&quot;</span>&gt;</span>CVV: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;ccCVV&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit order&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;form&gt; </code>标记与design 中使用的 <code>&lt;form&gt; </code>标记不同，因为它还指定了一个表单操作。如果没有指定操作，表单将向呈现表单的相同 URL 提交 HTTP POST 请求。但是在这里，指定表单应该提交到 /orders（使用 Thymeleaf 的 <code>@&#123;…&#125;</code> 操作符作为上下文相关路径）。</p>
<blockquote>
<p>与design提交的post不同，那个url一样，而这个url本来是order/current，应该变为order。</p>
</blockquote>
<p>因此，需要添加另外一个方法到 OrderController 类中，去处理 /orders 接口的 POST 请求。在进行到下一章之前，还没有办法将订单持久化，因此在这里简化它 —— 类似于在下一个程序清单中看到的内容。</p>
<blockquote>
<p>重定向到订单，显示订单页，订单表单中，有订单提交，post请求，需要一个控制器。返回首页。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public String processOrder(Order order) &#123;</span><br><span class="line">    log.info(&quot;Order submitted: &quot; + order);</span><br><span class="line">    return &quot;redirect:/&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 processOrder() 方法来处理提交的订单时，它将获得一个 order 对象，其属性绑定到提交的表单字段。Order 非常像 Taco，是一个相当简单的类，它携带订单信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">    <span class="keyword">private</span> String ccNumber;</span><br><span class="line">    <span class="keyword">private</span> String ccExpiration;</span><br><span class="line">    <span class="keyword">private</span> String ccCVV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="校验表单输入"><a href="#校验表单输入" class="headerlink" title="校验表单输入"></a>校验表单输入</h2><p>执行表单验证的一种方法是在 processDesign() 和 processOrder() 方法中加入一堆 if/then 块，检查每个字段以确保它满足适当的验证规则。但是这样做会很麻烦，并且难于阅读和调试。</p>
<p>幸运的是，Spring 支持 Java’s Bean Validation API（也称为 JSR-303；<a href="https://jcp.org/en/jsr/detail?id=303%EF%BC%89%E3%80%82%E8%BF%99%E4%BD%BF%E5%BE%97%E5%A3%B0%E6%98%8E%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99%E6%AF%94%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%BE%E5%BC%8F%E5%9C%B0%E7%BC%96%E5%86%99%E5%A3%B0%E6%98%8E%E9%80%BB%E8%BE%91%E6%9B%B4%E5%AE%B9%E6%98%93%E3%80%82%E4%BD%BF%E7%94%A8">https://jcp.org/en/jsr/detail?id=303）。这使得声明验证规则比在应用程序代码中显式地编写声明逻辑更容易。使用</a> Spring Boot，不需要做任何特殊的事情来将验证库添加到项目中，因为 Validation API 和 Validation API 的 Hibernate 实现作为Spring Boot web 启动程序的临时依赖项自动添加到了项目中。</p>
<p>要在 Spring MVC 中应用验证，需要这样做：</p>
<ul>
<li>对要验证的类声明验证规则：特别是 Taco 类。</li>
<li>指定验证应该在需要验证的控制器方法中执行，具体来说就是：DesignTacoController 的 processDesign() 方法和 OrderController 的 processOrder() 方法。</li>
<li>修改表单视图以显示验证错误。</li>
</ul>
<h3 id="声明验证规则"><a href="#声明验证规则" class="headerlink" title="声明验证规则"></a>声明验证规则</h3><p>对于 Taco 类，希望确保 name 属性不是空的或 null 的，并且所选配料列表中至少有一项。下面的程序清单显示了一个更新后的 Taco 类，它使用 @NotNull 和 @Size 来声明这些验证规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当涉及到对提交玉米饼订单进行验证声明时，必须对 Order 类应用注解。对于地址的属性，只需要确保用户没有留下任何空白字段。对于这一点，将使用 Hibernate Validator 的 @NotBlank 注解。</p>
<p>支付领域的验证是一个比较奇特的存在。你不仅需要确保 ccNumber 属性不为空，还要确保它包含的是一个有效的信用卡号码的值。该 ccExpiration 属性必须符合 MM/YY（两位数的年/月）格式。而 ccCVV 属性必须是一个三位的数字。为了实现这种验证，需要使用一些其他的 Java Bean Validation API 注释，同时需要从 Hibernate Validator 集合中借用一些验证注解。下面程序清单列出了验证 Order 类所需要的改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Name is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Street is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;City is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;State is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message=&quot;Zip code is required&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreditCardNumber(message=&quot;Not a valid credit card number&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pattern(regexp=&quot;^(0[1-9]|1[0-2])([\\/])([1-9][0-9])$&quot;,</span></span><br><span class="line"><span class="meta">             message=&quot;Must be formatted MM/YY&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccExpiration;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Digits(integer=3, fraction=0, message=&quot;Invalid CVV&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ccCVV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ccNumber 属性用 @CreditCardNumber 进行了注释。该注释声明属性的值必须是通过 Luhn 算法（<a href="https://en.wikipedia.org/wiki/Luhn_algorithm%EF%BC%89%E6%A3%80%E6%9F%A5%E8%BF%87%E7%9A%84%E6%9C%89%E6%95%88%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E3%80%82%E8%BF%99%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E5%87%BA%E9%94%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%85%E6%84%8F%E9%94%99%E8%AF%AF%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%8F%B7%E7%A0%81%E5%AE%9E%E9%99%85%E4%B8%8A%E8%A2%AB%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B8%90%E6%88%B7%EF%BC%8C%E6%88%96%E8%AF%A5%E5%B8%90%E6%88%B7%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BA%A4%E6%98%93%E3%80%82">https://en.wikipedia.org/wiki/Luhn_algorithm）检查过的有效信用卡号。这可以防止用户出错的数据和故意错误的数据，但不能保证信用卡号码实际上被分配到一个帐户，或该帐户可以用于交易。</a></p>
<p>不幸的是，没有现成的注释来验证 ccExpiration 属性的 MM/YY 格式。我已经应用了 @Pattern 注释，为它提供了一个正则表达式，以确保属性值符合所需的格式。</p>
<p>最后，用 @Digits 注释 ccCVV 属性，以确保值恰好包含三个数字。</p>
<p>所有的验证注释都包含一个消息属性，该属性定义了如果用户输入的信息不符合声明的验证规则的要求时将显示给用户的消息。</p>
<h3 id="表单绑定时执行校验"><a href="#表单绑定时执行校验" class="headerlink" title="表单绑定时执行校验"></a>表单绑定时执行校验</h3><p>上一节在领域类中制定了验证规则，现在需要重新修改每个控制器，让表单在POST提交至对应的控制器方法时执行对应的校验。</p>
<p>要验证提交的 Taco，需要将 Java Bean Validation API 的 @Valid 注释添加到 DesignTacoController 的 processDesign() 方法的 Taco 参数中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processDesign</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;design&quot;)</span> Taco design, Errors errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the taco design...</span></span><br><span class="line">    <span class="comment">// We&#x27;ll do this in chapter 3</span></span><br><span class="line">    log.info(<span class="string">&quot;Processing design: &quot;</span> + design);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Valid 注释告诉 Spring MVC 在提交的 Taco 对象绑定到提交的表单数据之后，以及调用 processDesign() 方法之前，对提交的 Taco 对象执行验证。如果存在任何验证错误，这些错误的详细信息将在传递到 processDesign() 的错误对象中捕获。processDesign() 的前几行查询 Errors 对象，询问它的 hasErrors() 方法是否存在任何验证错误。如果有，该方法结束时不处理 Taco，并返回 “design” 视图名，以便重新显示表单。</p>
<p>要对提交的 Order 对象执行验证，还需要对 OrderController 的 processOrder() 方法进行类似的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(<span class="meta">@Valid</span> Order order, Errors errors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;Order submitted: &quot;</span> + order);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，如果没有验证错误，则允许该方法处理提交的数据。如果存在验证错误，则请求将被转发到表单视图，以便用户有机会纠正其错误。</p>
<h3 id="显示验证错误"><a href="#显示验证错误" class="headerlink" title="显示验证错误"></a>显示验证错误</h3><p>前面会在传入控制器之前进行验证，验证有误，则返回之前页面。</p>
<p>但是用户如何知道哪些错误需要改正呢？除非调出表单上的错误，否则用户将只能猜测如何成功提交表单。</p>
<p>Thymeleaf 通过 fields 属性及其 <code>th:errors</code> 属性提供了对 Errors 对象的便捷访问。例如，要在信用卡号字段上显示验证错误，可以添加一个 <code>&lt;span&gt; </code>元素，该元素将这些错误引用用于订单模板，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;ccNumber&quot;</span>&gt;Credit Card #: &lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> th:field=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>/&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;validationError&quot;</span></span><br><span class="line">      th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;#fields.hasErrors(&#x27;ccNumber&#x27;)&#125;&quot;</span></span><br><span class="line">      th:errors=<span class="string">&quot;*&#123;ccNumber&#125;&quot;</span>&gt;CC Num Error&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>除了可以用来设置错误样式以引起用户注意的 class 属性外，<span> 元素还使用 <code>th:if</code> 属性来决定是否显示 <span>。fields 属性的 hasErrors() 方法检查 ccNumber 字段中是否有任何错误。如果有错误，<span> 将被渲染。</span></span></span></p>
<p><code>th:errors</code> 属性引用 ccNumber 字段，并且假设该字段存在错误，它将用验证消息替换 <span> 元素的占位符内容。</span></p>
<h2 id="使用视图控制器"><a href="#使用视图控制器" class="headerlink" title="使用视图控制器"></a>使用视图控制器</h2><p>到目前为止，已经为 Taco Cloud 应用程序编写了三个控制器。尽管每个控制器在应用程序的功能上都有不同的用途，但它们几乎都遵循相同的编程模型：</p>
<ul>
<li>它们都用 @Controller 进行了注释，以表明它们是控制器类，应该由 Spring 组件扫描自动发现，并在 Spring 应用程序上下文中作为 bean 进行实例化。</li>
<li>除了 HomeController 之外，所有的控制器都在类级别上使用 @RequestMapping 进行注释，以定义控制器将处理的基本请求模式。</li>
<li>它们都有一个或多个方法，这些方法都用 @GetMapping 或 @PostMapping 进行了注释，以提供关于哪些方法应该处理哪些请求的细节。</li>
</ul>
<p>即将编写的大多数控制器都将遵循这种模式。但是，如果一个控制器足够简单，不填充模型或流程输入（就像 HomeController 一样），那么还有另一种定义控制器的方法。请查看下一个程序清单，了解如何声明视图控制器 —— 一个只将请求转发给视图的控制器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 @WebConfig 最值得注意的是它实现了 WebMvcConfigurer 接口。WebMvcConfigurer 定义了几个配置 Spring MVC 的方法。尽管它是一个接口，但它提供了所有方法的默认实现，因此只需覆盖所需的方法。在本例中，覆盖了 addViewControllers() 方法。</p>
<p>addViewControllers() 方法提供了一个 ViewControllerRegistry，可以使用它来注册一个或多个视图控制器。在这里，在注册表上调用 addViewController()，传入 “/”，这是视图控制器处理 GET 请求的路径。该方法返回一个 ViewControllerRegistration 对象，在该对象上立即调用 setViewName() 来指定 home 作为应该转发 “/” 请求的视图。</p>
<p>就像这样，已经能够用配置类中的几行代码替换 HomeController。现在可以删除 HomeController，应用程序的行为应该与以前一样。惟一需要做的其他更改是重新访问第 1 章中的 HomeControllerTest，从 @WebMvcTest 注释中删除对 HomeController 的引用，这样测试类就可以无错误地编译了。</p>
<p>这里，已经创建了一个新的 WebConfig 配置类来存放视图控制器声明。但是任何配置类都可以实现 WebMvcConfigurer 并覆盖 addViewController() 方法。例如，可以将相同的视图控制器声明添加到引导 TacoCloudApplication 类中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoCloudApplication</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过扩展现有的配置类，可以避免创建新的配置类，从而降低项目工件数量。但是我倾向于为每种配置（web、数据、安全性等等）创建一个新的配置类，保持应用程序引导配置的简洁。</p>
<p>说到视图控制器，更一般地说，是控制器将请求转发给的视图。</p>
<h2 id="视图模板库"><a href="#视图模板库" class="headerlink" title="视图模板库"></a>视图模板库</h2><p>一般来说，可以选择想要的视图模板库，将其作为依赖项添加到构建中，然后开始在 /templates 目录中（在 Maven 或 Gradl 构建项目的 src/main/resources 目录下）编写模板。Spring Boot 将检测选择的模板库，并自动配置所需的组件来为 Spring MVC 控制器提供视图。</p>
<p>已经在 Taco Cloud 应用程序中用 Thymeleaf 实现了这一点。在第 1 章中，在初始化项目时选择了 Thymeleaf 复选框。这导致 Spring Boot 的 Thymeleaf starter 被包含在 pom.xml 文件中。当应用程序启动时，Spring Boot 自动配置会检测到 Thymeleaf 的存在，并自动配置 Thymeleaf bean。现在要做的就是开始在 /templates 中编写模板。</p>
<p>如果希望使用不同的模板库，只需在项目初始化时选择它，或者编辑现有的项目构建以包含新选择的模板库。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Spring 提供了一个强大的 web 框架，称为 Spring MVC，可以用于开发 Spring 应用程序的 web 前端。</li>
<li>Spring MVC 是基于注解的，可以使用 @RequestMapping、@GetMapping 和 @PostMapping 等注解来声明请求处理方法。</li>
<li>大多数请求处理方法通过返回视图的逻辑名称来结束，例如一个 Thymeleaf 模板，请求（以及任何模型数据）被转发到该模板。</li>
<li>Spring MVC 通过 Java Bean Validation API 和 Hibernate Validator 等验证 API 的实现来支持验证。</li>
<li>视图控制器可以用来处理不需要模型数据或处理的 HTTP GET 请求。</li>
<li>除了 Thymeleaf，Spring 还支持多种视图选项，包括 FreeMarker、Groovy Templates 和 Mustache。</li>
</ul>
<h1 id="第三章-使用数据"><a href="#第三章-使用数据" class="headerlink" title="第三章 使用数据"></a>第三章 使用数据</h1><p>本章内容：</p>
<ul>
<li>使用 Spring JdbcTemplate</li>
<li>使用 SimpleJdbcInsert 插入数据</li>
<li>使用 Spring Data 声明 JPA repositories</li>
</ul>
<p>在 Taco Cloud 应用程序中，需要能够维护关于 ingredients、tacos 和 orders 的信息。如果没有一个数据库来存储这些信息，应用程序将无法比在第 2 章中开发的应用程序取得更大的进展。</p>
<p>在本章中，将向 Taco Cloud 应用程序添加数据持久化操作。首先使用 Spring 对 JDBC（Java Database Connectivity）的支持来消除样板代码。然后，将重新使用 JPA（Java Persistence API）处理数据存储库，从而消除更多代码。</p>
<p>在处理关系数据时，Java 开发人员有多个选择。两个最常见的选择是 JDBC 和 JPA。Spring 通过抽象支持这两种方式，这使得使用 JDBC 或 JPA 比不使用 Spring 更容易。</p>
<h2 id="使用-JDBC-读写数据"><a href="#使用-JDBC-读写数据" class="headerlink" title="使用 JDBC 读写数据"></a>使用 JDBC 读写数据</h2><p>Spring JDBC 支持起源于 JdbcTemplate 类。JdbcTemplate 提供了一种方法，通过这种方法，开发人员可以对关系数据库执行 SQL 操作，与通常使用 JDBC 不同的是，这里不需要满足所有的条件和样板代码。</p>
<p>在没有 JdbcTemplate 的情况下用 Java 执行一个简单的查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = dataSource.getConnection();</span><br><span class="line">        statement = connection.prepareStatement(</span><br><span class="line">            <span class="string">&quot;select id, name, type from Ingredient&quot;</span>);</span><br><span class="line">        statement.setString(<span class="number">1</span>, id);</span><br><span class="line">        resultSet = statement.executeQuery();</span><br><span class="line">        Ingredient ingredient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next()) &#123;</span><br><span class="line">            ingredient = <span class="keyword">new</span> Ingredient(</span><br><span class="line">                resultSet.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                Ingredient.Type.valueOf(resultSet.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ingredient;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ??? What should be done here ???</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询语句被创建连接、创建语句和通过关闭连接、语句和结果集来清理的代码所包围。</p>
<p>更糟糕的是，在创建连接或语句或执行查询时，可能会出现许多问题。这要求捕获一个 SQLException，这可能有助于（也可能无助于）找出问题出在哪里或如何解决问题。</p>
<p>SQLException 是一个被检查的异常，它需要在 catch 块中进行处理。但是最常见的问题，如未能创建到数据库的连接或输入错误的查询，不可能在 catch 块中得到解决，可能会重新向上抛出以求处理。相反，要是考虑使用 JdbcTemplate 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>::mapRowToIngredient, id);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> Ingredient <span class="title">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">        rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有创建任何语句或连接。而且，在方法完成之后，不会对那些对象进行任何清理。最后，这样做不会存在任何在 catch 块中不能处理的异常。剩下的代码只专注于执行查询（调用 JdbcTemplate 的 queryForObject() 方法）并将结果映射到 Ingredient 对象（在 mapRowToIngredient() 方法中）。</p>
<h3 id="为域适配持久化"><a href="#为域适配持久化" class="headerlink" title="为域适配持久化"></a>为域适配持久化</h3><p>在将对象持久化到数据库时，通常最好有一个惟一标识对象的字段。Ingredient 类已经有一个 id 字段，但是需要向 Taco 和 Order 添加 id 字段。还需要向每个对象添加一个字段，以捕获保存对象的日期和时间。</p>
<p>新的taco：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date createdAt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的order：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date placedAt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用 Lombok 在运行时自动生成访问器方法，所以除了声明 id 和 createdAt 属性外，不需要做任何事情。它们将在运行时根据需要生成适当的 getter 和 setter 方法。</p>
<h3 id="使用-JdbcTemplate"><a href="#使用-JdbcTemplate" class="headerlink" title="使用 JdbcTemplate"></a><strong>使用 JdbcTemplate</strong></h3><p>在开始使用 JdbcTemplate 之前，需要将它添加到项目类路径中。这很容易通过添加 Spring Boot 的 JDBC starter 依赖来实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还需要一个存储数据的数据库。出于开发目的，嵌入式数据库足矣。我喜欢 H2 嵌入式数据库，所以我添加了以下依赖进行构建：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>写一个获取和保存 Ingredient 数据的存储库：</strong></em></p>
<h4 id="（1）定义-JDBC-数据库接口"><a href="#（1）定义-JDBC-数据库接口" class="headerlink" title="（1）定义 JDBC 数据库接口"></a>（1）定义 JDBC 数据库接口</h4><p>Ingredient repository 需要执行以下操作：</p>
<ul>
<li>查询所有的 Ingredient 使之变成一个 Ingredient 的集合对象</li>
<li>通过它的 id 查询单个 Ingredient</li>
<li>保存一个 Ingredient 对象</li>
</ul>
<p>以下 IngredientRepository 接口以方法声明的方式定义了这三种操作：<strong>每一个库一个单独接口文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Ingredient <span class="title">findOne</span><span class="params">(String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Ingredient <span class="title">save</span><span class="params">(Ingredient ingredient)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用-JdbcTemplate-编写具体操作，读取"><a href="#（2）使用-JdbcTemplate-编写具体操作，读取" class="headerlink" title="（2）使用 JdbcTemplate 编写具体操作，读取"></a>（2）使用 JdbcTemplate 编写具体操作，读取</h4><p>编写一个使用 JdbcTemplate 来查询数据库的 IngredientRepository 的实现。<strong>每一个库一个具体操作类文件，方法代表查询插入等。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcIngredientRepository</span> <span class="keyword">implements</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcIngredientRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcIngredientRepository 使用 @Repository 进行了注解。这个注解是 Spring 定义的少数几个原型注解之一，包括 @Controller 和 @Component。通过使用 @Repository 对 JdbcIngredientRepository 进行注解，这样它就会由 Spring 组件在扫描时自动发现，并在 Spring 应用程序上下文中生成 bean 实例。</p>
<p>当 Spring 创建 JdbcIngredientRepository bean 时，通过 @Autowired 注解将 JdbcTemplate 注入到 bean 中。构造函数将 JdbcTemplate 分配给一个实例变量，该变量将在其他方法中用于查询和插入数据库。谈到那些其他方法，让我们来看看 findAll() 和 findOne() 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.query(<span class="string">&quot;select id, name, type from Ingredient&quot;</span>,</span><br><span class="line">              <span class="keyword">this</span>::mapRowToIngredient);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>::mapRowToIngredient, id);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> Ingredient <span class="title">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">        rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">        rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">        Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findAll() 和 findOne() 都以类似的方式使用 JdbcTemplate。期望返回对象集合的 findAll() 方法使用了 JdbcTemplate 的 query() 方法。query() 方法接受查询的 SQL 以及 Spring 的 RowMapper 实现，以便将结果集中的每一行映射到一个对象。findAll() 还接受查询中所需的所有参数的列表作为它的最后一个参数。但是，在本例中，没有任何必需的参数。</p>
<p>findOne() 方法只期望返回单个成分对象，因此它使用 JdbcTemplate 的 queryForObject() 方法而不是 query()。queryForObject() 的工作原理与 query() 非常相似，只是它返回的是单个对象，而不是对象列表。在本例中，它给出了要执行的查询、一个 RowMapper 和要获取的 Ingredient 的 id，后者用于代替查询 SQL 中 的 <code>?</code>。</p>
<p>findAll() 和 findOne() 的 RowMapper 参数作为 mapRowToIngredient() 方法的方法引用。当使用 JdbcTemplate 作为显式 RowMapper 实现的替代方案时，使用 Java 8 的方法引用和 lambda 非常方便。但是，如果出于某种原因，想要或是需要一个显式的 RowMapper，那么 findOne() 的以下实现将展示如何做到这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">        <span class="string">&quot;select id, name, type from Ingredient where id=?&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> RowMapper&lt;Ingredient&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Ingredient <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">                    rs.getString(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                    rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">                    Ingredient.Type.valueOf(rs.getString(<span class="string">&quot;type&quot;</span>)));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）插入一行数据"><a href="#（3）插入一行数据" class="headerlink" title="（3）插入一行数据"></a>（3）插入一行数据</h4><p>JdbcTemplate 的 update() 方法可用于在数据库中写入或更新数据的任何查询。</p>
<p>使用JdbcTemplate插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">save</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    jdbc.update(</span><br><span class="line">        <span class="string">&quot;insert into Ingredient (id, name, type) values (?, ?, ?)&quot;</span>,</span><br><span class="line">        ingredient.getId(),</span><br><span class="line">        ingredient.getName(),</span><br><span class="line">        ingredient.getType().toString());</span><br><span class="line">    <span class="keyword">return</span> ingredient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有必要将 ResultSet 数据映射到对象，所以 update() 方法要比 query() 或 queryForObject() 简单得多。它只需要一个包含 SQL 的字符串来执行，以及为任何查询参数赋值。在本例中，查询有三个参数，它们对应于 save() 方法的最后三个参数，提供了 Ingredient 的 id、name 和 type。</p>
<p>完成了 JdbcIngredientRepository后，现在可以将其注入到 DesignTacoController 中，并使用它来提供一个 Ingredient 对象列表，而不是使用硬编码的值（正如第 2 章中所做的那样）。DesignTacoController 的变化如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DesignTacoController</span><span class="params">(IngredientRepository ingredientRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDesignForm</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;Ingredient&gt; ingredients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ingredientRepo.findAll().forEach(i -&gt; ingredients.add(i));</span><br><span class="line">        Type[] types = Ingredient.Type.values();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">                               filterByType(ingredients, type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>showDesignForm() 方法的第 2 行现在调用了注入的 IngredientRepository 的 findAll() 方法。findAll() 方法从数据库中提取所有 Ingredient，然后将它们对应到到模型的不同类型中。</p>
<h3 id="写表并预加载数据"><a href="#写表并预加载数据" class="headerlink" title="写表并预加载数据"></a>写表并预加载数据</h3><p>在开始从查询中引用的 Ingredient 表读取数据之前，应该创建这个表并写一些 Ingredient 数据进去。</p>
<p>除了 Ingredient 表之外，还需要一些保存订单和设计信息的表。也就是要定义数据库数据规则。create语句。</p>
<p><img src="https://img-blog.csdnimg.cn/f285480b152f4c6bb537a8b6dc309f46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<ul>
<li>Ingredient - 保存着原料信息</li>
<li>Taco - 保存着关于 taco 设计的重要信息</li>
<li>Taco_Ingredient - 包含 Taco 表中每一行的一个或多行数据，将 Taco 映射到该 Taco 的 Ingredient（如果一个taco有多个配料，就插入多行）</li>
<li>Taco_Order - 保存着重要的订单细节</li>
<li>Taco_Order_Tacos - 包含 Taco_Order 表中的每一行的一个或多行数据，将 Order 映射到 Order 中的Tacos</li>
</ul>
<p>创建表的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Ingredient (</span><br><span class="line">    id <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">25</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    type <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco (</span><br><span class="line">    id <span class="keyword">identity</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    createdAt <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Ingredients (</span><br><span class="line">    taco <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ingredient <span class="type">varchar</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Ingredients <span class="keyword">add</span> <span class="keyword">foreign</span> key (taco) <span class="keyword">references</span> Taco(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Ingredients <span class="keyword">add</span> <span class="keyword">foreign</span> key (ingredient) <span class="keyword">references</span> Ingredient(id);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Order (</span><br><span class="line">    id <span class="keyword">identity</span>,</span><br><span class="line">    deliveryName <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryStreet <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryCity <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryState <span class="type">varchar</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    deliveryZip <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ccNumber <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ccExpiration <span class="type">varchar</span>(<span class="number">5</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ccCVV <span class="type">varchar</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    placedAt <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> Taco_Order_Tacos (</span><br><span class="line">    tacoOrder <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    taco <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Order_Tacos <span class="keyword">add</span> <span class="keyword">foreign</span> key (tacoOrder) <span class="keyword">references</span> Taco_Order(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Taco_Order_Tacos <span class="keyword">add</span> <span class="keyword">foreign</span> key (taco) <span class="keyword">references</span> Taco(id);</span><br></pre></td></tr></table></figure>

<p>最大的问题是把这个模式定义放在哪里。事实证明，Spring Boot 回答了这个问题。</p>
<p>如果有一个名为 schema.sql 的文件。在应用程序的类路径根目录下执行 sql，然后在应用程序启动时对数据库执行该文件中的 SQL。因此，应该将定义数据库 的内容写入一个名为 schema.sql 的文件中，然后放在项目的 src/main/resources 文件夹下。</p>
<p>还需要用一些 Ingredient 数据来预加载数据库。幸运的是，Spring Boot 还将执行一个名为 data.sql 的文件，这个文件位于根路径下。因此，可以使用 src/main/resources/data.sql 中的预加载数据库程序中的 insert 语句来加载包含 Ingredient 数据的数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Order_Tacos;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Ingredients;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Taco_Order;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;FLTO&#x27;</span>, <span class="string">&#x27;Flour Tortilla&#x27;</span>, <span class="string">&#x27;WRAP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;COTO&#x27;</span>, <span class="string">&#x27;Corn Tortilla&#x27;</span>, <span class="string">&#x27;WRAP&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;GRBF&#x27;</span>, <span class="string">&#x27;Ground Beef&#x27;</span>, <span class="string">&#x27;PROTEIN&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;CARN&#x27;</span>, <span class="string">&#x27;Carnitas&#x27;</span>, <span class="string">&#x27;PROTEIN&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;TMTO&#x27;</span>, <span class="string">&#x27;Diced Tomatoes&#x27;</span>, <span class="string">&#x27;VEGGIES&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;LETC&#x27;</span>, <span class="string">&#x27;Lettuce&#x27;</span>, <span class="string">&#x27;VEGGIES&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;CHED&#x27;</span>, <span class="string">&#x27;Cheddar&#x27;</span>, <span class="string">&#x27;CHEESE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;JACK&#x27;</span>, <span class="string">&#x27;Monterrey Jack&#x27;</span>, <span class="string">&#x27;CHEESE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;SLSA&#x27;</span>, <span class="string">&#x27;Salsa&#x27;</span>, <span class="string">&#x27;SAUCE&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Ingredient (id, name, type) <span class="keyword">values</span> (<span class="string">&#x27;SRCR&#x27;</span>, <span class="string">&#x27;Sour Cream&#x27;</span>, <span class="string">&#x27;SAUCE&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>以上只开发了 Ingredient 数据的存储库，还需要继续编写用于持久化 Taco、Order 的存储库和相应的数据。</p>
<h3 id="具体持久化方法"><a href="#具体持久化方法" class="headerlink" title="具体持久化方法"></a>具体持久化方法</h3><p>到此，已经了解了如何使用 JdbcTemplate 向数据库写入数据。JdbcIngredientRepository 中的 save() 方法使用 JdbcTemplate 的 update() 方法将 Ingredient 对象保存到数据库中。</p>
<p>虽然这是第一个很好的例子，但是它可能有点太简单了。保存数据可能比 JdbcIngredientRepository 所需要的更复杂。使用 JdbcTemplate 保存数据的两种方法包括：</p>
<ul>
<li>直接使用 update() 方法</li>
<li>使用 SimpleJdbcInsert 包装类</li>
</ul>
<p>让我们首先看看，当持久话需求比保存一个 Ingredient 所需要的更复杂时，如何使用 update() 方法。</p>
<h4 id="使用-JdbcTemplate-保存数据"><a href="#使用-JdbcTemplate-保存数据" class="headerlink" title="使用 JdbcTemplate 保存数据"></a>使用 JdbcTemplate 保存数据</h4><p>目前，Taco 和 Order 存储库需要做的惟一一件事是保存它们各自的对象。为了保存 Taco 对象，TacoRepository 声明了一个 save() 方法，接口如下所示：OrderRepository接口 也声明了一个 save() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TacoRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">Taco <span class="title">save</span><span class="params">(Taco design)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">Order <span class="title">save</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存一个 Taco 设计需要将与该 Taco 关联的 Ingredient 保存到 Taco_Ingredient 表中。同样，保存 Order 也需要将与 Order 关联的 Taco 保存到 Taco_Order_Tacos 表中。这使得保存 Taco 和 Order 比 保存 Ingredient 更有挑战性。</p>
<p>要实现 TacoRepository，需要一个 save() 方法，该方法首先保存基本的 Taco 设计细节（例如，名称和创建时间），然后为 Taco 对象中的每个 Ingredient 在 Taco_Ingredients 中插入一行。下面的程序显示了完整的 JdbcTacoRepository 类。</p>
<p>使用 JdbcTemplate 实现 TacoRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.PreparedStatementCreatorFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.support.GeneratedKeyHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.support.KeyHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTacoRepository</span> <span class="keyword">implements</span> <span class="title">TacoRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcTacoRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Taco <span class="title">save</span><span class="params">(Taco taco)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tacoId = saveTacoInfo(taco);</span><br><span class="line">        taco.setId(tacoId);</span><br><span class="line">        <span class="keyword">for</span> (Ingredient ingredient : taco.getIngredients()) &#123;</span><br><span class="line">            saveIngredientToTaco(ingredient, tacoId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taco;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">saveTacoInfo</span><span class="params">(Taco taco)</span> </span>&#123;</span><br><span class="line">        taco.setCreatedAt(<span class="keyword">new</span> Date());</span><br><span class="line">        PreparedStatementCreator psc = <span class="keyword">new</span> PreparedStatementCreatorFactory(</span><br><span class="line">            <span class="string">&quot;insert into Taco (name, createdAt) values (?, ?)&quot;</span>,</span><br><span class="line">            Types.VARCHAR, Types.TIMESTAMP</span><br><span class="line">        ).newPreparedStatementCreator(</span><br><span class="line">            Arrays.asList(</span><br><span class="line">                taco.getName(),</span><br><span class="line">                <span class="keyword">new</span> Timestamp(taco.getCreatedAt().getTime())));</span><br><span class="line"></span><br><span class="line">        KeyHolder keyHolder = <span class="keyword">new</span> GeneratedKeyHolder();</span><br><span class="line">        jdbc.update(psc, keyHolder);</span><br><span class="line">        <span class="keyword">return</span> keyHolder.getKey().longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveIngredientToTaco</span><span class="params">(Ingredient ingredient, <span class="keyword">long</span> tacoId)</span> </span>&#123;</span><br><span class="line">        jdbc.update(</span><br><span class="line">            <span class="string">&quot;insert into Taco_Ingredients (taco, ingredient) &quot;</span> +<span class="string">&quot;values (?, ?)&quot;</span>,</span><br><span class="line">            tacoId, ingredient.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>save() 方法首先调用私有的 saveTacoInfo() 方法，然后使用该方法返回的 Taco id 调用 saveIngredientToTaco()，它保存每个配料。在 Taco 中插入一行时，需要知道数据库生成的 id，以便在每个 Ingredient 中引用它。保存 Ingredient 数据时使用的 update() 方法不能获得生成的 id，因此这里需要一个不同的 update() 方法。</p>
<p>需要的 update() 方法接受 PreparedStatementCreator 和 KeyHolder。KeyHolder 将提供生成的 Taco id，但是为了使用它，还必须创建一个 PreparedStatementCreator。创建 PreparedStatementCreator 非常重要。首先创建一个 PreparedStatementCreatorFactory，为它提供想要执行的 SQL，以及每个查询参数的类型。然后在该工厂上调用 newPreparedStatementCreator()，在查询参数中传递所需的值以生成 PreparedStatementCreator。通过使用 PreparedStatementCreator，可以调用 update()，传入 PreparedStatementCreator 和 KeyHolder（在本例中是 GeneratedKeyHolder 实例）。update() 完成后，可以通过返回 keyHolder.getKey().longValue() 来返回 Taco id。</p>
<p>回到 save() 方法，循环遍历 Taco 中的每个成分，调用 saveIngredientToTaco() 方法。saveIngredientToTaco() 方法使用更简单的 update() 形式来保存对到Taco_Ingredient 表中。</p>
<p>TacoRepository 剩下所要做的就是在 DesignTacoController 中进行持久化操作，将订单保存到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">    <span class="keyword">private</span> TacoRepository designRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DesignTacoController</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IngredientRepository ingredientRepo,</span></span></span><br><span class="line"><span class="params"><span class="function">        TacoRepository designRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">        <span class="keyword">this</span>.designRepo = designRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数包含一个 IngredientRepository 和一个TacoRepository。它将这两个变量都赋值给实例变量，以便它们可以在 showDesignForm() 和 processDesign() 方法中使用。</p>
<p>新的 processDesign() 方法，保存 Taco 设计并链接到 Order：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/design&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;taco&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Taco <span class="title">taco</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Taco();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processDesign</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Valid</span> Taco design, Errors errors,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@ModelAttribute</span> Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;design&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Taco saved = designRepo.save(design);</span><br><span class="line">        order.addDesign(saved);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/orders/current&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DesignTacoController 使用 @SessionAttributes(“order”) 进行了注解，并且在 order() 方法上有一个新的注解 @ModelAttribute。与 taco() 方法一样，order() 方法上的 @ModelAttribute 注解确保在模型中能够创建 Order 对象。但是与 <strong>session</strong> 中的 Taco 对象不同，这里<strong>需要在多个请求间显示订单，因此可以创建多个 Taco 并将它们添加到订单中</strong>。类级别的 @SessionAttributes 注解指定了任何模型对象，比如应该保存在会话中的 order 属性，并且可以<strong>跨多个请求使用</strong>。</p>
<p>taco 设计的实际处理发生在 processDesign() 方法中，除了 Taco 和 Errors 对象外，该方法现在还接受 Order 对象作为参数。Order 参数使用 @ModelAttribute 进行注解，以指示其值应该来自模型，而 Spring MVC 不应该尝试给它绑定请求参数。</p>
<p>在检查验证错误之后，processDesign() 使用注入的 TacoRepository 来保存 Taco。然后，<strong>它将 Taco 对象添加到保存于 session 中 Order 对象中</strong>。实际上，Order 对象仍然保留在 session 中，直到用户完成并提交 Order 表单才会保存到数据库中。此时，OrderController 需要调用 OrderRepository 的实现来保存订单。下面来写一下这个实现。</p>
<h4 id="使用-SimpleJdbcInsert-保存数据"><a href="#使用-SimpleJdbcInsert-保存数据" class="headerlink" title="使用 SimpleJdbcInsert 保存数据"></a>使用 SimpleJdbcInsert 保存数据</h4><p>在保存订单方面，也存在类似的情况。不仅必须将订单数据保存到 Taco_Order 表中，还必须引用 Taco_Order_Tacos 表中的每个 taco。但是不是使用繁琐的 PreparedStatementCreator, 而是使用SimpleJdbcInsert， SimpleJdbcInsert 是一个包装了 JdbcTemplate 的对象，它让向表插入数据的操作变得更容易。</p>
<p>首先创建一个 JdbcOrderRepository，它是 OrderRepository 的一个实现。但是在编写 save() 方法实现之前，让我们先关注构造函数，在构造函数中，将创建两个 SimpleJdbcInsert 实例，用于将值插入 Taco_Order 和 Taco_Order_Tacos 表中。下面的程序清单显示了 JdbcOrderRepository（没有 save() 方法）。从 JdbcTemplate 创建一个 SimpleJdbcTemplate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimpleJdbcInsert orderInserter;</span><br><span class="line">    <span class="keyword">private</span> SimpleJdbcInsert orderTacoInserter;</span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcOrderRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderInserter = <span class="keyword">new</span> SimpleJdbcInsert(jdbc)</span><br><span class="line">            .withTableName(<span class="string">&quot;Taco_Order&quot;</span>)</span><br><span class="line">            .usingGeneratedKeyColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.orderTacoInserter = <span class="keyword">new</span> SimpleJdbcInsert(jdbc)</span><br><span class="line">            .withTableName(<span class="string">&quot;Taco_Order_Tacos&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 JdbcTacoRepository 一样，JdbcOrderRepository 也通过其构造函数注入了 JdbcTemplate。但是，构造函数并没有将 JdbcTemplate 直接分配给一个实例变量，而是使用它来构造两个 SimpleJdbcInsert 实例。</p>
<p>第一个实例被分配给 orderInserter 实例变量，它被配置为使用 Taco_Order 表，并假定 id 属性将由数据库提供或生成。分配给 orderTacoInserter 的第二个实例被配置为使用 Taco_Order_Tacos 表，但是没有声明如何在该表中生成任何 id。</p>
<p>构造函数还创建 ObjectMapper 实例，并将其分配给实例变量。尽管 Jackson 用于 JSON 处理，但稍后将看到如何重新使用它来帮助保存订单及其关联的 tacos。</p>
<p>现在让我们看看 save() 方法如何使用 SimpleJdbcInsert 实例。下一个程序清单显示了 save() 方法，以及几个用于实际工作的 save() 委托的私有方法。</p>
<p>使用 SimpleJdbcInsert 插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">save</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    order.setPlacedAt(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">long</span> orderId = saveOrderDetails(order);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line"></span><br><span class="line">    List&lt;Taco&gt; tacos = order.getTacos();</span><br><span class="line">    <span class="keyword">for</span> (Taco taco : tacos) &#123;</span><br><span class="line">        saveTacoToOrder(taco, orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">saveOrderDetails</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;String, Object&gt; values = objectMapper.convertValue(order, Map.class);</span><br><span class="line">    values.put(<span class="string">&quot;placedAt&quot;</span>, order.getPlacedAt());</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">long</span> orderId = orderInserter.executeAndReturnKey(values).longValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveTacoToOrder</span><span class="params">(Taco taco, <span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; values = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    values.put(<span class="string">&quot;tacoOrder&quot;</span>, orderId);</span><br><span class="line">    values.put(<span class="string">&quot;taco&quot;</span>, taco.getId());</span><br><span class="line"></span><br><span class="line">    orderTacoInserter.execute(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>save() 方法实际上并不保存任何东西。它定义了保存订单及其关联 Taco 对象的流，并将持久性工作委托给 saveOrderDetails() 和 saveTacoToOrder()。</p>
<p>SimpleJdbcInsert 有两个执行插入的有用方法：execute() 和 executeAndReturnKey()。两者都接受 Map&lt;String, Object&gt;，其中 Map 键对应于数据插入的表中的列名，映射的值被插入到这些列中。</p>
<p>通过将 Order 中的值复制到 Map 的条目中，很容易创建这样的 Map。但是 Order 有几个属性，这些属性和它们要进入的列有相同的名字。因此，在 saveOrderDetails() 中，我决定使用 Jackson 的 ObjectMapper 及其 convertValue() 方法将 Order 转换为 Map。这是必要的，否则 ObjectMapper 会将 Date 属性转换为 long，这与 Taco_Order 表中的 placedAt 字段不兼容。</p>
<p>随着 Map 中填充完成订单数据，我们可以在 orderInserter 上调用 executeAndReturnKey() 方法了。这会将订单信息保存到 Taco_Order 表中，并将数据库生成的 id 作为一个 Number 对象返回，调用 longValue() 方法将其转换为从方法返回的 long 值。</p>
<p>saveTacoToOrder() 方法要简单得多。不是使用 ObjectMapper 将对象转换为 Map，而是创建 Map 并设置适当的值。同样，映射键对应于表中的列名。对 orderTacoInserter 的 execute() 方法的简单调用就能执行插入操作。</p>
<p>现在可以将 OrderRepository 注入到 OrderController 中并开始使用它。下面的程序清单显示了完整的 OrderController，包括因使用注入的 OrderRepository 而做的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.web;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.support.SessionStatus;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"><span class="keyword">import</span> tacos.data.OrderRepository;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(OrderRepository orderRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepo = orderRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/current&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">orderForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(<span class="meta">@Valid</span> Order order, Errors errors,</span></span></span><br><span class="line"><span class="params"><span class="function">                               SessionStatus sessionStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;orderForm&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        orderRepo.save(order);</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了将 OrderRepository 注入控制器之外，OrderController 中惟一重要的更改是 processOrder() 方法。在这里，表单中提交的 Order 对象（恰好也是在 session 中维护的 Order 对象）通过注入的 OrderRepository 上的 save() 方法保存。</p>
<p>一旦订单被保存，就不再需要它存在于 session 中了。事实上，如果不清除它，订单将保持在 session 中，包括其关联的 tacos，下一个订单将从旧订单中包含的任何 tacos 开始。因此需要 processOrder() 方法请求 SessionStatus 参数并调用其 setComplete() 方法来重置会话。</p>
<p>所有的 JDBC 持久化代码都准备好了。现在，可以启动 Taco Cloud 应用程序并进行测试。你想要多少 tacos 和多少 orders 都可以。</p>
<p>可能还会发现在数据库中进行挖掘是很有帮助的。因为使用 H2 作为嵌入式数据库，而且 Spring Boot DevTools 已经就位，所以应该能够用浏览器访问 <a href="http://localhost:8080/h2-console">http://localhost:8080/h2-console</a> 来查看 H2 控制台。虽然需要确保 JDBC URL 字段被设置为 JDBC:h2:mem:testdb，但是默认的凭证应该可以让你进入。登录后，应该能够对 Taco Cloud 模式中的表发起查询。</p>
<p>Spring 的 JdbcTemplate 和 SimpleJdbcInsert 使得使用关系数据库比普通 JDBC 简单得多。但是可能会发现 JPA 使它更加简单。3.2将展示JPA如何使用 Spring 数据使数据持久化更加容易。</p>
<h2 id="使用-Spring-Data-JPA-读写数据"><a href="#使用-Spring-Data-JPA-读写数据" class="headerlink" title="使用 Spring Data JPA 读写数据"></a>使用 Spring Data JPA 读写数据</h2><p>Spring Data 项目是一个相当大的伞形项目，几个子项目组成，其中大多数子项目关注于具有各种不同数据库类型的数据持久化。一些最流行的 Spring 数据项目包括：</p>
<ul>
<li>Spring Data JPA* - 针对关系数据库的持久化</li>
<li><em>Spring Data Mongo</em> - 针对 Mongo 文档数据库的持久化</li>
<li><em>Spring Data Neo4j</em> - 针对 Neo4j 图形数据库的持久化</li>
<li><em>Spring Data Redis</em> - 针对 Redis 键值存储的持久化</li>
<li><em>Spring Data Cassandra</em> - 针对 Cassandra 数据库的持久化</li>
</ul>
<p>Spring Data 为所有这些项目提供的最有意思和最有用的特性之一是能够<strong>基于存储库规范接口自动创建存储库</strong>。</p>
<p>为了了解 Spring Data 是如何工作的，需要将本章前面介绍的基于 jdbc 的存储库替换为 Spring Data JPA 创建的存储库。但是首先，需要将 Spring Data JPA 添加到项目构建中。</p>
<h3 id="添加Spring-Data-JPA依赖"><a href="#添加Spring-Data-JPA依赖" class="headerlink" title="添加Spring Data JPA依赖"></a>添加<strong>Spring Data JPA</strong>依赖</h3><p>Spring Data JPA 可用于具有 JPA starter 的 Spring Boot 应用程序。这个 starter 依赖不仅带来了 Spring Data JPA，还包括 Hibernate 作为 JPA 的实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="对领域类添加注解成为实体"><a href="#对领域类添加注解成为实体" class="headerlink" title="对领域类添加注解成为实体"></a>对领域类添加注解成为实体</h3><p>在创建存储库方面，Spring Data 做了一些惊人的事情。但不幸的是，在使用 JPA 映射注解域对象时，它并没有太大的帮助。需要打开 Ingredient、Taco 和 Order 类，并添加一些注解。首先是 Ingredient 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了将其声明为 JPA 实体，必须使用 @Entity 注解。它的 id 属性必须使用 @Id 进行注解，以便将其指定为惟一标识数据库中实体的属性。</p>
<p>除了特定于 JPA 的注解之外，还在类级别上添加了 @NoArgsConstructor 注解。JPA 要求实体有一个无参构造函数，所以 Lombok 的 @NoArgsConstructor 实现了这一点。但是要是不希望使用它，可以通过将 access 属性设置为 AccessLevel.PRIVATE 来将其设置为私有。因为必须设置 final 属性，所以还要将 force 属性设置为 true，这将导致 Lombok 生成的构造函数将它们设置为 null。</p>
<p>还添加了一个 @RequiredArgsConstructor。@Data 隐式地添加了一个必需的有参构造函数，但是当使用 @NoArgsConstructor 时，该构造函数将被删除。显式的 @RequiredArgsConstructor 确保除了私有无参数构造函数外，仍然有一个必需有参构造函数。</p>
<p>Taco类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.OneToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrePersist;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createdAt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToMany(targetEntity=Ingredient.class)</span></span><br><span class="line">    <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Ingredient&gt; ingredients;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createdAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createdAt = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Ingredient 一样，Taco 类现在使用 @Entity 注解，其 id 属性使用 @Id 注解。因为依赖于数据库自动生成 id 值，所以还使用 @GeneratedValue 注解 id 属性，指定自动策略。</p>
<p>要声明 Taco 及其相关 Ingredient 列表之间的关系，可以使用 @ManyToMany 注解 ingredient 属性。一个 Taco 可以有很多 Ingredient，一个 Ingredient 可以是很多 Taco 的一部分。</p>
<p>还有一个新方法 createdAt()，它用 @PrePersist 注解。将使用它将 createdAt 属性设置为保存 Taco 之前的当前日期和时间。</p>
<p>Order类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.OneToMany;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrePersist;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Digits;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Pattern;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.CreditCardNumber;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;Taco_Order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date placedAt;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToMany(targetEntity=Taco.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Taco&gt; tacos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDesign</span><span class="params">(Taco design)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tacos.add(design);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">placedAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placedAt = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Order 的更改与对 Taco 的更改非常相似。但是在类级别有一个新的注解：@Table。这指定订单实体应该持久化到数据库中名为 Taco_Order 的表中。</p>
<p>尽管可以在任何实体上使用这个注解，但它对于 Order 是必需的。没有它，JPA 将默认将实体持久化到一个名为 Order 的表中，但是 Order 在 SQL 中是一个保留字，会导致问题。</p>
<h3 id="声明-JPA-repository接口"><a href="#声明-JPA-repository接口" class="headerlink" title="声明 JPA repository接口"></a>声明 JPA repository接口</h3><p>在存储库的 JDBC 版本中，显式地声明了希望 repository 提供的方法。但是使用 Spring Data，扩展 CrudRepository 接口。例如，这是一个新的 IngredientRepository 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CrudRepository 为 CRUD（创建、读取、更新、删除）操作声明了十几个方法。注意，它是参数化的，第一个参数是存储库要持久化的实体类型，第二个参数是实体 id 属性的类型。对于 IngredientRepository，参数应该是 Ingredient 和 String 类型。</p>
<p>定义 TacoRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TacoRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Taco</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IngredientRepository 和 TacoRepository 之间唯一显著的区别是对于 CrudRepository 的参数不同。在这里，它们被设置为 Taco 和 Long 去指定 Taco 实体（及其 id 类型）作为这个 respository 接口的持久化单元。最后，同样的更改可以应用到 OrderRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了这三个 repository，可能认为需要为这三个 repository 编写实现，还包括每种实现的十几个方法。但这就是 Spring Data JPA 优秀的地方 —— 不需要编写实现！当应用程序启动时，Spring Data JPA 会动态地自动生成一个实现。这意味着 repository 可以从一开始就使用。只需将它们注入到控制器中，就像在基于 JDBC 的实现中所做的那样。</p>
<p>CrudRepository 提供的方法非常适合用于实体的通用持久化。但是如果有一些基本持久化之外的需求呢？让我们看看如何自定义 repository 来执行域特有的查询。</p>
<h3 id="自定义-JPA-repository实现"><a href="#自定义-JPA-repository实现" class="headerlink" title="自定义 JPA repository实现"></a>自定义 JPA repository实现</h3><p>想象一下，除了 CrudRepository 提供的基本 CRUD 操作之外，还需要获取投递给指定邮政编码的所有订单。事实证明，通过在 OrderRepository 中添加以下方法声明可以很容易地解决这个问题：</p>
<p><code>List&lt;Order&gt; findByDeliveryZip(String deliveryZip);</code></p>
<p>在生成 repository 实现时，Spring Data 检查存储库接口中的任何方法，解析方法名称，并<strong>尝试在持久化对象的上下文中理解方法的用途</strong>（在本例中是 Order）。本质上，Spring Data 定义了一种小型的领域特定语言（DSL），其中持久化细节用 repository 中的方法签名表示。</p>
<p>让我们考虑另一个更复杂的例子。假设需要查询在给定日期范围内投递给指定邮政编码的所有订单。在这种情况下，当添加到 OrderRepository 时，下面的方法可能会被证明是有用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Order&gt; <span class="title">readOrdersByDeliveryZipAndPlacedAtBetween</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    String deliveryZip, Date startDate, Date endDate)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em><strong><u>自动识别方法名猜测功能，方法命名约定</u></strong></em></p>
<p>虽然命名约定对于相对简单的查询很有用，但是对于更复杂的查询，不需要太多的想象就可以看出方法名称可能会失控。在这种情况下，可以随意将方法命名为任何想要的名称，并使用 @Query 对其进行注解，以显式地指定调用方法时要执行的查询，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;Order o where o.deliveryCity=&#x27;Seattle&#x27;&quot;)</span></span><br><span class="line"><span class="function">List&lt;Order&gt; <span class="title">readOrdersDeliveredInSeattle</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>JdbcTemplate 大大简化了 JDBC 的工作。</li>
<li>当需要知道数据库生成的 id 时，可以同时使用 PreparedStatementCreator 和 KeyHolder。</li>
<li>为了方便执行数据插入，使用 SimpleJdbcInsert。</li>
<li>Spring Data JPA 使得 JPA 持久化就像编写存储库接口一样简单。</li>
</ul>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>前端寄出-CSS层叠样式表</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS被用来同时控制多重网页的样式和布局。</p>
<p>通过使用 CSS，所有的格式化均可从 HTML 中剥离出来，并存储于一个独立的文件中。</p>
<p>CSS 指层叠样式表 (Cascading Style Sheets)<br>样式定义如何显示 HTML 元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;标题&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body</span><br><span class="line">&#123;</span><br><span class="line">	background-color:#d0e4fe;</span><br><span class="line">&#125;</span><br><span class="line">h1    //h1是选择器</span><br><span class="line">&#123;          //大括号里是一条或多条声明</span><br><span class="line">	color:orange;     //每一条声明由属性和值组成 ：分开</span><br><span class="line">	text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">p</span><br><span class="line">&#123;</span><br><span class="line">	font-family:&quot;Times New Roman&quot;;</span><br><span class="line">	font-size:20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;     //style元素在head元素里</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;CSS 实例!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h2><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:<br>选择器通常是您需要改变样式的 HTML 元素。<br>每条声明由一个属性和一个值组成。<br>属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。<br>css中，也就是<code>&lt;style&gt;</code>中，注释是 /*   */</p>
<h2 id="2-id选择器"><a href="#2-id选择器" class="headerlink" title="2.id选择器"></a>2.id选择器</h2><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p>
<p>HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">#para1</span><br><span class="line">&#123;</span><br><span class="line">	text-align:center;</span><br><span class="line">	color:red;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;para1&quot;&gt;Hello World!&lt;/p&gt;</span><br><span class="line">&lt;p&gt;这个段落不受该样式的影响。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>不要以数字开头</p>
<h2 id="3-class选择器"><a href="#3-class选择器" class="headerlink" title="3.class选择器"></a>3.class选择器</h2><p>class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。</p>
<p>class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">.center</span><br><span class="line">&#123;</span><br><span class="line">	text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 class=&quot;center&quot;&gt;标题居中&lt;/h1&gt;</span><br><span class="line">&lt;p class=&quot;center&quot;&gt;段落居中。&lt;/p&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>你也可以指定特定的HTML元素使用class。比如<code>p.center</code> 就只有标了类属性的段落起作用</p>
<h2 id="4-如何创建"><a href="#4-如何创建" class="headerlink" title="4.如何创建"></a>4.如何创建</h2><h3 id="（1）内联模式"><a href="#（1）内联模式" class="headerlink" title="（1）内联模式"></a>（1）内联模式</h3><p><code>&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</code></p>
<h3 id="2-内部样式表"><a href="#2-内部样式表" class="headerlink" title="(2) 内部样式表"></a>(2) 内部样式表</h3><p>上面的示例都是，<code>&lt;head&gt;</code>里的<code>&lt;style&gt;</code></p>
<h3 id="（3）外部样式表"><a href="#（3）外部样式表" class="headerlink" title="（3）外部样式表"></a>（3）外部样式表</h3><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。可以通过改变一个文件来改变整个站点的外观。</p>
<p>使用 <code>&lt;link&gt; </code>标签链接到样式表。</p>
<p>html中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>css：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hr &#123;color:sienna;&#125;</span><br><span class="line">p &#123;margin-left:20px;&#125;</span><br><span class="line">body &#123;background-image:url(&quot;/images/back40.gif&quot;);&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础-html层叠样式表</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTML/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML 是一种在 Web 上使用的通用标记语言。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示。</p>
<p>HTML 的关键是标签，其作用是指示将出现的内容。</p>
<p>页面F12看代码</p>
<!--         -->是注释语句。

<p>&lt;!     &gt;这不是，<!DOCTYPE HTML>这是放在第一行的声明，指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。</p>
<p>对于中文网页需要使用 <meta charset="utf-8"> 声明编码，否则会出现乱码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  //声明版本</span><br><span class="line">&lt;html&gt;     //根元素</span><br><span class="line">&lt;head&gt;    //包含文档元数据</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;    </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt;  //文档标题</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;    //可见的页面部分</span><br><span class="line">&lt;h1&gt;我的第一个标题&lt;/h1&gt;    //h1 -- h6</span><br><span class="line">&lt;hr&gt;       //一条水平线</span><br><span class="line">&lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">&lt;a href=&quot;https://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;   </span><br><span class="line">//&lt;a是标签   href是属性</span><br><span class="line">&lt;img loading=&quot;lazy&quot; src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;</span><br><span class="line">&lt;b&gt;加粗文本&lt;/b&gt;</span><br><span class="line">&lt;i&gt;斜体文本&lt;/i&gt;</span><br><span class="line">&lt;sub&gt; 下标&lt;/sub&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（1）元素-amp-标签"><a href="#（1）元素-amp-标签" class="headerlink" title="（1）元素 &amp; 标签"></a>（1）元素 &amp; 标签</h3><ul>
<li>HTML 元素以<strong>开始标签</strong>起始</li>
<li>HTML 元素以<strong>结束标签</strong>终止</li>
<li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li>
<li>大多数 HTML 元素可拥有<strong>属性</strong></li>
<li>HTML 标签对大小写不敏感：<P> 等同于 <p></p></P></li>
</ul>
<h3 id="（2）属性"><a href="#（2）属性" class="headerlink" title="（2）属性"></a>（2）属性</h3><ul>
<li>HTML 元素可以设置<strong>属性</strong></li>
<li>属性可以在元素中添加<strong>附加信息</strong></li>
<li>属性一般描述于<strong>开始标签</strong> &lt;&gt;里面</li>
<li>属性总是以名称/值对的形式出现，**比如：name=”value”**。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">class</td>
<td align="left">为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td>
</tr>
<tr>
<td align="left">id</td>
<td align="left">定义元素的唯一id</td>
</tr>
<tr>
<td align="left">style</td>
<td align="left">规定元素的行内样式（inline style）</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">描述了元素的额外信息 (作为工具条使用)</td>
</tr>
</tbody></table>
<h3 id="（3）可添加在头部的标签"><a href="#（3）可添加在头部的标签" class="headerlink" title="（3）可添加在头部的标签"></a>（3）可添加在头部<head>的标签</head></h3><head> 元素包含了所有的头部标签元素。在 <head>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。

<p>可以添加在头部区域的元素标签为:<code> &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;</code>。</p>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;title&gt;</code></td>
<td align="center">搜索引擎以及收藏夹中的标题</td>
</tr>
<tr>
<td align="center"><code>&lt;base&gt;</code></td>
<td align="center">定义了页面链接标签的默认链接地址</td>
</tr>
<tr>
<td align="center"><code>&lt;link&gt;</code></td>
<td align="center">文档和外部资源之间的关系</td>
</tr>
<tr>
<td align="center"><code>&lt;style&gt;</code></td>
<td align="center">定义了HTML文档的样式文件</td>
</tr>
<tr>
<td align="center"><code>&lt;meta&gt;</code></td>
<td align="center">定义了文档的元数据</td>
</tr>
<tr>
<td align="center"><code>&lt;script&gt;</code></td>
<td align="center">定义了客户端的脚本文件</td>
</tr>
</tbody></table>
<h3 id="（4）CSS"><a href="#（4）CSS" class="headerlink" title="（4）CSS"></a>（4）CSS</h3><p>CSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。使用方法：</p>
<ul>
<li>内联样式- 在HTML元素中使用”style” <strong>属性</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body style=&quot;background-color:yellow;&quot;&gt;</span><br><span class="line">&lt;h2 style=&quot;background-color:red;&quot;&gt;这是一个标题&lt;/h2&gt;</span><br><span class="line">&lt;p style=&quot;background-color:green;&quot;&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>内部样式表 -在HTML文档头部 <code>&lt;head&gt;</code> 区域使用<code>&lt;style&gt; </code><strong>标签</strong> 来包含CSS</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body &#123;background-color:yellow;&#125;</span><br><span class="line">p &#123;color:blue;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;这是一个标题&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这是一个段落。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部引用 - 使用外部 CSS <strong>文件</strong>（适合一个样式应用与多个页面）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（5）script脚本"><a href="#（5）script脚本" class="headerlink" title="（5）script脚本"></a>（5）script脚本</h3><p>JavaScript 使 HTML 页面具有更强的动态和交互性。</p>
<ul>
<li>使用<code>&lt;script&gt;</code>标签，可以在<code>&lt;head&gt;</code>也可以在<code>&lt;body&gt;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.write(&quot;Hello World!&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></head></head>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习与深度学习入门</title>
    <url>/2022/01/09/myblog/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="机器学习与深度学习的区别"><a href="#机器学习与深度学习的区别" class="headerlink" title="机器学习与深度学习的区别"></a>机器学习与深度学习的区别</h2><p>机器学习—拥有找一个函数的能力，根据输出的不同，分为regression回归、分类classification，以及很少提及的结构化学习structured learning（输出图像，文本）。</p>
<p>1.找一个带有未知参数的函数：y=b+wx，b偏置，w权重，机器学习中，未知的参数是通过数据来学习的。带有未知参数的函数称为model模型。</p>
<p>2.从训练数据中定义Loss（损失），Loss是关于参数b、w的函数，用来判断一组参数值好还是不好。<br>用训练集计算误差，可以是绝对值误差MAE，也可以是均方误差MSE。<br>如果y值是基于概率分布的，一般采取cross-entropy交叉熵，可以绘制误差等高线图error surface。</p>
<p>3.优化，找一组最好的参数w，b使得误差最小。<br>Gradient Descent 梯度下降。举例先只有一个参数w，绘制横坐标为w对应的损失函数曲线，初始时取一个点，随机取的，也可以用遗传算法给出一个较优的模型初始参数。选定一个随机初始值，求该点的偏导值，即该点曲线切线的斜率。然后进行移动点，跨度多少取决于斜率大小，斜率越大，跨度越大，此外，还有一个η，称为learning rate 学习率，自己设定，η越大跨度越大，训练越快。机器学习中需要自己设定的值称为超参数hyperparameters。以此类推，求下一个点下下个点。停止的时机：看预设的迭代次数，或者某一组参数计算出的微分值刚好是0，则停止训练，是个局部最优，不保证全部最优解。</p>
<p>对模型的修改需要对问题的具体理解，考虑前七天比只考虑前一天的误差要小。x是前一天的，y是预测的后一天的。考虑前七天的话，就有七个w。训练数据集是已知的，测试数据集是本来假装不知道的，也就是要预测的y。</p>
<p>输入x乘权重，再加上一个偏置的模型，称为线性模型。</p>
<p>线性模型具有局限性，模型偏差。</p>
<p>有时是分段线性折线函数=常数+一些列的分段斜线。</p>
<p>有时是曲线：可以用分段线性折线逼近连续曲线，需要足够的切分。（也可以用max(0,斜线)叠加表示）</p>
<p>分段斜线可以用sigmoid函数来逼近。</p>
<p><img src="https://img-blog.csdnimg.cn/db4301aa58234ae881c7774fb1472f4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_18,color_FFFFFF,t_70,g_se,x_16"></p>
<p>改变w，可以改变坡度。改变b可以左右移动。改变c可以改变高度。</p>
<p><img src="https://img-blog.csdnimg.cn/b57fe006fd424401b0976b630ed3331b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>来源：<a href="https://www.bilibili.com/video/BV1qP4y147PJ/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1qP4y147PJ/?spm_id_from=333.788.recommend_more_video.-1</a></p>
<p>总结来讲：首先选择模型，线性模型或者复杂逼近曲线，最小化损失函数，用梯度下降法，选择初始值迭代计算进行逼近。</p>
<p>Sigmold函数和ReLU在机器学习中，称为激活函数。可以将激活函数过程重复几次，来优化模型。激活函数的部分叫做神经元，很多神经元组成神经网络。每一列神经元称为隐藏层，很多层影藏层形成深度学习。</p>
<p>AlexNet16层。VGG19层。GoogleNet22层。ResidualNet152层。并不是层数越多网络越深预测的效果就更好，会发生过拟合Overfitting。</p>
<h2 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h2><h3 id="1-机器学习概述"><a href="#1-机器学习概述" class="headerlink" title="1.机器学习概述"></a>1.机器学习概述</h3><h4 id="1-1-人工智能概述"><a href="#1-1-人工智能概述" class="headerlink" title="1.1.人工智能概述"></a>1.1.人工智能概述</h4><p>1956年达特茅斯会议，人工智能元年。最初是用来搞统计的。</p>
<p>人工智能包括机器学习，机器学习包括深度学习。<br>机器学习是人工智能的实现途径（1980s开始）<br>深度学习（人工神经网络）是机器学习的方法（2020开始）</p>
<h4 id="1-2-人工智能的几个方向："><a href="#1-2-人工智能的几个方向：" class="headerlink" title="1.2.人工智能的几个方向："></a>1.2.人工智能的几个方向：</h4><p>传统预测（量化投资、广告推荐等）<br>图像cv（人脸识别、图像检测）<br>自然语言处理nlp（翻译、智能客服）</p>
<h4 id="1-3-机器学习概述"><a href="#1-3-机器学习概述" class="headerlink" title="1.3.机器学习概述"></a>1.3.机器学习概述</h4><p>机器学习是从数据中自动分析获得模型，并利用模型对未知数据进行预测。</p>
<p>机器学习：数据 -（训练）- 模型 - 预测<br>人：经验 - （归纳）- 规律 - 预测</p>
<h4 id="1-4-数据集构成"><a href="#1-4-数据集构成" class="headerlink" title="1.4.数据集构成"></a>1.4.数据集构成</h4><p>特征值（房子面积、位置、楼层） + 目标值（房价）</p>
<p>每一行是一个样本。<br>数据集可以没有目标值。</p>
<h4 id="1-5-机器学习算法分类"><a href="#1-5-机器学习算法分类" class="headerlink" title="1.5.机器学习算法分类"></a>1.5.机器学习算法分类</h4><p>目标值：类别 - 分类问题（人脸识别）<br>目标值：连续型数据 - 回归问题<br>目标值：无 - 无监督学习</p>
<ul>
<li>监督学习(supervised learning)（预测）<br>定义：输入数据是由输入特征值和目标值所组成。函数的输出可以是一个连续的值(称为回归），或是输出是有限个离散值（称作分类）。<br>分类： k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络<br>回归： 线性回归、岭回归</li>
<li>无监督学习(unsupervised learning)<br>定义：输入数据是由输入特征值所组成。<br>聚类： k-means</li>
</ul>
<p>还有半监督学习，强化学习。</p>
<h4 id="1-6-机器学习开发流程"><a href="#1-6-机器学习开发流程" class="headerlink" title="1.6.机器学习开发流程"></a>1.6.机器学习开发流程</h4><p>获取数据 -&gt; 数据预处理 -&gt; 特征工程 -&gt; 机器学习算法与训练 -&gt; 模型评估 -&gt; 应用</p>
<p>算法是核心，数据、计算是基础。</p>
<p>从入门到实际，再到理论。</p>
<p>库和框架：Scikit-learn、Tensflow（深度学习框架）</p>
<h3 id="2-特征工程"><a href="#2-特征工程" class="headerlink" title="2.特征工程"></a>2.特征工程</h3><h4 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1.数据集"></a>2.1.数据集</h4><p>✅可用数据集：<br>scikitlearn特点：1、数据量较小  2、方便学习<br>scikit-learn网址：<a href="http://scikit-learn.org/stable/datasets/index.html#datasets">http://scikit-learn.org/stable/datasets/index.html#datasets</a></p>
<p>Kaggle特点：1、大数据竞赛平合   2、80万科学家   3、真实数据     4、数据量巨大<br>Kaggle网址：<a href="https://www.kaggle.com/datasets">https://www.kaggle.com/datasets</a></p>
<p>Uc特点：1、收录了360个数据集    2、覆盖科学、生活、经济等领域   3、数据量几十万<br>UCI数据集网址： <a href="http://archive.ics.uci.edu/ml/">http://archive.ics.uci.edu/ml/</a></p>
<p>✅Scikit-learn：<br>Python语言的机器学习工具<br>Scikit-learn包括许多知名的机器学习算法的实现<br>Scikit-learn文档完善，容易上手，丰富的API</p>
<p>✅安装：<br><code>pip3 install sklearn</code>  安装<br><code>pip3 list</code>   查看一下<br><code>python3</code>  进入python<br><code>import sklearn</code>  验证一下</p>
<p>✅获取数据集api：<br>sklearn.datasets 加载获取流行数据集<br>1、datasets.load_*()<br>获取小规模数据集，数据包含在datasets里<br>2、datasets.fetch_*(data_home=None)<br>获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录,默认是 ~/scikit_learn_data/<br>datasets.fetch_20newsgroups(data_home=None,subset=‘train’)<br>subset：’train’或者’test’，’all’，可选，选择要加载的数据集。<br>训练集的“训练”，测试集的“测试”，两者的“全部”</p>
<blockquote>
<p>load和fetch返回的数据类型datasets.base.Bunch(字典格式)<br>data：特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组<br>target：标签数组，是 n_samples 的一维 numpy.ndarray 数组<br>DESCR：数据描述<br>feature_names：特征名,新闻数据，手写数字、回归数据集没有<br>target_names：标签名</p>
</blockquote>
<p>**Bunch(字典格式)**，继承自字典的数据结构，可以键值对，也可以点属性。</p>
<p>✅数据集的划分api：划分为训练数据和测试数据</p>
<p>训练数据：用于训练，构建模型    70% 80% 75%<br>测试数据：在模型检验时使用，用于评估模型是否有效    30% 20% 30%</p>
<p>sklearn.model_selection.train_test_split(arrays, *options)</p>
<blockquote>
<p>x 数据集的特征值<br>y 数据集的标签值<br>test_size 测试集的大小，一般为float<br>random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。<br>return 测试集特征训练集特征值值，训练标签，测试标签(默认随机取)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn .datasets import load_iris</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line"></span><br><span class="line">def datasets_demo():</span><br><span class="line">    # 获取数据集</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    print(&quot;鸢尾花数据集：\n&quot;, iris)</span><br><span class="line">    print(&quot;查看数据集描述：\n&quot;, iris[&quot;DESCR&quot;])</span><br><span class="line">    print(&quot;查看特征值名字：\n&quot;, iris.feature_names)</span><br><span class="line">    print(&quot;查看样本数：\n&quot;, iris.data.shape)</span><br><span class="line"></span><br><span class="line">    # 数据集划分</span><br><span class="line">    # 训练集的特征值x_train 测试集的特征值x_test 训练集的目标值y_train 测试集的目标值y_test</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2, random_state=22)</span><br><span class="line">    print(&quot;x_train:\n&quot;, x_train.shape)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # sklearn数据集使用</span><br><span class="line">    datasets_demo()</span><br></pre></td></tr></table></figure>

<h4 id="2-2-特征工程"><a href="#2-2-特征工程" class="headerlink" title="2.2.特征工程"></a>2.2.特征工程</h4><p>什么是特征工程：<br>特征工程是使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好的作用的过程。<br>意义：会直接影响机器学习的效果</p>
<p>重要性：<br>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</p>
<p>pandas:一个数据读取非常方便以及基本的处理格式的工具（数据清洗、数据处理）<br>sklearn:对于特征的处理提供了强大的接口</p>
<p>特征工程包括：<br>特征抽取、特征预处理、特征降维</p>
<h5 id="✅特征抽取"><a href="#✅特征抽取" class="headerlink" title="✅特征抽取"></a>✅特征抽取</h5><p>将任意数据（如文本或图像）转换为可用于机器学习的数字特征<br>也叫特征值化，是为了计算机更好的去理解数据<br>分为：<br>1.字典特征提取(特征离散化)<br>2.文本特征提取<br>3.图像特征提取（深度学习将介绍）</p>
<p>特征提取的API：<br><code>sklearn.feature_extraction</code></p>
<p><strong>字典特征提取</strong>：对字典数据进行特征值化<br><code>sklearn.feature_extraction.DictVectorizer(sparse=True,…)</code><br><code>DictVectorizer.fit_transform(X)</code> X:字典或者包含字典的迭代器返回值：返回sparse矩阵<br><code>CountVectorizer.get_feature_names()</code> 返回值:单词列表<br>字典 -&gt; 矩阵（二维数组）（其中字典每一行是一个矢量，也就是一维数组）<br>其中属于类别的，会用onehot编码，比如有三类，会变成三列。<br>对于特征当中存在类别信息的我们都会做one-hot编码处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_extraction import DictVectorizer</span><br><span class="line"></span><br><span class="line">def dict_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对字典类型的数据进行特征抽取</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&#123;&#x27;city&#x27;: &#x27;北京&#x27;,&#x27;temperature&#x27;:100&#125;, &#123;&#x27;city&#x27;: &#x27;上海&#x27;,&#x27;temperature&#x27;:60&#125;, &#123;&#x27;city&#x27;: &#x27;深圳&#x27;,&#x27;temperature&#x27;:30&#125;]</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = DictVectorizer(sparse=False)</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(data)</span><br><span class="line">    print(&quot;返回的结果:\n&quot;, data)</span><br><span class="line">    # 打印特征名字</span><br><span class="line">    print(&quot;特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">返回的结果:</span><br><span class="line"> [[  0.   1.   0. 100.]</span><br><span class="line"> [  1.   0.   0.  60.]</span><br><span class="line"> [  0.   0.   1.  30.]]</span><br></pre></td></tr></table></figure>
<p>没有加上sparse=False参数的结果是矩阵1的位置，<strong>稀疏矩阵</strong>，优点：节省内存，提高加载速度。</p>
<p>字典特征提取的使用场景：<br>1、数据集中类别特征比较多<br>2、本身拿到的就是字典类型</p>
<p><strong>文本特征提取</strong>：对文本数据进行特征值化<br>单词作为特征最合适。</p>
<p><strong>1.countVectorizer文本特征提取 - 出现个数</strong></p>
<p>api：<br><code>sklearn.feature_extraction.text.CountVectorizer(stop_words=[])</code>      返回词频矩阵（统计每个样本特征词出现的个数），stop_words是停用词，没有用的词，比如to，以列表形式传入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CountVectorizer.fit_transform(X)    X:文本或者包含文本字符串的可迭代对象 返回值：返回sparse矩阵</span><br><span class="line">CountVectorizer.inverse_transform(X)    X:array数组或者sparse矩阵 返回值:转换之前数据格</span><br><span class="line">CountVectorizer.get_feature_names()     返回值:单词列表</span><br></pre></td></tr></table></figure>
<p>标点和字母不作为特征词列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def text_count_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对文本进行特征抽取，countvetorizer</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&quot;life is short,i like like python&quot;, &quot;life is too long,i dislike python&quot;]</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    # transfer = CountVectorizer(sparse=False)</span><br><span class="line">    transfer = CountVectorizer()</span><br><span class="line">    # 2、调用fit_transform （（注意返回格式，利用toarray()方法进行sparse矩阵转换array数组））</span><br><span class="line">    data = transfer.fit_transform(data)</span><br><span class="line">    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())</span><br><span class="line">    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 3、文本特征提取</span><br><span class="line">    text_count_demo()</span><br></pre></td></tr></table></figure>

<p>[“life is short,i like like python”, “life is too long,i dislike python”]<br>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回特征名字：</span><br><span class="line"> [&#x27;dislike&#x27;, &#x27;is&#x27;, &#x27;life&#x27;, &#x27;like&#x27;, &#x27;long&#x27;, &#x27;python&#x27;, &#x27;short&#x27;, &#x27;too&#x27;]</span><br><span class="line">文本特征抽取的结果：</span><br><span class="line"> [[0 1 1 2 0 1 1 0]</span><br><span class="line"> [1 1 1 0 1 1 0 1]]</span><br></pre></td></tr></table></figure>

<p><strong>jieba分词</strong><br>如果样本是中文，整个短语变成特征词了，得用空格隔开。用jieba分词可以分开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.feature_extraction.text import CountVectorizer</span><br><span class="line">import jieba</span><br><span class="line"></span><br><span class="line">def cut_word(text):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对中文进行分词</span><br><span class="line">    &quot;我爱北京天安门&quot;————&gt;&quot;我 爱 北京 天安门&quot;</span><br><span class="line">    :param text:</span><br><span class="line">    :return: text</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 用结巴对中文字符串进行分词，想要字符串</span><br><span class="line">    text = &quot; &quot;.join(list(jieba.cut(text)))</span><br><span class="line"></span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line">def text_chinese_count_demo2():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对中文进行特征抽取</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&quot;今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;,</span><br><span class="line">            &quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;,</span><br><span class="line">            &quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;]</span><br><span class="line">    # 将原始数据转换成分好词的形式</span><br><span class="line">    text_list = []</span><br><span class="line">    for sent in data:</span><br><span class="line">        text_list.append(cut_word(sent))</span><br><span class="line">    print(text_list)</span><br><span class="line"></span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    # transfer = CountVectorizer(sparse=False)</span><br><span class="line">    transfer = CountVectorizer(stop_words=[&quot;一种&quot;])</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(text_list)</span><br><span class="line">    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())</span><br><span class="line">    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 4、中文文本特征提取</span><br><span class="line">    text_chinese_count_demo2()</span><br></pre></td></tr></table></figure>

<p>但是这样有个问题：想找的关键词其实是在某一个类别的文章中出现的次数很多，但是在其他类别的文章中出现次数很少，不要我们这些词。</p>
<p><strong>2.Tf-idf文本特征提取 - 重要程度</strong></p>
<p>TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。<br>TF-IDF作用：用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。<br>分类机器学习算法进行文章分类中前期数据处理方式</p>
<p>公式：<br>词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率<br>逆向文档频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到</p>
<p>例子：<br>注：假如一篇文件的总词语数是100个，而词语”非常”出现了5次，那么”非常”一词在该文件中的词频就是5/100=0.05。而计算文件频率（IDF）的方法是以文件集的文件总数，除以出现”非常”一词的文件数。所以，如果”非常”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是lg（10,000,000 / 1,0000）=3。最后”非常”对于这篇文档的tf-idf的分数为0.05 * 3=0.15。</p>
<p>API：<br><code>transfer = TfidfVectorizer(stop_words=[&#39;一种&#39;, &#39;不会&#39;, &#39;不要&#39;])</code><br><code>data = transfer.fit_transform(text_list)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def text_chinese_tfidf_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对中文进行特征抽取</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [&quot;一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;,</span><br><span class="line">            &quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;,</span><br><span class="line">            &quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;]</span><br><span class="line">    # 将原始数据转换成分好词的形式</span><br><span class="line">    text_list = []</span><br><span class="line">    for sent in data:</span><br><span class="line">        text_list.append(cut_word(sent))</span><br><span class="line">    print(text_list)</span><br><span class="line"></span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    # transfer = CountVectorizer(sparse=False)</span><br><span class="line">    transfer = TfidfVectorizer(stop_words=[&#x27;一种&#x27;, &#x27;不会&#x27;, &#x27;不要&#x27;])</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(text_list)</span><br><span class="line">    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())</span><br><span class="line">    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 5、tfidf文本提取</span><br><span class="line">    text_chinese_tfidf_demo()</span><br></pre></td></tr></table></figure>


<h5 id="✅特征预处理"><a href="#✅特征预处理" class="headerlink" title="✅特征预处理"></a>✅特征预处理</h5><p>scikit-learn的解释：<br><code>provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators.</code><br>翻译过来：通过一些转换函数将特征数据转换成更加适合算法模型的特征数据的过程</p>
<p>数值型数据的<strong>无量纲化</strong>：<br>归一化<br>标准化</p>
<p>api：<br><code>sklearn.preprocessing</code></p>
<p>为什么我们要进行归一化/标准化(无量纲化)？<br>特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级，容易影响（支配）目标结果，使得一些算法无法学习到其它的特征。<br>量纲不统一<br>所以，需要用到一些方法进行无量纲化，使不同规格的数据转换到同一规格。</p>
<p><strong>归一化</strong><br>通过对原始数据进行变换把数据映射到(默认为[0,1])之间<br>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.preprocessing.MinMaxScaler (feature_range=(0,1)… )</span><br><span class="line">MinMaxScalar.fit_transform(X)</span><br><span class="line">X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：转换后的形状相同的array</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from sklearn.preprocessing import MinMaxScaler</span><br><span class="line"></span><br><span class="line">def minmax_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    归一化演示</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 0、pandas读取文本</span><br><span class="line">    data = pd.read_csv(&quot;dating.txt&quot;)</span><br><span class="line">    # 不要目标值每一行都要，要前三列</span><br><span class="line">    data = data.iloc[:, :3]</span><br><span class="line">    print(data)</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = MinMaxScaler(feature_range=(2, 3))</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(data[[&#x27;milage&#x27;,&#x27;Liters&#x27;,&#x27;Consumtime&#x27;]])</span><br><span class="line">    print(&quot;最小值最大值归一化处理的结果：\n&quot;, data)</span><br><span class="line"></span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 6、特征预处理-归一化</span><br><span class="line">    minmax_demo()</span><br></pre></td></tr></table></figure>

<p>归一化缺点：最大值最小值是变化的，另外，最大值与最小值（可能是异常值）非常容易受异常点影响，所以这种方法鲁棒性较差，只适合传统精确小数据场景。</p>
<p><strong>标准化</strong><br>通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内<br>公式：<br>(原值 - 平均值) / 标准差<br>优点：<br>对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变<br>对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。<br>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.preprocessing.StandardScaler( )</span><br><span class="line">处理之后每列来说所有数据都聚集在均值0附近标准差差为1</span><br><span class="line">StandardScaler.fit_transform(X)</span><br><span class="line">X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：转换后的形状相同的array</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">def stand_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    标准化演示</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = pd.read_csv(&quot;dating.txt&quot;)</span><br><span class="line">    print(data)</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data = transfer.fit_transform(data[[&#x27;milage&#x27;,&#x27;Liters&#x27;,&#x27;Consumtime&#x27;]])</span><br><span class="line">    print(&quot;标准化的结果:\n&quot;, data)</span><br><span class="line">    print(&quot;每一列特征的平均值：\n&quot;, transfer.mean_)</span><br><span class="line">    print(&quot;每一列特征的方差：\n&quot;, transfer.var_)</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>
<p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。</p>
<h5 id="✅特征降维"><a href="#✅特征降维" class="headerlink" title="✅特征降维"></a>✅特征降维</h5><p>ndarray<br>维数：嵌套的层数<br>0维：标量<br>1维：向量<br>2维：矩阵<br>3维：</p>
<p>此处的降维的对象是二维数组（几行表示几个样本，几列表示几个特征），目标是<strong>降低特征的个数</strong>。</p>
<p>降维是指在某些限定条件下，降低随机变量(特征)个数，得到一组“不相关”主变量的过程。</p>
<p>相关的特征：比如湿度与降雨量</p>
<p>为什么要特征降维？<br>正是因为在进行训练的时候，我们都是使用特征进行学习。如果特征本身存在问题或者特征之间相关性较强，对于算法学习预测会影响较大。</p>
<p><strong>第一部分：特征选择</strong><br>数据中包含冗余或无关变量（或称特征、属性、指标等），旨在从原有特征中找出主要特征。（例如鸟是否有爪子就是冗余特征）<br>**Filter(过滤式)**：主要探究特征本身特点、特征与特征和目标值之间关联<br>方差选择法：低方差特征过滤<br>相关系数：衡量某两个特征之间的相关程度<br>**Embedded (嵌入式)**：算法自动选择特征（特征与目标值之间的关联）<br>决策树:信息熵、信息增益<br>正则化：L1、L2<br>深度学习：卷积等</p>
<p>模块：<br><code>sklearn.feature_selection</code></p>
<p>过滤式：<br><strong>低方差特征过滤</strong>：删除低方差的一些特征<br>特征方差小：某个特征大多样本的值比较相近，比如都是有爪子，就是0<br>特征方差大：某个特征很多样本的值都有差别<br>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.feature_selection.VarianceThreshold(threshold = 0.0)</span><br><span class="line">删除所有低方差特征</span><br><span class="line">Variance.fit_transform(X)</span><br><span class="line">X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：训练集差异低于threshold的特征将被删除。默认值是保留所有非零方差特征，即删除所有样本中具有相同值的特征。</span><br></pre></td></tr></table></figure>

<p>低方差特征过滤例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def variance_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    删除低方差特征——特征选择</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = pd.read_csv(&quot;factor_returns.csv&quot;)</span><br><span class="line">    print(data)</span><br><span class="line">    # 1、实例化一个转换器类</span><br><span class="line">    transfer = VarianceThreshold(threshold=1)</span><br><span class="line">    # 2、调用fit_transform，iloc去掉一些无用的列</span><br><span class="line">    data = transfer.fit_transform(data.iloc[:, 1:10])</span><br><span class="line">    print(&quot;删除低方差特征的结果：\n&quot;, data)</span><br><span class="line">    print(&quot;形状：\n&quot;, data.shape)</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>
<p>效果：去掉了一些没用的冗余的特征</p>
<p><strong>相关系数</strong>：<br>皮尔逊相关系数(Pearson Correlation Coefficient)<br>反映变量之间相关关系密切程度的统计指标，公式略。<br>相关系数解读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关系数的值介于–1与+1之间，即–1≤ r ≤+1。其性质如下：</span><br><span class="line"></span><br><span class="line">当r&gt;0时，表示两变量正相关，r&lt;0时，两变量为负相关</span><br><span class="line">当|r|=1时，表示两变量为完全相关，当r=0时，表示两变量间无相关关系</span><br><span class="line">当0&lt;|r|&lt;1时，表示两变量存在一定程度的相关。且|r|越接近1，两变量间线性关系越密切；|r|越接近于0，表示两变量的线性相关越弱</span><br><span class="line">一般可按三级划分：|r|&lt;0.4为低度相关；0.4≤|r|&lt;0.7为显著性相关；0.7≤|r|&lt;1为高度线性相关</span><br></pre></td></tr></table></figure>
<p>api:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from scipy.stats import pearsonr</span><br><span class="line">x : (N,) array_like</span><br><span class="line">y : (N,) array_like Returns: (Pearson’s correlation coefficient, p-value)</span><br></pre></td></tr></table></figure>

<p>相关系数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from scipy.stats import pearsonr</span><br><span class="line"></span><br><span class="line">def pearsonr_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    相关系数计算</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = pd.read_csv(&quot;factor_returns.csv&quot;)</span><br><span class="line"></span><br><span class="line">    factor = [&#x27;pe_ratio&#x27;, &#x27;pb_ratio&#x27;, &#x27;market_cap&#x27;, &#x27;return_on_asset_net_profit&#x27;, &#x27;du_return_on_equity&#x27;, &#x27;ev&#x27;,</span><br><span class="line">              &#x27;earnings_per_share&#x27;, &#x27;revenue&#x27;, &#x27;total_expense&#x27;]</span><br><span class="line"></span><br><span class="line">    for i in range(len(factor)):</span><br><span class="line">        for j in range(i, len(factor) - 1):</span><br><span class="line">            print(</span><br><span class="line">                &quot;指标%s与指标%s之间的相关性大小为%f&quot; % (factor[i], factor[j + 1], pearsonr(data[factor[i]], data[factor[j + 1]])[0]))</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>也可以通过画图来观察结果，散点图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.figure(figsize=(20, 8), dpi=100)</span><br><span class="line">plt.scatter(data[&#x27;revenue&#x27;], data[&#x27;total_expense&#x27;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>如果两个特征相关性很高：<br>1.可以选取其中一个<br>2.可以按一定权重加权两个特征<br>3.主成分分析，自动将相关性很强的特征合成</p>
<p><strong>第二部分：主成分分析</strong><br>定义：高维数据转化为低维数据的过程，在此过程中可能会舍弃原有数据、创造新的变量。PCA：主成分分析<br>作用：是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。<br>应用：回归分析或者聚类分析当中<br>抽象理解：将一个三维的东西拍成一个二维的照片，尽可能保留更多的信息，保持原有的特征。<br>再比如：二维的几个点降到一维（一条线），想投影到一条线之后，五个点也还在，且距离直接之和更少。找到一个合适的直线，通过一个矩阵运算得出主成分分析的结果。</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.decomposition.PCA(n_components=None)</span><br><span class="line">将数据分解为较低维数空间</span><br><span class="line">n_components:</span><br><span class="line">小数：表示保留百分之多少的信息</span><br><span class="line">整数：减少到多少特征</span><br><span class="line">PCA.fit_transform(X) X:numpy array格式的数据[n_samples,n_features]</span><br><span class="line">返回值：转换后指定维度的array</span><br></pre></td></tr></table></figure>

<p>三个特征降维的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.decomposition import PCA</span><br><span class="line"></span><br><span class="line">def pca_demo():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    对数据进行PCA降维</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data = [[2,8,4,5], [6,3,0,8], [5,4,9,1]]</span><br><span class="line"></span><br><span class="line">    # 1、实例化PCA, 小数——保留多少信息</span><br><span class="line">    transfer = PCA(n_components=0.9)</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data1 = transfer.fit_transform(data)</span><br><span class="line"></span><br><span class="line">    print(&quot;保留90%的信息，降维结果为：\n&quot;, data1)</span><br><span class="line"></span><br><span class="line">    # 1、实例化PCA, 整数——指定降维到的维数</span><br><span class="line">    transfer2 = PCA(n_components=3)</span><br><span class="line">    # 2、调用fit_transform</span><br><span class="line">    data2 = transfer2.fit_transform(data)</span><br><span class="line">    print(&quot;降维到3维的结果：\n&quot;, data2)</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保留90%的信息，降维结果为：</span><br><span class="line"> [[ -3.13587302e-16   3.82970843e+00]</span><br><span class="line"> [ -5.74456265e+00  -1.91485422e+00]</span><br><span class="line"> [  5.74456265e+00  -1.91485422e+00]]</span><br><span class="line">降维到3维的结果：</span><br><span class="line"> [[ -3.13587302e-16   3.82970843e+00   4.59544715e-16]</span><br><span class="line"> [ -5.74456265e+00  -1.91485422e+00   4.59544715e-16]</span><br><span class="line"> [  5.74456265e+00  -1.91485422e+00   4.59544715e-16]]</span><br></pre></td></tr></table></figure>

<p><strong>第三部分：案例：探究用户对物品类别的喜好细分降维</strong></p>
<p>1）合并表，使得user_id与aisle在一张表当中<br>2）进行交叉表变换-交叉表透视表<br>3）特征冗余过多-PCA降维</p>
<p>pandas可以读取csv文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(“./route”)</span><br><span class="line">table3 = pd.merge(table1, table2, on=[“uid”, “uid”]) //用来合并表，默认内连接</span><br><span class="line"></span><br><span class="line">3、交叉表处理，把user_id和aisle进行分组</span><br><span class="line">table = pd.crosstab(tab3[&quot;user_id&quot;], tab3[&quot;aisle&quot;])</span><br><span class="line"></span><br><span class="line">4、主成分分析的方法进行降维</span><br><span class="line"> 1）实例化一个转换器类PCA</span><br><span class="line">transfer = PCA(n_components=0.95)</span><br><span class="line"> 2）fit_transform</span><br><span class="line">data = transfer.fit_transform(table)</span><br><span class="line"></span><br><span class="line">data.shape</span><br></pre></td></tr></table></figure>
<p>Jupiter 处理数据的工具，可视化数据。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://img-blog.csdnimg.cn/f293d52326fb423aa007de3748b7598e.png"></p>
<h3 id="3-分类算法"><a href="#3-分类算法" class="headerlink" title="3.分类算法"></a>3.分类算法</h3><p>目标值：类别</p>
<h4 id="3-1-sklearn转换器和预估器-estimator"><a href="#3-1-sklearn转换器和预估器-estimator" class="headerlink" title="3.1 sklearn转换器和预估器(estimator)"></a>3.1 sklearn转换器和预估器(estimator)</h4><p>  3.1.1 转换器-特征工程的父类<br>    1 实例化（实例化的是一个转换器类（Transformer））<br>    2 调用fit_transform 标准化，是fit计算每一列平均值和标准差 transform进行计算转换</p>
<p>  3.1.2 估计器-sklearn机器学习算法的实现<br>    1 实例化一个eatimator<br>    2 estimator.fit(x_train, y_train) 计算 — 调用完毕，模型生成<br>    3 模型评估<br>      1）直接对比真实值和预测值<br>        y_predict = estimator.predictor(x_test)<br>        y_test = y_predict<br>      2）计算准确率<br>      accuracy = estimator.score(x_test, y_test)</p>
<h4 id="3-2-K-近邻算法-KNN算法"><a href="#3-2-K-近邻算法-KNN算法" class="headerlink" title="3.2 K-近邻算法(KNN算法)"></a>3.2 K-近邻算法(KNN算法)</h4><p>  核心思想：根据邻居来推断出类别<br>  3.2.1 KNN算法原理<br>     如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。<br>    k=1 容易收到异常点的影响<br>    如何确定谁是邻居，计算距离 eg：欧氏距离（默认），曼哈顿距离（绝对值距离），明可夫斯基距离<br>    例子：电影分类：先求距离，再取k。<br>    K值取得过大：容易收到样本不均衡的影响。</p>
<p>  3.2.2 k-近邻算法api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=&#x27;auto&#x27;)</span><br><span class="line">	◦	n_neighbors：k值，int,可选（默认= 5），k_neighbors查询默认使用的邻居数</span><br><span class="line">	◦	algorithm：&#123;‘auto’，‘ball_tree’，‘kd_tree’，‘brute’&#125;，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)</span><br></pre></td></tr></table></figure>

<p>  3.2.3 案例：鸢尾花种类预测<br>    1）获取数据，四个特征<br>    2）数据集划分<br>    3）特征工程：标准化<br>    4）KNN预估器流程<br>    5）模型评估</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">def knn_iris():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    案例：鸢尾花种类预测</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据，四个特征</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）数据集划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）特征工程：标准化 1.实例化一个转换器类 2.对训练集和测试集标准化（测试集用训练集fit的结果）</span><br><span class="line">    transform = StandardScaler()</span><br><span class="line">    x_train = transform.fit_transform(x_train)</span><br><span class="line">    x_test = transform.transform(x_test)</span><br><span class="line">    # 4）KNN预估器流程：1.实例化一个预估器对象 2.将训练集的特征值和目标值传入进行训练</span><br><span class="line">    estimator = KNeighborsClassifier(n_neighbors=3)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line">    # 5）模型评估  1.直接比对真实值和预估值 2.计算准确率</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 代码1.knn算法对iris进行分类</span><br><span class="line">    knn_iris()</span><br></pre></td></tr></table></figure>

<p>  3.2.4 knn优缺点<br>    •    优点：<br>    ◦    简单，易于理解，易于实现，无需训练<br>    •    缺点：<br>    ◦    懒惰算法，对测试样本分类时的计算量大，内存开销大<br>    ◦    必须指定K值，K值选择不当则分类精度不能保证<br>    •    使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试</p>
<h4 id="3-3-模型选择与调优"><a href="#3-3-模型选择与调优" class="headerlink" title="3.3 模型选择与调优"></a>3.3 模型选择与调优</h4><p>  3.3.1 什么是交叉验证<br>交叉验证：将拿到的训练数据，分为训练和验证集。例如：将数据分成5份，其中一份作为验证集。然后经过5次(组)的测试，每次都更换不同的验证集。即得到5组模型的结果，取平均值作为最终结果。又称5折交叉验证。目的：让被评估的模型更加准确可信<br>  •    训练集：训练集+验证集<br>    •    测试集：测试集</p>
<p>  3.3.2 超参数搜索-网格搜索<br>  通常情况下，有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数。但是手动过程繁杂，所以需要对模型预设几种超参数组合。每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型</p>
<p>  3.3.3 模型选择与调优api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)</span><br><span class="line">◦	对估计器的指定参数值进行详尽搜索</span><br><span class="line">◦	estimator：估计器对象</span><br><span class="line">◦	param_grid：估计器参数(dict)&#123;“n_neighbors”:[1,3,5]&#125;，将想要用的参数值以字典格式传入</span><br><span class="line">◦	cv：指定几折交叉验证，常用10折</span><br><span class="line">◦	fit：输入训练数据</span><br><span class="line">◦	score：准确率</span><br><span class="line">◦	结果分析：</span><br><span class="line">▪	best_param：最佳参数</span><br><span class="line">▪	bestscore：最佳结果</span><br><span class="line">▪	best_estimator：最佳估计器</span><br><span class="line">▪	cv_results：交叉验证结果-每次交叉验证后的验证集准确率结果和训练集准确率结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def knn_iris_gscv():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    案例：鸢尾花种类预测knn,添加网格搜索和交叉验证</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据，四个特征</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）数据集划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）特征工程：标准化 1.实例化一个转换器类 2.对训练集和测试集标准化（测试集用训练集fit的结果）</span><br><span class="line">    transform = StandardScaler()</span><br><span class="line">    x_train = transform.fit_transform(x_train)</span><br><span class="line">    x_test = transform.transform(x_test)</span><br><span class="line">    # 4）KNN预估器流程：1.实例化一个预估器对象 2.将训练集的特征值和目标值传入进行训练</span><br><span class="line">    estimator = KNeighborsClassifier()</span><br><span class="line">    # 加入网格搜索和交叉验证</span><br><span class="line">    # 参数准备</span><br><span class="line">    param_dict = &#123;&quot;n_neighbors&quot;: [3, 5, 10]&#125;</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=10)</span><br><span class="line">    estimator.fit(x_train, y_train)</span><br><span class="line">    # 5）模型评估  1.直接比对真实值和预估值 2.计算准确率</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)  # 测试集的结果</span><br><span class="line">    print(&quot;最佳参数:\n&quot;, estimator.best_params_)</span><br><span class="line">    print(&quot;最佳结果:\n&quot;, estimator.best_score_)  # 验证集的结果</span><br><span class="line">    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)</span><br><span class="line">    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>


<p>  3.3.4 案例-Facebook签到位置预测K值调优</p>
<pre><code>处理数据，反复调试，如果用pycharm，每次调试都要加载一次。所以用jupyter。

流程：
  1）获取数据
  2）数据处理：过滤无用数据，筛选特征值x和目标值y，数据集划分
</code></pre>
<p><code>data.head() data=data.query(“x&lt;2 &amp; x&gt;1”)</code><br><code>处理时间数据：time_value = pd.to_data_time(data[“time”], unit=“s”)  date = pd.DateTimeIndex(time_value)</code><br><code>对数据进行分组： data.groupby(“place”).count()</code><br>      3）特征工程：标准化<br>      4）KNN算法预估流程<br>      5）模型选择与调优<br>      6）模型评估</p>
<h4 id="3-4-朴素贝叶斯算法"><a href="#3-4-朴素贝叶斯算法" class="headerlink" title="3.4 朴素贝叶斯算法"></a>3.4 朴素贝叶斯算法</h4><p>3.4.1 什么是朴素贝叶斯算法：<br>给出分类事件每个类别的概率。</p>
<p>•    联合概率：包含多个条件，且所有条件同时成立的概率<br>◦    记作：P(A,B)<br>◦    特性：P(A, B) = P(A)P(B) &lt;=&gt; 事件AB相互独立<br>•    条件概率：就是事件A在另外一个事件B已经发生条件下的发生概率<br>◦    记作：P(A|B)</p>
<p>贝叶斯公式：<code>p(c|w) = [p(w|c)p(c)]/p(w)</code>。w为特征值，c为目标值。</p>
<p>朴素是什么：假定特征与特征之间相互独立。</p>
<p>应用场景：文本分类(单词作为特征，假设相互独立) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(C)：每个文档类别的概率(某文档类别数／总文档数量)</span><br><span class="line">P(W│C)：给定类别下特征（被预测文档中出现的词）的概率（某类别词1数量/某类别所有次数量）</span><br><span class="line">计算方法：P(F1│C)=Ni/N （训练文档中去计算）</span><br><span class="line">Ni为该F1词在C类别所有文档中出现的次数</span><br><span class="line">N为所属类别C下的文档所有词出现的次数和</span><br><span class="line">P(F1,F2,…) 预测文档中每个词的概率</span><br></pre></td></tr></table></figure>

<p>计算出来某个概率为0，怎么办？<br>拉普拉斯平滑系:  <code>p(w|c) = (ni+a)/(n+am)</code><br>目的：防止计算出的分类概率为0<br>a为指定的系数一般为1，m为训练文档中统计出的特征词有多少种</p>
<p>3.4.2 朴素贝叶斯api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.naive_bayes.MultinomialNB(alpha = 1.0)</span><br><span class="line">朴素贝叶斯分类</span><br><span class="line">alpha：拉普拉斯平滑系数</span><br></pre></td></tr></table></figure>

<p>3.4.3 案例：20类新闻分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def nbcls():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    朴素贝叶斯对新闻数据集进行预测</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 获取新闻的数据，20个类别</span><br><span class="line">    news = fetch_20newsgroups(data_home=&#x27;/Users/liuxuan/MyProject/pypro/python-learn&#x27;, subset=&#x27;all&#x27;)</span><br><span class="line">    # 划分数据集</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(news.data, news.target, test_size=0.3)</span><br><span class="line">    # 对于文本数据，进行特征抽取 1.获取实例化对象 2.转换</span><br><span class="line">    tf = TfidfVectorizer()</span><br><span class="line">    x_train = tf.fit_transform(x_train)</span><br><span class="line">    # 这里打印出来的列表是：训练集当中的所有不同词的组成的一个列表</span><br><span class="line">    print(tf.get_feature_names())</span><br><span class="line">    # print(x_train.toarray())</span><br><span class="line">    # 不能调用fit_transform</span><br><span class="line">    x_test = tf.transform(x_test)</span><br><span class="line">    # estimator估计器流程,并训练</span><br><span class="line">    mlb = MultinomialNB(alpha=1.0)</span><br><span class="line">    mlb.fit(x_train, y_train)</span><br><span class="line">    # 进行预测，验证</span><br><span class="line">    y_predict = mlb.predict(x_test)</span><br><span class="line">    print(&quot;预测每篇文章的类别：&quot;, y_predict[:100])</span><br><span class="line">    print(&quot;真实类别为：&quot;, y_test[:100])</span><br><span class="line">    print(&quot;预测准确率为：&quot;, mlb.score(x_test, y_test))</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>3.4.4 优缺点<br>优点：<br>朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。<br>对缺失数据不太敏感，算法也比较简单，常用于文本分类。<br>分类准确度高，速度快<br>缺点：<br>由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好</p>
<h4 id="3-5-决策树"><a href="#3-5-决策树" class="headerlink" title="3.5 决策树"></a>3.5 决策树</h4><p>决策树思想的来源非常朴素，程序设计中的条件分支结构就是if-then结构，最早的决策树就是利用这类结构分割数据的一种分类学习方法<br>思想：如何高效地进行决策，先看哪个再看哪个，决定特征的先后顺序。</p>
<p>3.5.1 决策树分类原理<br>用数学的方法来得到，应该先看哪个特征再看哪个特征。<br>信息论基础<br>信息：消除随机不定性的东西<br>信息的衡量 - 信息量 - 信息墒<br>p为每个球队获胜的概率（假设概率相等，都为1/32）<br>信息墒 H = -(p1logp1 + p2logp2 + … + p32logp32)=5bit<br>决策树的划分依据之一——信息增益<br>信息增益：特征A对训练数据集D的信息增益g(D,A),定义为集合D的信息熵H(D)与特征A给定条件下D的信息条件熵H(D|A)之差<br>（知道哪个特征之后，不确定性减少的量）<br><code>g(D,A)= H(D) - 条件墒H(D|A)</code><br>条件墒怎么算：特征A有多少种，每种分别计算信息墒，然后根据样本特征类种类比例累加。</p>
<p>3.5.2 决策树api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•	class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)</span><br><span class="line">◦	决策树分类器</span><br><span class="line">◦	criterion:默认是’gini’系数，也可以选择信息增益的熵’entropy’</span><br><span class="line">◦	max_depth:树的深度大小，太深容易过拟合</span><br><span class="line">◦	random_state:随机数种子</span><br><span class="line">•	其中会有些超参数：max_depth:树的深度大小</span><br><span class="line">◦	其它超参数我们会结合随机森林讲解</span><br></pre></td></tr></table></figure>
<p>步骤：<br>1）获取数据集<br>2）划分数据集，决策树不用做标准化<br>3）决策树预估器进行分类<br>4）模型评估</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def decision_iris():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用决策树对鸢尾花进行分类</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）划分数据集，决策树不用做标准化</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）决策树预估器进行分类</span><br><span class="line">    estimator = DecisionTreeClassifier(criterion=&#x27;entropy&#x27;)</span><br><span class="line">    estimator.fit(x_train,y_train)</span><br><span class="line">    # 4）模型评估</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)</span><br></pre></td></tr></table></figure>

<p>3.5.3 决策树可视化</p>
<p>1.保存树的结构到dot文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、sklearn.tree.export_graphviz() 该函数能够导出DOT格式</span><br><span class="line">	◦tree.export_graphviz(estimator,out_file=&#x27;tree.dot’,feature_names=[‘’,’’])</span><br><span class="line">2、复制文件内容到网站：http://www.webgraphviz.com</span><br><span class="line"></span><br><span class="line"> 可视化决策树</span><br><span class="line">export_graphviz(estimator, out_file=&#x27;iris_tree.dot&#x27;)</span><br></pre></td></tr></table></figure>

<p>3.5.4 决策树优缺点<br>    •    优点：<br>    ◦    简单的理解和解释，树木可视化。可理解性强，反观神经网络是个黑盒。<br>    •    缺点：<br>    ◦    容易产生过拟合。<br>    •    改进：<br>    ◦    减枝cart算法(决策树API当中已经实现，随机森林参数调优有相关介绍)<br>    ◦    随机森林<br>注：企业重要决策，由于决策树很好的分析能力，在决策过程应用较多， 可以选择特征</p>
<p>⚠️：特征转换为字典，进行字典特征抽取，因为one-hot编码特征变多，用get_feature_names，获取特征。</p>
<h4 id="3-6-随机森林"><a href="#3-6-随机森林" class="headerlink" title="3.6 随机森林"></a>3.6 随机森林</h4><p>什么是集成学习方法：<br>集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是生成多个分类器/模型，各自独立地学习和作出预测。这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。三个臭皮匠，顶一个诸葛亮。由分类结果的众数来决定目标值。</p>
<p>什么是随机森林：<br>在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。<br>3.6.1 随机森林原理过程<br>如何建造每棵树：两个随机：<br>N个样本，M个特征<br>1）训练集随机<br>采取bootstrap抽样（随机有放回抽样）<br>用N来表示训练用例（样本）的个数，M表示特征数目。<br>    ◦    1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）<br>    ◦    2、随机去选出m个特征, m &lt;&lt;M，建立决策树，起到降维的效果，运算快。可以让正确的结果脱颖而出（真理掌握在少数人手里）</p>
<p>2）特征随机。</p>
<p>为什么采用BootStrap抽样<br>    •    为什么要随机抽样训练集？　　<br>    ◦    如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的<br>    •    为什么要有放回地抽样？<br>    ◦    如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</p>
<p>3.6.2 随机森林api</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•	class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)</span><br><span class="line">◦	随机森林分类器</span><br><span class="line">◦	n_estimators：integer，optional（default = 10）森林里的树木数量</span><br><span class="line">◦	criterion：string，可选（default =“gini”）分割特征的测量方法</span><br><span class="line">◦	max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30</span><br><span class="line">◦	max_features=&quot;auto”,每个决策树的最大特征数量(m怎么选)</span><br><span class="line">▪	If &quot;auto&quot;, then max_features=sqrt(n_features).</span><br><span class="line">▪	If &quot;sqrt&quot;, then max_features=sqrt(n_features) (same as &quot;auto&quot;).</span><br><span class="line">▪	If &quot;log2&quot;, then max_features=log2(n_features).</span><br><span class="line">▪	If None, then max_features=n_features.</span><br><span class="line">◦	bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</span><br><span class="line">◦	min_samples_split:节点划分最少样本数</span><br><span class="line">◦	min_samples_leaf:叶子节点的最小样本数</span><br><span class="line">•	超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</span><br></pre></td></tr></table></figure>

<p>3.6.3 鸢尾花实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def random_decision_iris():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用决策树对鸢尾花进行分类</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    # 2）划分数据集，决策树不用做标准化</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=6)</span><br><span class="line">    # 3）随机森林预估器进行分类</span><br><span class="line">    estimator = RandomForestClassifier(criterion=&#x27;entropy&#x27;)</span><br><span class="line">    # 加入网格搜索和交叉验证</span><br><span class="line">    # 参数准备</span><br><span class="line">    param_dict = &#123;&quot;n_estimators&quot;: [120, 200, 300, 500, 800, 1200], &quot;max_depth&quot;: [5, 8, 15, 25, 30]&#125;</span><br><span class="line">    # 超参数调优</span><br><span class="line">    estimator = GridSearchCV(estimator, param_grid=param_dict, cv=2)</span><br><span class="line">    estimator.fit(x_train,y_train)</span><br><span class="line">    # 4）模型评估</span><br><span class="line">    y_predict = estimator.predict(x_test)</span><br><span class="line">    print(&quot;y_predict:\n&quot;, y_predict)</span><br><span class="line">    print(&quot;预测值和真实值:\n&quot;, y_predict == y_test)</span><br><span class="line">    score = estimator.score(x_test, y_test)</span><br><span class="line">    print(&quot;score:\n&quot;, score)</span><br><span class="line">    # 可视化决策树</span><br><span class="line">    # export_graphviz(estimator, out_file=&#x27;iris_tree.dot&#x27;)</span><br><span class="line">    print(&quot;score:\n&quot;, score)  # 测试集的结果</span><br><span class="line">    print(&quot;最佳参数:\n&quot;, estimator.best_params_)</span><br><span class="line">    print(&quot;最佳结果:\n&quot;, estimator.best_score_)  # 验证集的结果</span><br><span class="line">    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)</span><br><span class="line">    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>3.6.4 优缺点<br>    •    在当前所有算法中，具有极好的准确率（没有免费的午餐）<br>    •    能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维（M&gt;&gt;m相当于是降维了）<br>    •    能够评估各个特征在分类问题上的重要性</p>
<h4 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h4><p>1.转换器和预估器：转换器在特征工程里用，预估器在机器学习算法训练模型里用。封装在同一父类里面，调同一个方法（fit_transform、fit）</p>
<p>2.KNN算法：核心思想是根据邻居确定类别，谁是邻居：距离公式，k的取值：找几个邻居，太小容易受异常值影响，过大容易受样本不均衡影响。缺陷是时间复杂度高，应用场景是少量数据。</p>
<p>3.朴素贝叶斯算法：朴素：假定特征与特征之间独立。样本量不够导致出现0的情况：引入拉普拉斯平滑系数。优点：对缺失数据不敏感，计算快。缺点：特征之间关联影响效果。应用场景：文本分类。</p>
<p>4.决策树：以何种顺序决策是最高效的，用信息增益来决定决策顺序。信息增益=信息墒-条件墒。优点是可以可视化，可解释能力强。缺点容易过拟合。</p>
<p>5.随机森林：随机：训练集随机和特征随机，森林：多个决策树。优点容易取得比较好的效果，有降维的效果，降低模型复杂度。应用场景：高维度特征大数据场景。</p>
<h3 id="4-回归与聚类算法"><a href="#4-回归与聚类算法" class="headerlink" title="4.回归与聚类算法"></a>4.回归与聚类算法</h3><h4 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h4><p>4.1.1 线性回归原理<br>回归问题 - 目标值是连续性的。<br>线性回归(Linear regression)是利用回归方程(函数)对一个或多个自变量(特征值)和因变量(目标值)之间关系进行建模的一种分析方式。<br>通俗：找到一个特定的函数关系，描述特征值和目标值的关系。<br>满足线性关系的：<br>h(w) = w1x1+w2x2+…+b = wTx+b<br>W是权重值/回归系数。b是偏置。<br>这个函数关系就叫做线性模型。<br>广义的线性模型，可以是非线性关系。<br>线性模型，当函数关系当中，满足自变量一次/参数一次的，都叫线性模型。<br>自变量一次：h(w) = w1x1+w2x2+…+b = wTx+b<br>参数一次：y=w1x1 + w2x1^2 + w3x1^3 + w4x2^3 +…+b （没有log/e）<br>线性关系一定是线性模型，但是线性模型不一定是线性关系。</p>
<p>4.1.2 线性回归的损失和优化原理<br>权重和偏置（模型参数）是未知的，求解，使得预测准确。<br>首先，随意假定一组模型参数，带入一组特征值。<br>预测值和真实值的差值在迭代中缩小。<br>衡量预测值和真实值的误差：损失函数/cost/成本函数/目标函数<br>损失函数=累加(预测值-真实值)^2<br>减少这个损失，使得预测更准确，又称最小二乘法。</p>
<p>优化损失的方法：<br>1.正规方程（天才）-用正规方程直接求解w<br>当特征过多过复杂时，求解速度太慢并且得不到结果（特别是求逆），只能在线性回归中使用。</p>
<p>2.梯度下降（勤奋努力的普通人）-不断地试错、改进<br>数据量很大的情况下，梯度下降可以取得更好的结果。<br>先给初使的权重，迭代来获取新的权重，沿着切线的方向移动<br>α为学习速率，需要手动指定（超参数），表示步长，α旁边的整体表示方向<br>沿着这个函数下降的方向找，最后就能找到山谷的最低点，然后更新W值<br>使用：面对训练数据规模十分庞大的任务 ，能够找到较好的结果。<br>线性回归的损失函数图像有一个唯一的最小值点。<br>但不是线性回归的损失函数，可能到一个局部最小点。<br>机器学习中的学习过程就可以理解为梯度下降的试错改进。</p>
<p>4.1.3 线性回归API<br>sklearn提供给我们两种实现的API， 可以根据选择使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LinearRegression(fit_intercept=True)</span><br><span class="line">  通过正规方程优化</span><br><span class="line">  fit_intercept：是否计算偏置，一般true，不然只能是过原点的，局限性</span><br><span class="line">  LinearRegression.coef_：看回归系数</span><br><span class="line">  LinearRegression.intercept_：看偏置</span><br><span class="line">sklearn.linear_model.SGDRegressor(loss=&quot;squared_loss&quot;, fit_intercept=True, learning_rate =&#x27;invscaling&#x27;, eta0=0.01)</span><br><span class="line">  SGDRegressor类实现了随机梯度下降学习，它支持不同的loss函数和正则化惩罚项来拟合线性回归模型。</span><br><span class="line">  loss:损失函数类型</span><br><span class="line">  loss=”squared_loss”: 普通最小二乘法</span><br><span class="line">  fit_intercept：是否计算偏置</span><br><span class="line">  learning_rate : string, optional</span><br><span class="line">    学习率算法</span><br><span class="line">    &#x27;constant&#x27;: eta = eta0 （默认0.01）</span><br><span class="line">    &#x27;optimal&#x27;: eta = 1.0 / (alpha * (t + t0)) [default]随着迭代次数变多学习率变小</span><br><span class="line">    &#x27;invscaling&#x27;: eta = eta0 / pow(t, power_t)  power_t=0.25:存在父类当中</span><br><span class="line">    对于一个常数值的学习率来说，可以使用learning_rate=’constant’ ，并使用eta0来指定学习率。</span><br><span class="line">  SGDRegressor.coef_：回归系数</span><br><span class="line">  SGDRegressor.intercept_：偏置</span><br></pre></td></tr></table></figure>


<p>4.1.4 波士顿房价预测<br>流程：<br>1）获取数据集<br>2）划分数据集<br>3）特征工程：无量纲化-标准化<br>4）预估器流程 fit() -&gt; 模型 coef_ intercept_<br>5）模型评估 </p>
<p>回归性能评估: 均方误差MSE（上面的损失函数+平均）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.mean_squared_error(y_true, y_pred)</span><br><span class="line">均方误差回归损失</span><br><span class="line">y_true:真实目标值</span><br><span class="line">y_pred:预测目标值</span><br><span class="line">return:浮点数结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets import load_boston</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.linear_model import LinearRegression,SGDRegressor</span><br><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line"></span><br><span class="line">def linear1():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    线性回归正规方程优化方法预测房子价格</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    lb = load_boston()</span><br><span class="line">    # print(lb.data)</span><br><span class="line">    # print(lb.target)</span><br><span class="line">    print(&quot;特征数量&quot;, lb.data.shape)</span><br><span class="line"></span><br><span class="line">    # 2)对数据集进行划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(lb.data, lb.target, test_size=0.3, random_state=24)</span><br><span class="line"></span><br><span class="line">    # 3）特征工程：无量纲化 - 标准化</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line">    # print(x_train)</span><br><span class="line"></span><br><span class="line">    # 4）预估器流程 fit() -&gt; 模型</span><br><span class="line">    # 使用正规方程求解</span><br><span class="line">    lr = LinearRegression()</span><br><span class="line">    lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    # 5）得出模型</span><br><span class="line">    print(&quot;权重系数：&quot;, lr.coef_)</span><br><span class="line">    print(&quot;偏置：&quot;, lr.intercept_)</span><br><span class="line"></span><br><span class="line">    # 6）模型评估</span><br><span class="line">    y_predict = lr.predict(x_test)</span><br><span class="line">    print(&quot;预测房价：&quot;, y_predict)</span><br><span class="line">    print(&quot;正规方程的均方误差为：&quot;, mean_squared_error(y_test, y_predict))</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">def linear2():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    线性回归梯度下降优化方法预测房子价格</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1）获取数据集</span><br><span class="line">    lb = load_boston()</span><br><span class="line">    # print(lb.data)</span><br><span class="line">    # print(lb.target)</span><br><span class="line"></span><br><span class="line">    # 2)对数据集进行划分</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(lb.data, lb.target, test_size=0.3, random_state=24)</span><br><span class="line"></span><br><span class="line">    # 3）特征工程：无量纲化 - 标准化</span><br><span class="line">    transfer = StandardScaler()</span><br><span class="line">    x_train = transfer.fit_transform(x_train)</span><br><span class="line">    x_test = transfer.fit_transform(x_test)</span><br><span class="line">    # print(x_train)</span><br><span class="line"></span><br><span class="line">    # 4）梯度下降进行预测，调参</span><br><span class="line">    sgd = SGDRegressor(max_iter=10000, eta0=0.0001, learning_rate=&quot;constant&quot;)</span><br><span class="line">    sgd.fit(x_train, y_train)</span><br><span class="line">    print(&quot;SGD的权重参数为：&quot;, sgd.coef_)</span><br><span class="line">    print(&quot;偏置：&quot;, sgd.intercept_)</span><br><span class="line"></span><br><span class="line">    # 6）模型评估</span><br><span class="line">    y_predict = sgd.predict(x_test)</span><br><span class="line">    print(&quot;预测房价：&quot;, y_predict)</span><br><span class="line">    print(&quot;梯度下降的均方误差为：&quot;, mean_squared_error(y_test, y_predict))</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    linear1()</span><br><span class="line">    linear2()</span><br></pre></td></tr></table></figure>

<p>4.1.5 正规方程和梯度下降的对比</p>
<p>梯度下降            正规方程<br>需要选择学习率    不需要<br>需要迭代求解     一次运算得出<br>特征数量较大可以使用  需要计算方程，时间复杂度高O(n3)</p>
<p>选择：<br>小规模数据：LinearRegression(不能解决拟合问题)、岭回归<br>大规模数据：SGDRegressor</p>
<p>4.1.6 梯度下降优化方法GD、SGD、SAG</p>
<p>GD<br>梯度下降(Gradient Descent)，原始的梯度下降法需要计算所有样本的值才能够得出梯度，计算量大，所以后面才有会一系列的改进。</p>
<p>SGD<br>随机梯度下降(Stochastic gradient descent)是一个优化方法。它在一次迭代时只考虑一个训练样本。<br>SGD的优点是：高效容易实现<br>SGD的缺点是：SGD需要许多超参数：比如正则项参数、迭代数。SGD对于特征标准化是敏感的。</p>
<p>SAG<br>随机平均梯度法(Stochasitc Average Gradient)，由于收敛的速度太慢，有人提出SAG等基于梯度下降的算法<br>Scikit-learn：SGDRegressor、岭回归、逻辑回归等当中都会有SAG优化</p>
<h4 id="4-2-过拟合和欠拟合"><a href="#4-2-过拟合和欠拟合" class="headerlink" title="4.2 过拟合和欠拟合"></a>4.2 过拟合和欠拟合</h4><p>训练集上表现得好，测试集上表现不好 - 过拟合。<br>学习到的特征太小，导致区分标准太粗糙，不能准确识别。-欠拟合<br>学的特征太多了 - 过拟合。</p>
<p>过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合， 但是在测试数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)<br>欠拟合：一个假设在训练数据上不能获得更好的拟合，并且在测试数据集上也不能很好地拟合数据，此时认为这个假设出现了欠拟合的现象。(模型过于简单)</p>
<p>用一个曲线来表示：随着模型复杂度的增大，训练集的损失值越来越少，但是测试集的损失值先变小再变大。临界值左边是欠拟合，右边是过拟合。</p>
<p>欠拟合原因以及解决办法<br>原因：学习到数据的特征过少<br>解决办法：增加数据的特征数量</p>
<p>过拟合原因以及解决办法<br>原因：原始特征过多，存在一些嘈杂特征， 模型过于复杂是因为模型尝试去兼顾各个测试数据点，泛化能力比较差。<br>解决办法：<br>正则化，尽量减小高次项特征的影响<br>（这里针对回归，我们选择了正则化。但是对于其他机器学习算法如分类算法来说也会出现这样的问题，除了一些算法本身作用之外（决策树、神经网络），我们更多的也是去自己做特征选择，包括之前说的删除、合并一些特征）</p>
<p>在学习的时候，数据提供的特征有些影响模型复杂度或者这个特征的数据点异常较多，所以算法在学习的时候尽量减少这个特征的影响（甚至删除某个特征的影响），这就是正则化</p>
<p>注：调整时候，算法并不知道某个特征影响，而是去调整参数得出优化的结果</p>
<p>正则化类别：<br>L2正则化<br>作用：可以使得模型其中一些W权重系数都很小，都接近于0，削弱某个特征的影响<br>优点：越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象<br>Ridge回归（岭回归）<br>加入L2正则化后的损失函数：<br>损失函数=(累加(预测值-真实值)^2)*(1/2m) + 惩罚系数(超参，惩罚的补偿) * 惩罚项(权重系数的平方和)<br>目的是：不仅使得损失变小，还让权重系数变小。达到不仅让模型更加准确，还消除高次项的影响。</p>
<p>L1正则化<br>作用：可以使得其中一些W的值直接为0，删除这个特征的影响<br>LASSO回归<br>惩罚项是w的绝对值。</p>
<p>线性回归的损失函数用最小二乘法，等价于当预测值与真实值的误差满足正态分布时的极大似然估计；岭回归的损失函数，是最小二乘法+L2范数，等价于当预测值与真实值的误差满足正态分布，且权重值也满足正态分布（先验分布）时的最大后验估计；LASSO的损失函数，是最小二乘法+L1范数，等价于等价于当预测值与真实值的误差满足正态分布，且且权重值满足拉普拉斯分布（先验分布）时的最大后验估计。</p>
<h4 id="4-3-线性回归的改进-岭回归"><a href="#4-3-线性回归的改进-岭回归" class="headerlink" title="4.3 线性回归的改进 - 岭回归"></a>4.3 线性回归的改进 - 岭回归</h4><p>岭回归，其实也是一种线性回归。只不过在算法建立回归方程时候，加上L2正则化的限制，从而达到解决过拟合的效果</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True,solver=&quot;auto&quot;, normalize=False)</span><br><span class="line">具有l2正则化的线性回归</span><br><span class="line">alpha:正则化力度=惩罚项系数，也叫 λ</span><br><span class="line">λ取值：0~1 1~10</span><br><span class="line">-fit_intercept：是否添加偏置</span><br><span class="line">solver:会根据数据自动选择优化方法</span><br><span class="line">-sag:如果数据集、特征都比较大，选择该随机梯度下降优化</span><br><span class="line">normalize:数据是否进行标准化</span><br><span class="line">-normalize=False:可以在fit之前调用preprocessing.StandardScaler标准化数据</span><br><span class="line"></span><br><span class="line">模型参数：</span><br><span class="line">Ridge.coef_:回归权重</span><br><span class="line">Ridge.intercept_:回归偏置</span><br></pre></td></tr></table></figure>

<p>Ridge方法相当于SGDRegressor(penalty=’l2’, loss=”squared_loss”),默认l2,只不过SGDRegressor实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG)</p>
<p>正则化力度越大，权重系数会越小<br>正则化力度越小，权重系数会越大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd = Ridge(alpha=1.0)</span><br><span class="line"></span><br><span class="line">rd.fit(x_train, y_train)</span><br><span class="line">print(&quot;岭回归的权重参数为：&quot;, rd.coef_)</span><br><span class="line"></span><br><span class="line">y_rd_predict = std_y.inverse_transform(rd.predict(x_test))</span><br><span class="line"></span><br><span class="line">print(&quot;岭回归的预测的结果为：&quot;, y_rd_predict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;岭回归的均方误差为：&quot;, mean_squared_error(y_test, y_rd_predict))</span><br></pre></td></tr></table></figure>

<h4 id="4-4-分类；分类算法-逻辑回归与二分类"><a href="#4-4-分类；分类算法-逻辑回归与二分类" class="headerlink" title="4.4 分类；分类算法-逻辑回归与二分类"></a>4.4 分类；分类算法-逻辑回归与二分类</h4><p>逻辑回归（Logistic Regression）是机器学习中的一种分类模型，逻辑回归是一种分类算法，虽然名字中带有回归，但是它与回归之间有一定的联系。由于算法的简单和高效，在实际中应用非常广泛。</p>
<p>应用场景：<br>广告点击率<br>是否为垃圾邮件<br>是否患病<br>金融诈骗<br>虚假账号<br>都属于两个类别之间的判断。逻辑回归就是解决二分类问题的利器</p>
<p>线性回归的输出 就是 逻辑回归（激活函数）的输入。</p>
<p>激活函数sigmoid函数：<code>1/(1 + e^(-x))</code><br>将某个函数映射到0-1区间。<br>回归的结果输入到sigmoid函数当中<br>输出结果：[0, 1]区间中的一个概率值，默认为0.5为阈值.</p>
<p>逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为1(正例),另外的一个类别会标记为0(反例)。</p>
<p>需要构建损失函数：（先线性回归，再sigmiod映射为逻辑回归结果，再计算损失函数）<br>线性回归的损失函数： (y_predict - y_true)平方和/总数<br>逻辑回归的真实值/预测值：是否属于某个类别<br>所以用：<strong>对数似然损失</strong>，定义为一个分段函数（根据真实值），真实值为1时，预测越接近1损失越小。</p>
<p>优化：<br>同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，提升原本属于1类别的概率，降低原本是0类别的概率。</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LogisticRegression(solver=&#x27;liblinear&#x27;, penalty=‘l2’, C = 1.0)</span><br><span class="line">solver:优化求解方式（默认开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数）</span><br><span class="line">-sag：根据数据集自动选择，随机平均梯度下降</span><br><span class="line">penalty：正则化的种类(l2)</span><br><span class="line">C：正则化力度</span><br></pre></td></tr></table></figure>

<p>LogisticRegression方法相当于 SGDClassifier(loss=”log”, penalty=” “),SGDClassifier实现了一个普通的随机梯度下降学习，也支持平均随机梯度下降法（ASGD），可以通过设置average=True。而使用LogisticRegression(实现了SAG)</p>
<p>案例：<br>流程：<br>1）获取数据<br>2）数据处理-处理缺失值<br>3）数据集划分<br>4）特征工程：无量纲化处理-标准化<br>5）逻辑回归预估器<br>6）模型评估</p>
<p>用jupyter可视化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def logisticregression():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    逻辑回归进行癌症预测</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 1、读取数据，处理缺失值以及标准化</span><br><span class="line">    column_name = [&#x27;Sample code number&#x27;, &#x27;Clump Thickness&#x27;, &#x27;Uniformity of Cell Size&#x27;, &#x27;Uniformity of Cell Shape&#x27;,</span><br><span class="line">                   &#x27;Marginal Adhesion&#x27;, &#x27;Single Epithelial Cell Size&#x27;, &#x27;Bare Nuclei&#x27;, &#x27;Bland Chromatin&#x27;,</span><br><span class="line">                   &#x27;Normal Nucleoli&#x27;, &#x27;Mitoses&#x27;, &#x27;Class&#x27;]</span><br><span class="line"></span><br><span class="line">    data = pd.read_csv(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&quot;,</span><br><span class="line">                       names=column_name)</span><br><span class="line"></span><br><span class="line">    # 删除缺失值</span><br><span class="line">    data = data.replace(to_replace=&#x27;?&#x27;, value=np.nan)</span><br><span class="line"></span><br><span class="line">    data = data.dropna()</span><br><span class="line"></span><br><span class="line">    # 取出特征值</span><br><span class="line">    x = data[column_name[1:10]]</span><br><span class="line"></span><br><span class="line">    y = data[column_name[10]]</span><br><span class="line"></span><br><span class="line">    # 分割数据集</span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)</span><br><span class="line"></span><br><span class="line">    # 进行标准化</span><br><span class="line">    std = StandardScaler()</span><br><span class="line"></span><br><span class="line">    x_train = std.fit_transform(x_train)</span><br><span class="line"></span><br><span class="line">    x_test = std.transform(x_test)</span><br><span class="line"></span><br><span class="line">    # 使用逻辑回归</span><br><span class="line">    lr = LogisticRegression()</span><br><span class="line"></span><br><span class="line">    lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">    print(&quot;得出来的权重,几个特征有几个：&quot;, lr.coef_)</span><br><span class="line"></span><br><span class="line">    # 预测类别</span><br><span class="line">    print(&quot;预测的类别：&quot;, lr.predict(x_test))</span><br><span class="line"></span><br><span class="line">    # 得出准确率</span><br><span class="line">    print(&quot;预测的准确率:&quot;, lr.score(x_test, y_test))</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>在很多分类场景当中我们不一定只关注预测的准确率，比如以这个癌症举例子！！！我们并不关注预测的准确率，而是关注在所有的样本当中，癌症患者有没有被全部预测（检测）出来。</p>
<p>想要关注的：真的患癌症的，能够被检测出来。</p>
<p>✅精确率和召回率：<br>混淆矩阵：<br>在分类任务下，预测结果(Predicted Condition)与正确标记(True Condition)之间存在四种不同的组合，构成混淆矩阵(适用于多分类)<br>真实结果是正例，预测结果是正例：真正例TP<br>真实结果是正例，预测结果是假例：伪反例FN<br>真实结果是假例，预测结果是正例：伪正例FP<br>真实结果是假例，预测结果是假例：真反例TN</p>
<p>精确率：预测结果为正例样本中真实为正例的比例 （TP/TP+FP）<br>召回率：真实为正例的样本中预测结果为正例的比例（查的全，对正样本的区分能力）（TP/TP+FN）</p>
<hr>
<p>总结：<br>1.准确率（Accuracy）。顾名思义，就是所有预测正确的（包括正类和负类）占总的的比例。</p>
<p>2.精确率（Precision），查准率。即正确预测为正类的占全部预测为正类的的比例。个人理解：在所有预测为正类中真正为正类的占所有预测为正类的的比例。</p>
<p>3.召回率（Recall），查全率。即正确预测为正类的占全部实际为正类的的比例。个人理解：在所有预测为正类中真正为正类的占总体实际为正类的的比例。</p>
<p>对于精确率和召唤率，其实就是分母不同，一个分母是预测为正类的样本数，另一个是原始样本中所有的正类样本数。</p>
<p>召回率 (Recall)：该类样本有多少被找出来了（召回了多少）。</p>
<p>精确率 (Precision)：你认为的该类样本，有多少猜对了（猜的精确性如何）。</p>
<p>召回率：<a href="https://blog.csdn.net/PingBryant/article/details/115561777">https://blog.csdn.net/PingBryant/article/details/115561777</a></p>
<hr>
<p>还有其他的评估标准，F1-score，反映了模型的稳健型<br>F1 = 2TP/(2TP + FN + FP) = （2<em>准确率</em>召回率）/（准确率+召回率）</p>
<p>分类评估报告api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )</span><br><span class="line">y_true：真实目标值</span><br><span class="line">y_pred：估计器预测目标值</span><br><span class="line">labels:指定类别对应的数字</span><br><span class="line">target_names：目标类别名称</span><br><span class="line">return：每个类别精确率与召回率</span><br><span class="line"></span><br><span class="line">print(&quot;每个特征的精确率和召回率为：&quot;, classification_report(y_test, lr.predict(x_test), labels=[2, 4], target_names=[&#x27;良性&#x27;, &#x27;恶性&#x27;]))</span><br></pre></td></tr></table></figure>

<p>假设这样一个情况，如果99个样本癌症，1个样本非癌症，不管怎样我全都预测正例(默认癌症为正例),准确率就为99%，召回率100%但是这样效果并不好，这就是样本不均衡下的评估问题。</p>
<p>ROC曲线与AUC指标：</p>
<p>TPR = TP / (TP + FN)<br>所有真实类别为1的样本中，预测类别为1的比例 - 召回率<br>FPR = FP / (FP + FN)<br>所有真实类别为0的样本中，预测类别为1的比例</p>
<p>ROC曲线的横轴就是FPRate，纵轴就是TPRate，当二者相等时，表示的意义则是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的，此时AUC为0.5。</p>
<p>AUC如何计算：ROC曲线和坐标轴包围的面积，如果是0，1，那就是1.</p>
<p>AUC的概率意义是随机取一对正负样本，正样本得分大于负样本的概率<br>AUC的最小值为0.5，最大值为1，取值越高越好<br>AUC=1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。<br>0.5&lt;AUC&lt;1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。<br>最终AUC的范围在[0.5, 1]之间，并且越接近1越好</p>
<p>AUC计算api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.metrics import roc_auc_score</span><br><span class="line">sklearn.metrics.roc_auc_score(y_true, y_score)</span><br><span class="line">计算ROC曲线面积，即AUC值</span><br><span class="line">y_true:每个样本的真实类别，必须为0(反例),1(正例)标记</span><br><span class="line">y_score:每个样本预测的概率值</span><br><span class="line"></span><br><span class="line">0.5~1之间，越接近于1约好</span><br><span class="line">y_test = np.where(y_test &gt; 2.5, 1, 0)</span><br><span class="line"></span><br><span class="line">print(&quot;AUC指标：&quot;, roc_auc_score(y_test, lr.predict(x_test)))</span><br></pre></td></tr></table></figure>

<p>AUC只能用来评价二分类<br>AUC非常适合评价样本不平衡中的分类器性能.</p>
<h4 id="4-5-模型保存和加载"><a href="#4-5-模型保存和加载" class="headerlink" title="4.5 模型保存和加载"></a>4.5 模型保存和加载</h4><p>当训练或者计算好一个模型之后，那么如果别人需要我们提供结果预测，就需要保存模型（主要是保存算法的参数）</p>
<p>sklearn模型的保存和加载API:(模型序列化到本地)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.externals import joblib</span><br><span class="line">保存：joblib.dump(rf, &#x27;test.pkl&#x27;)</span><br><span class="line">加载：estimator = joblib.load(&#x27;test.pkl&#x27;)</span><br></pre></td></tr></table></figure>

<p>保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 使用线性模型进行预测</span><br><span class="line"> 使用正规方程求解</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line">保存训练完结束的模型</span><br><span class="line">joblib.dump(lr, &quot;test.pkl&quot;)</span><br></pre></td></tr></table></figure>

<p>加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过已有的模型去预测房价</span><br><span class="line">model = joblib.load(&quot;test.pkl&quot;)</span><br><span class="line">print(&quot;从文件加载进来的模型预测房价的结果：&quot;, std_y.inverse_transform(model.predict(x_test)))</span><br></pre></td></tr></table></figure>


<h4 id="4-6-无监督学习-K-means"><a href="#4-6-无监督学习-K-means" class="headerlink" title="4.6 无监督学习 K-means"></a>4.6 无监督学习 K-means</h4><p>没有目标值 - 无监督学习</p>
<p>聚类：K-means(K均值聚类)<br>降维：PCA</p>
<p>K-means聚类步骤：<br>1、随机设置K个特征空间内的点作为初始的聚类中心<br>2、对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别<br>3、接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）<br>4、如果计算得出的新中心点与原中心点一样，那么结束，否则重新进行第二步过程</p>
<p>K-超参数<br>1）看需求，要分为多少堆<br>2）调节超参数</p>
<p>api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.cluster.KMeans(n_clusters=8,init=‘k-means++’)</span><br><span class="line">k-means聚类</span><br><span class="line">n_clusters:开始的聚类中心数量，k值</span><br><span class="line">init:初始化方法，默认为&#x27;k-means ++’</span><br><span class="line">labels_:默认标记的类型，可以和真实值比较（不是值比较）</span><br><span class="line"></span><br><span class="line">cust = data[:500]</span><br><span class="line">km = KMeans(n_clusters=4)</span><br><span class="line">km.fit(cust)</span><br><span class="line">pre = km.predict(cust)</span><br></pre></td></tr></table></figure>

<p>Kmeans性能评估指标：<br>轮廓系数，类似设计模式中的高内聚低耦合。<br>内部距离最小化，外部距离最大化。<br><code>SCi = (bi - ai)/max(bi,ai)</code><br>对于每个点i 为已聚类数据中的样本 ，b_i 为i 到其它族群的所有样本的距离最小值，a_i 为i 到本身簇的距离平均值。最终计算出所有的样本点的轮廓系数平均值</p>
<p>如果b_i&gt;&gt;a_i:趋近于1效果越好， b_i&lt;&lt;a_i:趋近于-1，效果不好。轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。</p>
<p>轮廓系数api：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sklearn.metrics.silhouette_score(X, labels)</span><br><span class="line">计算所有样本的平均轮廓系数</span><br><span class="line">X：特征值</span><br><span class="line">labels：被聚类标记的目标值</span><br></pre></td></tr></table></figure>

<p>K-means优缺点：<br>特点分析：采用迭代式算法，直观易懂并且非常实用<br>缺点：容易收敛到局部最优解(多次聚类)<br>应用场景：没有目标值的分类，做在分类之前。</p>
<h4 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7 总结"></a>4.7 总结</h4><p>1.线性回归 - 线性模型 - 线性关系：y=w1x1+w2x2+…+wnxn+b。构建损失函数-最小二乘法/均方误差。优化损失：正规方程（矩阵相乘直接求解），梯度下降（不断试错，不断迭代）。模型评估：均方误差。<br>2.过拟合和欠拟合，过拟合：模型过于复杂 - 正则化（用L2）。欠拟合：模型过于简单 - 增加数据、特征。<br>3.岭回归，正则化力度对模型参数的影响。<br>4.逻辑回归，用于分类，输入是线性回归的输出，放入激活函数sigmoid中。损失函数：对数似然函数。优化损失：梯度下降。二分类的模型评估：召回率，样本不均衡时使用AUC指标，接近0.5就不好。<br>5.保存和加载模型<br>6.K-Means，聚类的步骤，模型评估：用轮廓系数[-1,1]</p>
<h2 id="看图说话"><a href="#看图说话" class="headerlink" title="看图说话"></a>看图说话</h2><p>什么是特征：图像的像素、区域。单词的特性，等可以被区别于其他图像的地方，并且可以经过向量化的计算被模型所获取。</p>
<p>CNN核函数 - 得到向量一片区域的相关特性<br>编码器：例如Faster-RCNN，yolo，把文本或图像的特征做向量化的处理<br>解码器：CNN-LSTM。Transformer，把向量化处理后的特征做语义识别、分割等操作，并输出。</p>
<p>图片向量化、编码器（生成计算机可以理解的上下文信息）、解码器、文本向量化</p>
<p>看图说话：用编码器Faster-RCNN从图像中提取对象，用解码器生成一句话图像表达</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>前端寄出-JavaScript</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>JavaScript 是脚本语言，可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。<br>JavaScript 是一种轻量级的编程语言。<br>JavaScript 是可插入 HTML 页面的编程代码。<br>JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。<br>JavaScript 语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。</p>
<p>作用：直接写入html输出流。对事件做出反应。改变HTML内容。改变HTML图像。改变HTML样式。验证输入。等</p>
<p>JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。</p>
<p>Java（由 Sun 发明）是更复杂的编程语言。</p>
<p>JavaScript 由 Brendan Eich 发明。它于 1995 年出现，被 ECMA（一个标准协会）采纳。。</p>
<h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h2><h3 id="1-内部方式"><a href="#1-内部方式" class="headerlink" title="(1)内部方式"></a>(1)内部方式</h3><p>脚本必须位于<code> &lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间。<br>脚本可被放置在 HTML 页面的 <code>&lt;body&gt; </code>和 <code>&lt;head&gt; </code>部分中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">&lt;h1&gt;我的第一段 JavaScript&lt;/h1&gt;</span><br><span class="line">&lt;p id=&quot;demo&quot;&gt;</span><br><span class="line">JavaScript 能改变 HTML 元素的样式。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;script&gt;       //可以在body，也可以在head</span><br><span class="line">function myFunction()       //函数作用：捕获元素之后改变样式</span><br><span class="line">&#123;</span><br><span class="line">	x=document.getElementById(&quot;demo&quot;) // 找到元素  getElementById函数捕获id选择器</span><br><span class="line">	x.style.color=&quot;#ff0000&quot;;          // 改变样式</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;  //使用函数</span><br><span class="line">	</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-外部方式"><a href="#2-外部方式" class="headerlink" title="(2)外部方式"></a>(2)外部方式</h3><p>以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>导入方式：在 <code>&lt;script&gt;</code> 标签的 “src” 属性中设置该 .js 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-JavaScript输出"><a href="#3-JavaScript输出" class="headerlink" title="3.JavaScript输出"></a>3.JavaScript输出</h2><p>JavaScript 可以通过不同的方式来输出数据：<br>使用 window.alert() 弹出警告框。</p>
<p>使用 document.write() 方法将内容写到 HTML 文档中。</p>
<p>使用 innerHTML 写入到 HTML元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML=&quot;段落已修改。&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用 console.log() 写入到浏览器的控制台。</p>
<h2 id="4-JavaScript语法"><a href="#4-JavaScript语法" class="headerlink" title="4.JavaScript语法"></a>4.JavaScript语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var points = 10;     // Number 通过表达式字面量赋值</span><br><span class="line">var lastName = &quot;Johnson&quot;;   // String 通过字符串字面量赋值</span><br><span class="line">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];    // Array  通过数组字面量赋值</span><br><span class="line">var person = &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;&#125;;  // Object 通过对象字面量赋值</span><br><span class="line">使用：对象是拥有属性和方法的数据。对象键值对的形式。</span><br><span class="line">name=person.lastname;</span><br><span class="line">name=person[&quot;lastname&quot;];</span><br></pre></td></tr></table></figure>

<p>JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。</p>
<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。<br>引用数据类型：对象(Object)、数组(Array)、函数(Function)。<br>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型。<br>JavaScript 只有一种数字类型。数字可以带小数点，也可以不带。</p>
<h2 id="5-JavaScript事件"><a href="#5-JavaScript事件" class="headerlink" title="5.JavaScript事件"></a>5.JavaScript事件</h2><p>HTML 事件是发生在 HTML 元素上的事情。<br>当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。<br>HTML 事件可以是浏览器行为，也可以是用户行为。<br>以下是 HTML 事件的实例：<br>HTML 页面完成加载<br>HTML input 字段改变时<br>HTML 按钮被点击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;标题&lt;/title&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button onclick=&quot;displayDate()&quot;&gt;点这里&lt;/button&gt;  </span><br><span class="line">//事件，onclick属性对应了script里的函数，点击运行script里的函数</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function displayDate()&#123;</span><br><span class="line">	document.getElementById(&quot;demo&quot;).innerHTML=Date();</span><br><span class="line">&#125;      //写入html元素</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;  //id选择器找元素</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-JavaScript数据类型"><a href="#6-JavaScript数据类型" class="headerlink" title="6.JavaScript数据类型"></a>6.JavaScript数据类型</h2><h3 id="1-字符串与对象"><a href="#1-字符串与对象" class="headerlink" title="(1)字符串与对象"></a>(1)字符串与对象</h3><p>var x = “John”;<br>var y = new String(“John”);<br>(x === y) // 结果为 false，因为 x 是字符串，y 是对象</p>
<p>两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串</p>
<p>你可以使用 typeof 操作符来检测变量的数据类型。<br>typeof “John”                // 返回 string</p>
<h3 id="2-undefined-和-null-的区别"><a href="#2-undefined-和-null-的区别" class="headerlink" title="(2)undefined 和 null 的区别"></a>(2)undefined 和 null 的区别</h3><p>null 和 undefined 的值相等，但类型不等：<br>typeof undefined             // undefined<br>typeof null                  // object<br>null === undefined           // false<br>null == undefined            // true<br>在严格的比较运算中，=== 为恒等计算符，同时检查表达式的值与类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、定义</span><br><span class="line"> （1）undefined：是所有没有赋值变量的默认值，自动赋值。</span><br><span class="line"> （2）null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。</span><br><span class="line">2、何时使用null?</span><br><span class="line">当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。</span><br><span class="line">3、null 与 undefined 的异同点是什么呢？</span><br><span class="line">共同点：都是原始类型，保存在栈中变量本地。</span><br><span class="line">不同点：</span><br><span class="line">（1）undefined——表示变量声明过但并未赋过值。</span><br><span class="line">它是所有未赋值变量默认值，例如：</span><br><span class="line">var a;    // a 自动被赋值为 undefined</span><br><span class="line">（2）null——表示一个变量将来可能指向一个对象。</span><br><span class="line">一般用于主动释放指向对象的引用，例如：</span><br><span class="line">var emps = [&#x27;ss&#x27;,&#x27;nn&#x27;];</span><br><span class="line">emps = null;     // 释放指向数组的引用</span><br><span class="line">4、延伸——垃圾回收站</span><br><span class="line">它是专门释放对象内存的一个程序。</span><br><span class="line"> （1）在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期；</span><br><span class="line"> （2）总有一个对象不再被任何变量引用时，才释放。</span><br></pre></td></tr></table></figure>

<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="(3)类型转换"></a>(3)类型转换</h3><p>JavaScript 数据类型：<br>在 JavaScript 中有 6 种不同的数据类型：string、number、boolean、object、function、symbol<br>3 种对象类型：Object、Date、Array<br>2 个不包含任何值的数据类型：null、undefined</p>
<p>Number() 转换为数字， String() 转换为字符串， Boolean() 转换为布尔值。</p>
<h3 id="4-声明提升"><a href="#4-声明提升" class="headerlink" title="(4)声明提升"></a>(4)声明提升</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。<br>声明提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。<br>但是：只有声明会提升，初始化不会。</p>
<h2 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7.正则表达式"></a>7.正则表达式</h2><p>正则表达式：使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。<br>搜索模式可用于文本搜索和文本替换。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var patt = /runoob/i</span><br><span class="line">实例解析：</span><br><span class="line">/runoob/i  是一个正则表达式。</span><br><span class="line">runoob  是一个正则表达式主体 (用于检索)。</span><br><span class="line">i  是一个修饰符 (搜索不区分大小写)。</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</span><br><span class="line">replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</span><br></pre></td></tr></table></figure>

<p>正则表达式修饰符：<br>i    执行对大小写不敏感的匹配。<br>g    执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。<br>m    执行多行匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</span><br><span class="line">var patt = /e/;</span><br><span class="line">patt.test(&quot;The best things in life are free!&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec() 方法用于检索字符串中的正则表达式的匹配。</span><br><span class="line">该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</span><br><span class="line">/e/.exec(&quot;The best things in life are free!&quot;);</span><br><span class="line">字符串中含有 &quot;e&quot;，所以该实例输出为:e</span><br></pre></td></tr></table></figure>

<h2 id="8-JavaScript错误"><a href="#8-JavaScript错误" class="headerlink" title="8.JavaScript错误"></a>8.JavaScript错误</h2><p>try 语句测试代码块的错误。<br>catch 语句处理错误。<br>throw 语句创建自定义错误。<br>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现一个输入框，输入5-10之间数字，如果错误则报错，每次输入完自动清空输入框</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;不管输入是否正确，输入框都会再输入后清空。&lt;/p&gt;</span><br><span class="line">&lt;p&gt;请输入 5 ~ 10 之间的数字：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;    //输入框</span><br><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;  //按钮触发函数</span><br><span class="line"></span><br><span class="line">&lt;p id=&quot;p01&quot;&gt;&lt;/p&gt;    //用来输出错误信息的段落</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">  var message, x;</span><br><span class="line">  message = document.getElementById(&quot;p01&quot;);   //输出错误信息用</span><br><span class="line">  x = document.getElementById(&quot;demo&quot;).value;     //获得输入框的东西</span><br><span class="line">  try &#123;                                   //判断，抛出错误</span><br><span class="line">    if(x == &quot;&quot;) throw &quot;值是空的&quot;;</span><br><span class="line">    if(isNaN(x)) throw &quot;值不是一个数字&quot;;</span><br><span class="line">    x = Number(x);</span><br><span class="line">    if(x &gt; 10) throw &quot;太大&quot;;</span><br><span class="line">    if(x &lt; 5) throw &quot;太小&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  catch(err) &#123;</span><br><span class="line">    message.innerHTML = &quot;错误: &quot; + err + &quot;.&quot;;     //错误信息写入元素中</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).value = &quot;&quot;;  //清空输入框</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="9-JavaScript表单"><a href="#9-JavaScript表单" class="headerlink" title="9.JavaScript表单"></a>9.JavaScript表单</h2><p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现：输入一个东西，弹出新页表，提示输入的是什么</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function validateForm() &#123;       //进行验证的函数</span><br><span class="line">    var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;</span><br><span class="line">    if (x == null || x == &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;需要输入名字。&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form name=&quot;myForm&quot; action=&quot;demo_form.php&quot;      //表单，有一些属性</span><br><span class="line">onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;</span><br><span class="line">名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;      //一个文本输入框</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;       //一个提交按钮</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础-vue</title>
    <url>/2021/08/23/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Vue/</url>
    <content><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><h3 id="1-CDN方法"><a href="#1-CDN方法" class="headerlink" title="(1)CDN方法"></a>(1)CDN方法</h3><p>在页面上以 CDN 包的形式导入。<br><code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></p>
<blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<p>由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>    </span><br><span class="line">//<span class="tag">&lt;<span class="name">div</span>&gt;</span> 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。用 id 或 class 来标记 <span class="tag">&lt;<span class="name">div</span>&gt;</span>，那么该标签的作用会变得更加有效。</span><br><span class="line">//如果与 CSS 一同使用，<span class="tag">&lt;<span class="name">div</span>&gt;</span> 元素可用于对大的内容块设置样式属性。</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//&#123;&#123; &#125;&#125; 用于输出对象属性和函数返回值。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,   <span class="comment">//id选择器</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;         <span class="comment">//输出什么东西？</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用npm方法"><a href="#2-使用npm方法" class="headerlink" title="(2)使用npm方法"></a>(2)使用npm方法</h3><p>npm run dev</p>
<p>Vue.js 提供一个官方命令行工具vue-cli，可用于快速搭建大型单页应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">$ cnpm install --global vue-cli</span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line"></span><br><span class="line">安装及运行：</span><br><span class="line">$ cd my-project</span><br><span class="line">$ cnpm install</span><br><span class="line">$ cnpm run dev</span><br><span class="line"></span><br><span class="line">项目打包：</span><br><span class="line">npm run build</span><br><span class="line">执行完成后，会在 Vue 项目下生成一个 dist 目录，一般包含 index.html 文件及 static 目录，static 目录包含了静态文件 js、css 以及图片目录 images。</span><br><span class="line">直接双击 dist/index.html 文件就可以在浏览器中看到效果了。</span><br></pre></td></tr></table></figure>

<h2 id="3-VUE项目"><a href="#3-VUE项目" class="headerlink" title="3.VUE项目"></a>3.VUE项目</h2><h3 id="1-项目目录"><a href="#1-项目目录" class="headerlink" title="(1)项目目录"></a>(1)项目目录</h3><table>
<thead>
<tr>
<th align="left">目录/文件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">build</td>
<td align="left">项目构建(webpack)相关代码</td>
</tr>
<tr>
<td align="left">config</td>
<td align="left">配置目录，包括端口号等。我们初学可以使用默认的。</td>
</tr>
<tr>
<td align="left">node_modules</td>
<td align="left">npm 加载的项目依赖模块</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态资源目录，如图片、字体等。</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">初始测试目录，可删除</td>
</tr>
<tr>
<td align="left">.xxxx文件</td>
<td align="left">这些是一些配置文件，包括语法配置，git配置等。</td>
</tr>
<tr>
<td align="left">index.html</td>
<td align="left">首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td>
</tr>
<tr>
<td align="left">package.json</td>
<td align="left">项目配置文件。</td>
</tr>
<tr>
<td align="left">README.md</td>
<td align="left">项目的说明文档，markdown 格式</td>
</tr>
</tbody></table>
<p>app.vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 展示模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 导入组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">&#x27;./components/Hello&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Hello</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 样式代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir&#x27;</span>, Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-template标签"><a href="#2-template标签" class="headerlink" title="(2)template标签"></a>(2)template标签</h3><p>使用 <code>&lt;template&gt;</code> 保留页面加载时隐藏的内容。使用 JavaScript 来显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;template 元素&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;单击下面的按钮，显示 template 元素中的隐藏内容。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=&quot;showContent()&quot;&gt;显示隐藏的内容&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;     //点击按钮才会显示，JavaScript响应事件</span><br><span class="line">  &lt;h2&gt;Flower&lt;/h2&gt;</span><br><span class="line">  &lt;img src=&quot;/i/photo/flower.gif&quot; width=&quot;180&quot; height=&quot;180&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function showContent() &#123;</span><br><span class="line">  var temp = document.getElementsByTagName(&quot;template&quot;)[0];</span><br><span class="line">  var clon = temp.content.cloneNode(true);</span><br><span class="line">  document.body.appendChild(clon);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-vue应用"><a href="#3-vue应用" class="headerlink" title="(3)vue应用"></a>(3)vue应用</h3><p>每个 Vue 应用都需要通过实例化 Vue 来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue 测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/vue/2.4.2/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue_det&quot;</span>&gt;</span>   //块儿</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>site : &#123;&#123;site&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>url : &#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Alexa : &#123;&#123;alexa&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 我们的数据对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = &#123; <span class="attr">site</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;www.runoob.com&quot;</span>, <span class="attr">alexa</span>: <span class="number">10000</span>&#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;    <span class="comment">//vue应用</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#vue_det&#x27;</span>,    <span class="comment">//id选择器</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: data       <span class="comment">//数据，在外面</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 它们引用相同的对象！</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(vm.site === data.site) <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置属性也会影响到原始数据</span></span></span><br><span class="line"><span class="javascript">    vm.site = <span class="string">&quot;Runoob&quot;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(data.site + <span class="string">&quot;&lt;br&gt;&quot;</span>) <span class="comment">// Runoob</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ……反之亦然</span></span></span><br><span class="line"><span class="javascript">    data.alexa = <span class="number">1234</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(vm.alexa) <span class="comment">// 1234</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。</p>
<h2 id="4-vscode运行html"><a href="#4-vscode运行html" class="headerlink" title="4.vscode运行html"></a>4.vscode运行html</h2><p>(1).新建.html文件</p>
<p>(2).安装open in browser插件</p>
<p>(3).html页面右键选择open in other browser</p>
<h2 id="5-vue项目不用localhost"><a href="#5-vue项目不用localhost" class="headerlink" title="5.vue项目不用localhost"></a>5.vue项目不用localhost</h2><p>改变config下index.js里的ip，也是本机的私有ip，公网内的其他ip可访问。前提：一个公网。</p>
<h2 id="6-项目解读"><a href="#6-项目解读" class="headerlink" title="6.项目解读"></a>6.项目解读</h2><p>main.js 像是加vue应用的。</p>
<p>.vue 里面有<code>&lt;template&gt;</code> <code>&lt;script&gt;</code> <code>&lt;style&gt;</code></p>
<p>首页入口文件：index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>myfirstvue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目入口文件：App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-family</span>: <span class="string">&#x27;Avenir&#x27;</span>, Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="css">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ES6：全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。</p>
<p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>用于导出常量、函数、文件、模块等。</p>
<p>export可以有多个，export default只能有一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.vue中：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Welcome to Your Vue.js App&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-vscode打开终端"><a href="#7-vscode打开终端" class="headerlink" title="7.vscode打开终端"></a>7.vscode打开终端</h3><p>ctrl+·（左上角esc下面的）</p>
<p>或：查看-&gt;终端</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建第一个VUE项目，入门级别</title>
    <url>/2021/08/19/myblog/%E5%89%8D%E7%AB%AF%E9%97%A8%E5%A4%96%E6%B1%89/%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAVUE%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%85%A5%E9%97%A8%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1-开发软件vscode"><a href="#1-开发软件vscode" class="headerlink" title="1.开发软件vscode"></a>1.开发软件vscode</h3><p>vscode特点：</p>
<ul>
<li>开源，免费；</li>
<li>自定义配置</li>
<li>集成git</li>
<li>智能提示强大</li>
<li>支持各种文件格式（html/jade/css/less/sass/xml）</li>
<li>调试功能强大</li>
<li>各种方便的快捷键</li>
<li>强大的插件扩展</li>
</ul>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>Debugger for Chrome：从VS Code调试在Google Chrome中运行的JavaScript代码。</p>
<p>beautify：格式化代码工具，美化Javascript，JSON，CSS，Sass，和HTML在Visual Studio代码。</p>
<p>Atuo Rename Tag：修改 html 标签，自动帮你完成头部和尾部闭合标签的同步修改。</p>
<p>中文（简体）语言包</p>
<p>Code Spell Checker：代码拼写检查器，一个与camelCase代码配合良好的基本拼写检查程序。此拼写检查程序的目标是帮助捕获常见的拼写错误，同时保持误报数量较低。 </p>
<p>vscode-icons：显示Visual Studio代码的图标，目前该插件已被vscode内部支持：”文件” -&gt; “首选项” -&gt; “文件图标主题”。 </p>
<p>guides：显示代码对齐辅助线，很好用。</p>
<p>filesize：在状态栏中显示当前文件大小，点击后还可以看到详细创建</p>
<p>Path Intellisense：可自动填充文件名。 </p>
<h3 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h3><ol>
<li><strong>HTML</strong> 定义了网页的内容</li>
<li><strong>CSS</strong> 描述了网页的布局</li>
<li><strong>JavaScript</strong> 控制了网页的行为</li>
<li><strong>Vue.js</strong>（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。<br>Vue 只关注视图层， 采用自底向上增量开发的设计。<br>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</li>
</ol>
<h3 id="3-开始一个vue项目"><a href="#3-开始一个vue项目" class="headerlink" title="3.开始一个vue项目"></a>3.开始一个vue项目</h3><h4 id="1）安装node环境"><a href="#1）安装node环境" class="headerlink" title="1）安装node环境"></a>1）安装node环境</h4><h5 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h5><p>简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<p>Node.js是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言</p>
<p>类似于J2EE</p>
<blockquote>
<p>Java的三个版本 : JAVASE(标准版),JAVAEE(企业版),JAVAME(微型版).</p>
<p>java是一个平台。他包括了，java语言，java开发环境(jdk)。java有三个版本，j2se(标准版),j2ee(企业版),j2me(微型版)不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。j2EE是java的企业级开发版本，其实换句话说就是用来做web开发的java框架。javaEE通过设定统一的标准来解决web开发的问题，javaEE的接口，抽象类，规定了web开发所需要实现的流程。整个web的开发，有2层，第1层是服务器容器，比如tomcat，weblogic。他们在javaEE的规范下，实现套接字的连接，封装消息等等，第2层是业务，而这一层是你要做的，通过tomcat封装的消息，进行相应的业务处理。服务器容器的开发由大型的产商开发，而我们通常做的开发是在服务器容器上的业务开发，正是sun的javaEE统一了规范(比如用servlet)我们的业务代码，能和comcat进行很好的通讯。</p>
</blockquote>
<p>下载地址为：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<h5 id="npm简介"><a href="#npm简介" class="headerlink" title="npm简介"></a>npm简介</h5><p>npm：Node.js的包管理工具（package manager）大家都把自己开发的模块打包后放到npm官网上，如果要使用，</p>
<p>直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X</p>
<p>npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。</p>
<p>类似与MAVEN</p>
<p><code>npm install -g cnpm –registry=https://registry.npm.taobao.org</code>，即可安装npm镜像，以后再用到npm的地方直接用cnpm来代替就好了。</p>
<h4 id="2）搭建vue项目环境"><a href="#2）搭建vue项目环境" class="headerlink" title="2）搭建vue项目环境"></a>2）搭建vue项目环境</h4><p><strong>vue-cli简介</strong></p>
<p>vue-cli是vue官方提供的一个命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需一分钟即可启动带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。</p>
<p>安装vue-cli：vue-cli是vue.js的脚手架，用于自动生成vue.js+webpack的项目模板，自动化前端项目工具</p>
<p>webpack是一个<strong>打包器（bundler）</strong>，它能将多个js文件打包成一个文件（其实不止能打包js文件，也能打包其他类型的文件，比如css文件，json文件等）。</p>
<p><code>npm install --global vue-cli</code></p>
<h4 id="2-5）centos下安装"><a href="#2-5）centos下安装" class="headerlink" title="2.5）centos下安装"></a>2.5）centos下安装</h4><p><code>sudo yum install -y nodejs</code></p>
<p><code>sudo yum install -y npm</code></p>
<p><code>npm install --global vue-cli</code>    //发生错误，无法成功安装</p>
<blockquote>
<p><code>npm config set strict-ssl false</code>   //绕过https</p>
<p>再sudo执行还是不行👋🏻  卡住了。。。</p>
<p>Yarn是facebook发布的一款取代npm的包管理工具。</p>
<p><code>sudo npm install -g yarn</code>  同样的错误：npm ERR! Error: CERT_UNTRUSTED</p>
</blockquote>
<p>挥之不去的错误：npm安装过不了</p>
<p><strong>转战MAC安装：</strong></p>
<blockquote>
<p>1.安装node.js(<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">http://www.runoob.com/nodejs/nodejs-install-setup.html</a>)  node -v<br>2.安装npm：略  npm -v<br>3.安装cnpm：sudo npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>4.安装全局vue-cli脚手架,用于帮助搭建所需的模板框架：sudo cnpm install -g vue-cli</p>
</blockquote>
<h4 id="3-创建一个基于webpack模板的新项目"><a href="#3-创建一个基于webpack模板的新项目" class="headerlink" title="3)创建一个基于webpack模板的新项目"></a>3)创建一个基于webpack模板的新项目</h4><p>进入项目目录，创建一个基于webpack模板的新项目<br><code>vue init webpack myfirstvue</code></p>
<p>选择项目名字、项目描述、作者等等Vue build ==&gt; 打包方式，回车即可；</p>
<p>Install vue-router ==&gt; 是否要安装 vue-router</p>
<p>Use ESLint to lint your code ==&gt; 是否需要 js 语法检测 </p>
<p>Set up unit tests ==&gt; 是否安装 单元测试工具</p>
<p>Setup e2e tests with Nightwatch ==&gt; 是否需要 端到端测试工具 </p>
<p>顺便还安装了yarn</p>
<h4 id="4）进入项目，安装依赖"><a href="#4）进入项目，安装依赖" class="headerlink" title="4）进入项目，安装依赖"></a>4）进入项目，安装依赖</h4><p>cd myfirstvue 进入项目</p>
<p>安装成功后，项目文件夹中会多出一个目录：node_modules</p>
<h4 id="5）运行项目"><a href="#5）运行项目" class="headerlink" title="5）运行项目"></a>5）运行项目</h4><p>npm run dev  </p>
<p>运行效果：</p>
<p><img src="https://img2020.cnblogs.com/blog/2499596/202108/2499596-20210817150434095-1939209105.png"></p>
<h4 id="6）项目目录解读"><a href="#6）项目目录解读" class="headerlink" title="6）项目目录解读"></a>6）项目目录解读</h4><p>1、build：构建脚本目录</p>
<p>　　　　1）build.js  ==&gt; 生产环境构建脚本；``</p>
<p>　　　　2）check-versions.js  ==&gt; 检查npm，node.js版本；</p>
<p>　　　　3）utils.js  ==&gt; 构建相关工具方法；</p>
<p>　　　　4）vue-loader.conf.js  ==&gt; 配置了css加载器以及编译css之后自动添加前缀；</p>
<p>　　　　5）webpack.base.conf.js  ==&gt; webpack基本配置；</p>
<p>　　　　6）webpack.dev.conf.js  ==&gt; webpack开发环境配置；</p>
<p>　　　　7）webpack.prod.conf.js  ==&gt; webpack生产环境配置；</p>
<p>2、config：项目配置</p>
<p>　　　　1）dev.env.js  ==&gt; 开发环境变量；</p>
<p>　　　　2）index.js  ==&gt; 项目配置文件；</p>
<p>　　　　3）prod.env.js  ==&gt; 生产环境变量；</p>
<p>3、node_modules：npm 加载的项目依赖模块</p>
<p>4、src：这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</p>
<p>　　　　1）assets：资源目录，放置一些图片或者公共js、公共css。这里的资源会被webpack构建；</p>
<p>　　　　2）components：组件目录，我们写的组件就放在这个目录里面；</p>
<p>　　　　3）router：前端路由，我们需要配置的路由路径写在index.js里面；</p>
<p>　　　　4）App.vue：根组件；</p>
<p>　　　　5）main.js：入口js文件；</p>
<p>5、static：静态资源目录，如图片、字体等。不会被webpack构建</p>
<p>6、index.html：首页入口文件，可以添加一些 meta 信息等</p>
<p>7、package.json：npm包配置文件，定义了项目的npm脚本，依赖包等信息``</p>
<p>8、README.md：项目的说明文档，markdown 格式</p>
<p>9、.xxxx文件：这些是一些配置文件，包括语法配置，git配置等</p>
<h4 id="7）项目改造"><a href="#7）项目改造" class="headerlink" title="7）项目改造"></a>7）项目改造</h4><p>1.在components目录下新建一个views目录，里面写我们的vue组件<br>  在views目录下新建First.vue</p>
<p>2.在router目录下的index.js里面配置路由路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line">import HelloWorld from &#x27;@/components/HelloWorld&#x27;</span><br><span class="line">import first from &#x27;@components/views/first&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      name: &#x27;HelloWorld&#x27;,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: &#x27;/first&#x27;,</span><br><span class="line">      name: &#x27;first&#x27;,</span><br><span class="line">      component: first</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3.template 写 html，script写 js，style写样式（运行会提示空格引号错误之类的，按要求修改即可）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&gt;</span><br><span class="line">  &lt;div class=&quot;first-app&quot;&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;first&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;welcome to firstapp&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- what --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>4.效果：</p>
<p><img src="https://img2020.cnblogs.com/blog/2499596/202108/2499596-20210817150350056-832764408.png"></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.cnblogs.com/hellman/p/10985377.html">https://www.cnblogs.com/hellman/p/10985377.html</a></p>
<p><a href="https://www.cnblogs.com/miller-star/p/6394760.html">https://www.cnblogs.com/miller-star/p/6394760.html</a></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>java数和数组输入</title>
    <url>/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/0.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>java的输入需要依赖Scanner类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure>

<p>如果需要输入，则先声明一个Scanner对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner s = new Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>Scanner附属于输入流System.in，声明Scanner对象之后，在输入的时候需要使用<strong>next()方法</strong>系列指定输入的类型，如输入整数、输入字符串等。遇到回车结束。</p>
<p>常用的next()方法系列：nextInt():输入整数  nextLine():输入字符串   nextDouble():输入双精度数   next():输入字符串（以空格作为分隔符）。</p>
<p>next()方法读取到空白符就结束l；<br>nextLine()读取到回车结束也就是“\r”；</p>
<p>!!!意思是next(),空格结束是键盘输入，回车之后，拿取空格之前的，还是需要回车的。</p>
<p>就不能空格结束算作输入一个吗？？？貌似不能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入数字</span></span><br><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        x=in.nextFloat();</span><br><span class="line">        System.out.println(x);   <span class="comment">//换行输出，输出之后自动换行</span></span><br><span class="line">        System.out.print(x);    <span class="comment">//不换行打印</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;输出是：%f&quot;</span>, x);   <span class="comment">//按格式输出</span></span><br><span class="line"></span><br><span class="line">        String s1;</span><br><span class="line">        Scanner sin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        s1=sin.next();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        String s2;</span><br><span class="line">        Scanner sin2=<span class="keyword">new</span> Scanner(System.in);  <span class="comment">//每次输入之前，都需要重新来？？？</span></span><br><span class="line">        s2=sin2.nextLine();</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入数组</span></span><br><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nums</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入不定长的数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">            System.out.print(b[j] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输入定长数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入三个数：&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.length; i++)&#123;</span><br><span class="line">            c[i]=in.nextInt();</span><br><span class="line">            System.out.print(c[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>java二分查找</title>
    <url>/2021/10/13/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/1.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>有序的序列，每次都是以序列的中间位置的数来与待查找的关键字进行比较，每次缩小一半的查找范围，直到匹配成功。</p>
<p>一个情景：将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twosplit</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类内二分查找函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commonBinarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;            <span class="comment">//定义middle</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[low] || key &gt; arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            middle = low + (high - low) / <span class="number">2</span>;  <span class="comment">//防止溢出</span></span><br><span class="line">            <span class="comment">//如果 left 和 right 足够大，mid = (left + right)/2，可能会由于 left+right 导致 int 数据类型越界。</span></span><br><span class="line">            <span class="keyword">if</span> (arr[middle] &gt; key) &#123;</span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &lt; key) &#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;        <span class="comment">//最后仍然没有找到，则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入输出+测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入有序数组：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入目标值：&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> target = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=commonBinarySearch(nums, target);</span><br><span class="line">        System.out.printf(<span class="string">&quot;结果：%d&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode两数之和</title>
    <url>/2021/10/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>关于hashmap的使用：</p>
<p>m.put(a,b)  插入<br>m.containkey(a)  查找key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twonumbersum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先写功能函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a= target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.containsKey(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m.get(a), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再写测试函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入数组：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            nums[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入目标值：&quot;</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> target = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=twoSum(nums, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> re : res) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;结果：&quot;</span>);</span><br><span class="line">            System.out.print(re + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问：功能函数不是static型时，main函数也不能事static的，但是无运行按钮。除非把两个函数都变成static型。</p>
]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode丢失的数字</title>
    <url>/2022/01/04/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.1.4.%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</span><br><span class="line">输入：nums = [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p>首先解决输入，输入数组，next()方法读取到空白符就结束，因此使用nextLine()方法，可以规定以空格还是逗号来分割字符串，变为字符串数组，然后将字符串转变为int类型数字。</p>
<p>方法：如果先排序的话，排序算法时间复杂度高，排完序还得遍历一遍。不如直接遍历一遍，求和，然后算少谁，输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 丢失的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-04 20:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">missedNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入[0，n]的n个数字：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);  <span class="comment">//首先Scanner对象</span></span><br><span class="line">        String str = sc.nextLine();    <span class="comment">//使用Scanner的方法</span></span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);  <span class="comment">//分割字符串函数</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];  <span class="comment">//数组长度没括号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            b[i] = Integer.parseInt(arr[i]); <span class="comment">//字符串转数字函数parseInt</span></span><br><span class="line">        &#125;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        System.out.println(s.missingNumber(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;  <span class="comment">//Solution类不能是public的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="number">1</span>+nums.length)*nums.length/<span class="number">2</span> - sum;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识点：</p>
<p>求平方：<code>double pre = Math.pow(nums.length, 2);</code></p>
<p>double类型转换为int类型：<code>int res = new Double(pre).intValue();</code></p>
<p>数组排序：<code>Arrays.sort(nums);</code></p>
<p>其他方法：</p>
<p>哈希集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> missing = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) &#123;</span><br><span class="line">                missing = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异或运算：自己与自己异或，得到的是0，自己与0异或，得到的是自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xor ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            xor ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode Excel表列名称</title>
    <url>/2022/01/05/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.1.5.Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</span><br><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br></pre></td></tr></table></figure>

<p>首先要输入一个int，输出一个string，应该涉及到大写字母到小写字母的转换，以及字母到ASCII码的转换。</p>
<p>相当于26进制的转换，10进制变26进制，再转变为字母。</p>
<blockquote>
<p>A的ASCII码是65，a的ASCII码是97，ASCII码表中，小写字母排在大写字母的后面，一个字母的大小写数值相差32，一般知道大写字母的ASCII码数值，其对应的小写字母的ASCII码数值就算出来了，是大写字母的ASCII码数值+32。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Excel表列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-05 14:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">excelTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入一个数字：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        excelTableSolution s = <span class="keyword">new</span> excelTableSolution();</span><br><span class="line">        System.out.println(s.convertToTitle(num));</span><br><span class="line">        System.out.println(s.convertToTitle1(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">excelTableSolution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = (columnNumber-<span class="number">1</span>) % <span class="number">26</span> +<span class="number">1</span>;  <span class="comment">//26除余是0，这样变为26</span></span><br><span class="line">            res += (<span class="keyword">char</span>) (pre - <span class="number">1</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            columnNumber = (columnNumber - pre) / <span class="number">26</span>; <span class="comment">//注意！</span></span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(res);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者，直接用StringBuilder类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle1</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(columnNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = (columnNumber-<span class="number">1</span>) % <span class="number">26</span> +<span class="number">1</span>;  <span class="comment">//26除余是0，这样变为26</span></span><br><span class="line">            sb.append((<span class="keyword">char</span>) (pre - <span class="number">1</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            columnNumber = (columnNumber - pre) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode 整数转罗马数字</title>
    <url>/2022/01/08/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.1.8.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。  1 &lt;= num &lt;= 3999</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">；</span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/integer-to-roman</span><br><span class="line"></span><br><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<p>注意总共 13 个独特的符号（每个符号由 1 个或 2 个字母组成）。确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。</p>
<p>思路：建立一个数值-罗马符号的列表，从大到小排列，对列表进行遍历，如果num值大于当前遍历到的列表元素，就减去，并加上相应的字符串，直到num变为0。需要注意：同一个符号可能用好多次。所以while循环。列表就用数组表示，两个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 罗马数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-01-08 20:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">luomashuzi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入一个整数：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        luomashuziSolution s = <span class="keyword">new</span> luomashuziSolution();</span><br><span class="line">        System.out.print(s.intToRoman(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">luomashuziSolution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = values[i];</span><br><span class="line">            String symbol = symbols[i];</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= value)&#123;</span><br><span class="line">                num -= value;</span><br><span class="line">                res.append(symbol);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode 检测大写字母</title>
    <url>/2022/02/06/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.2.6.%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">520.给你一个字符串 word 。</span><br><span class="line">我们定义，在以下情况时，单词的大写用法是正确的：</span><br><span class="line">全部字母都是大写，比如 &quot;USA&quot; 。</span><br><span class="line">单词中所有字母都不是大写，比如 &quot;leetcode&quot; 。</span><br><span class="line">如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot; 。</span><br><span class="line"></span><br><span class="line">如果大写用法正确，返回 true ；否则，返回 false 。</span><br><span class="line">输入：word = &quot;Usa&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>关于字符串，遍历字符串使用<code>charAt</code>，以及判断字母是大写还是小写。ASC码中，A是65，a是97。大写小写相差32，而不是26.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 检测是否全大写520</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-02-06 10:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JianceDaxie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入字符串：&quot;</span>);</span><br><span class="line">        Scanner sin=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String ss = sin.next();</span><br><span class="line"><span class="comment">//        StringBuilder s = new StringBuilder(ss);  //String变StringBuilder</span></span><br><span class="line"><span class="comment">//        System.out.println(s);</span></span><br><span class="line">        JianceDaxieSolution s = <span class="keyword">new</span> JianceDaxieSolution();</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：&quot;</span>+s.detectCapitalUse(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianceDaxieSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse_1</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = word.charAt(i);  <span class="comment">//直接变acs码？？</span></span><br><span class="line">            <span class="keyword">if</span>(num &gt;=<span class="number">97</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> allUpperCase = <span class="keyword">true</span>;  <span class="comment">//是否全部大写</span></span><br><span class="line">        <span class="keyword">boolean</span> allLowerCaseFromSecond = <span class="keyword">true</span>;  <span class="comment">//是否从第二个开始全部小写</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(i) &lt; <span class="string">&#x27;A&#x27;</span> || word.charAt(i) &gt; <span class="string">&#x27;Z&#x27;</span>) &#123; <span class="comment">//可以直接判断的</span></span><br><span class="line">                allUpperCase = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (word.charAt(i) &lt; <span class="string">&#x27;a&#x27;</span> || word.charAt(i) &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                allLowerCaseFromSecond = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allUpperCase || allLowerCaseFromSecond;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他解法：</p>
<p><code>Character.isLowerCase(word.charAt(0))</code>判断字符是大写还是小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若第 1 个字母为小写，并且第二个字母是大写，则肯定false</span></span><br><span class="line">        <span class="keyword">if</span> (word.length() &gt;= <span class="number">2</span> &amp;&amp; Character.isLowerCase(word.charAt(<span class="number">0</span>)) &amp;&amp; Character.isUpperCase(word.charAt(<span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无论第 1 个字母是否大写，其他字母必须与第 2 个字母的大小写相同，比较绕了属于是</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLowerCase(word.charAt(i)) ^ Character.isLowerCase(word.charAt(<span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/detect-capital/solution/jian-ce-da-xie-zi-mu-by-leetcode-solutio-449z/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><code>word.toUpperCase()</code>字符串内所有字符大小写转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.toUpperCase().equals(word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (word.toLowerCase().equals(word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = word.length(), idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Character.isUpperCase(word.charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="keyword">while</span> (idx &lt; n &amp;&amp; Character.isLowerCase(word.charAt(idx))) idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：AC_OIer</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/detect-capital/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-rpor/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode 500.键盘行</title>
    <url>/2022/02/14/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/2022.2.14.%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<p>一道关于哈希表的题目，温习一下哈希表的java操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。</span><br><span class="line"></span><br><span class="line">美式键盘 中：</span><br><span class="line"></span><br><span class="line">第一行由字符 &quot;qwertyuiop&quot; 组成。</span><br><span class="line">第二行由字符 &quot;asdfghjkl&quot; 组成。</span><br><span class="line">第三行由字符 &quot;zxcvbnm&quot; 组成。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/keyboard-row</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure>

<p>温习：关于hashmap、hashset原理及使用。</p>
<p>思路一：知道各个字母键盘上的位置，编写一串26个字母的字符串，进行比较判别。当然，首先应该设置一个<code>ArrayList&lt;String&gt;()</code>，用来存放结果。</p>
<p>我们为每一个英文字母标记其对应键盘上的行号，然后检测字符串中所有字符对应的行号是否相同。</p>
<p>我们可以预处理计算出每个字符对应的行号。<br>遍历字符串时，统一将大写字母转化为小写字母方便计算。</p>
<blockquote>
<p>疑问：<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code>和<code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code>的区别？</p>
<p>第一种形式用当前类作为引用类型，那么可以访问到ArrayList这个类中的所有公用方法。</p>
<p>第二种形式，用ArrayList实现的接口List作为引用类型，那么通过list引用可以访问到接口中定义的方法。</p>
<p>也就是说ArrayList这个类实现了List接口，除了要必须实现接口List中声明的方法外，还可以实现额外的一些方法。</p>
<p>但是，第二种形式就无法调用的List接口以外的方法。</p>
<p>使用上，设计模式中有：“代码尽量依赖于抽象，不依赖于具体”。第一种形式就是依赖具体，第二种形式就是依赖于抽象。因为List是接口。代码依赖于抽象的好处是，代码可以方便替换。<br>————————————————<br>例如:代码List list = new ArrayList();下面通过list来操作集合。代码编写后发现集合使用的不准确，应该使用LinkedList，那么只要修改一行代码List list = new LinkedList();就可以，这行以后的代码不需要修改，因为List接口保证了调用的都是接口中的方法，而ArrayList与LinkedList都实现了List接口。而如果当时用ArrayList list = new ArrayList()这种形式的话，那么list访问到的就可能是ArrayList里独有的方法而非List接口中的方法。这样替换成LinkedList的时候就有可能需要修改很多的代码。<br>————————————————<br>前一个可以使用ArrayList独有的方法。后面的只能调用List接口声明的方法<br>List是一个接口，而ListArray是一个类。<br>ListArray继承并实现了List。<br>所以List不能被构造，但可以向上面那样为List创建一个引用，而ListArray就可以被构造。<br>List list; //正确 list=null;<br>List list=new List(); // 是错误的用法<br>List list = new ArrayList();这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个List对象了，有些ArrayList有但是List没有的属性和方法，它就不能再用了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: leeco</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-02-14 17:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JianPanHang500</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入字符串数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        JianPanHang500Solution s = <span class="keyword">new</span> JianPanHang500Solution();</span><br><span class="line">        <span class="comment">//数组直接返回是地址，必须要用Arrays.toString</span></span><br><span class="line">        System.out.println(Arrays.toString(s.findWords(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianPanHang500Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String rowIdx = <span class="string">&quot;12210111011122000010020202&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isValid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//首先看第一个字母是第几行的</span></span><br><span class="line">            <span class="keyword">char</span> idx = rowIdx.charAt(Character.toLowerCase(word.charAt(<span class="number">0</span>)) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">                <span class="comment">//遍历字符串中的字符，注意需要变小写，遇到不是同一行的就break，同时需要标志位</span></span><br><span class="line">                <span class="keyword">if</span> (rowIdx.charAt(Character.toLowerCase(word.charAt(i)) - <span class="string">&#x27;a&#x27;</span>) != idx) &#123;</span><br><span class="line">                    isValid = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">                list.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//list类型的字符串数组变为字符串数组，有简单方法：return ans.toArray(new String[ans.size()]);</span></span><br><span class="line">        String[] ans = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法本质上并没有用到哈希表，用到了集合ArrayList，为什么不直接用String[]呢，因为数组长度不可变，得用容器。</p>
<hr>
<p>思路二：其实一样，思路一那个字符串被当作是哈希表里，它是直接就创建了。下面可以自定义函数创建，创建的是数组，因为字母个数有限，所以不论是字符串还是数组，都是下标对应哪个字母，值对应值，也算是key（字母）–  value（哪一行）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">static</span> &#123;   <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="comment">// 整理26个字母分别每一行对应1、2、3</span></span><br><span class="line">    set(<span class="string">&quot;qwertyuiop&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    set(<span class="string">&quot;asdfghjkl&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    set(<span class="string">&quot;zxcvbnm&quot;</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String s, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        chars[index(s.charAt(i))] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>static{}(静态代码块)与{}(非静态代码块)的异同点?</p>
<p>相同点：都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个。　一般在代码块中对一些static变量进行赋值。</p>
<p>不同点：静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p>
</blockquote>
]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode二叉树篇</title>
    <url>/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87/</url>
    <content><![CDATA[<h2 id="二叉树的输入和遍历"><a href="#二叉树的输入和遍历" class="headerlink" title="二叉树的输入和遍历"></a>二叉树的输入和遍历</h2><p>二叉树定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点回车一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        TreeNode root = creatTree();</span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="comment">//回车结束输入</span></span><br><span class="line">        <span class="comment">//Scanner in=new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//num=in.nextInt();</span></span><br><span class="line">        <span class="comment">//还是回车结束</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        num=Integer.parseInt(str);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            root=<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            root.left=creatTree();</span><br><span class="line">            root.right=creatTree();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序创建二叉树：输入一个节点空格一次，一行输入。</p>
<h2 id="前中后序遍历，用递归，带输入输出"><a href="#前中后序遍历，用递归，带输入输出" class="headerlink" title="前中后序遍历，用递归，带输入输出"></a>前中后序遍历，用递归，带输入输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入二叉树！&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = creatTree(b);</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        ArrayList&lt;Integer&gt; qianxu = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        qianxu=preOrderReverse(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>+qianxu);</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        List&lt;Integer&gt; zhongxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        zhongxu=inorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>+zhongxu);</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        List&lt;Integer&gt; houxu = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        houxu=postorderTraversal(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>+houxu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照前序遍历方式创建二叉树，0代表空，例如1左2右3：1200300</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTree</span><span class="params">(<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">int</span> num=b[t++];</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root.left=creatTree(b);</span><br><span class="line">        root.right=creatTree(b);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归法进行遍历</span></span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrderReverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);           <span class="comment">// 注意这一句</span></span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             <span class="comment">// 注意这一句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前中后序遍历，用迭代"><a href="#前中后序遍历，用迭代" class="headerlink" title="前中后序遍历，用迭代"></a>前中后序遍历，用迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS--递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--迭代方式--借助队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) que.offer(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226题-翻转二叉树"><a href="#226题-翻转二叉树" class="headerlink" title="226题.翻转二叉树"></a>226题.翻转二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后序遍历都可以</span></span><br><span class="line"><span class="comment">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapChildren</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101题-对称二叉树"><a href="#101题-对称二叉树" class="headerlink" title="101题.对称二叉树"></a>101题.对称二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较外侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareOutside = compare(left.left, right.right);</span><br><span class="line">        <span class="comment">// 比较内侧</span></span><br><span class="line">        <span class="keyword">boolean</span> compareInside = compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> compareOutside &amp;&amp; compareInside;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.pollFirst();</span><br><span class="line">            TreeNode rightNode = deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric3</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            TreeNode leftNode = deque.poll();</span><br><span class="line">            TreeNode rightNode = deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="keyword">null</span> || rightNode == <span class="keyword">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="257题-二叉树的所有路径"><a href="#257题-二叉树的所有路径" class="headerlink" title="257题.二叉树的所有路径"></a>257题.二叉树的所有路径</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        traversal(root, paths, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        paths.add(root.val);</span><br><span class="line">        <span class="comment">// 叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - <span class="number">1</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39题-组合总和"><a href="#39题-组合总和" class="headerlink" title="39题.组合总和"></a>39题.组合总和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line">说明：</span><br><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。</span><br><span class="line">示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 剪枝优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); <span class="comment">// 先进行排序</span></span><br><span class="line">        backtracking(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到了数字和为 target 的组合</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(res, path, candidates, target, sum + candidates[i], i);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯，移除路径 path 最后一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode哈希表篇</title>
    <url>/2021/11/03/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p>
<p>哈希函数、哈希碰撞：拉链法。线性探测法（要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了）</p>
<p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<h3 id="Java中Map与HashMap-Hashtable-HashSet的区别"><a href="#Java中Map与HashMap-Hashtable-HashSet的区别" class="headerlink" title="Java中Map与HashMap,Hashtable,HashSet的区别"></a>Java中Map与HashMap,Hashtable,HashSet的区别</h3><p>HashMap和Hashtable两个类都实现了Map接口，二者保存K-V对（key-value对）；HashSet则实现了Set接口，性质类似于集合。</p>
<p>HashTable和HashMap区别：</p>
<p>一、继承的父类不同<br>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。<br>二、线程安全性不同<br>Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。<br>三、是否提供contains方法<br>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。<br>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。<br>四、key和value是否允许null值<br>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br>Hashtable中，key和value都不允许出现null值。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>五、两个遍历方式的内部实现上不同<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>六、hash值不同<br>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>七、内部实现使用的数组初始化和扩容方式不同<br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。<br>HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<h2 id="242题-有效的字母异位词"><a href="#242题-有效的字母异位词" class="headerlink" title="242题.有效的字母异位词"></a>242题.有效的字母异位词</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span><br><span class="line">示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</span><br><span class="line">示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false</span><br></pre></td></tr></table></figure>

<p>思路：用map，先遍历一个往里加，再遍历另一个减，如果没有或者value是0，则false。看到只有小写字母，所以长度为26的数组来充当map也可以。</p>
<p>知识：char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<p>判断map中是否有某key：if(!m.containsKey(ch))</p>
<p>获得key对应的value：m.get(key)</p>
<p>改变某key的value，直接覆盖？不能：m[i]++;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt;m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())&#123;</span><br><span class="line">        <span class="comment">//数组的长度length不加括号，字符串的长度要加括号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch))&#123;</span><br><span class="line">                m.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(ch) || m.get(ch)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//a==0 和 a.equals(0) 一样</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.put(ch, m.get(ch)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法：单纯的字符串排序比较</p>
<p>首先将字符串变成字符数组，然后进行排序，然后进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="349题-两个数组的交集"><a href="#349题-两个数组的交集" class="headerlink" title="349题.两个数组的交集"></a>349题.两个数组的交集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定两个数组，编写一个函数来计算它们的交集。</span><br><span class="line">说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</span><br></pre></td></tr></table></figure>

<p>思路：哈希set即可。一个遍历得到数字，一个存储结果。</p>
<p>int[] 是固定长数组，没法像vector一样push_back</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="keyword">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] resArr = <span class="keyword">new</span> <span class="keyword">int</span>[resSet.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将结果几何转为数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : resSet) &#123;  <span class="comment">//数组、set可以这样做，string不行</span></span><br><span class="line">            resArr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题.快乐数"></a>202题.快乐数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</span><br></pre></td></tr></table></figure>

<p>思路：使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>知识：set判断某数是否存在：s.contains(i);</p>
<p>set添加一个数：s.add(i);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !record.contains(n)) &#123;</span><br><span class="line">            record.add(n);</span><br><span class="line">            n = getsum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得n各位平方后的和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="454题-四数相加"><a href="#454题-四数相加" class="headerlink" title="454题.四数相加"></a>454题.四数相加</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</span><br><span class="line"></span><br><span class="line">为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</span><br></pre></td></tr></table></figure>

<p>思路：用一个map代表双层循环，另外再来个双层循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span>[] nums3, <span class="keyword">int</span>[] nums4)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15题-三数之和"><a href="#15题-三数之和" class="headerlink" title="15题.三数之和"></a>15题.三数之和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意： 答案中不可以包含重复的三元组。</span><br><span class="line">示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure>

<p>思路：难点在于去重</p>
<p>方法一：两层循环，第二层加一个set。注意去重。</p>
<p>方法二：双指针法，其实是三指针，i指针后，left和right。三数之和如果大了，右指针左移，小了，左指针右移。</p>
<p>知识：动态数组ArrayList。添加数：result.add(Arrays.asList(nums[i], nums[left], nums[right])); （）asList是降int[]变成list的意思。</p>
<p>数组int[] 排序：Arrays.sort(nums);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18题-四数之和"><a href="#18题-四数之和" class="headerlink" title="18题.四数之和"></a>18题.四数之和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line">注意：答案中不可以包含重复的四元组。</span><br><span class="line">示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>

<p>四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode刷题数组篇</title>
    <url>/2021/10/31/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%95%B0%E7%BB%84%E7%AF%87/</url>
    <content><![CDATA[<h2 id="27题の移除元素"><a href="#27题の移除元素" class="headerlink" title="27题の移除元素"></a>27题の移除元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>思路：暴力解法：两个for循环，每找到一个，都将它后面的元素一个个往前移。时间复杂度是O(n^2)。</p>
<p>简单解法：快慢指针法，对哪个指针进行判断是关键，如果对慢指针进行判断，则有一个就会后面一直相邻交换。应该对快指针进行判断，快指针判断到不是目标值，将该值赋给慢指针所在位置，慢指针移动1，如果是目标值，直接跳过，慢指针不移动。因此一层循环可以解决，<strong>循环内是快指针</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>; fast&lt;nums.length; fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="977题の有序数组的平方"><a href="#977题の有序数组的平方" class="headerlink" title="977题の有序数组的平方"></a>977题の有序数组的平方</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</span><br><span class="line"></span><br><span class="line">示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</span><br><span class="line"></span><br><span class="line">示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<p>思路：双指针，因为原始数组是有序的，但是左边可能是负数，所以，数组的左右各一个指针，都往中间移动，判断两头的大小，挨个按照逆序塞到结果数组中。</p>
<p>知识：创建数组 int[] nums=new int[size];<br>Math.pow(n,m)幂次运算结果为double类型<br>强制类型转换(int)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];  <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">int</span> index=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.pow(nums[left],<span class="number">2</span>)&gt;=Math.pow(nums[right],<span class="number">2</span>))&#123;</span><br><span class="line">                res[index--]=(<span class="keyword">int</span>)Math.pow(nums[left],<span class="number">2</span>);</span><br><span class="line">                <span class="comment">//pow幂次运算结果是double类型，(int)来强制类型转换</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index--]=(<span class="keyword">int</span>)Math.pow(nums[right],<span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209题の长度最小的子数组"><a href="#209题の长度最小的子数组" class="headerlink" title="209题の长度最小的子数组"></a>209题の长度最小的子数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p>思路：滑动窗口，想象一下：右边加一个数，左边可以少几个数<br>窗口：连续的数组<br>起始位置：终止位置移动后，根据窗口内的和来判断是否移动起始指针<br>终止位置：<strong>循环内</strong>一个一个移动</p>
<p>知识：int的最大值：Integer.MAX_VALUE<br>最小运算：Math.min(a,b)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>; right&lt;nums.length; right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="comment">//这里得是&gt;=，并且min运算得在前面，因为开始窗口移动后可能不足target</span></span><br><span class="line">                res=Math.min(right-left+<span class="number">1</span>, res); <span class="comment">//注意判断的位置，一定得是while里</span></span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==Integer.MAX_VALUE? <span class="number">0</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59题の螺旋矩阵Ⅱ"><a href="#59题の螺旋矩阵Ⅱ" class="headerlink" title="59题の螺旋矩阵Ⅱ"></a>59题の螺旋矩阵Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</span><br><span class="line">示例:</span><br><span class="line">输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</span><br></pre></td></tr></table></figure>

<p>思路：判断是否进入四个角，需要拐弯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n*n; k++)&#123;</span><br><span class="line">            res[i][j]=k;</span><br><span class="line">            <span class="keyword">if</span>((i==<span class="number">0</span>||res[i-<span class="number">1</span>][j]!=<span class="number">0</span>)&amp;&amp;j&lt;n-<span class="number">1</span>&amp;&amp;res[i][j+<span class="number">1</span>]==<span class="number">0</span>)  j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((j==n-<span class="number">1</span>||res[i][j+<span class="number">1</span>]!=<span class="number">0</span>)&amp;&amp;i&lt;n-<span class="number">1</span>&amp;&amp;res[i+<span class="number">1</span>][j]==<span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((i==n-<span class="number">1</span>||res[i+<span class="number">1</span>][j]!=<span class="number">0</span>)&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;res[i][j-<span class="number">1</span>]==<span class="number">0</span>) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((j==<span class="number">0</span>||res[i][j-<span class="number">1</span>]!=<span class="number">0</span>)&amp;&amp;i&gt;=<span class="number">1</span>&amp;&amp;res[i-<span class="number">1</span>][j]==<span class="number">0</span>) i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于数组，思考一些双指针法、快慢指针法、滑动窗口法。</p>
<h2 id="动态数组ArrayList"><a href="#动态数组ArrayList" class="headerlink" title="动态数组ArrayList"></a>动态数组ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunoobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Weibo&quot;</span>);</span><br><span class="line">        System.out.println(sites);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">访问 ArrayList 中的元素可以使用 get() 方法：</span><br><span class="line">System.out.println(sites.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">如果要修改 ArrayList 中的元素可以使用 set() 方法：</span><br><span class="line">sites.set(<span class="number">2</span>, <span class="string">&quot;Wiki&quot;</span>); <span class="comment">// 第一个参数为索引位置，第二个为要修改的值</span></span><br><span class="line"></span><br><span class="line">如果要删除 ArrayList 中的元素可以使用 remove() 方法：</span><br><span class="line">sites.remove(<span class="number">3</span>); <span class="comment">// 删除第四个元素</span></span><br><span class="line"></span><br><span class="line">如果要计算 ArrayList 中的元素数量可以使用 size() 方法：</span><br><span class="line">System.out.println(sites.size());</span><br><span class="line"></span><br><span class="line">Collections.sort(sites);  <span class="comment">// 字母排序</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode字符串篇</title>
    <url>/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>char ch : s.<strong>toCharArray()</strong>  遍历字符串中的字符。c++中的 ch：s 不可用。</p>
<p>字符串中，获得第几个字符，不能用s[i]，而是：s.<strong>charAt(i)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sb.setCharAt(<span class="number">0</span>,<span class="string">&#x27;v&#x27;</span>);  <span class="comment">//替换某位置的字符</span></span><br></pre></td></tr></table></figure>

<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;Runoob&quot;;</span><br><span class="line">String str2=new String(&quot;Runoob&quot;);</span><br><span class="line">String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</span><br><span class="line">char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;;</span><br><span class="line">String helloString = new String(helloArray);  </span><br></pre></td></tr></table></figure>

<p>**注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。</p>
<p>如果需要对字符串做很多修改，那么应该选择使用 [StringBuffer &amp; StringBuilder 类]。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String site = &quot;www.runoob.com&quot;;</span><br><span class="line">int len = site.length();   (结果为14)</span><br></pre></td></tr></table></figure>

<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);</span><br><span class="line">String string1 = &quot;菜鸟教程网址：&quot;;     </span><br><span class="line">System.out.println(&quot;1、&quot; + string1 + &quot;www.runoob.com&quot;);  </span><br></pre></td></tr></table></figure>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.printf(字符串变量的值为%s&quot;, stringVar);</span><br><span class="line">String fs;</span><br><span class="line">fs = String.format(&quot; 字符串变量的值为 %s&quot;, stringVar);</span><br></pre></td></tr></table></figure>

<h3 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h3><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，<strong>所以如果需要对字符串进行修改推荐使用 StringBuffer。</strong></p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder(10);  //定大小</span><br><span class="line">sb.append(&quot;Runoob..&quot;);    //在容量内加</span><br><span class="line">sb.insert(8, &quot;Java&quot;);    //在容量外加</span><br><span class="line">System.out.println(sb); </span><br><span class="line">sb.delete(5,8);    //删除</span><br><span class="line">变成string字符串：  res.toString();</span><br></pre></td></tr></table></figure>

<p><strong>在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类</strong>。</p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Str.substring(4)   从4开始，包括4</span><br><span class="line">Str.substring(4, 10)   左闭右开，包括4不包括10</span><br></pre></td></tr></table></figure>

<h3 id="字符串转换为int"><a href="#字符串转换为int" class="headerlink" title="字符串转换为int"></a>字符串转换为int</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer.valueOf(&quot;444&quot;,16)  //16进制</span><br><span class="line">Integer.parseInt(arr[j]);</span><br></pre></td></tr></table></figure>

<h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder sb=new StringBuilder(s);</span><br><span class="line">return sb.reverse().toString();</span><br></pre></td></tr></table></figure>

<h2 id="344题-反转字符串"><a href="#344题-反转字符串" class="headerlink" title="344题.反转字符串"></a>344题.反转字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p>思路：一头一尾双指针，交换即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            s[l] ^= s[r]; </span><br><span class="line">            s[r] ^= s[l];  </span><br><span class="line">            s[l] ^= s[r];  </span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="541题-反转字符串Ⅱ"><a href="#541题-反转字符串Ⅱ" class="headerlink" title="541题.反转字符串Ⅱ"></a>541题.反转字符串Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</span><br><span class="line">如果剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line">如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span><br><span class="line">示例:</span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解法一：用StringBuffer类，对字符串进行改变。用到append（）方法、substring方法（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 找到k处和2k处</span></span><br><span class="line">            StringBuffer temp = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 与length进行判断，如果大于length了，那就将其置为length</span></span><br><span class="line">            <span class="keyword">int</span> firstK = (start + k &gt; length) ? length : start + k;</span><br><span class="line">            <span class="keyword">int</span> secondK = (start + (<span class="number">2</span> * k) &gt; length) ? length : start + (<span class="number">2</span> * k);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无论start所处位置，至少会反转一次</span></span><br><span class="line">            temp.append(s.substring(start, firstK));</span><br><span class="line">            res.append(temp.reverse());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果firstK到secondK之间有元素，这些元素直接放入res里即可。</span></span><br><span class="line">            <span class="keyword">if</span> (firstK &lt; secondK) &#123; <span class="comment">//此时剩余长度一定大于k。</span></span><br><span class="line">                res.append(s.substring(firstK, secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            start += (<span class="number">2</span> * k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：用char型数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="comment">//这里是判断尾数够不够k个来取决end指针的位置</span></span><br><span class="line">            <span class="keyword">int</span> end = Math.min(ch.length - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//用异或运算反转 </span></span><br><span class="line">            <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);   <span class="comment">//char型数组变string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer05-替换空格"><a href="#剑指offer05-替换空格" class="headerlink" title="剑指offer05.替换空格"></a>剑指offer05.替换空格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1： 输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>思路：直接用一个stringbuilder来新建字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//选用 StringBuilder 单线程使用，比较快</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//碰到空格则替换，否则直接复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">		<span class="comment">//str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot; &quot;</span>.equals(String.valueOf(s.charAt(i))))&#123;</span><br><span class="line">        <span class="comment">//.valueOf类型转换，类似parseInt也可以string转int</span></span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>思路：首先将整个字符串反转过来，然后将字符串中的单词反转一下，即可。</p>
<ul>
<li>移除多余空格 : “the sky is blue”</li>
<li>字符串反转：”eulb si yks eht”</li>
<li>单词反转：”blue is sky the”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseWords2() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        StringBuilder sb = removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">removeSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p>思路：如果要求不申请额外空间</p>
<ol>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        reverseString(sb,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverseString(sb,n,len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//翻转函数</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="459题-重复的子字符串"><a href="#459题-重复的子字符串" class="headerlink" title="459题.重复的子字符串"></a>459题.重复的子字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</span><br><span class="line">输入: &quot;abab&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p>思路：KMP算法，KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>KMP的精髓所在就是前缀表，前缀表：起始位置到下表i之前（包括i）的子串中，有多大长度的相同前缀后缀。</p>
<p>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。</p>
<p>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode栈与队列篇</title>
    <url>/2021/11/07/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/java%E3%81%AEleecode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack&lt;Character&gt; st = new Stack&lt;Character&gt;();</span><br><span class="line">或</span><br><span class="line">Deque&lt;Character&gt; st = new LinkedList&lt;Character&gt;();</span><br><span class="line">st.isEmpty()</span><br><span class="line">st.peek()</span><br><span class="line">st.pop();</span><br><span class="line">st.push(ch);</span><br></pre></td></tr></table></figure>

<h2 id="20题-有效的括号"><a href="#20题-有效的括号" class="headerlink" title="20题.有效的括号"></a>20题.有效的括号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串，判断字符串是否有效。</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = new HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">            put(&#x27;)&#x27;, &#x27;(&#x27;);</span><br><span class="line">            put(&#x27;]&#x27;, &#x27;[&#x27;);</span><br><span class="line">            put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        //Deque&lt;Character&gt; stack = new LinkedList&lt;Character&gt;();</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            char ch = s.charAt(i);</span><br><span class="line">            if (pairs.containsKey(ch)) &#123;</span><br><span class="line">                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue1= new LinkedList&lt;&gt;();</span><br><span class="line">queue1.isEmpty()</span><br><span class="line">queue2.offer(x);   //添加一个元素并返回true   如果队列已满，则返回false</span><br><span class="line">queue1.poll()   //移除并返问队列头部的元素  如果队列为空，则返回null</span><br><span class="line">queue1.peek()  //返回队列头部的元素   如果队列为空，则返回null</span><br><span class="line">remove   移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">element  返回队列头部的元素  如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">add       增加一个元索   如果队列已满，则抛出一个IIIegaISlabEepeplian异常</span><br><span class="line">put       添加一个元素  如果队列满，则阻塞</span><br><span class="line">take      移除并返回队列头部的元素    如果队列为空，则阻塞</span><br><span class="line"></span><br><span class="line">1、add()和offer()区别:</span><br><span class="line">add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</span><br><span class="line"></span><br><span class="line"> 2、poll()和remove()区别：</span><br><span class="line">remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</span><br><span class="line"></span><br><span class="line">3、element() 和 peek() 区别：</span><br><span class="line">element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</span><br></pre></td></tr></table></figure>

<h2 id="deque与queue"><a href="#deque与queue" class="headerlink" title="deque与queue"></a>deque与queue</h2><p><strong>Queue</strong>是简单的FIFO队列，<strong>Deque</strong>继承<strong>Queue</strong>实现双端队列。</p>
<p>队列(queue)是一种常用的<strong>数据结构</strong>，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，<strong>LinkedList实现了Queue接口</strong>,因为LinkedList进行插入、删除操作效率较高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      抛出异常	返回特殊值</span><br><span class="line">插入	add(e)	offer(e)</span><br><span class="line">移除	remove()	poll()</span><br><span class="line">检查	element()	peek()</span><br><span class="line"></span><br><span class="line">boolean add(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。</span><br><span class="line">boolean offer(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。</span><br><span class="line">E remove();获取并移除此队列的头。</span><br><span class="line">E poll();获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">E element();获取，但是不移除此队列的头。</span><br><span class="line">E peek();获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br></pre></td></tr></table></figure>

<p>双向队列<strong>Deque</strong>继承了<strong>Queue</strong>，此队列两端都能进行出列和入列操作。除了继承了<strong>Queue</strong>的接口，又对每种方法额外添加了<code>first</code>与<code>last</code>方法用以实现操作双端队列。</p>
<h3 id="队列queue的使用："><a href="#队列queue的使用：" class="headerlink" title="队列queue的使用："></a>队列queue的使用：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;String&gt;que = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        que.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        que.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+que);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=que.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+que);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向队列deque的使用："><a href="#双向队列deque的使用：" class="headerlink" title="双向队列deque的使用："></a>双向队列deque的使用：</h3><p>第一种用法：同queue一样，作为单向队列使用，此时使用offer入列，poll出列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq.offer(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq.offer(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=deq.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种用法：作为双向队列使用，此时使用offerFirst、pollFirst，offerLast、pollFirst，则可以实现队首队尾入列或者出列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; deq2 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;aa&quot;</span>);  <span class="comment">//从后面进入</span></span><br><span class="line">        deq2.offerLast(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        deq2.offerLast(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的队列：&quot;</span>+deq2);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(deq2.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= deq2.pollFirst();  <span class="comment">//从前面输出</span></span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的队列：&quot;</span>+deq2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种用法：作为栈来使用，遵循先入后出的原则，使用push和pop进行入栈和出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> inoutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDeque3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Deque&lt;String&gt; st = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        st.push(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        st.push(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">//输出队列</span></span><br><span class="line">        System.out.println(<span class="string">&quot;录入后的栈：&quot;</span>+st);</span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(st.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str= st.pop(); </span><br><span class="line">            System.out.println(<span class="string">&quot;依次输出：&quot;</span>+str);</span><br><span class="line">            System.out.println(<span class="string">&quot;输出后的栈：&quot;</span>+st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>queue是单向队列，遵循先入先出的原则，而deque是queue的子接口，不仅可以作为单向队列使用，同时可以作为双向队列使用，根据入列出列在队尾或者队首决定输出元素顺序，在使用push和poll方法时，deque被称为栈，实现先入后出的原则。</p>
<h2 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题.滑动窗口最大值"></a>239题.滑动窗口最大值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回滑动窗口中的最大值。</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br></pre></td></tr></table></figure>

<p>思路：单调队列，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p>
<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用双端队列手动实现单调队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347题-前K个高频元素（优先级队列）"><a href="#347题-前K个高频元素（优先级队列）" class="headerlink" title="347题.前K个高频元素（优先级队列）"></a>347题.前K个高频元素（优先级队列）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p>思路：统计元素出现的频率，对频率进行排序，找出前k个高频元素。首先统计元素出现的频率，这一类的问题可以使用map来进行统计。然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p>
<p>优先级队列：其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p><strong>堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<p>本题<strong>要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="comment">// 根据map的value值正序排，相当于一个小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode</title>
    <url>/2022/10/22/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/leeco%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>题目：给个数组和目标值，给出数组中两个数之和等于目标值的数的索引。<br>思想：哈希映射，利用map的快速查找key特性（<code>map.containsKey(key)</code>）来实现遍历一次就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 两数之和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-20 23:39</span><br><span class="line"> **/</span><br><span class="line">public class TwoNumSum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = new int[]&#123;2,7,11,15&#125;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        int[] res = solution.twoSum(nums, 9);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">                if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                    return new int[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalArgumentException(&quot;no result&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="两链表表示的数相加"><a href="#两链表表示的数相加" class="headerlink" title="两链表表示的数相加"></a>两链表表示的数相加</h2><p>题目：两个链表表示的数，1-&gt;2-&gt;3 表示 123，相加得到和的链表。<br>思想：相加遍历进位即可，carry表示进位，要在while循环外定义，要先算和再算进位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算两个琏表表示的数的和</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 10:18</span><br><span class="line"> **/</span><br><span class="line">public class TwoLinkNumSum &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 构造链表</span><br><span class="line">        ListNode listNode1 = ListNode.inputList(1, 2, 3);</span><br><span class="line">        ListNode.printList(listNode1);</span><br><span class="line">        ListNode.printList(ListNode.reverseList(listNode1));</span><br><span class="line">        ListNode l1 = ListNode.inputList(2, 4, 3);</span><br><span class="line">        ListNode l2 = ListNode.inputList(5, 6, 4);</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        ListNode sum = s.addTwoNumbers(l1, l2);</span><br><span class="line">        ListNode.printList(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">            // 定义pre节点，保证头节点也参与循环</span><br><span class="line">            ListNode pre = new ListNode(0);</span><br><span class="line">            ListNode cur = pre;</span><br><span class="line">            int carry = 0;</span><br><span class="line">            while (l1 != null || l2 != null) &#123;</span><br><span class="line">                int x = l1 == null ? 0 : l1.val;</span><br><span class="line">                int y = l2 == null ? 0 : l2.val;</span><br><span class="line">                int sum = (x + y + carry) % 10;</span><br><span class="line">                carry = (x + y + carry) / 10;</span><br><span class="line">                cur.next = new ListNode(sum);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                if (l1 != null) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (l2 != null) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (carry != 0) &#123;</span><br><span class="line">                cur.next = new ListNode(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            return pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;;</span><br><span class="line">        ListNode(int val) &#123;this.val = val;&#125;</span><br><span class="line">        ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        /** 向队尾添加节点 */</span><br><span class="line">        private void addNode(ListNode newNode) &#123;</span><br><span class="line">            if (this.next == null) &#123;</span><br><span class="line">                this.next = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.next.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 使用方法可变参数把一串数字变成链表 */</span><br><span class="line">        public static ListNode inputList(int ...data) &#123;</span><br><span class="line">            ListNode listHead = null;</span><br><span class="line">            for (int temp : data) &#123;</span><br><span class="line">                ListNode newNode = new ListNode(temp);</span><br><span class="line">                if (listHead == null) &#123;</span><br><span class="line">                    listHead = newNode;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    listHead.addNode(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return listHead;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 打印链表 */</span><br><span class="line">        public static void printList(ListNode head) &#123;</span><br><span class="line">            while (head != null) &#123;</span><br><span class="line">                System.out.print(head.val + &quot;-&gt;&quot;);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        /** 翻转链表 */</span><br><span class="line">        public static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">            ListNode pre = null;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            while (cur != null) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的最长无重复字符子串"><a href="#字符串的最长无重复字符子串" class="headerlink" title="字符串的最长无重复字符子串"></a>字符串的最长无重复字符子串</h2><p>题目：一个字符串，给出字符串的连续子串中其中无重复字符的子串的最大长度。<br>思想：滑动窗口，或者叫做双指针，两个指针的差+1表示窗口的长度，用一个map记录某字符最晚出现的位置的下一个位置。如果在start指针后面出现过就需要移动start到map该字符的value的位置了。如果要子串本身，还得记录开始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 无重复字符的最长子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-22 12:29</span><br><span class="line"> **/</span><br><span class="line">public class MaxNoRepeatString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabc&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">            // 用map表示字符对应的下一个位置</span><br><span class="line">            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            int res = 0;</span><br><span class="line">            String sub = null;</span><br><span class="line">            for (int start = 0, end = 0; end &lt; s.length(); end ++) &#123;</span><br><span class="line">                char c = s.charAt(end);</span><br><span class="line">                if (map.containsKey(c)) &#123;</span><br><span class="line">                    start = Math.max(start, map.get(c));</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果存在key，会更新</span><br><span class="line">                map.put(c, end + 1);</span><br><span class="line">                //res = Math.max(res, end - start + 1);</span><br><span class="line">                if (end - start + 1 &gt; res) &#123;</span><br><span class="line">                    res = end - start + 1;</span><br><span class="line">                    sub = s.substring(start, end + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;sub字符串：&quot; + sub);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>题目：给两个正序排列的数组，返回这两个数组合起来的数组的中位数。<br>思路1：遍历，在两个数组间横跳，遍历(m+n)/2+1次就好了。时间复杂度是O(m+n)<br>思路2：遍历是挨个排除不可能的值，那么如果用二分法就可以一半一半地排除不可能的值。其实是找第K小的数，要比两个数组的K/2位置的数，小的那个数组K/2及前面的数就可以排除掉，这样递归查找。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 寻找两个正序数组的中位数</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-23 10:10</span><br><span class="line"> **/</span><br><span class="line">public class MedianOfTwoArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array1 = new int[]&#123;1, 2&#125;;</span><br><span class="line">        int[] array2 = new int[]&#123;3, 4&#125;;</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.findMedianSortedArrays(array1, array2));</span><br><span class="line">        System.out.println(s.findMedianSortedArrays2(array1, array2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        // 方法一：在两个数组间遍历，移动(m+n)/2+1步</span><br><span class="line">        public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int index1 = 0, index2 = 0, left = 0, right = 0;</span><br><span class="line">            int size = nums1.length + nums2.length;</span><br><span class="line">            for (int i = 0; i &lt;= size / 2; i++) &#123;</span><br><span class="line">                // left慢一步</span><br><span class="line">                left = right;</span><br><span class="line">                if (index1 &lt; nums1.length &amp;&amp; (index2 == nums2.length || nums1[index1] &lt;= nums2[index2])) &#123;</span><br><span class="line">                    right = nums1[index1++];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right = nums2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (size % 2 == 0) &#123;</span><br><span class="line">                return (left + right) / 2.0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法二：二分法</span><br><span class="line">        public double findMedianSortedArrays2(int[] nums1, int[] nums2) &#123;</span><br><span class="line">            int n = nums1.length;</span><br><span class="line">            int m = nums2.length;</span><br><span class="line">            int left = (n + m + 1) / 2;</span><br><span class="line">            int right = (n + m + 2) / 2;</span><br><span class="line">            return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取两正序数组的第k大的值</span><br><span class="line">        private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;</span><br><span class="line">            // 要进行比较的数组的长度</span><br><span class="line">            int len1 = end1 - start1 + 1;</span><br><span class="line">            int len2 = end2 - start2 + 1;</span><br><span class="line">            if (len1 + len2 &lt; k) &#123;throw new IllegalArgumentException(&quot;no result&quot;);&#125;</span><br><span class="line">            // 出递归条件</span><br><span class="line">            if (len1 == 0) return nums2[start2 + k - 1];</span><br><span class="line">            if (len2 == 0) return nums1[start1 + k - 1];</span><br><span class="line">            if (k == 1) return Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">            // 要比较的两个数组的索引</span><br><span class="line">            int i = start1 + Math.min(len1, k / 2) - 1;</span><br><span class="line">            int j = start2 + Math.min(len2, k / 2) - 1;</span><br><span class="line">            if (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>题目：给一个字符串，返回该字符串的最长回文子串，例如：aba，abba。<br>思想1：可以挨个遍历每个字符，从字符开始向左右散发，如果不相等了就停止，并且分两种散发：一个中心字符，两个一样的作为中心字符。记录开始位置和结束位置。<br>思想2：回文子串也是该字符串与它倒过来的字符串的最长公共子串，可以用动态规划维护一个二维数组来做。动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。作用和工程中用 redis 做缓存有异曲同工之妙。<br>求出最长公共子串后，并不一定是回文串，我们还需要判断该字符串倒置前的下标和当前的字符串下标是不是匹配</p>
<blockquote>
<p>整体思想就是，申请一个二维的数组初始化为 0，然后判断对应的字符是否相等，相等的话<br>arr [ i ][ j ] = arr [ i - 1 ][ j - 1] + 1 。<br>当 i = 0 或者 j = 0 的时候单独分析，字符相等的话 arr [ i ][ j ] 就赋为 1 。<br>arr [ i ][ j ] 保存的就是公共子串的长度，表示以i为结尾和以j为结尾的前arr[i][j]个字符是公共子串。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最长回文子串</span><br><span class="line"> *</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-10-29 20:43</span><br><span class="line"> **/</span><br><span class="line">public class HuiWenString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aacabdkacaa&quot;;</span><br><span class="line">        Solution solution = new Solution();</span><br><span class="line">        System.out.println(solution.longestPalindrome(s));</span><br><span class="line">        System.out.println(solution.longestPalindrome1(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String longestPalindrome(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            int max = 0;</span><br><span class="line">            String res = null;</span><br><span class="line">            for (int i = 0; i &lt; s.length() - 1; i ++) &#123;</span><br><span class="line">                int l = i, r = i;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l + 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l + 1;</span><br><span class="line">                    res = s.substring(l + 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">                l = i;</span><br><span class="line">                r = i + 1;</span><br><span class="line">                while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                    l --;</span><br><span class="line">                    r ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r - l + 1 &gt; max) &#123;</span><br><span class="line">                    max = r - l + 1;</span><br><span class="line">                    res = s.substring(l + 1, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String longestPalindrome1(String s) &#123;</span><br><span class="line">            if (null == s || s.length() &lt; 2) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">            String res = null;</span><br><span class="line">            int max = 0;</span><br><span class="line">            int length = s.length();</span><br><span class="line">            int[][] arr = new int[length][length];</span><br><span class="line">            String rev = new StringBuffer(s).reverse().toString(); //字符串翻转</span><br><span class="line">            for (int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; length; j ++) &#123;</span><br><span class="line">                    //如果不想等可以不赋值为0，表示以这个字符为公共最后字符没有公共字符，动态规划也用不上</span><br><span class="line">                    if (s.charAt(i) == rev.charAt(j)) &#123;</span><br><span class="line">                        //为0的边界</span><br><span class="line">                        if (i == 0 || j == 0) &#123;</span><br><span class="line">                            arr[i][j] = 1;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            arr[i][j] = arr[i - 1][j - 1] + 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (arr[i][j] &gt; max) &#123;</span><br><span class="line">                        int beforeRev = length - 1 - j; //倒置前的坐标</span><br><span class="line">                        if (beforeRev + arr[i][j] - 1 == i) &#123; //判断下标是否对应</span><br><span class="line">                            max = arr[i][j];</span><br><span class="line">                            res = s.substring(i - arr[i][j] + 1, i + 1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><p>题目：将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>思路：根据行数可以得出多少个循环一次半Z，然后第一行就是除以几余几的，看有咩用方法可以获取一个字符串中位置是/n余i的字符组成的字符串。String的split方法尽管可以按照正则表达式来分割，但是貌似无法实现隔位分割。<br>所以只能是新建一个<code>List&lt;StringBuilder&gt;</code>，然后遍历字符串来append进去。比取余更好的做法是用一个index标注，往下是+1，遇到拐角就-1.</p>
<p>遍历字符串中的字符：<code>char c : s.toCharArray()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.string;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 12:08</span><br><span class="line"> **/</span><br><span class="line">public class ZTransform &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;PAYPALISHIRING&quot;;</span><br><span class="line">        Solution so = new Solution();</span><br><span class="line">        String res = so.convert(s, 3);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public String convert(String s, int numRows) &#123;</span><br><span class="line">            if (numRows &lt; 2) return s;</span><br><span class="line">            List&lt;StringBuilder&gt; rows = Lists.newArrayList();</span><br><span class="line">            //List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;();</span><br><span class="line">            //需要写入numRows个StringBuilder到List</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                rows.add(sb);</span><br><span class="line">            &#125;</span><br><span class="line">            int index = 0;</span><br><span class="line">            int step = -1;</span><br><span class="line">            for (char c : s.toCharArray()) &#123;</span><br><span class="line">                rows.get(index).append(c);</span><br><span class="line">                //遇到拐点，方向就反</span><br><span class="line">                if (index == 0 || index == numRows - 1) &#123;</span><br><span class="line">                    step = -step;</span><br><span class="line">                &#125;</span><br><span class="line">                index += step;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder res = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">                res.append(rows.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            return res.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><p>题目：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。-123 变 -321<br>Integer整数区间：[−2^31,  2^31 − 1]<br>思路1：变成一个字符串，然后反转，然后加符号。<br>思路2：对int一步一步/10，然后拿到结果一步一步*10<br>思路3：用栈stack，也得先变字符串，本质上也是字符串反转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leeco.nums;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-12 22:38</span><br><span class="line"> **/</span><br><span class="line">public class IntegerReverse &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        System.out.println(Math.pow(2, 31) - 1);</span><br><span class="line">        int i = -33;</span><br><span class="line">        System.out.println(~(i-1));  //和-i一样</span><br><span class="line">        Solution s = new Solution();</span><br><span class="line">        System.out.println(s.reverse(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">        System.out.println(s.reverse2(-123));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Solution &#123;</span><br><span class="line">        public int reverse(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                String newS = new StringBuilder(old).reverse().toString();</span><br><span class="line">                int res = Integer.parseInt(newS);</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse2(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                int res = 0;</span><br><span class="line">                while (x &gt; 0) &#123;</span><br><span class="line">                    res = res * 10 + x % 10;</span><br><span class="line">                    x = x / 10;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag) res = - res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int reverse3(int x) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean flag = false;</span><br><span class="line">                if (x &lt; 0) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x = -x;</span><br><span class="line">                &#125;</span><br><span class="line">                String old = String.valueOf(x);</span><br><span class="line">                Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">                for (char c : old.toCharArray()) stack.push(c);</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                while (!stack.empty()) sb.append(stack.pop());</span><br><span class="line">                int res = Integer.parseInt(sb.toString());</span><br><span class="line">                if (flag) res = -res;</span><br><span class="line">                return res;</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>javaのleecode刷题链表篇</title>
    <url>/2021/11/02/myblog/leecode%E5%88%B7%E9%A2%98%E4%B9%8Bjava/%E9%93%BE%E8%A1%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="链表的定义输入输出"><a href="#链表的定义输入输出" class="headerlink" title="链表的定义输入输出"></a>链表的定义输入输出</h2><p>首先使用结构体定义，与c++不同，java中没有指针，隐藏指针，让指向某对象的指针看起来更像那个对象本身。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">为什么java中的main函数不能是非static？</span><br><span class="line"></span><br><span class="line">不能在main方法中打印this关键字的信息，因为不能在静态方法中调用this。理由很简单，this表示“这个对象”，也就是声明一个类的对象，然而静态方法是不属于某一个特定对象而是属于这个类的。那么问题来了，为什么main函数必须设置成静态的呢？</span><br><span class="line"></span><br><span class="line">首先，main函数作为java程序的入口，也可以理解为一个接口，这个接口不是提供给程序员使用的，这时提供给用户等使用的，用户等不需要知道程序内部的实现，只需要知道接口就可以了，如果是非静态的，那么当用户开始使用时，就必须先去创建对象，那么创建对象的代码又写在哪里呢？呵呵，所以这个很难讲清。</span><br><span class="line"></span><br><span class="line">Main方法是我们学习Java编程语言时知道的第一个方法，你是否曾经想过为什么main方法是public、static、void的。当然，很多人首先学的是C和C++，但是在Java中main方法与前者有些细微的不同，它不会返回任何值，为什么main方式是public、static、void，这篇文章尝试去找到一些答案。</span><br><span class="line"></span><br><span class="line">Main方法是Java程序的入口，记住，我们这里不会讨论Servlet、MIDlet和其他任何容器管理的java程序，在java核心编程中，JVM会查找类中的public static void main(String[] args)，如果找不到该方法就抛出错误NoSuchMethodError:main 程序终止。</span><br><span class="line">Main方法必须严格遵循它的语法规则，方法签名必须是public static void，参数是字符串数组类型，如果是Java1.5及以后的版本还可以使用可变参数：</span><br><span class="line">public  static void main(String... args)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么main方法是静态的（static）</span><br><span class="line"></span><br><span class="line">正因为main方法是静态的，JVM调用这个方法就不需要创建任何包含这个main方法的实例。</span><br><span class="line">因为C和C++同样有类似的main方法作为程序执行的入口。</span><br><span class="line">如果main方法不声明为静态的，JVM就必须创建main类的实例，因为构造器可以被重载，JVM就没法确定调用哪个main方法。</span><br><span class="line">静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果main方法是静态的，那么它就会被加载到JVM上下文中成为可执行的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么main方法是公有的（public）</span><br><span class="line">Java指定了一些可访问的修饰符如：private、protected、public，任何方法或变量都可以声明为public，Java可以从该类之外的地方访问。因为main方法是公共的，JVM就可以轻松的访问执行它。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么main方法没有返回值（Void） </span><br><span class="line"></span><br><span class="line">因为main返回任何值对程序都没任何意义，所以设计成void，意味着main不会有任何值返回</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">main方法必须声明为public、static、void，否则JVM没法运行程序</span><br><span class="line">如果JVM找不到main方法就抛出NoSuchMethodError:main异常，例如：如果你运行命令：java HelloWrold，JVM就会在HelloWorld.class文件中搜索public static void main (String[] args) 放法</span><br><span class="line">main方式是程序的入口，程序执行的开始处。</span><br><span class="line">main方法被一个特定的线程”main”运行，程序会一直运行直到main线程结束或者non-daemon线程终止。</span><br><span class="line">当你看到“Exception in Thread main”如：Excpetion in Thread main:Java.lang.NullPointedException ,意味着异常来自于main线程</span><br><span class="line">你可以声明main方法使用java1.5的可变参数的方式如：</span><br><span class="line">public  static void main(String... args)</span><br><span class="line">除了static、void、和public，你可以使用final，synchronized、和strictfp修饰符在main方法的签名中，如：</span><br><span class="line">public  strictfp final  synchronized static  void main(String[] args)</span><br><span class="line">main方法在Java可以像其他方法一样被重载，但是JVM只会调用上面这种签名规范的main方法。</span><br><span class="line">你可以使用throws子句在方法签名中，可以抛出任何checked和unchecked异常</span><br><span class="line">静态初始化块在JVM调用main方法前被执行，它们在类被JVM加载到内存的时候就被执行了。</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://blog.csdn.net/peikunye/article/details/100513579">https://blog.csdn.net/peikunye/article/details/100513579</a></p>
<p><a href="https://blog.csdn.net/maxiao1204/article/details/75142811?yyue=a21bo.50862.201879">https://blog.csdn.net/maxiao1204/article/details/75142811?yyue=a21bo.50862.201879</a></p>
<p>对于java的构造函数有点懵逼，有参构造和无参构造可以同时存在吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链表节点定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;  <span class="comment">//必须要加public吗？</span></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反转链表：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入输出+测试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输入不定长的数组</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入链表：&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        ListNode head = <span class="keyword">null</span>; <span class="comment">//代表是个空节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>; <span class="comment">//pre在这里定义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">            b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(b[j]); <span class="comment">//真正的构造节点</span></span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;  <span class="comment">//首先判断是不是头节点</span></span><br><span class="line">                head = node;</span><br><span class="line">                pre = head; <span class="comment">//pre在这里等于head，不能在上面等于</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next=node;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        printList(head);</span><br><span class="line">        ListNode res = reversal(head);</span><br><span class="line">        printList(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reversal</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode front = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = front;</span><br><span class="line">            front = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203题-移除链表元素"><a href="#203题-移除链表元素" class="headerlink" title="203题.移除链表元素"></a>203题.移除链表元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题意：删除链表中等于给定值 val 的所有节点。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>思路：有可能头节点是要删除的，所以用prehead节点。c/c++需要清理节点内存。java/python则不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链表节点定义：</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode() &#123;&#125;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">     ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next = head;</span><br><span class="line">        <span class="comment">//ListNode prehead = new ListNode(-1, head);</span></span><br><span class="line">        ListNode pre = prehead;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//括号内不可以只是pre.next</span></span><br><span class="line">            <span class="keyword">if</span>(pre.next.val == val)&#123;</span><br><span class="line">                pre.next=pre.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24题-两两交换链表中得节点"><a href="#24题-两两交换链表中得节点" class="headerlink" title="24题.两两交换链表中得节点"></a>24题.两两交换链表中得节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p>思路：相当于是swap节点，不能只改变值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next = head;</span><br><span class="line">        ListNode pre = prehead;</span><br><span class="line">        <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span> &amp;&amp; pre.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode node1 = pre.next;</span><br><span class="line">            pre.next = node1.next;</span><br><span class="line">            ListNode node2 = pre.next.next;</span><br><span class="line">            pre.next.next = node1;</span><br><span class="line">            node1.next = node2;</span><br><span class="line">            pre = pre.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19题-删除链表的倒数第N个节点"><a href="#19题-删除链表的倒数第N个节点" class="headerlink" title="19题.删除链表的倒数第N个节点"></a>19题.删除链表的倒数第N个节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line">输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] </span><br></pre></td></tr></table></figure>

<p>思路：明显的双指针法，为了降低时间复杂度，尽可能扫描一次链表来解决。一个指针先走n步，再一起走，当前面的走到头，那就是要删除的倒数第n个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        prehead.next=head;</span><br><span class="line">        ListNode left = prehead;</span><br><span class="line">        ListNode right = prehead;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            left=left.next;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next=left.next.next;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</span><br></pre></td></tr></table></figure>

<p>思路：一眼双指针，阿里二面题目，这道题里链表相交的话后面是重叠了，合并，而不是只交一个点，交一个点的话只能双层for循环了。两个指针走完了都走另一个，会同时到达合并的第一个节点。如果没有合并，同时遍历到空节点返回空节点。如果两个合并的长度一样，则走到第一个点就会返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="keyword">null</span>)  a=headB;</span><br><span class="line">            <span class="keyword">else</span> a=a.next;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="keyword">null</span>)  b=headA;</span><br><span class="line">            <span class="keyword">else</span> b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142题-环形链表Ⅱ"><a href="#142题-环形链表Ⅱ" class="headerlink" title="142题.环形链表Ⅱ"></a>142题.环形链表Ⅱ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</span><br><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p>思路：经典的快慢指针。一个一次走一格，一个一次走两格。不需要虚拟头节点。这是判断链表是否有环的方法，如果有环，两个指针都会一直走，两个指针一定会相遇。但是相遇的点不一定是环的入口。</p>
<p>这个环肯定是后面一个环就不再出来了。</p>
<p>而要找到环的入口，画个图，最后得出来：x = (n - 1) (y + z) + z。再跑一遍就可以得到环的入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;  <span class="comment">//有环了，下面再找入口</span></span><br><span class="line">                <span class="keyword">while</span>(head!=slow)&#123;</span><br><span class="line">                    head=head.next;</span><br><span class="line">                    slow=slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>链表的种类主要为：单链表，双链表，循环链表</li>
<li>链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。</li>
</ul>
]]></content>
      <categories>
        <category>leecode刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面经</title>
    <url>/2021/10/31/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h3 id="虾皮-后端-一面-2021-7-18"><a href="#虾皮-后端-一面-2021-7-18" class="headerlink" title="虾皮-后端-一面-2021.7.18"></a>虾皮-后端-一面-2021.7.18</h3><p>1.redis数据类型的底层结构 set<br>2.hashmap底层结构<br>3.c++禁止拷贝构造<br>4.tcp三次握手四次挥手<br>5.四次挥手time_wait机制<br>6.http、ip、dns属于什么层<br>7.cpu调度算法<br>8.linux命令，看文件后几行，日志关键词查询<br>9.进程间通信 信号量<br>10.逻辑地址与物理地址映射<br>11.编程：翻转句子但不翻转单词</p>
<h3 id="字节-商业化后端-一面-2021-7-18"><a href="#字节-商业化后端-一面-2021-7-18" class="headerlink" title="字节-商业化后端-一面-2021.7.18"></a>字节-商业化后端-一面-2021.7.18</h3><p>1.redis分布式锁机制<br>2.redis数据类型使用场景<br>3.hashmap用红黑树优点是什么，map底层数据结构<br>4.vector和list底层实现原理<br>5.互斥锁底层原理，如何实现原子性<br>6.智力题：圆上取三点，构成锐角、直角、钝角三角形的概率？<br>7.编程：合并区间<br>8.编程：最长回文子串</p>
<h3 id="字节-商业化后端-二面-2021-7-18"><a href="#字节-商业化后端-二面-2021-7-18" class="headerlink" title="字节-商业化后端-二面-2021.7.18"></a>字节-商业化后端-二面-2021.7.18</h3><p>1.编程：给定一个多任务场景， 不同任务执行过程中是有相互依赖关系的；<br>输入： n 代表n个任务<br>输出： k代表k个依赖关系<br>输出： n个任务能够完成一次调度执行；<br>提示：用节点的入度，入度为0可以删掉。<br>2.redis如何保证原子性<br>3.redis事务<br>4.mysql避免死锁底层如何实现<br>5.tcp是保序的吗？seq、syn<br>6.五层模型都是干嘛的</p>
<h3 id="商汤scg-三面-2021-7-19"><a href="#商汤scg-三面-2021-7-19" class="headerlink" title="商汤scg-三面-2021.7.19"></a>商汤scg-三面-2021.7.19</h3><p>1.乐观锁的版本号机制如何实现<br>2.redis集群主从同步失败怎么办<br>3.网站打不开的原因，发散<br>4.聚簇索引和非聚簇索引，增量索引？<br>5.编程：岛屿数量<br>6.go结构体嵌套，new操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type a struct &#123;</span><br><span class="line">    add string</span><br><span class="line">&#125;</span><br><span class="line">type b struct &#123;</span><br><span class="line">    *a</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    b := new(b)</span><br><span class="line">    b.add = &quot;add&quot;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节-商业化后端-三面-2021-7-20"><a href="#字节-商业化后端-三面-2021-7-20" class="headerlink" title="字节-商业化后端-三面-2021.7.20"></a>字节-商业化后端-三面-2021.7.20</h3><p>1.编程：二叉树转化为双向链表<br>2.智力：老虎吃羊问题<br>3.redis索引原理<br>4.线程池实现考虑什么，伪代码<br>5.c++的锁<br>6.c++管理内存泄漏的方法<br>7.说说智能指针，几种的区别<br>8.单继承和多继承的虚函数表的区别<br>9.多态如何实现<br>10.IO多路复用<br>11.redis持久化</p>
<h3 id="字节-数据中台后端-一面-2021-7-29"><a href="#字节-数据中台后端-一面-2021-7-29" class="headerlink" title="字节-数据中台后端-一面-2021.7.29"></a>字节-数据中台后端-一面-2021.7.29</h3><p>1.redis持久化写硬盘，对内存操作有没有影响？<br>2.写硬盘的方法，怎么最快<br>3.mysql索引底层<br>4.数据库锁<br>5.select * from table where a between 10 and 20 for update；之后再插入一条20-20之间的数据，发生什么？<br>可重复读：不能插，解决了幻读。读未提交，能插入？<br>6.实现strncpy函数<br>7.二分查找<br>8.截断数组的查找</p>
<h3 id="字节-数据中台后端-二面-2021-8-2"><a href="#字节-数据中台后端-二面-2021-8-2" class="headerlink" title="字节-数据中台后端-二面-2021.8.2"></a>字节-数据中台后端-二面-2021.8.2</h3><p>1.redis单线程如何实现的<br>2.http输入url过程<br>3.http和https<br>4.评论系统数据库表设计<br>5.写代码，求一条评论的所有子评论个数<br>6.网络攻击手段，sql注入，怎么防止，把自己套圈子里了</p>
<h3 id="虾皮-后端-二面-2021-8-3"><a href="#虾皮-后端-二面-2021-8-3" class="headerlink" title="虾皮-后端-二面-2021.8.3"></a>虾皮-后端-二面-2021.8.3</h3><p>1.hashtable怎么实现的<br>2.c++ stl用过什么，数组与链表<br>3.二叉树路径-回溯算法<br>4.针对订单的安全id怎么生成</p>
<h3 id="阿里云-后端-二面-2021-8-3"><a href="#阿里云-后端-二面-2021-8-3" class="headerlink" title="阿里云-后端-二面-2021.8.3"></a>阿里云-后端-二面-2021.8.3</h3><p>1.个人云和企业云的区别的看法，toB和toC<br>2.发号器不需要做切流，下线吗？<br>    系统自保、准入条件、云计算：资源的池化、分割售卖、安全隔离、资源隔离、超卖、服务契约<br>3.哈希打散的id怎么生成？<br>4.雪花算法，时间回滚，机器不知道，不能识别，怎么办？<br>5.code：求相对路径</p>
<h3 id="商汤-hr面-2021-8-5"><a href="#商汤-hr面-2021-8-5" class="headerlink" title="商汤-hr面-2021.8.5"></a>商汤-hr面-2021.8.5</h3><p>1.性格缺点<br>2.选择公司最看重什么<br>3.对智慧交通看法</p>
<h3 id="360-后端一面-2021-8-6"><a href="#360-后端一面-2021-8-6" class="headerlink" title="360-后端一面-2021.8.6"></a>360-后端一面-2021.8.6</h3><p>1.平衡二叉树和红黑树，为什么用红黑树<br>2.服务器实例无法访问数据库怎么办，db不能平衡扩展<br>3.编程：扑克牌判断是不是顺子<br>4.udp怎么可靠</p>
<h3 id="虾皮-后端-hr面-2021-8-10"><a href="#虾皮-后端-hr面-2021-8-10" class="headerlink" title="虾皮-后端-hr面-2021.8.10"></a>虾皮-后端-hr面-2021.8.10</h3><p>1.如何看待加班<br>2.评价一下自己，他人眼中的你什么样的<br>3.有什么其他offer或者流程中<br>4.想要什么公司氛围<br>5.想去什么业务<br>6.为啥选后端</p>
<h3 id="腾讯-交通平台产品部-一面-2021-8-10"><a href="#腾讯-交通平台产品部-一面-2021-8-10" class="headerlink" title="腾讯-交通平台产品部-一面-2021.8.10"></a>腾讯-交通平台产品部-一面-2021.8.10</h3><p>1.有啥爱好？？？？？<br>2.推荐悬疑书？？？<br>3.手撕：一个字符串切片成字典里的字符串，回溯<br>4.unordered_set和set区别，实现方面<br>5.c++和go<br>6.set什么语法实现降序</p>
<h3 id="阿里-三面-凉经"><a href="#阿里-三面-凉经" class="headerlink" title="阿里-三面-凉经"></a>阿里-三面-凉经</h3><p>1.做过网络编程没有<br>2.一个程序运行，资源空间如何变化<br>3.拷问项目<br>4.为什么对边缘计算感兴趣<br>5.怎么看边缘计算<br>6.大致觉得没有网络相关的项目，没有可问的，问我自己认为有什么优点<br>7.大佬就是大佬，秒凉</p>
<h3 id="阿里-高德-后端-一面"><a href="#阿里-高德-后端-一面" class="headerlink" title="阿里-高德-后端-一面"></a>阿里-高德-后端-一面</h3><p>1.用过除redis、mysql之外的中间件吗<br>2.mysql innodb为什么用B+树<br>3.redis数据结构底层实现<br>4.redis集群怎么部署<br>5.设计模式了解哪些，平常用的<br>6.zookeeper优缺点<br>7.聚集索引和非聚集索引</p>
<h3 id="网易-AI-c-算法落地-一面"><a href="#网易-AI-c-算法落地-一面" class="headerlink" title="网易-AI-c++算法落地-一面"></a>网易-AI-c++算法落地-一面</h3><p>1.深挖项目<br>2.为什么不用高频？？高频-&gt;波长短-&gt;按说传输距离高，因为频率高衰减大<br>  说成了多普勒，开始深挖多普勒<br>3.手撕：1.最少跳跃次数 （用广度优先，没写过）换：2.最小编辑距离（ac）        </p>
<h3 id="渤海银行-提前批-软开-2021-8-29-笔试准备"><a href="#渤海银行-提前批-软开-2021-8-29-笔试准备" class="headerlink" title="渤海银行-提前批-软开-2021.8.29-笔试准备"></a>渤海银行-提前批-软开-2021.8.29-笔试准备</h3><p>渤海银行成立时间：</p>
<p>渤海企业文化：诚信、远见、开放、创新、关爱</p>
<p>品牌主张：一旦选择,终身相伴</p>
<h3 id="阿里高德-一面-笔试面"><a href="#阿里高德-一面-笔试面" class="headerlink" title="阿里高德-一面-笔试面"></a>阿里高德-一面-笔试面</h3><p>笔试构造什么数据结构，父子结构的，<br>分布式事务<br>CAP原则<br>一致性哈希<br>消息队列<br>限流算法</p>
<h3 id="网易有道AI-c-算法开发工程师-二面"><a href="#网易有道AI-c-算法开发工程师-二面" class="headerlink" title="网易有道AI-c++算法开发工程师-二面"></a>网易有道AI-c++算法开发工程师-二面</h3><p>深挖项目<br>手撕：给一个数组变成偶数位上都是偶数或是奇数位上都是奇数<br>手撕：二叉树回溯，求路径和</p>
<h3 id="阿里-高德-二面-凉经"><a href="#阿里-高德-二面-凉经" class="headerlink" title="阿里-高德-二面-凉经"></a>阿里-高德-二面-凉经</h3><p>上来自己的IDE共享屏幕手撕：多线程输出<br>手撕：最长无重复子串的长度<br>思考：相交链表找相交节点<br>数据库隔离级别如何实现<br>手里的offer，规划之类</p>
<h3 id="阿里-高德-三面"><a href="#阿里-高德-三面" class="headerlink" title="阿里-高德-三面"></a>阿里-高德-三面</h3><p>面试官还不错，上来问我以后用啥语言，跟我讲阿里的java生态<br>思考题：城市有公交站和地铁站，每个站有辐射面积，算城市交通的覆盖率。<br>聊聊面向对象三个特征<br>自己的优缺点<br>平常怎么提高效率的<br>有了解什么新技术吗？面试官讲了一通中国软件界的兼容问题<br>反问：学习java意见<br>1、学语言思想，《深入浅出java虚拟机》《java编程思想》学习语法<br>2、应用，java web spring mvc boot<br>数据库MYbrits，关系型数据库，分布式数据库H-base，分库分表，catch<br>RPC框架，分布式高并发高响应。</p>
<h3 id="渤海-一面"><a href="#渤海-一面" class="headerlink" title="渤海-一面"></a>渤海-一面</h3><p>java垃圾回收，sb了应该说一些的<br>hashmap负载因子<br>hashmap和hashtable<br>数据库存储引擎<br>写代码多少年了<br>redis持久化<br>重载和重写<br>异常处理，catch和finish，蒙了一些</p>
<h3 id="农行-测试-2021-9-13"><a href="#农行-测试-2021-9-13" class="headerlink" title="农行-测试-2021.9.13"></a>农行-测试-2021.9.13</h3><p>三道题，a了一点多道</p>
<h3 id="华为-通信算法-一面-2021-9-13"><a href="#华为-通信算法-一面-2021-9-13" class="headerlink" title="华为-通信算法-一面-2021.9.13"></a>华为-通信算法-一面-2021.9.13</h3><p>全程问项目论文，对于细节问的蛮多<br>本来2点开始，结果2.20才叫面试<br>三点10分还没结束，无奈最后的写一个框图的题写得草率。</p>
<h3 id="华为-通信算法-二面"><a href="#华为-通信算法-二面" class="headerlink" title="华为-通信算法-二面"></a>华为-通信算法-二面</h3><p>论文+项目<br>做一道题，关于似然等概率知识的，都忘光了</p>
<h3 id="华为-通信算法-主管面"><a href="#华为-通信算法-主管面" class="headerlink" title="华为-通信算法-主管面"></a>华为-通信算法-主管面</h3><p>论文，还可以</p>
<h3 id="农行-2021-9-14-凉经"><a href="#农行-2021-9-14-凉经" class="headerlink" title="农行-2021.9.14-凉经"></a>农行-2021.9.14-凉经</h3><p>c++连接数据库的方式<br>c++不能重载的运算符<br>c++创建进程的方式<br>创建线程的类<br>创建线程池的方式</p>
<h3 id="网易-总监面-2021-9-14"><a href="#网易-总监面-2021-9-14" class="headerlink" title="网易-总监面-2021.9.14"></a>网易-总监面-2021.9.14</h3><p>手撕求平方，精确到小数点后10位<br>手撕两个四边形面积的重叠面积/总面积<br>看我的论文？？？</p>
<h3 id="网易-hr面"><a href="#网易-hr面" class="headerlink" title="网易-hr面"></a>网易-hr面</h3><h3 id="阿里-hr面"><a href="#阿里-hr面" class="headerlink" title="阿里-hr面"></a>阿里-hr面</h3><p>介绍个项目，遇到的难点，如何解决<br>遇到过什么困难，如何化解</p>
]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.8.15 笔试记录</title>
    <url>/2021/08/19/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/2021.8.15%20%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>1.需要掌握以下图的深度优先遍历</p>
<p>2.信号量上执行正确的PV操作可有效避免多进程并发执行产生的与时间有关的错误。信号量S=0时，表示当前？</p>
]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>实习面经</title>
    <url>/2021/12/29/myblog/%E7%AC%94%E7%BB%8F%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h3 id="阿里云一面"><a href="#阿里云一面" class="headerlink" title="阿里云一面"></a>阿里云一面</h3><p>自我介绍</p>
<p>挑个项目阐述一下，针对项目最难的一个问题，怎么解决的</p>
<p>TCP拥塞控制</p>
<p>100万台服务器找100台CPU利用率最高的</p>
<p>指针和引用的区别</p>
<p>多进程和多线程</p>
<p>100万个数据排序怎么控制内存</p>
<p>Linux熟悉吗</p>
<p>如何解决死锁</p>
<p>如果进来还有什么需要学习的</p>
<p>有什么问题</p>
<h3 id="阿里钉钉一面"><a href="#阿里钉钉一面" class="headerlink" title="阿里钉钉一面"></a>阿里钉钉一面</h3><p>面试官你好，思考了很久。可以用锁，但是平时偏底层的代码基本没写过，所以没写出来。</p>
<ol>
<li>读写锁</li>
</ol>
<p>public static void putIfAbsent(Vector vector, Object object) {<br>    synchronized(vector) {<br>        if (!vector.contains(object)) {<br>            vector.add(object);<br>        }<br>        else {<br>            System.out.println(“The vertor is contains the object of “ + object.toString());<br>        }<br>    }<br>}</p>
<ol>
<li>固定vector大小</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>struct和classs的区别，struct可以多态吗，可以继承吗</p>
</li>
<li><p>c++内存分配，举例</p>
</li>
<li><p>c++新特性</p>
</li>
<li><p>一个数据表如果量非常大，如何处理提高效率。</p>
</li>
<li><p>序列化和反序列化</p>
</li>
<li><p>目标：实现一个线程安全的vector<br>需求：<br>1、类似于std::vector的功能，比如push_back，insert，erase，size，clear，迭代功能等（按照自己的思路提供方法，比如你想提供哪些给别人用，就设计哪些方法）<br>2、要求能多线程安全<br>3、如果能跨平台则加分<br>备注：<br>1、考虑一下性能<br>2、可使用STL vector<br>3、需要单测</p>
<p>//.h内容<br>//.cpp内容</p>
</li>
</ol>
<h3 id="阿里钉钉二面"><a href="#阿里钉钉二面" class="headerlink" title="阿里钉钉二面"></a>阿里钉钉二面</h3><p>1.阐述项目，要比较清晰，半小时</p>
<p>2.静态转换和动态转换</p>
<p>3.c++内存分配，栈分配内存效率为什么高</p>
<p>4.操作系统如何管理内存</p>
<p>5.智能指针</p>
<h3 id="腾讯游戏客户端开发，一面挂"><a href="#腾讯游戏客户端开发，一面挂" class="headerlink" title="腾讯游戏客户端开发，一面挂"></a>腾讯游戏客户端开发，一面挂</h3><p>1.多重继承问题</p>
<p>2.虚析构函数</p>
<p>3.内存对齐问题</p>
<p>4.vector和list差别</p>
<p>5.list删除元素操作</p>
<p>6.erase函数用法</p>
<p>7.物理内存和虚拟内存的辨析</p>
<p>8.tcp和udp，http时tcp还是udp</p>
<h3 id="字节跳动测开面经，1面-2面-3面-hr面"><a href="#字节跳动测开面经，1面-2面-3面-hr面" class="headerlink" title="字节跳动测开面经，1面+2面+3面+hr面"></a>字节跳动测开面经，1面+2面+3面+hr面</h3><p>看了那么多大佬的面经，现在来回馈牛客啦。可能记录不全，当时不会的肯定记得，会的有些忘记了。几次面试问的问题也是有重复的。楼主语言是C++。字节面试体验非常不错。</p>
<p>每一面都有问到项目，跨专业的，跟计算机没啥关系，就不具体说了。</p>
<h4 id="1面，一小时10分钟"><a href="#1面，一小时10分钟" class="headerlink" title="1面，一小时10分钟"></a>1面，一小时10分钟</h4><p>1.线程与进程</p>
<p>2.TCP与UDP</p>
<p>3.指针与引用</p>
<p>4.new和malloc</p>
<p>5.C++与C</p>
<p>6.虚函数</p>
<p>7.浏览器输入URL发生什么</p>
<p>8.数据库三大范式</p>
<p>（一面问的比较八股，都是基础知识，操作系统，计算机网络，数据库都有问到）</p>
<p>9.测试用例设计，微信发朋友圈</p>
<p>10.对测试开发的理解</p>
<p>11.测试方法</p>
<p>手撕代码：有效的IP地址。</p>
<h4 id="2面，一个小时"><a href="#2面，一个小时" class="headerlink" title="2面，一个小时"></a>2面，一个小时</h4><p>1.HTTP和HTTPS</p>
<p>2.端口</p>
<p>3.static几种用法</p>
<p>4.inline内联函数</p>
<p>5.数组的sizeof</p>
<p>6.-1在计算机中是怎么存储的</p>
<p>7.堆和栈</p>
<p>手撕代码：题目忘记了，用排序sort做很简单，但是面试官说超出限制，就让我写了快排。</p>
<h4 id="3面，40分钟"><a href="#3面，40分钟" class="headerlink" title="3面，40分钟"></a>3面，40分钟</h4><p>1.事务</p>
<p>2.刷抖音后面变卡了，找原因</p>
<p>3.有限内存实现大量数据的排序，即外排</p>
<p>4.快排的时间复杂度</p>
<p>5.B+树</p>
<p>6.数据库索引，A索引andB索引能否生效</p>
<p>7.为什么不选开发</p>
<p>8.有哪些offer，在面哪些公司</p>
<p>9.对加班的看法</p>
<p>10.说说自己的优点和缺点</p>
<p>11.实习时间</p>
<p>有点意外，没有手撕代码。而且40分钟结束，楼主本来已经做好了面一个多小时的准备。最后反问的时候才知道这一面是交叉面。</p>
<h4 id="hr面，20分钟"><a href="#hr面，20分钟" class="headerlink" title="hr面，20分钟"></a>hr面，20分钟</h4><p>1.基本情况之类的</p>
<p>2.保研还是考研，本科成绩</p>
<p>3.其他offer</p>
<p>4.面试过程中有啥收获</p>
<p>5.对部门的了解</p>
<p>6.反问实习工资，说有档次？</p>
<p>许愿offer</p>
<h3 id="阿里钉钉二、三面"><a href="#阿里钉钉二、三面" class="headerlink" title="阿里钉钉二、三面"></a>阿里钉钉二、三面</h3><p>没问很多技术的问题，更多的是深挖思考，都是突然袭击。</p>
<p>第一个深挖的点是智能指针</p>
<p>第二个是实现线程安全的vector</p>
<p>手撕代码是字符串问题，不难，但是不能使用容器，有空间复杂度要求。</p>
<h3 id="美团-买菜部门-一面"><a href="#美团-买菜部门-一面" class="headerlink" title="美团-买菜部门-一面"></a>美团-买菜部门-一面</h3><p>美团技术栈是java，会问面试前了解过java吗，这时候即使了解一点点也别说了解，就说没学过，不然会问java的问题，答不上来gg。</p>
<p>HTTP为什么用TCP</p>
<p>HTTP的短连接和长连接，用了什么机制进行改善？</p>
<p>笔试的题目下去有没有再做？</p>
<p>快排时间复杂度是多少，为什么？</p>
<p>线程与进程的区别</p>
<p>多线程，线程安全举例，什么时候需要加锁，为什么加锁，举例</p>
<p>事务的特点</p>
<p>事务的隔离级别</p>
<p>可重复读指什么，怎么实现的？</p>
<p>什么是幻读？</p>
<p>手撕：字母组成的字符串a和字符串b，判断字符串a是否包含字符串b的所有字符，只要包含就行，不需要关心个数。用的26长度的数组代替set判断a中包含哪些字符，然后再遍历b，如果b中字符在数组中显示找不到，则不包含。时间复杂度On^2。</p>
<p>反问：什么部门，新兴部门吗？进去实习做什么？对实习生的培养计划？</p>
<h3 id="阿里-钉钉部门-HR面"><a href="#阿里-钉钉部门-HR面" class="headerlink" title="阿里-钉钉部门-HR面"></a>阿里-钉钉部门-HR面</h3><p>自我介绍</p>
<p>讲一个有挑战的事情</p>
<p>大学有啥实践工作</p>
<p>坚持最久的事情是什么？</p>
<p>在面其他什么公司</p>
<p>反问</p>
<h3 id="百度-C-开发-一面"><a href="#百度-C-开发-一面" class="headerlink" title="百度-C++开发-一面"></a>百度-C++开发-一面</h3><p>C++特点，与C相比，与其他语言相比</p>
<p>C++11新特性</p>
<p>多态，虚函数与纯虚函数</p>
<p>C++内存管理，堆和栈的区别</p>
<p>DNS属于哪一层，原理（不会）</p>
<p>七层模型说一下</p>
<p>数据库存储引擎区别</p>
<p>HTTP状态码各个数字开头代表什么</p>
<p>线程与进程的区别</p>
<p>进程间同步（不会）死锁，如何避免死锁？</p>
<p>Linux用过吗？用过什么指令，查看端口占用的指令用过吗</p>
<p>LInux的IO模型了解吗</p>
<p>手撕：删除链表的倒数第n个节点（1.先算节点个数，再删除。2.双指针，r指针先移动n）</p>
<h3 id="百度-C-二面"><a href="#百度-C-二面" class="headerlink" title="百度-C++-二面"></a>百度-C++-二面</h3><p>项目介绍，项目中的难点</p>
<p>C++虚函数和纯虚函数</p>
<p>C++模板，泛型编程，STL用过什么</p>
<p>多线程和多进程区别，多嘴说了单核多核，问了计算机组成原理的问题，CPU怎么组成的</p>
<p>单核上多线程和多进程区别</p>
<p>C++内存泄漏，如何排查</p>
<p>mysql会到什么程度</p>
<p>线程间通信方式</p>
<p>互斥锁和自旋锁</p>
<p>手撕：二叉树的层序遍历，需要自己构造二叉树。</p>
<h3 id="百度-C-三面"><a href="#百度-C-三面" class="headerlink" title="百度-C++-三面"></a>百度-C++-三面</h3><p>项目介绍</p>
<p>内存泄漏是第三次问了，怎么排查内存泄漏</p>
<p>看过开源的代码吗</p>
<p>问的技术问题不多，而且很多重复的</p>
<p>手撕：给了个中难度的，二叉搜索树，给一个值，返回大于这个值的最小的节点，就是大于这个值，但是最靠近这个值的节点。</p>
]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解java虚拟机》笔记</title>
    <url>/2023/02/19/myblog/%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="第一章-走进java"><a href="#第一章-走进java" class="headerlink" title="第一章 走进java"></a>第一章 走进java</h2><h4 id="1-java体系"><a href="#1-java体系" class="headerlink" title="1.java体系"></a>1.java体系</h4><p>java技术体系：<br>1.Java程序运行的虚拟机<br>2.java类库<br>3.java编程语言<br>4.第三方框架 spring、mybatis</p>
<p>虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。虚拟机完成对硬件平台的兼容和对内存等资源的管理工作。</p>
<p>程序性能、稳定性、扩展性上，需要知道虚拟机的特性及调节方式。</p>
<p>java语言 + java虚拟机 + java类库 = jdk（支持java程序开发的最小环境）<br>java类库中java se api + java虚拟机 = jre（java程序运行的标准环境）</p>
<p>1991年 james gosling 目标开发一种在电子产品上运行的程序架构。1995年改名为java，口号：write once， run anywhere。<br>1998年sun将java体系分为三个方向：面向桌面应用开发的j2se，面向企业级开发的j2ee，面向手机等移动终端开发的j2me。<br>2006年sun将java开源，建立openjdk组织进行管理源码，2009年oracle收购sun。<br>2013年java8发布，有lambda表达式（拥有函数式表达能力）、移除hotspot的永久代。<br>2018年oracle放弃java，所有权直接赠送给eclipse基金会。redhat（ibm的）负责了jdk历史版本的维护。</p>
<p>为什么喜欢用java8？<br>java8是一个功能强大的版本，新特性例如lambda表达式、stream api、新的日期/时间api，这些可以提高开发效率。其次，java8可以兼容早期的java版本，提高开发效率。基于可维护的考量，java8可以保证程序的可维护性。</p>
<h4 id="2-java虚拟机家族"><a href="#2-java虚拟机家族" class="headerlink" title="2.java虚拟机家族"></a>2.java虚拟机家族</h4><p>1996年，sun发布的jdk1.0中携带的虚拟机：Classic VM，只能使用纯解释器方式来执行，需要外挂编译器。Exact VM：热点探测、准确内存管理，摒弃掉Classic VM中基于句柄的对象查找方式。</p>
<p>HotSpot是Sun/Oracle JDK和OpenJDK中的默认java虚拟机。开始由小公司研发，热点代码探测技术、即时编译。2014年JDK 8 中移除了永久带。</p>
<p>BEA JRockit 专注于服务器硬件和服务端应用，不关心启动速度，里面不包含解释器。</p>
<p>IBM J9 VM。</p>
<p>Apache Harmony 没有大规模商用，但是他的许多java类库被吸纳。</p>
<h4 id="3-展望java的技术"><a href="#3-展望java的技术" class="headerlink" title="3.展望java的技术"></a>3.展望java的技术</h4><p>java：庞大的用户群和及其成熟的软件生态。</p>
<p>在hotspot基础上增强而成的跨语言全栈虚拟机：Graal VM，可以作为任何语言的运行平台使用。原理是用解释器来解释中间代码。（无语言倾向）</p>
<p>即时编译器：Graal编译器，代替C2。已经在java10中引入，不过要改参数来启用。</p>
<p>跑个helloworld也需要百兆的JRE，在近几年大型单体应用架构向小型微服务应用架构发展的技术潮流下，java不适应。在微服务架构视角下，应用拆分，高可用的服务集群，不需要单个服务不间断运行。但是java启动时间长，需要预热才能达到最高性能，有悖于微服务场景。所以发展提前编译。</p>
<p>hotspot虚拟机拥有了组合拆分功能的特性，源码中是接口与实现的分离。开放了编译器接口，重构了java虚拟机的垃圾回收器接口。</p>
<p>语言特性和语法糖：协程、不可变类型、JNI调用本地代码。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日常使用</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/Linux%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="给用户添加sudo权限"><a href="#给用户添加sudo权限" class="headerlink" title="给用户添加sudo权限"></a>给用户添加sudo权限</h2><p>–切换到拥有sudo权限的用户下，可以是su。 –输入命令”sudo vim /etc/sudoers”开始编辑/etc/sudoers文件。 –找到”root ALL=(ALL:ALL) ALL”这一 行，在它下面添加”xxx ALL=(ALL:ALL) ALL”(这里的xxx是你的用户名)，然后保存退出。因为是只读模式，输入”:wq!”强制保存并退出。</p>
<h2 id="获得本机ip"><a href="#获得本机ip" class="headerlink" title="获得本机ip"></a>获得本机ip</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig | grep &quot;inet&quot;</span><br><span class="line">ifconfig en0</span><br></pre></td></tr></table></figure>

<p>localhost：127.0.0.1 ，在 Linux 中，其定义位于 /etc/hosts。用于本机中各个应用之间的网络交互。不需要联网，本机访问。</p>
<p>localhost等于127.0.0.1，不过localhost是域名，127.0.0.1是IP地址。</p>
<p>本机 IP 就是本机对外放开访问的IP地址，这个网址就是与物理网卡绑定的IP地址。</p>
<p>访问127.0.0.1不调用网卡驱动，而是立即转发到本机IP层进行处理，不涉及底层操作。</p>
<p>本机IP，我们可以理解为本机有三块网卡，一块网卡叫做loopback（虚拟网卡），一块叫做ethernet（有线网卡），一块叫做wlan（你的无线网卡）。127.0.0.1 这个地址通常分配给 loopback 接口。</p>
<p>ping 127.0.0.1一般作为测试本机TCP/IP协议栈正常与否的判断之一。</p>
<h3 id="共有ip："><a href="#共有ip：" class="headerlink" title="共有ip："></a>共有ip：</h3><p>组建一个企业级网络，需要去向“电信运营商ISP”申请一个接入Internet的宽带，同时ISP还会给我们分配一个或多个IP地址，这些IP地址可以供我们企业内部上网，这些ISP分配给我们的IP，就是公有IP。</p>
<p>公有地址（Public address，也可称为公网地址）由Internet NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Internet NIC提出申请的组织机构。通过它直接访问因特网，它是广域网范畴内的。</p>
<h3 id="私有IP："><a href="#私有IP：" class="headerlink" title="私有IP："></a>私有IP：</h3><p>我们企业或家庭内部组建局域网用的IP，一般都会用私有IP。</p>
<p>私有地址（Private address，也可称为专网地址）属于非注册地址，专门为组织机构内部使用，它是局域网范畴内的，私有IP禁止出现在Internet中，在ISP连接用户的地方，将来自于私有IP的流量全部都会阻止并丢掉。私有ip在公网上不能被识别。必须通过NAT将内部IP地址转换成公网上可用的IP地址，从而实现内部IP地址与外部公网的通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址分固定和动态的两种，固定IP地址不会变，价格比较贵，多是企事业单位使用。</span><br><span class="line">家庭宽带连接就是动态IP，在不上网的时候,先前所用IP资源就会被释放出来供他人使用. 如果再上网，系统又分配一个IP给你，所以家庭用户的IP都是自动分配的，上网了就找一个给你用，断网了马上收回，再给其它人用，这样可以缓解IP地址紧张的问题。</span><br></pre></td></tr></table></figure>

<h3 id="子网掩码-netmask："><a href="#子网掩码-netmask：" class="headerlink" title="子网掩码 netmask："></a><strong>子网掩码 netmask：</strong></h3><p>将某个IP地址划分成网络地址和主机地址两部分，子网掩码必须是多个 1 相连，多个 0 相连的形式，总共 8 * 4 = 32 位。1的部分就是网络地址部分 0的部分就是主机地址部分。</p>
<p>255.255.255.0这个子网掩码可以容纳2的8次方（台）电脑，也就是256台，但是有两个IP是不能用的，位数全为0为网络号 位数全为1位广播号，减去这两台，就是254台。</p>
<p>一种子网掩码的简便写法:<br>192.163.1.199/24<br>ip后面的/24就是子网掩码255.255.255.0的简写 意为网络位为24位也就是二进制左边24个1</p>
<h3 id="广播地址broadcast："><a href="#广播地址broadcast：" class="headerlink" title="广播地址broadcast："></a>广播地址broadcast：</h3><p>广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.0.0.0 ）网段，其直播广播地址为10.255.255.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.255.255.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<h3 id="my-Mac-地址："><a href="#my-Mac-地址：" class="headerlink" title="my Mac 地址："></a>my Mac 地址：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inet 172.22.150.82 netmask 0xfffffe00 broadcast 172.22.151.255</span><br><span class="line">inet是本机ip</span><br><span class="line">netmask表示了23位网络位，9位主机位</span><br><span class="line">broadcast表示150二进制：10010110，前七位网络号，后面一位变1，即广播号：172.22.151.255</span><br></pre></td></tr></table></figure>

<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls  显示所有文件</span><br><span class="line">ls -a   显示包括.开头的隐藏文件</span><br><span class="line">ls -l   列出文件详细信息  = ll</span><br><span class="line">ll -a = ls -al</span><br><span class="line"></span><br><span class="line">ll -a |grep pre  //找pre的</span><br><span class="line"></span><br><span class="line">tree  数状显示当前目录下所有文件</span><br><span class="line">tree需要先安装</span><br><span class="line">tree --version  参看是否安装</span><br><span class="line">sudo apt/brew install tree   安装</span><br><span class="line">tree -L 2   显示二级目录</span><br></pre></td></tr></table></figure>

<h2 id="文本查看相关"><a href="#文本查看相关" class="headerlink" title="文本查看相关"></a>文本查看相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat 是一个文本文件查看和连接工具。</span><br><span class="line">cat -n a.md   带行号显示</span><br><span class="line">cat -b a.md   空白行不编号</span><br><span class="line">cat a.md &gt; b.md  a内容写到b中，覆盖</span><br><span class="line">cat a.md b.md &gt; c.md  a.b.都写到c里</span><br><span class="line">cat a.md|tail -n2   显示最后两行</span><br><span class="line">cat a.md|tail -n+2   显示从第二行到尾</span><br><span class="line">cat a.md|head -n2   显示前两行</span><br><span class="line">cat a.md|head -n4 | tail -n+2   显示2-4行 tail从2开始，head前4行，两者交集</span><br><span class="line">cat /dev/null &gt; a.md  清空文件</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail 命令可用于查看文件的内容，-f 常用于查阅正在改变的日志。</span><br><span class="line">tail -f -n10 a.md  不断循环读取尾部10行</span><br><span class="line">tail -n10 a.md  显示最后10行</span><br><span class="line">tail -n +20 notes.log   从第20行显示至末尾</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;2,4p&#x27; a.md    显示2-4行</span><br></pre></td></tr></table></figure>

<p><code>tail -fn10 worker.log</code></p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>场景：求日志中某一值的个数及平均值<br>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。<br>样式扫描和处理语言。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;BEGIN&#123;sum=0&#125;&#123;sum=sum+$1&#125;END&#123;print sum/NR&#125;&#x27;</span><br><span class="line">//输出平均</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f platform-idproducer.log.wf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; platform-idproducer.log.wf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;END&#123;print NR&#125;&#x27;</span><br><span class="line">//输出行数</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf</span><br><span class="line">//-F指定分隔符用来指定分隔符，指定&#x27;Cost time:&#x27;为分隔符。</span><br><span class="line">//总共分成两个域，&#x27;&#123;print $2&#125;&#x27;表示输出第二个域，&#x27;&#x27;少不了</span><br></pre></td></tr></table></figure>

<p>awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，<code>$0</code>则表示所有域,<code>$1</code>表示第一个域,<code>$n</code>表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;</span><br><span class="line">//表示上一步输出的文本，逐行筛选，有ns的输出，不加&#x27;&#x27;也行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">//上一步输出逐行的***ns，这一步自定义ns为分隔符，输出第一个域，相当于去掉了ns，只剩下数字</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;&#123;print NR,$0&#125;&#x27;</span><br><span class="line">//NR表示每行的记录号，这个输出行号+所有域</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F &#x27;Cost time:&#x27; &#x27;&#123;print $2&#125;&#x27; platform-idproducer.log.wf|grep &#x27;ns&#x27;|awk -F &#x27;ns&#x27; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;BEGIN&#123;sum=0&#125;&#123;sum=sum+$1&#125;END&#123;print sum/NR&#125;&#x27;</span><br><span class="line">//BEGIN 初始化代码块，主要是引用全局变量</span><br><span class="line">//END 结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</span><br><span class="line">//begin的作用在于不会每行都刷新sum，保证sum的全局性</span><br><span class="line">//end的意思是最后遍历完才执行后面的语句，如果不用end，则每行都计算一下</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用：查看日志中error为0的行数：</span><br><span class="line">awk &#x27;&#123;print $0&#125;&#x27; old.log|grep &#x27;errno&quot;:0&#x27;|awk &#x27;END&#123;print NR&#125;&#x27;</span><br><span class="line">//输出有error：0的行数，即正确请求数</span><br></pre></td></tr></table></figure>



<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -A    显示所有进程信息</span><br><span class="line">-e和-A的意思是一样的，即显示有关其他用户进程的信息，包括那些没有控制终端的进程。</span><br><span class="line">-f显示用户id，进程id，父进程id，最近CPU使用情况，进程开始时间等等。</span><br><span class="line">ps -ef|grep idpro</span><br></pre></td></tr></table></figure>

<p>✅ps- ef 和 -aux</p>
<p>1、ps -ef用于查看全格式的全部进程，ps -aux也是用于查看进程。其中“ps”是在Linux中是查看进程的命令，“-e ”参数代表显示所有进程，“-f”参数代表全格式。</p>
<p>2、ps -ef和ps aux，这两者的输出结果差别不大，但展示风格不同。aux是BSD风格，显示的项目有：USER , PID , %CPU , %MEM , VSZ , RSS , TTY , STAT , START , TIME , COMMAND。而-ef是System V风格，显示的项目有：UID , PID , PPID , C , STIME , TTY , TIME , CMD。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-ef字段含义：</span><br><span class="line">字段含义如下：</span><br><span class="line">UID       PID       PPID      C     STIME    TTY       TIME         CMD</span><br><span class="line">zzw      14124   13991      0     00:38      pts/0      00:00:00    grep --color=auto dae</span><br><span class="line"></span><br><span class="line">UID      ：程序被该 UID 所拥有</span><br><span class="line">PID      ：就是这个程序的 ID </span><br><span class="line">PPID    ：则是其上级父程序的ID</span><br><span class="line">C          ：CPU使用的资源百分比</span><br><span class="line">STIME ：系统启动时间</span><br><span class="line">TTY     ：登入者的终端机位置</span><br><span class="line">TIME   ：使用掉的CPU时间。</span><br><span class="line">CMD   ：所下达的是什么指令</span><br><span class="line"></span><br><span class="line">aux字段含义：</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line"></span><br><span class="line">格式说明：</span><br><span class="line">USER: 进程拥有者</span><br><span class="line">PID: pid</span><br><span class="line">%CPU: 占用的 CPU 使用率</span><br><span class="line">%MEM: 占用的记忆体使用率</span><br><span class="line">VSZ: 占用的虚拟记忆体大小</span><br><span class="line">RSS: 占用的记忆体大小</span><br><span class="line">TTY: 终端的次要装置号码 (minor device number of tty)</span><br><span class="line"></span><br><span class="line">STAT: 该行程的状态，linux的进程有5种状态：</span><br><span class="line">D 不可中断 uninterruptible sleep (usually IO)</span><br><span class="line">R 运行 runnable (on run queue)</span><br><span class="line">S 中断 sleeping</span><br><span class="line">T 停止 traced or stopped</span><br><span class="line">Z 僵死 a defunct (”zombie”) process</span><br><span class="line">注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</span><br><span class="line">1、运行状态(正在运行或在运行队列中等待[就绪队列])</span><br><span class="line">2、中断状态(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</span><br><span class="line">3、不可中断状态(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</span><br><span class="line">4、僵死状态(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</span><br><span class="line">5、停止状态(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</span><br><span class="line"></span><br><span class="line">START: 行程开始时间</span><br><span class="line">TIME: 执行的时间</span><br><span class="line">COMMAND:所执行的指令</span><br></pre></td></tr></table></figure>

<p>3、COMMADN列如果过长，aux会截断显示，而ef不会。</p>
<p>综上，如果想查看进程的CPU占用率和内存占用率，可以使用aux ，如果想查看进程的父进程ID和完整的COMMAND命令，可以使用ef。</p>
<p>ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_54514751/article/details/126281162">https://blog.csdn.net/weixin_54514751/article/details/126281162</a></p>
<p>✅pid<br>PID 代表进程标识号process identification，它是在操作系统中创建时自动分配给每个进程的唯一标识号。一个进程是一个正在运行的程序实例。</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 搜索文本中匹配某个模式的行</p>
<p>grep命令是查找，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;UpdateItem&#x27; ./platform-idproducer.log  //必须得是单引号</span><br></pre></td></tr></table></figure>

<h2 id="jps-查看进程信息"><a href="#jps-查看进程信息" class="headerlink" title="jps-查看进程信息"></a>jps-查看进程信息</h2><p>JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程。</p>
<p>功能： 显示当前所有java进程pid的命令，我们可以通过这个命令来查看到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例）。</p>
<p>缺点： 不过jps有个缺点是只能显示当前用户的进程id，要显示其他用户的还只能用linux的ps命令。</p>
<p>jps：列出所有正在运行的java进程，其中jps命令也是一个java程序，前面的数字就是对应的进程id。</p>
<p>jps -l：（输出主类全名或jar路径）输出应用程序main.class的完整package名或者应用程序jar文件完整路径名。</p>
<p>jps -q：只输出LVMID</p>
<p>jps -m：输出JVM启动时传递给main()的参数。</p>
<p>jps -v：输出JVM启动时显示指定的JVM参数</p>
<p>✅jps失效：<br>在定位问题过程会遇到这样一种情况，用 jps 查看不到进程id，用 ps -ef | grep java 却能看到启动的java进程。</p>
<p>jps 的实现机制：<br>java程序启动后，会在目录 /tmp/hsperfdata_{userName}/ 下生成几个文件，文件名就是java进程的 pid ，因此jps列出进程id就是把这个目录下的文件名列一下而已，至于系统参数，则是读取文件中的内容。</p>
<p>jps失效情况：<br>由于磁盘满了，无法创建这些文件；<br>用户对这些文件没有读的权限；<br>因为某种原因这些文件或者目录被清除；<br>出现以上这些情况，就会导致jps命令失效。</p>
<p>如果jps命令失效，而我们又要获取pid，还可以使用以下两种方法：<br>top | grep java<br>ps -ef |grep java</p>
<p>原文：<a href="https://blog.csdn.net/wangzhongshun/article/details/112546027">https://blog.csdn.net/wangzhongshun/article/details/112546027</a></p>
<h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率</p>
<p>top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.</p>
<p>top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p>
<p>直接top，显示信息解读：<br><a href="https://blog.csdn.net/m0_51627713/article/details/118091336">https://blog.csdn.net/m0_51627713/article/details/118091336</a></p>
<p>top命令选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d      #delay time  延迟时间</span><br><span class="line">-H      #Threads mode  是否开启线程模式，默认是off</span><br><span class="line">-p      # PID monitoring  只显示某个进程的信息，e.g: top -P 488  只显示进程号为488的进程信息</span><br><span class="line">-u      # user filter    过滤用户</span><br><span class="line">-o      # sort 排序，-o fieldname  ,指定要排序的字段  ,</span><br><span class="line">          e.g: top -d 300  -o +PID  按照PID字段从小到大排序</span><br><span class="line">      top -d 300  -o -PID  按照PID字段从大到小排序</span><br><span class="line">-w      # -w [ number ] 指定字段之间的间隔宽度，默认是512</span><br><span class="line">-b :  #批处理模式，可以把top命令行的输出导入到一个文件中</span><br><span class="line">c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称</span><br></pre></td></tr></table></figure>

<h2 id="参看端口使用"><a href="#参看端口使用" class="headerlink" title="参看端口使用"></a>参看端口使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof</span><br><span class="line">lsof(list open files)是一个列出当前系统打开文件的工具。</span><br><span class="line">而有一点要切记，在Unix中一切（包括网络套接口）都是文件。</span><br><span class="line">lsof 查看端口占用语法格式：</span><br><span class="line">lsof -i:端口号</span><br><span class="line">使用-i:port来显示与指定端口相关的网络信息</span><br><span class="line"></span><br><span class="line">参考：https://www.jianshu.com/p/a3aa6b01b2e1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat</span><br><span class="line">yum install -y net-tools</span><br><span class="line">netstat -tunlp | grep 端口号</span><br><span class="line">-t (tcp) 仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化为数字</span><br><span class="line">-l 仅列出在Listen(监听)的服务状态</span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">netstat -ntlp   //查看当前所有tcp端口</span><br><span class="line">netstat -ntulp | grep 80   //查看所有80端口使用情况</span><br><span class="line">netstat -ntulp | grep 3306   //查看所有3306端口使用情况</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp查看端口占用情况</span><br><span class="line"></span><br><span class="line">-a，显示所有</span><br><span class="line">-n，不用别名显示，只用数字显示</span><br><span class="line">-p，显示进程号和进程名</span><br></pre></td></tr></table></figure>

<h2 id="yum-apt-brew"><a href="#yum-apt-brew" class="headerlink" title="yum apt brew"></a>yum apt brew</h2><p>linux系统基本上分两大类：<br>1.RedHat系列：Redhat、Centos、Fedora等，使用yum<br>2.Debian系列：Debian、Ubuntu等，使用apt-get</p>
<p>Mac系统:<br>Homebrew，Homebrew简称brew</p>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>在网络中ping是一个十分强大的TCP/IP工具。它的作用主要为：<br>（1）用来检测网络的连通情况和分析网络速度；<br>（2）根据域名得到服务器IP；<br>（3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</p>
<blockquote>
<p>我们通常会用它来直接ping IP地址，来测试网络的连通情况。</p>
<p>bytes值：数据包大小，也就是字节。</p>
<p>time值：响应时间，这个时间越小，说明你连接这个地址速度越快。</p>
<p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p>
<p>默认情况下，Linux系统的TTL值为64或255，WindowsNT/2000/XP系统的TTL值为128，Windows98系统的TTL值为32，UNIX主机的TTL值为255。</p>
<p>100<del>130ms之间，Windows系统 ；<br>240</del>255ms之间，UNIX/Linux系统。</p>
</blockquote>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>测试指定端口连通性：</p>
<blockquote>
<p>telnet 102.106.228.173 8601即可</p>
<p>1、检测主机是否安装telnet<br>rpm -qa telnet-server<br>若无输入内容，则表示没有安装。出于安全考虑telnet-server.rpm是默认没有安装的，而telnet的客户端是标配。即下面的软件是默认安装的。</p>
<p>2、若未安装，则安装telnet-server，否则忽略此步骤<br>yum install telnet-server 　</p>
<p>3、检测telnet-server的rpm包是否安装<br>rpm -qa telnet<br>输出：telnet-0.17-47.el6_3.1.x86_64</p>
<p>4、若未安装，则安装telnet，否则忽略此步骤<br>yum install telnet</p>
<p>5.测试<br>Trying ::1…<br>Connected to localhost.<br>Escape character is ‘^]’.</p>
<p>表明连接成功。（stats查看状态，flush_all:清楚缓存）</p>
</blockquote>
<p>8080端口一下访问不了？</p>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://www.linux.com  //访问网址</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存网页：</span><br><span class="line">1.使用linux的重定向功能保存</span><br><span class="line">curl http://www.linux.com &gt;&gt; linux.html</span><br><span class="line">2.可以使用curl的内置option:-o(小写)保存网页</span><br><span class="line">curl -o linux.html http://www.linux.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存网页中的文件：</span><br><span class="line">curl -O http://www.linux.com/hello.sh</span><br><span class="line">要注意这里后面的url要具体到某个文件，不然抓不下来</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl进行post请求：</span><br><span class="line">-H后面为请求头，可以添加多个，curl默认的请求方式是GET，我们要使用POST的话，就得加上“-X POST</span><br><span class="line"></span><br><span class="line">请求体，也就是json格式，此时只需要添加-d后，加上单引号，单引号里面添加花括号，然后json格式的key-value添加进去即可</span><br><span class="line"></span><br><span class="line">curl &#x27;http://10.12.205.134:8182/pt/idproducer/v2/createapp&#x27; -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;appid&quot;:10001,&quot;machineid&quot;:250031,&quot;step&quot;:10000,&quot;autoincre&quot;:0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>curl命令，只能linux上操作，mac上还不行。</p>
<h2 id="Linux-的打印命令-echo"><a href="#Linux-的打印命令-echo" class="headerlink" title="Linux 的打印命令 echo"></a>Linux 的打印命令 echo</h2><p><code>echo &quot;c.biancheng.net&quot;</code> </p>
<p>如果加入了 <code>-n</code>选项，则在输出内容结束后，不会换行，直接显示新行的提示符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出时间：</span><br><span class="line">echo &quot;访问时间是：`date &#x27;+%Y%m%d %H:%M:%S&#x27;`&quot;</span><br><span class="line">输出：访问时间是：20210902 17:14:27</span><br><span class="line"></span><br><span class="line">想要输出换行：</span><br><span class="line">echo -e &quot;hello\nman&quot;</span><br></pre></td></tr></table></figure>

<p>shell脚本中打印变量：<br><code>a=1 echo $a a=$a+1 echo $a</code><br>这样打印的是字符型<code>1+1</code><br>Bash 本质上只有字符型变量<br>执行<code>M=$((45+20)</code>，或<code>let M=45+20 </code>才能得到65。如果事先声明变量是整型数，就不必使用<code>$((…))</code>或者<code>let</code>。</p>
<p>用带选项-i 的declare 命令，可以使变量具有整数（integer）属性。</p>
<p><code>declare -i a</code></p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ A=15 B=30</span><br><span class="line">$ declare -i C=$A+$B</span><br><span class="line">$ D=$A+$B</span><br><span class="line">$ echo C=$C, D=$D</span><br><span class="line">C=45, D=15+30</span><br></pre></td></tr></table></figure>

<h2 id="vim快速操作"><a href="#vim快速操作" class="headerlink" title="vim快速操作"></a>vim快速操作</h2><p>在vim的普通模式下.</p>
<p><code>gg</code>光标跳转到该文件的行首</p>
<p>应用鼠标： 按下<code>:</code>之后，<code>set mouse=a</code></p>
<p>关闭鼠标功能：<code>:set mouse-=a</code></p>
<h2 id="linux执行多行命令"><a href="#linux执行多行命令" class="headerlink" title="linux执行多行命令"></a>linux执行多行命令</h2><p><code>;</code>隔开即可</p>
<h2 id="shell脚本后台一直运行"><a href="#shell脚本后台一直运行" class="headerlink" title="shell脚本后台一直运行"></a>shell脚本后台一直运行</h2><p>使用sh，其中test.sh为所执行的脚本，out.txt为输出信息的地方。<br>sh test.sh&gt;&amp;out.txt &amp;</p>
<h2 id="rm-mv-cp"><a href="#rm-mv-cp" class="headerlink" title="rm mv cp"></a>rm mv cp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用指令 cp 将当前目录 test/ 下的所有文件复制到新目录 newtest 下，输入如下命令：</span><br><span class="line">cp –r test/ newtest</span><br><span class="line"></span><br><span class="line">删除当前目录下的所有文件及目录，命令行为：</span><br><span class="line">rm  -r  *</span><br><span class="line">-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</span><br><span class="line">-r 将目录及以下之档案亦逐一删除。</span><br><span class="line"></span><br><span class="line">将 /usr/runoob 下的所有文件和目录移到当前目录下</span><br><span class="line">mv /usr/runoob/*  . </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp  拷贝</span><br><span class="line">cp bj.txt ./java/jee：把当前目录的bj.txt拷贝到当前目的java文件夹里的jee文件夹里</span><br><span class="line">cp dd.txt ee.txt   ：复制并改名,并存放在当前目录下  (cp源文件名 新文件名)</span><br><span class="line">cp file1 file2 复制一个文件 </span><br><span class="line">cp dir/* . 复制一个目录下的所有文件到当前工作目录 </span><br><span class="line">cp -a /tmp/dir1 . 复制一个目录到当前工作目录 </span><br><span class="line">cp -a dir1 dir2 复制一个目录</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv  移动/剪切、重命名</span><br><span class="line">mv aa.txt ../android/   把当前目录下的文件aa.txt剪切到上一级目录的子目录android目录里</span><br><span class="line">mv aa.txt ..     把文件aa.txt移动到上一级目录</span><br><span class="line">mv bb.txt cc.txt   把文件bb.txt重命名为cc.txt</span><br><span class="line">mv dir1 new_dir    重命名/移动 一个目录 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm  删除文件或目录</span><br><span class="line">rm 直接删除，rm文件名</span><br><span class="line">rm -f file1   删除一个叫做 &#x27;file1&#x27; 的文件或目录，假如要删除的文件不存在,也不提示 rm -f文件名</span><br><span class="line">rm -i   删除前提示是否删除，默认不删除， 若要删除，输入y</span><br><span class="line">rm -d   删除空白目录   rm -d空目录名  </span><br><span class="line">rm -r  删除有内容的目录,将指定目录下的所有文件及子目录一并处理，递归删除  </span><br><span class="line">rm -rf filename  强制删除目录或文件(目录有内容时，也删除)</span><br><span class="line">rm -rf dir1  删除一个叫做 &#x27;dir1&#x27;的目录并同时删除其内容 </span><br><span class="line">rm -rf dir1 dir2   同时删除两个目录及它们的内容</span><br></pre></td></tr></table></figure>

<h2 id="alias-设置指令的别名"><a href="#alias-设置指令的别名" class="headerlink" title="alias 设置指令的别名"></a>alias 设置指令的别名</h2><p>alis 别名 = 指令名称<br>输入alias可列出目前所有的别名设置。<br>alias只限于该次登录操作，若要永久，需要在～/.zshrc文件中设置<br>alias 简写 = 全写</p>
<h2 id="tr-多行合成一行-、awk使用"><a href="#tr-多行合成一行-、awk使用" class="headerlink" title="tr(多行合成一行)、awk使用"></a>tr(多行合成一行)、awk使用</h2><p>tr：转换文本中的字符</p>
<p>wc：统计文本的行数、字数、字节数</p>
<p>✅想把文件里的换行变成逗号（多行变一行）：<br><code>cat doc.txt|tr &#39;\n&#39; &#39;,&#39;</code></p>
<p>✅想把每行按照自己想要的方式组装：<br><code>awk -F &quot;,&quot; &#39;&#123;print &quot;想拼接的字符串&quot; $2&#125;&#39; 文件名</code><br><code>-F &quot;,&quot; 是指定每行几个列的分割元素，默认是空格。</code><br><code>&#39;&#123;print $0&#125;&#39; 是打印整行</code><br><code>&#39;&#123;print $1&#125;&#39; 是打印第一列</code><br><code>&#39;&#123;print $2 “\&quot;”&#125;&#39; 是打印第二列后面再拼接一个“ </code><br>eg:<code>awk -F &quot;,&quot; &#39;&#123;print &quot;balabala&quot; $1 &quot;bala&quot; $2&#125;&#39; a.txt</code></p>
<p>想排序输出：<code>|sort -k 2</code>  根据第二列排序,-r倒叙，-n根据数值<br>sort命令：<a href="https://www.runoob.com/linux/linux-comm-sort.html">https://www.runoob.com/linux/linux-comm-sort.html</a></p>
<p>想只展示前多少行：<code>|head -10</code></p>
<p>✅想把输出的文本保存到文件里<br><code>awk ... &gt; out.txt</code></p>
<p>✅awk中字符串截取substr<br>每一行从第3个字符开始截取到末尾(包括第三个)：<br><code>awk &#39;&#123;print substr($0, 3)&#125;&#39; test.txt</code><br>每一行某列字符串的截取：从第3个开始截取10个<br><code>awk &#39;&#123;print substr($1, 3,10)&#125;&#39; test.txt</code></p>
<p>✅awk中字符串替换<br><code>gsub(r,s) 在整个$0中用s替代r:</code><br>将文件中的所有逗号变没：<br><code>awk &#39;gsub(&quot;,&quot;, &quot;&quot;)&#123;print $0&#125;&#39; test.txt</code><br>注意gsub内部用双引号””<br>注意如果没逗号，啥都不输出<br><code>gsub(r,s,t) 在整个t中用s替代r:</code><br><code>awk &#39;gsub(&quot;1&quot;,&quot;2&quot;,$1)&#39; test.txt</code><br>仅输出被替换的行，如果没有被替换字符，不输出。</p>
<p>✅awk列运算<br>求每一行中的最大值的列：<br><code>awk &#39;&#123;m=0;for(x=0;x&lt;=NF;x++)if($x&gt;m) &#123;m=$x&#125;;print m&#125;&#39; test.txt</code></p>
<p>求第2列中最大的值(遍历行)：<br><code>awk &#39;BEGIN&#123;max=0&#125;&#123;if($3&gt;max)max=$3&#125;END&#123;print &quot;Max =&quot;,max&#125;&#39; test.txt</code></p>
<p>求第2列所有行的和：<br><code>awk &#39;&#123;sum+=$2&#125;END&#123;print &quot;Sum =&quot;,sum&#125;&#39; test.txt</code></p>
<p>对第2列求平均值：<br><code>awk &#39;&#123;sum+=$2&#125;END&#123;print &quot;Avg =&quot;,sum/NR&#125;&#39; test.txt</code></p>
<p>对每一行的前5列求平均值：<br><code>awk &#39;&#123;sum=0;for(i=1;i&lt;=5;i++)&#123;sum+=$i&#125;&#123;print sum/5&#125;&#125;&#39; test.txt</code><br><code>awk &#39;&#123;sum=0;for(i=1;i&lt;=5;i++)&#123;sum+=$i&#125;;print sum/5&#125;&#39; test.txt</code><br>可以用{}分割语句，也可以用;分割</p>
<p>✅awk输出/删除指定列<br>输出每行的前5列，并按行输出：<br><code>awk &#39;&#123;for(i=1;i&lt;6;i++)printf(&quot;%s &quot;,$i);printf(&quot;\n&quot;)&#125;&#39; test.txt</code><br>用print的话带自动换行，但是不要加%s占位符<br>都输出到一行：<br><code>awk &#39;&#123;for(i=1;i&lt;6;i++)printf(&quot;%s &quot;,$i)&#125;&#39; test.txt</code></p>
<p>每行输出多列，并修改分隔符：<br><code>awk &#39;&#123;for(i=2;i&lt;=NF;i++)printf(&quot;%s\t&quot;,$i);printf(&quot;\n&quot;)&#125;&#39; test.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; 本来每行输出一个，print会自动换行</span><br><span class="line">如果没行输出多个，for遍历是针对单行的，最大列NF，不换行用printf</span><br></pre></td></tr></table></figure>

<p>删除最后一列：<br><code>awk &#39;&#123;$NF=&quot;&quot;;print&#125;&#39; test.txt</code><br>删除第三列:<br><code>awk &#39;&#123;$3=&quot;&quot;;print&#125;&#39; test.txt</code></p>
<p>每三行合并成一列：<br><code>awk &#39;&#123;if(NR%3 != 0)&#123;ORS=&quot; &quot;&#125;else&#123;ORS=&quot;\n&quot;&#125;print&#125;&#39; test.txt</code></p>
<p>✅awk基本操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$0             表示整个当前行</span><br><span class="line">$1             每行第一个字段</span><br><span class="line">NF            字段数量变量</span><br><span class="line">NR            每行的记录号，多文件记录递增</span><br><span class="line">FNR          与NR类似，不过多文件记录不递增，每个文件都从1开始</span><br><span class="line">\t                制表符</span><br><span class="line">\n               换行符</span><br><span class="line">FS             BEGIN时定义分隔符</span><br><span class="line">RS             输入的记录分隔符， 默认为换行符(即文本是按一行一行输入)</span><br><span class="line">~                匹配，与==相比不是精确比较</span><br><span class="line">!~               不匹配，不精确比较</span><br><span class="line">==              等于，必须全部相等，精确比较</span><br><span class="line">!=               不等于，精确比较</span><br><span class="line">&amp;&amp;　          逻辑与</span><br><span class="line">||                逻辑或</span><br><span class="line">+                匹配时表示1个或1个以上</span><br><span class="line">/[0-9][0-9]+/      两个或两个以上数字</span><br><span class="line">/[0-9][0-9]*/       一个或一个以上数字</span><br><span class="line">OFS            输出字段分隔符， 默认是空格，可以改为制表符等</span><br><span class="line">ORS           输出的记录分隔符，默认是换行符，即一行一行输出到屏幕</span><br><span class="line">-F  &#x27;[:#/]&#x27;      定义三个分隔符，[ ]内可以放置多个分隔符</span><br><span class="line"></span><br><span class="line">链接：https://www.jianshu.com/p/e3fa91a8d9f2</span><br></pre></td></tr></table></figure>

<p>✅awk实现根据1还是0变到true/false</p>
<p><code>awk -F &#39;,&#39; &#39;&#123;print $1 &quot;,&quot; $2&#125;&#123;if($2&lt;1)&#123;bb=&quot;false&quot;&#125;else&#123;bb=&quot;true&quot;&#125;&#123;print &quot;,&quot; bb&#125;&#125;&#39; test.txt &gt; out.txt</code></p>
<p>awk中{}和;的区别：<br>1.首先，最外层必须有<code>&#39;&#39;</code><br>2.awk中for循环和后面要执行的语句必须在一个{}中，不能单独把for()用{}圈起来。<br>3.如果for循环后面想执行两条语句，<code>for(x=1;x&lt;4;x++)&#123;m+=$x;print m&#125;</code>，单个语句用{}或者;都可以。<br>4.最外面的<code>&#39;&#39;</code>里面只有几条语句，必须要用{}，几个{}语句可以不用{}阔起来。</p>
<p>$1和$2之间加不加逗号有什么区别：<br>{print ($1 $2)} 两个输出之间没有分割。<br>{print ($1 $2)} 两个输出之间有分割，但不管-F用什么分割的，这个分割都是一个空格。</p>
<h2 id="看磁盘空间"><a href="#看磁盘空间" class="headerlink" title="看磁盘空间"></a>看磁盘空间</h2><p><code>df -h</code><br>看文件的大小：<br>直接ll，显示的是文件的字节大小，想用M、G单位来表示文件的大小：用<code>ll -h</code></p>
<p>✅想清理日志<br>清理日志，rm worker.log 清不干净。</p>
<p>1、通过重定向到空来清空文件内容<br>shell重定向null<br><code>&gt; access.log</code></p>
<p>2、使用’true’命令重定向清空文<br>本质上等同于true命令，它可以用作无操作<br><code>true &gt; access.log</code></p>
<p>3、使用echo命令清空文件<br>使用带有空字符串的echo命令，并将其重定向到文件<br><code>echo “” &gt; access.log </code> 或 <code>echo &gt; access.log</code></p>
<p>更多：<a href="https://cloud.tencent.com/developer/article/1721287">https://cloud.tencent.com/developer/article/1721287</a></p>
<h2 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h2><p>sort命令可以把文本或文本的内容按照一定的字母顺序排列并格式化输出，是一个不错的文本分析工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b 忽略行首的空格</span><br><span class="line">-f 英文字母判断时忽略大小写</span><br><span class="line">-r 将文本以反序输出</span><br><span class="line">-t 定义文本中的分隔符</span><br><span class="line">-n 以数字大小排序</span><br><span class="line">-u 去除重复行，输出唯一的行</span><br><span class="line">-k 按照指定的列进行排序</span><br><span class="line">-m 将多个文本文件合并并排序：sort -m file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort -u big.csv &gt; small.csv</span><br><span class="line">cat big.csv | sort | uniq  也可以</span><br><span class="line">cat big.csv | sort | uniq -d 输出重复行</span><br><span class="line"></span><br><span class="line">cat file1.csv file2.csv | sort | uniq  并集</span><br><span class="line">cat file1.csv file2.csv | sort | uniq -d  交集</span><br></pre></td></tr></table></figure>

<h2 id="shell两个数组比较，得到元素的并集、交集"><a href="#shell两个数组比较，得到元素的并集、交集" class="headerlink" title="shell两个数组比较，得到元素的并集、交集"></a>shell两个数组比较，得到元素的并集、交集</h2><p>linux shell 实现数组比较，取元素的并集、交集时，可以使用sort排序、uniq统计和awk数据过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_list_1=(&quot;test1&quot; &quot;test2&quot; &quot;test3&quot; &quot;test4&quot; &quot;test5&quot; &quot;test6&quot;)</span><br><span class="line">file_list_2=(&quot;test5&quot; &quot;test6&quot; &quot;test7&quot; &quot;test8&quot;)</span><br><span class="line"></span><br><span class="line">-# 对list去重</span><br><span class="line">file_list_uniq=`echo $&#123;file_list_1[*]&#125;|uniq`</span><br><span class="line">echo $&#123;file_list_uniq[*]&#125;</span><br><span class="line"></span><br><span class="line">-# 获取并集，A ∪ B</span><br><span class="line">file_list_union=(`echo $&#123;file_list_1[*]&#125; $&#123;file_list_2[*]&#125;|sed &#x27;s/ /\n/g&#x27;|sort|uniq`)</span><br><span class="line">echo $&#123;file_list_union[*]&#125;</span><br><span class="line"></span><br><span class="line">-# 获取交集，A n B</span><br><span class="line">file_list_inter=(`echo $&#123;file_list_1[*]&#125; $&#123;file_list_2[*]&#125;|sed &#x27;s/ /\n/g&#x27;|sort|uniq -c|awk &#x27;$1!=1&#123;print $2&#125;&#x27;`)</span><br><span class="line">echo $&#123;file_list_inter[*]&#125;</span><br><span class="line"></span><br><span class="line">-# 对称差集，不属于 A n B</span><br><span class="line">file_list_4=(`echo $&#123;file_list_1[*]&#125; $&#123;file_list_2[*]&#125;|sed &#x27;s/ /\n/g&#x27;|sort|uniq -c|awk &#x27;$1==1&#123;print $2&#125;&#x27;`)</span><br><span class="line">echo $&#123;file_list_4[*]&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/const-zpc/p/16900535.html">https://www.cnblogs.com/const-zpc/p/16900535.html</a></p>
<p>sed命令：从文本中抽取文本，构建修改文本。<br><code>sed &#39;s/ /\n/g&#39;</code> 命令：意思是将文本中的每个空格替换成一个换行符，从而将文本拆分成多行文本。</p>
<p><code>sed &#39;s/被替换的字符串/替换的字符串/g&#39;</code>  <code>/g</code>时全局的意思，找到所有匹配项。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC安装MySQL</title>
    <url>/2021/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/MAC%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装：<code>brew install mysql</code></p>
<p>查看：<code>brew info mysql</code></p>
<p>启动数据库服务：<code>mysql.server start</code></p>
<p>登录：<code>mysql -u root -p </code></p>
<blockquote>
<p>遇到问题，发现是brew没更新，brew update更新后再试就可以</p>
</blockquote>
<p>MySQL数据库第一次安装完成后,root用户初始的登录密码为空。直接回车进行登录。</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t_goods \G</span><br></pre></td></tr></table></figure>

<p>一行一行地显示，注意：\G为大写字母，不可使用小写；使用\G参数后，SQL语句后可以不加分隔符，如果加分隔符，则会报“error:no query specified”的错误。</p>
<h2 id="添加用户改密码"><a href="#添加用户改密码" class="headerlink" title="添加用户改密码"></a>添加用户改密码</h2><p><code>select User, Host, password_expired from mysql.user;</code>  显示用户</p>
<p><strong>创建用户</strong>：<code>create user &#39;name&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>
<p>username：你将创建的用户名<br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%<br>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</p>
<p><code>CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code><br><code>CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</code><br><code>CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</code></p>
<p><strong>授权</strong>：<code>grant privileges on databasename.tablename to &#39;username&#39;@&#39;host&#39;</code></p>
<p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL<br>databasename：数据库名<br>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</p>
<p>例子:<br><code>GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</code><br><code>GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code><br><code>GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</code></p>
<p><strong>修改密码</strong>：<code>set password for &#39;name&#39;@&#39;localhost&#39;=password(&#39;newpass&#39;);</code></p>
<p>如果是当前登陆用户用:<br><code>SET PASSWORD = PASSWORD(&quot;newpassword&quot;);</code><br>例子:<br><code>SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; = PASSWORD(&quot;123456&quot;);</code></p>
<p><strong>撤销授权</strong>：<code>REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</code></p>
<p>例子:<br><code>REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;</code></p>
<p><strong>查看授权</strong>：<code>SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; </code></p>
<p><strong>删除用户</strong>：<code>DROP USER &#39;username&#39;@&#39;host&#39;;</code></p>
<p><strong>刷新权限</strong>：<code>flush privileges;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select User, Host, password_expired from mysql.user;</span><br><span class="line">grant all on *.* to &#x27;liuxuan&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">mysql -u liuxuan -p</span><br><span class="line">登录</span><br></pre></td></tr></table></figure>

<h2 id="2022-1-31-登录出错"><a href="#2022-1-31-登录出错" class="headerlink" title="2022.1.31.登录出错"></a>2022.1.31.登录出错</h2><p><code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code></p>
<p>参考：<a href="https://blog.csdn.net/u012373815/article/details/82188361">https://blog.csdn.net/u012373815/article/details/82188361</a></p>
<p>无法连接本地sql服务，是mysql.sock文件找不到了，这个文件以前在/tmp 下现在没有了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步：找到mysql的安装目录，我的是：cd /usr/local/Cellar/mysql/8.0.27</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：执行 sudo ./support-files/mysql.server start  启动mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#报错： ERROR! The server quit without updating PID file (/usr/local/var/mysql/liuxuan.pid).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可能是没有bogon/没有权限，我们给予权限即可：sudo chmod -R 777 /usr/local/var/mysql/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重新执行第二步，success</span></span><br></pre></td></tr></table></figure>

<p>可以查看mysql 的error 文件 /usr/local/var/mysql/abel-MacBook-Pro.local.err。</p>
<h2 id="2022-2-1-MAC可视化sql软件Navicat"><a href="#2022-2-1-MAC可视化sql软件Navicat" class="headerlink" title="2022.2.1.MAC可视化sql软件Navicat"></a>2022.2.1.MAC可视化sql软件Navicat</h2><p>Navicat Premium for Mac 是Mac平台上优秀的数据库开发工具，你可以使用Navicat Premium 同时连接MySQL、SQL Server、Oracle、SQLite等数据库，功能强大，navicat premium 让你轻松创建、管理和维护数据库，非常实用。<br>————————————————</p>
<p>Mac安装和破解参考：<a href="https://www.jianshu.com/p/527c59277406">https://www.jianshu.com/p/527c59277406</a>  （公钥界面打不开）</p>
<p>换一个：<a href="https://www.jianshu.com/p/8011db219dd9?from=groupmessage@">https://www.jianshu.com/p/8011db219dd9?from=groupmessage@</a></p>
<p>使用：<a href="https://blog.csdn.net/weixin_45877226/article/details/105667708">https://blog.csdn.net/weixin_45877226/article/details/105667708</a></p>
<p>直接下载的一个：<a href="http://www.xue51.com/mac/3343.html">http://www.xue51.com/mac/3343.html</a></p>
<p>都没成</p>
<h2 id="2022-2-2-换一个DataGrip"><a href="#2022-2-2-换一个DataGrip" class="headerlink" title="2022.2.2.换一个DataGrip"></a>2022.2.2.换一个DataGrip</h2><p>DataGrip Mac版是由JetBrains公司推出的<a href="http://www.pc6.com/mach/macsql/">数据库</a>管理软件，DataGrip支持几乎所有主流的关系数据库产品，如DB2、Derby、H2、MySQL、Oracle、PostgreSQL、SQL Server、Sqllite及Sybase等，并且提供了简单易用的界面，<a href="http://www.pc6.com/mach/rjkfgj/">开发</a>者上手几乎不会遇到任何困难。目前市场上已经存在很多数据库客户端，如MySQL WorkBench、Toad、NaviCat、phpMyAdmin、Sequel Pro、SQLWave等等，这些既有的产品中，有些是免费的，有些则是收费的。</p>
<p>安装与激活教程：<a href="https://www.jianshu.com/p/c914447618e7">https://www.jianshu.com/p/c914447618e7</a> （不能用）</p>
<p>换一个教程：<a href="https://www.yuque.com/docs/share/35877f5f-dd13-484b-a660-1a34f03d1f38">https://www.yuque.com/docs/share/35877f5f-dd13-484b-a660-1a34f03d1f38</a>  windows：<a href="https://www.jb51.net/article/200560.htm">https://www.jb51.net/article/200560.htm</a>  （只有一个月，windows没准行）</p>
<p>一个月的激活码：<a href="https://tieba.baidu.com/p/7389553127">https://tieba.baidu.com/p/7389553127</a>  （每月更新 <a href="https://33tool.com/idea/%EF%BC%89">https://33tool.com/idea/）</a></p>
<p>换一个激活：<a href="https://www.hicxy.com/3487.html">https://www.hicxy.com/3487.html</a>  （没有试）</p>
<p>连接数据库：<a href="https://jingyan.baidu.com/article/358570f684f305ce4724fc31.html">https://jingyan.baidu.com/article/358570f684f305ce4724fc31.html</a></p>
<p><strong>有点问题，每月的激活码后来又不能用了，之后想办法破解吧</strong></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac日常使用</title>
    <url>/2021/08/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/MAC%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="查看ssd寿命"><a href="#查看ssd寿命" class="headerlink" title="查看ssd寿命"></a>查看ssd寿命</h3><p>brew安装查询工具：<code>brew install smartmontools</code></p>
<p>参看磁盘：<code>diskutil list</code></p>
<p>参看使用情况：<code>smartctl -a disk0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMART/Health Information (NVMe Log 0x02)</span><br><span class="line">Critical Warning:                   0x00</span><br><span class="line">Temperature:                        47 Celsius</span><br><span class="line">Available Spare:                    83%</span><br><span class="line">Available Spare Threshold:          2%</span><br><span class="line">Percentage Used:                    5%</span><br><span class="line">Data Units Read:                    97,383,945 [49.8 TB]</span><br><span class="line">Data Units Written:                 85,617,562 [43.8 TB]</span><br><span class="line">Host Read Commands:                 1,110,595,079</span><br><span class="line">Host Write Commands:                574,485,961</span><br><span class="line">Controller Busy Time:               0</span><br><span class="line">Power Cycles:                       11,730</span><br><span class="line">Power On Hours:                     389</span><br><span class="line">Unsafe Shutdowns:                   34</span><br><span class="line">Media and Data Integrity Errors:    0</span><br><span class="line">Error Information Log Entries:      0</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.xiaoyuanjiu.com/18812.html">https://www.xiaoyuanjiu.com/18812.html</a></p>
<h3 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h3><p>command + 空格，搜索终端，即出来了。</p>
<h3 id="打开后台"><a href="#打开后台" class="headerlink" title="打开后台"></a>打开后台</h3><p>command+option+esc：打开后台</p>
<h3 id="文件夹添加为收藏"><a href="#文件夹添加为收藏" class="headerlink" title="文件夹添加为收藏"></a>文件夹添加为收藏</h3><p>文件夹往过拖就行</p>
<h3 id="安装brew"><a href="#安装brew" class="headerlink" title="安装brew"></a>安装brew</h3><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></p>
<p>brew help检查</p>
<h3 id="iterm2终端"><a href="#iterm2终端" class="headerlink" title="iterm2终端"></a>iterm2终端</h3><p>1.iTerm2 是默认终端的替代品，也是目前 macOS 下最好用的终端工具，集颜值和效率于一身。</p>
<p>官网安装即可，配置颜色，窗口，光标等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考：https://cloud.tencent.com/developer/article/1772592</span><br><span class="line">https://www.jianshu.com/p/5ba0a559416e</span><br></pre></td></tr></table></figure>

<p>2.安装on my zsh </p>
<p><code>$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;&quot;</code></p>
<p>如果不行，就自建脚本复制粘贴，然后允许，一样的意思。</p>
<p>3.安装<strong>powerlevel10k</strong></p>
<p>powerlevel10k是一款 zsh 主题，是 powerlevel9k的升级版，强调快速、高效和开箱即用。powerlevel10k 免去了之前 powerlevel9k 比较繁琐的安装方式，如安装字体，配置样式、修改主题等一系列繁琐的操作，开箱即用，非常简单。</p>
<p><code>brew install romkatv/powerlevel10k/powerlevel10k</code>，并根据brew提示，在.zshrc中添加<code>source /usr/local/opt/powerlevel10k/powerlevel10k.zsh-theme</code></p>
<p><code>source ~/.zshrc</code></p>
<p><code>p10k configure</code> //开始配置</p>
<p>4.安装插件</p>
<p>安装zsh命令行高亮插件<code>brew install zsh-syntax-highlighting</code>，并根据brew提示在.zshrc中添加<code>source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code></p>
<p>安装zsh自动提示插件<code>brew install zsh-autosuggestions</code>，并根据brew提示在.zshrc中添加<code>source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh</code></p>
<p><code>source ~/.zshrc</code></p>
<h3 id="切换输入法"><a href="#切换输入法" class="headerlink" title="切换输入法"></a>切换输入法</h3><p>control+空格</p>
<h3 id="文件夹整理"><a href="#文件夹整理" class="headerlink" title="文件夹整理"></a>文件夹整理</h3><p>command+control+1</p>
<h3 id="mvn、mysql开机须自启问题"><a href="#mvn、mysql开机须自启问题" class="headerlink" title="mvn、mysql开机须自启问题"></a>mvn、mysql开机须自启问题</h3><p>jdk配置在 /etc/profile中，开机时运行<br>mvn配置在 ~/.zprofile中，启动终端时运行<br>export PATH=”$Maven/bin:$PATH”<br>~/.zshrc 中增加 source /etc/profile 使得jdk配置生效<br>一些p10k的配置也在 ～/.zshrc中配置了</p>
<p>关于mysql重启之后就没了<br>在 /etc/profile 中增加：<br>sudo ./support-files/mysql.server start<br>也不行。</p>
<p>发现brew没了，不知道为什么。<br>重开一下终端就好了。</p>
<p>目前是：<br>/etc/profile 中加了个开启mysql的语句<br>.zshrc中没有加 source /etc/profile的语句。<br>重启之后，mysql就不行啦，source /etc/profile 一下得了</p>
<h3 id="mac剪贴板历史"><a href="#mac剪贴板历史" class="headerlink" title="mac剪贴板历史"></a>mac剪贴板历史</h3><p>参考：<a href="https://www.jianshu.com/p/05d7bd51a4bf">https://www.jianshu.com/p/05d7bd51a4bf</a></p>
<p>clipy软件：官网地址：<a href="https://clipy-app.com/">https://clipy-app.com/</a></p>
<p>使用快捷键shift+command+v即可调用剪切板</p>
<h3 id="安装xcode"><a href="#安装xcode" class="headerlink" title="安装xcode"></a>安装xcode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates</span><br><span class="line"></span><br><span class="line">$ rm -rf /Library/Developer/CommandLineTools</span><br><span class="line">$ xcode-select --install</span><br><span class="line"></span><br><span class="line">若没权限，加sudo</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch</title>
    <url>/2022/12/10/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/elasticsearch/</url>
    <content><![CDATA[<h2 id="什么是elasticsearch"><a href="#什么是elasticsearch" class="headerlink" title="什么是elasticsearch"></a>什么是elasticsearch</h2><p>ES=elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。<br>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，通过面向文档从而让全文搜索变得简单。</p>
<p><a href="https://blog.csdn.net/weixin_45081813/article/details/113061113">https://blog.csdn.net/weixin_45081813/article/details/113061113</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>git与github应用</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/git%E5%BA%94%E7%94%A8%E4%B8%8Egithub/</url>
    <content><![CDATA[<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>1、git pull只是将远程本分支上的更新pull下来，如果要pull远程master，需要：git pull origin master</p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是[Linus Torvalds]为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>SSH 为 [Secure Shell](<a href="https://baike.baidu.com/item/Secure">https://baike.baidu.com/item/Secure</a> Shell) 的缩写，是建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。</p>
<p>传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。<strong>通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗</strong>。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以<strong>可以加快传输的速度</strong>。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道”   。</p>
<p>git 使用 rsa，rsa 要解决的一个核心问题是，如何使用一对特定的数字，使其中一个数字可以用来加密，而另外一个数字可以用来解密。这两个数字就是你在使用 git 和 github 的时候所遇到的 public key 也就是公钥以及 private key 私钥。本地用私钥，上传公钥。</p>
<h4 id="本地创建ssh-key"><a href="#本地创建ssh-key" class="headerlink" title="本地创建ssh key"></a>本地创建ssh key</h4><p><code>$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code></p>
<p><code>~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。标题建议和仓库名一致, 便于区分. </code></p>
<p>验证：<code>$ ssh -T git@github.com</code></p>
<p>本地设置git：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;jadeliuliu&quot;</span><br><span class="line">git config --global user.email &quot;xxxxx@163.com&quot;</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h3 id="与github建立连接"><a href="#与github建立连接" class="headerlink" title="与github建立连接"></a>与github建立连接</h3><p>1.github上建立仓库</p>
<p>2.本地建立仓库 <code>git init // 把这个目录变成Git可以管理的仓库，本地多一个.git文件夹，用来跟踪管理版本库</code></p>
<p><code>mac第一次建仓库出现问题：xcode-select --install</code></p>
<p><code>git clone git@github.com:jadeliuliu/HelloWorld.git（复制自项目的链接）    相当于创建一个远程仓库的克隆版本</code></p>
<p>3.关联github仓库 <code>git remote add origin git@github.com:Hexagon-Man/HelloWorld.git</code></p>
<p>4.提交代码</p>
<p><code>git add 添加文件</code></p>
<p><code>git add . // 将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录</code></p>
<p><code>git remote add origin git@github.com:xxx/xxx.git // 关联远程仓库</code></p>
<p><code>git commit -m &quot;&quot;  // 提交到了 HEAD，但是还没到你的远端仓库 </code></p>
<p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt; ，例如 git push origin HEAD：refs/for/master  // refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的 </code> </p>
<p><code>git push -u origin master // 把本地库的所有内容推送到远程库上</code></p>
<h3 id="git仓库结构"><a href="#git仓库结构" class="headerlink" title="git仓库结构"></a>git仓库结构</h3><p>本地仓库由 git 维护的三部分组成。第一个是 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p>
<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><p><code>git checkout -b f  //创建并切换分支</code></p>
<p><code>git branch -d f    //删除分支</code></p>
<p><code>git branch -a     # 查看本地和远程的所有分支</code></p>
<p><code>git push origin &lt;branch&gt;    //分支推送到远端</code></p>
<p><code>git pull   //获取fetch并合并到本地</code></p>
<p><code>git rm 文件  //将文件从暂存区和工作区中删除，加-f强制删除</code></p>
<p><code>git rm --cached 文件  //将文件从暂存区中删除</code></p>
<p><code>删除缓存区所有文件命令:  git rm -r --cached .   #主要这个点一定要写</code></p>
<p><code>git log --oneline</code></p>
<h4 id="✅三个git-add"><a href="#✅三个git-add" class="headerlink" title="✅三个git add"></a>✅三个git add</h4><p>git add -u &lt;==&gt; git add –update<br>提交所有被删除和修改的文件到数据暂存区</p>
<p>git add .<br>提交所有修改的和新建的数据暂存区</p>
<p>git add -A &lt;==&gt;git add –all   （用它就wans）<br>提交所有被删除、被替换、被修改和新增的文件到数据暂存区</p>
<h4 id="✅git-restore"><a href="#✅git-restore" class="headerlink" title="✅git restore"></a>✅git restore</h4><p>git restore命令是撤销的意思。<br>有git restore <file>和git restore –staged <file>两种常用的用法。</file></file></p>
<p>新建文件，没add，git status后，前面显示？？，这种文件未被跟踪，在add之前git啥都干不了。<br>对新建文件进行git add，就到了暂存区，使用git restore –staged 文件，它就又回到了本地工作区。</p>
<p>对于已有的文件进行修改，修改的文件从暂存区跑到了本地工作区，此时可以对这个修改的文件git add到暂存区，然后才能git commit到本地版本库，也可以使用git restore，修改的文件就恢复了，没修改了，叫撤销修改。</p>
<p>git pull，有冲突，这时冲突文件里有===head之类的，这时候不想解决冲突了，想恢复，用：git restore –staged</p>
<p>❗️几种工作区：<br>1、新建的，也就是未跟踪的（Untracked files）：本地工作区<br>2、更改的(modified)和删除的(deleted) 还没add的（Changes not staged for commit）：本地工作区，可以使用git restore取消更改。<br>3、更改/新增之后add的（Changes to be committed）：暂存区，可以使用git restore –stage使得文件回到本地工作区。<br>4、git commit 后到本地版本库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">	modified:   2022.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">	modified:   aaa.md</span><br><span class="line">	deleted:    hello.go</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">	1.md</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、git restore –staged的作用是将暂存区的文件从暂存区撤出，回到本地工作区，但不会更改文件的内容。就是已经git add的文件，新建的使用该命令后，回到untracked，更改的回到changes not staged for commit。</p>
<p>2、git restore指令使得在工作空间但是不在暂存区的文件撤销更改(内容恢复到没修改之前的状态). 对新加的文件不能使用。对更改的文件使用</p>
<p>参考：<a href="https://blog.csdn.net/qq_38158479/article/details/106972138">https://blog.csdn.net/qq_38158479/article/details/106972138</a></p>
<h3 id="git空间与命令"><a href="#git空间与命令" class="headerlink" title="git空间与命令"></a>git空间与命令</h3><p>Working Directory：即工作区。操作系统层面的目录树结构，也可以理解为一个tree目录对象</p>
<p>Stage(Index)：即暂存区，为等待Commit的文件列表。是以扁平的文件清单实现的，不过从理解层面上也可以理解为tree目录对象</p>
<p>Local Repository(History)：本地版本库。有向无环图，其每一个节点都是一个tree目录对象</p>
<p>Remote Repository：远程版本库。有向无环图，其每一个节点都是一个tree目录对象<br><img src="https://img-blog.csdnimg.cn/e1d1bb1fa97743cfb9074e383841a1eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"><br>转自：<a href="https://www.cnblogs.com/kekec/p/9248487.html">https://www.cnblogs.com/kekec/p/9248487.html</a></p>
<p>git status 是看暂存区的改动，如果commit了，暂存区就空了。</p>
<h3 id="应用：在本地进行了add-commit还未push，想要撤销本地的本次commit"><a href="#应用：在本地进行了add-commit还未push，想要撤销本地的本次commit" class="headerlink" title="应用：在本地进行了add-commit还未push，想要撤销本地的本次commit"></a>应用：在本地进行了add-commit还未push，想要撤销本地的本次commit</h3><p>git log 查看commit id，拿上一个commit id，而不是最新的commit id（这是要回退的id）<br>git reset ：回退到某个版本，不清空暂存区，工作区也不变，需要再提交的话需要add后commit<br>git reset –soft：回退到某个版本，不清空暂存区，工作区也不变，需要再提交的话直接commit<br>git reset –hard：彻底回退到某个版本，撤销的commit中的所有更改都被冲掉，暂存区为空了，工作区也恢复为版本库版本。</p>
<h3 id="应用：本地修改了，没有add，想撤销修改变为版本库里的"><a href="#应用：本地修改了，没有add，想撤销修改变为版本库里的" class="headerlink" title="应用：本地修改了，没有add，想撤销修改变为版本库里的"></a>应用：本地修改了，没有add，想撤销修改变为版本库里的</h3><p>用git reset –hard 解决  //恢复为本地库里的内容</p>
<p>用  git checkout – hello.go  比较好，相当于清空了暂存区内容，工作区内容也变为修改前的。</p>
<p>用  git rm –cached hello.go  不行，从暂存区中删除文件，会显示delete，修改的也会记录，只不过还需要add，不改变工作区。<br>不懂了，不管是有没有add，都会加一条delete，而不是把原本的删掉。</p>
<h3 id="应用：本地版本恢复为远程版本"><a href="#应用：本地版本恢复为远程版本" class="headerlink" title="应用：本地版本恢复为远程版本"></a>应用：本地版本恢复为远程版本</h3><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </p>
<p>git pull origin master</p>
<p>git pull 默认拉去远程当前分支到本地当前分支</p>
<h3 id="应用：本地只有master分支，本地拉取线上其他分支"><a href="#应用：本地只有master分支，本地拉取线上其他分支" class="headerlink" title="应用：本地只有master分支，本地拉取线上其他分支"></a>应用：本地只有master分支，本地拉取线上其他分支</h3><p>git branch -a  //查看要拉取线上的什么分支</p>
<p>git pull origin 分支名：本地分支名  //直接git pull origin 分支名，本地新建该分支</p>
<p>git checkout 分支名  //切换</p>
<h3 id="应用：想新开发一版，但又不想保留目前"><a href="#应用：想新开发一版，但又不想保留目前" class="headerlink" title="应用：想新开发一版，但又不想保留目前"></a>应用：想新开发一版，但又不想保留目前</h3><p>想的再建一个仓库来的，没必要。</p>
<p>在不同分支上开发就行？</p>
<p>1.远程创建分支</p>
<p>2.创建完成后<code>git branch -a </code>并没有看到新分支</p>
<p>3.本地创建并切换新分支<code>git checkout -b mbox-7354 </code>，代码之前分支一样，并不是master代码。</p>
<p>4.切换分支并不会更改代码。是因为没有<code>git add + git commit</code>，修改的代码在本地工作区，执行commit操作后代码修改到了本地版本库，这时再切换分支，代码没有提现另一个分支的修改了。</p>
<p>5.切换到mbox-7354分支，pull 代码</p>
<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  </code></p>
<p><code>git pull origin mbox-7354 : mbox-7354</code> 被拒绝</p>
<p>出现<code>non-fast-forward</code>的错误，证明本地库跟远程库的提交记录不一致，即本地库版本需要更新</p>
<p>6.pull不行，换从远程拉取分支</p>
<p>删除分支，先切换到别的分支，再<code>git brqanch -d name</code> -D强制删除</p>
<p><code>git checkout -b mbox-7354 origin/master</code> 创建</p>
<p><code>git pull origin master</code>  把远程分支上的内容都拉取到本地</p>
<p>7.拉取了和线上master一样的代码，接下来可以修改代码</p>
<h3 id="应用：commit之后想改commit的名字"><a href="#应用：commit之后想改commit的名字" class="headerlink" title="应用：commit之后想改commit的名字"></a>应用：commit之后想改commit的名字</h3><p><code>git commit -m &quot;v2&quot;</code></p>
<p><code>git commit --amend -m &quot;v2 add two interfaces&quot;</code></p>
<h3 id="应用：本地创建多个分支互不干扰"><a href="#应用：本地创建多个分支互不干扰" class="headerlink" title="应用：本地创建多个分支互不干扰"></a>应用：本地创建多个分支互不干扰</h3><p>（1）本地已有分支dev，写了需求a，但是不要提交。</p>
<p>（2）执行git stash命令，将工作区的内容“储存起来”</p>
<p>（3）接着在dev分支上修改bug，并提交，push</p>
<p>（4）执行git stash pop，恢复工作区原来的内容。</p>
<h3 id="应用：本地代码提交到另一分支上"><a href="#应用：本地代码提交到另一分支上" class="headerlink" title="应用：本地代码提交到另一分支上"></a>应用：本地代码提交到另一分支上</h3><p>开发过程中难免切换分支，不管是开发另一个需求，还是提交到另一个分支。git checkout 切换分支之后，本地工作区的代码会不会变？ 之前切换到新建的分支，本地的代码还在，可以提交到新分支；可是再切回去，出现问题。因此有必要用stash解决。</p>
<p><code>git stash save &quot;save message&quot;</code>：执行存储时，添加备注，方便查找，只有 git stash 也是可以的</p>
<p><code>git stash list</code>：查看stash了哪些存储</p>
<p><code>git stash show</code>：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加 stash@{$num}，比如第二个 git stash show stash@{1}</p>
<p><code>git stash apply</code>：应用某个存储，但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@{0}，如果要使用其他的，git stash apply stash@{$num}， 比如第二个：git stash apply stash@{1}</p>
<p><code>git stash pop</code>：恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下，默认为第一个 stash，即 stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num}，比如应用并删除第二个：git stash pop stash@{1}</p>
<p><code>git stash drop stash@&#123;$num&#125;</code>：丢弃 stash@{$num} 存储，从列表中删除这个存储</p>
<p><code>git stash clear</code>：删除所有缓存的stash</p>
<p>但是对于新增的文件，<code>git stash</code> 是不会存进去的，因为新增的文件没有被git托管，需要先执行下 <code>git add</code> 加到git版本控制中，然后再 <code>git stash</code> 就可以了</p>
<p>只备份部分文件怎么办？</p>
<ol>
<li>add 那些你不想备份的文件（例如： git add file1.js, file2.js）</li>
<li>调用 <code>git stash –keep-index</code>。只会备份那些没有被add的文件。</li>
<li>调用 <code>git reset</code> 取消已经 add 的文件的备份，继续自己的工作。</li>
</ol>
<p>✅Git如何stash部分文件：<br>想要stash部分代码，其他的要push。<br>用git stash -p，它是一个交互式命令,我们可以一个文件一个文件的遍历,决定每个文件的操作方式.<br>到我们需要stash的文件,我们就y,不需要stash需要commit的文件,我们就n,如果接下来没有需要stash的文件,则直接q。<br>将文件保存好后,我们就可以commit和push剩下的代码了.</p>
<p>✅stash pop后有冲突，想取消stash怎么办</p>
<p>如果使用 git stash pop 后有冲突时，如何撤销?<br>可以使用 git reset –hard ，即可撤销 git stash pop 操作，将当前分支状态恢复。<br>而该操作后，git stash 暂存区的记录也不会被删除，可通过 git stash show 查看。</p>
<p>###git merge<br><code>git merge A</code>  是将A代码合并到当前分支，不会改变A分支的</p>
<p>当master代码改动了，需要更新开发分支（dev）上的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git pull </span><br><span class="line">git checkout dev</span><br><span class="line">git merge master </span><br><span class="line">git push -u origin dev</span><br></pre></td></tr></table></figure>

<p>开发分支开发完了，需要在迭代分支上上线，合并到迭代分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 迭代</span><br><span class="line">git merge 开发</span><br><span class="line">git push -u origin 迭代</span><br></pre></td></tr></table></figure>


<h3 id="查看git配置"><a href="#查看git配置" class="headerlink" title="查看git配置"></a>查看git配置</h3><p>git config –list</p>
<h3 id="commit之后，追加提交"><a href="#commit之后，追加提交" class="headerlink" title="commit之后，追加提交"></a>commit之后，追加提交</h3><p>1.如果还没有push到远程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &#x27;initial commit&#x27;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend   //wq保存</span><br></pre></td></tr></table></figure>
<p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。<br>先git add提交修改的文件<br>再git commit –amend<br>也叫追加提交，它可以在不增加一个新的commit的情况下，将新修改的代码追加到前一次的commit中。<br>使用该命令的好处，是避免许多无用的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用参数：</span><br><span class="line"></span><br><span class="line">--no-edit：使用选定的提交消息而无需启动编辑器。（追加提交，且不修改message信息。）</span><br><span class="line"></span><br><span class="line">--reset-author：加载提交用户的信息。</span><br><span class="line"></span><br><span class="line">比如你从新配置本地用户的信息，然后使用该参数可以重新加载新用户的信息，并且更新在追加提交中。</span><br><span class="line"></span><br><span class="line">--author=：可修改Git 的 author 和 email 信息。</span><br><span class="line">示例：git commit --amend --author=&#x27;xxx &lt;xxxx@xxx.xxx&gt;&#x27;</span><br><span class="line"></span><br><span class="line">摘自：http://events.jianshu.io/p/f015b97bda53</span><br><span class="line"></span><br><span class="line">-m: 执行git commit --amend -m &quot;这里填写提交的注释&quot;命令进行提交。</span><br><span class="line"></span><br><span class="line">使用git commit --amend命令，表面上没有生成新的提交，只是进行了内容的追加。但实际上通过git reflog命令查看历史提交记录，我们还是看到了，其实是新生成了一个commit。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.已经push到远程了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend     // 修改上一次的提交</span><br><span class="line"></span><br><span class="line">// 进入提交信息编辑界面</span><br><span class="line">// 修改保存退出</span><br><span class="line"></span><br><span class="line">// 强制推送 (本地分支:远程分支)</span><br><span class="line">git push -f origin master:master</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***git commit --amend 命令原理:***</span><br><span class="line">git commit --amend这个命令给人的感觉，是用新提交的数据，追加到了前一个commit上。</span><br><span class="line"></span><br><span class="line">其实git commit --amend命令底层原理如下：</span><br><span class="line"></span><br><span class="line">前提：你把遗漏提交的文件，或者修改的文件先提交到暂存区。</span><br><span class="line"></span><br><span class="line">1. git reset --soft HEAD^：回退一个版本，且工作区和暂存区中的内容不会退。</span><br><span class="line"></span><br><span class="line">2. git commit -c ORIG_HEAD：提交操作。在根据此时的暂存区生成一个新的提交对象，代替原来提交的位置。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">-C &lt;commit&gt;，全称--reuse-message=&lt;commit&gt;：获取现有的提交对象，并在创建提交时重用现有提交对象的日志消息和作者信息（包括时间戳）。</span><br><span class="line">-c &lt;commit&gt;，全称--reedit-message=&lt;commit&gt;：与-C类似，但是-c会调用编辑器，以便用户可以进一步编辑提交消息。</span><br></pre></td></tr></table></figure>


<h3 id="git如何撤销已提交的commit重新提交"><a href="#git如何撤销已提交的commit重新提交" class="headerlink" title="git如何撤销已提交的commit重新提交"></a>git如何撤销已提交的commit重新提交</h3><p>1、首先，使用git log -n 3 –stat命令，可以查看最近3次提交的详细信息，并且会显示每次commit的哈希值。</p>
<blockquote>
<p>git log 会显示：commit 哈希id、提交的Author信息、提交的日期和时间、commit info信息<br>–oneline： 只显示提交的 SHA1 值和提交信息，SHA1 还是缩短显示前几位，一般为前七位（commit id的前七位？）<br>–graph：绘制一个 ASCII 图像来展示提交历史的分支结构，类似于一个树形结构，很方便很好看<br>–stat参数: 主要可以在git log 的基础上输出文件增删改的统计数据<br>-p参数与–stat类似，不过-p参数更为详细，可以看到每个文件更为详细的修改内容<br>–author用来过滤commit,限定输出给定的用户:git log –author=”Stephen Curry”<br>–after和–before:  限定指定日期范围的log : git log –after ‘08-12-2020’</p>
</blockquote>
<p>漂亮log命令：<code>git log --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date=relative --all</code></p>
<p>2、接着使用如下命令来回到某次提交：git reset –soft 某次commit哈希值的任意前缀</p>
<blockquote>
<p>最近一次commit了，但是不想要了，git log 获得这次提交的上一次的commit id，然后git reset，本地代码改动就回到本地工作空间了。可以重新改了再提交。<br>reset之后，最近一次的commit就在log里消失了。</p>
</blockquote>
<p>3、回到那次commit之后，接着使用如下命令强制提交到master分支：git push origin master –force执行结束后，可以看到远程git仓库的希望撤回的commit已经不见了。</p>
<p>4、强制提交之后，那次commit之后所有的修改都处于没有提交的状态，可以再修改文件，然后将他们都再添加提交即可。</p>
<p>5、使用git commit -m命令再提交新的commit。</p>
<p>6、最终是希望撤回的commit已经消失，换成了新提交的commit。</p>
<h3 id="feature分支和release分支"><a href="#feature分支和release分支" class="headerlink" title="feature分支和release分支"></a>feature分支和release分支</h3><p>1⃣️ master 分支：<br>master 为主分支，也是用于部署生产环境的分支，确保master分支稳定性，master 分支一般由develop以及hotfix分支合并，任何时间都不能直接修改代码。</p>
<p>2⃣️ develop 分支：<br>develop 为开发分支，始终保持最新完成以及bug修复后的代码<br>一般开发的新功能时，feature分支都是基于develop分支下创建的</p>
<p>3⃣️ feature 分支：<br>开发新功能时，以develop为基础创建feature分支<br>分支命名: feature/ 开头的为特性分支， 命名规则: feature/user_module、 feature/cart_module</p>
<p>4⃣️ release分支：<br>release 为预上线分支，发布提测阶段，会release分支代码为基准提测</p>
<blockquote>
<p>当有一组feature开发完成，首先会合并到develop分支，进入提测时，会创建release分支。<br>如果测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。<br>当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p>
</blockquote>
<p>5⃣️ hotfix 分支：<br>分支命名: hotfix/ 开头的为修复分支，它的命名规则与 feature 分支类似<br>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支</p>
<h3 id="git冲突"><a href="#git冲突" class="headerlink" title="git冲突"></a>git冲突</h3><p>1⃣️ 产生冲突的原因：</p>
<p>简单来说就是本地修改的文件和目标远程库的同一个文件都有修改。这时无论是pull/push/merge时都会产生冲突。</p>
<p>场景1：多个分支代码合并到一个分支时：<br>开发a分支对某文件进行了修改，并提交到了master分支，这时开发b分支也对该文件进行了修改，然后合并到master分支，这时可能会发生冲入。（同一文件不同部分的修改，git会自动合并，同一文件同一行或是连续的一部分，git无法自动合并，需要手动解决冲突后合并）</p>
<p>场景2：同一分支下本地和远程的冲突：<br>比如a和b开发同一分支，a改了某文件，并且merge上去了，b也改了这个文件，此时b要pull或push，都会发生冲突，代表本地和远程分支的代码是不同步的。</p>
<p>其实类似，第一种基准是master分支，往里合并的是两个远程分支；第二种基准是远程分支，往里合并的是两个人的本地分支。</p>
<hr>
<p>2⃣️ 如何解决冲突：</p>
<p>场景1:<br>修改谁：修改要合并的那个分支</p>
<p>1、merge/pull 远程master分支到本地当前分支，修改冲突，然后add commit push</p>
<p>场景2:<br>首先尽量避免第二种的发生：开发之前先git pull一下最新的代码。</p>
<p>冲突了修改谁：修改本地的文件。案例：提交代码，cv之后，显示冲突，需要本地解决再push。</p>
<p>1、git pull更新代码，发现CONFLICT：Merge conflict in 文件<br>Automatic merge failed：fix conficts…<br>这说明你的该文件与远程有冲突，此时暂停merge，远程改动都到了本地暂存区（add前），需要先提交本地的修改然后更新。</p>
<p>2、找到冲突文件，并打开你会在文件中发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD </span><br><span class="line">我的代码</span><br><span class="line">======= </span><br><span class="line">别人的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; ae9a0f6b7e42fda2ce9b14a21a7a03cfc5344d61这种标记。</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD和=======中间的是你自己的代码，</span><br><span class="line">======= 和&gt;&gt;&gt;&gt;&gt;&gt;&gt;中间的是其他人修改的代码，</span><br><span class="line">改好之后，最后删除&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt;这种标志。</span><br></pre></td></tr></table></figure>
<p>改好了，git status -s看到冲突文件前面有个UU</p>
<p>3、git add 冲突文件<br>git commit -m ‘冲突解决’<br>提交本地的pom.xml文件，不进行推送远程</p>
<p>4、然后都不用git pull，自动就pull了，然后再push就好了，push之前也不用再commit。</p>
<p>总结：解决冲突的原则是修改要提交/正在开发的那个分支，将基准分支的代码pull过来，解决冲突后进行提交。</p>
<p>问题：git pull 有冲突，改动到了本地暂存区，冲突解决之后，commit了冲突文件之后，再git pull就会把本地暂存区的文件合并到本地 ？</p>
<p>答：解决冲突，提交了冲突文件之后，暂存区的文件不见了，之前自己加的文件也不见了…应该是提交冲突之后，自动git pull了。</p>
<p>参考：<a href="https://blog.csdn.net/mrwangisgoodboy/article/details/123245194">https://blog.csdn.net/mrwangisgoodboy/article/details/123245194</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1711887140444140945&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1711887140444140945&amp;wfr=spider&amp;for=pc</a></p>
<hr>
<p>用idea处理冲突：</p>
<p>1、点右上角蓝箭头：<br>（一）Merge the incoming changes into the current branch</p>
<pre><code>将传入的更改合并到当前分支中（常用） 相当于git pull
</code></pre>
<p>（二）Rebase the current branch on top of the incoming changes</p>
<pre><code>把你当前分支的 commit 放到公共分支的最后面,所以叫变基
</code></pre>
<p>master与rebase：<a href="https://blog.csdn.net/weixin_41231928/article/details/107040880">https://blog.csdn.net/weixin_41231928/article/details/107040880</a></p>
<p>2、选择merge the incoming…（等同于git pull）</p>
<p>3、点master，点merge into current</p>
<p>4、处理冲突：左边是自己的，这件是merge的，右边是别人的，绿色可以自动处理，红色需要手动处理。</p>
<p>5、git add commit push</p>
<hr>
<p>202207用idea解决冲突：<br>push之后，cr代码冲突了，本地git pull，然后代码区域右键git - git resolve merge。挨个文件点merge。先点左上角all，然后左右点箭头，都要的两边都点，不要的点x。 左边是当前分支的，右边是master分支的。</p>
<h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p>使用场景：对于多分支的代码库，将代码从一个分支转移到另一个分支，并且，只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.首先查出要用的提交的commit id（哈希值）</span><br><span class="line">git log --oneline</span><br><span class="line"></span><br><span class="line">2.切换到现在要写的分支</span><br><span class="line">git checkout feature1</span><br><span class="line"></span><br><span class="line">3.合并到当前分支</span><br><span class="line">git cherry-pick f</span><br><span class="line">//git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</span><br><span class="line"></span><br><span class="line">4.如果合并时候冲突了，Cherry pick 会停下来，让用户决定如何继续操作。</span><br><span class="line">1）--continue</span><br><span class="line">用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行</span><br><span class="line">git cherry-pick --continue</span><br><span class="line"></span><br><span class="line">2）--abort</span><br><span class="line">发生代码冲突后，放弃合并，回到操作前的样子</span><br><span class="line">git cherry-pick --abort</span><br><span class="line"></span><br><span class="line">3）--quit</span><br><span class="line">发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</span><br></pre></td></tr></table></figure>

<p>更多：<a href="https://blog.csdn.net/qq_35432904/article/details/107232691">https://blog.csdn.net/qq_35432904/article/details/107232691</a></p>
<p>实操步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、git log --oneline 查看要cherry-pick过来的commit id</span><br><span class="line">2、git cherry-pick commit id</span><br><span class="line">3、有冲突，解决冲突</span><br><span class="line">4、解决完，git cherry-pick --continue</span><br></pre></td></tr></table></figure>

<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p><a href="https://zhuanlan.zhihu.com/p/183131156">https://zhuanlan.zhihu.com/p/183131156</a></p>
<h3 id="回退到某次提交"><a href="#回退到某次提交" class="headerlink" title="回退到某次提交"></a>回退到某次提交</h3><p>git reset –hard commit id</p>
<h3 id="总结：几种放弃修改"><a href="#总结：几种放弃修改" class="headerlink" title="总结：几种放弃修改"></a>总结：几种放弃修改</h3><p>1、未使用 git add 缓存代码时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout --&lt;文件名称&gt;</span><br><span class="line">放弃单个文件的修改</span><br><span class="line"></span><br><span class="line">$ git checkout .</span><br><span class="line">放弃全部文件的修改</span><br><span class="line"> </span><br><span class="line">注：此命令不会删除新建的文件，因为刚新建的文件还没已有加入到 git 的管理系统中，所以对于git是未知的。自己手动删除就好了</span><br></pre></td></tr></table></figure>

<p>2、已经使用了 git add 缓存了代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;文件名称&gt;</span><br><span class="line">放弃指定文件的缓存</span><br><span class="line"> </span><br><span class="line">$ git reset HEAD .</span><br><span class="line">放弃全部文件缓存</span><br><span class="line"> </span><br><span class="line">注：此命令用来清除git add的缓存，相当于撤销git add命令，使用本命令后本地修改的文件并不会发生变化，继续使用git checkout命令可放弃修改</span><br></pre></td></tr></table></figure>

<p>3、已经用 git commit 提交了代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">回退到上一次commit状态</span><br><span class="line"> </span><br><span class="line">$ git reset --hard &lt;commitid&gt;</span><br><span class="line">回退到任意版本</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个hexo博客</title>
    <url>/2021/09/12/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/hexo/</url>
    <content><![CDATA[<h3 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h3><p>jadeliuliu.github.io</p>
<h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>首先需要安装npm，Node Package Manager ，是一个NodeJS包管理和分发工具，大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<h4 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h4><p><code>brew install node</code>     安装好了nodejs和npm </p>
<p><code>npm -v</code>  检查</p>
<p>安装hexo:<code>npm install -g hexo</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/390f202c5b0e">https://www.jianshu.com/p/390f202c5b0e</a></p>
<h3 id="3-初始化项目"><a href="#3-初始化项目" class="headerlink" title="3.初始化项目"></a>3.初始化项目</h3><p><code>hexo init</code>  </p>
<p><code>hexo s</code>  浏览器可访问</p>
<h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4.部署到github"></a>4.部署到github</h3><p>在项目根目录下找到 <code>_congif.yml</code>，找到 <code>deploy</code> 字段并填写完整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">  repo: https://github.com/jadeliuliu/jadeliuliu.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>需要额外的一个工具来帮助我们推到仓库上，是 <code>hexo-deployer-git</code></p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p><code>hexo clean</code></p>
<p><code>hexo deploy</code></p>
<h3 id="5-出现443的问题"><a href="#5-出现443的问题" class="headerlink" title="5.出现443的问题"></a>5.出现443的问题</h3><p>连接超时的问题：网上主流解决方法是自定义一个接口代理或输入如下语句禁用接口代理</p>
<p><code>git config --global --unset https.proxy</code></p>
<p>参考：<a href="https://blog.csdn.net/longroad1216/article/details/114853527">https://blog.csdn.net/longroad1216/article/details/114853527</a></p>
<p>或者https换成git试一试</p>
<p>6.登录github需要tocken</p>
<p>参考：<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">https://blog.csdn.net/weixin_41010198/article/details/119698015</a></p>
<h3 id="6-更换next主题"><a href="#6-更换next主题" class="headerlink" title="6.更换next主题"></a>6.更换next主题</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>配置文件里改theme</p>
<p>hexo s 看效果</p>
<p>hexo -s 看帮助</p>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_39766258/article/details/110638797</span><br><span class="line">（比较全的指南）</span><br><span class="line"></span><br><span class="line">https://www.jianshu.com/p/e17711e44e00</span><br><span class="line">（添加分类）</span><br></pre></td></tr></table></figure>

<h3 id="8-添加分类"><a href="#8-添加分类" class="headerlink" title="8.添加分类"></a>8.添加分类</h3><p>测试：</p>
<p>// 我们可以写成一条命令<br>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br>$ hexo d</p>
<p>文章：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 如何搭建一个hexo博客</span><br><span class="line">date: <span class="number">2021</span>年<span class="number">09</span>月<span class="number">15</span>日 <span class="number">20</span>:<span class="number">58</span>:<span class="number">49</span></span><br><span class="line">categories: </span><br><span class="line">- 后端</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="9-增加目录"><a href="#9-增加目录" class="headerlink" title="9.增加目录"></a>9.增加目录</h3><p>主题配置文件位于<code>themes/next/_config.yml</code></p>
<p>每行目录超长自动换行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true  </span><br><span class="line">  wrap: true </span><br></pre></td></tr></table></figure>

<h3 id="10-首页只显示文章标题"><a href="#10-首页只显示文章标题" class="headerlink" title="10.首页只显示文章标题"></a>10.首页只显示文章标题</h3><span id="more"></span>     #首页只会显示标记以前的内容，标记后的内容可以通过阅读更多查阅

<p><a href="https://blog.csdn.net/yueyue200830/article/details/104470646">https://blog.csdn.net/yueyue200830/article/details/104470646</a></p>
<h3 id="11-如何改变创建时间"><a href="#11-如何改变创建时间" class="headerlink" title="11.如何改变创建时间"></a>11.如何改变创建时间</h3><p>改变date格式</p>
<h3 id="12-增加访问统计"><a href="#12-增加访问统计" class="headerlink" title="12.增加访问统计"></a>12.增加访问统计</h3><p>没成功，害我搞的deploy一直报错，花里胡哨</p>
<h3 id="13-插入图片问题"><a href="#13-插入图片问题" class="headerlink" title="13.插入图片问题"></a>13.插入图片问题</h3><p><a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p>
<h3 id="更新出现问题"><a href="#更新出现问题" class="headerlink" title="更新出现问题"></a>更新出现问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br></pre></td></tr></table></figure>

<p>解决方法：<code>xcode-select --install</code></p>
<h3 id="14-博客添加search功能"><a href="#14-博客添加search功能" class="headerlink" title="14.博客添加search功能"></a>14.博客添加search功能</h3><p>1.安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>2.全局配置文件_config.yml，新增如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>3.hexo主题配置文件（\themes\next\_config.yml），修改local_search的enable为true：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>

<h3 id="15-博客增加访客统计"><a href="#15-博客增加访客统计" class="headerlink" title="15.博客增加访客统计"></a>15.博客增加访客统计</h3><p>1.打开next主题配置文件\themes\next\_config.yml，搜索找到<strong>busuanzi_count</strong>，把enable设置为true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true    //访客数</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true    //访问数</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true     //文章阅读数</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<p>2.同样是在next主题配置文件\themes\next\_config.yml下，搜索<strong>footer</strong>，在它底下添加counter，设值为true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  Counter: true</span><br></pre></td></tr></table></figure>

<p>3.来到themes\next\layout\_partials，找到<strong>footer.swig</strong>文件，打开编辑，在底下添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/baidu_34310405/article/details/102665373">https://blog.csdn.net/baidu_34310405/article/details/102665373</a></p>
<h3 id="16-博客侧边栏添加联系方式"><a href="#16-博客侧边栏添加联系方式" class="headerlink" title="16.博客侧边栏添加联系方式"></a>16.博客侧边栏添加联系方式</h3><p>1.在主题配置文件<code>themes/next-theme/_config.yml</code>中，搜索<code>social</code>，在<code>social</code>下使用如下格式增加侧栏链接：</p>
<p><code>Key: permalink || icon</code></p>
<p><code>Key</code>为显示给访问用户的链接名称；<br><code>permalink</code>为链接地址；<br><code>icon</code>为FontAwesome图标，如果未指定图标，则显示为一个<code>地球</code>图标。</p>
<p>2.添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/jadeliuliu || github</span><br><span class="line">  E-Mail: mailto:jadeliu1998@163.com || envelope</span><br><span class="line">  CSDN: https://blog.csdn.net/jadeliu1998|| crosshairs</span><br><span class="line">  Weibo: https://weibo.com/u/5823044646 || weibo</span><br></pre></td></tr></table></figure>

<p>3.图标及标签文字的显示及隐藏</p>
<p>搜索<code>social_icons</code>并定位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enable: true</span><br><span class="line">icons_only: false</span><br><span class="line">transition: false</span><br></pre></td></tr></table></figure>

<p>通过修改<code>enable</code>、<code>icons_only</code>实现对图标的以及图标旁标签文字的显示及隐藏功能，修改<code>transition</code>实现是否显示过渡效果功能。</p>
<p>参考：<a href="https://blog.csdn.net/wangqingchuan92/article/details/116223408">https://blog.csdn.net/wangqingchuan92/article/details/116223408</a></p>
<h3 id="17-博客添加头像"><a href="#17-博客添加头像" class="headerlink" title="17.博客添加头像"></a>17.博客添加头像</h3><p>1.找到配置文件<code>themes/next/_config.yml</code>，搜索<code>avatar: /images/avatar_2.gif</code>，取消注释</p>
<p>2.在image文件夹中添加图片.</p>
<h3 id="18-修改站点图标"><a href="#18-修改站点图标" class="headerlink" title="18.修改站点图标"></a>18.修改站点图标</h3><p>1.矢量图库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn</a></p>
<p>2.在<code>/themes/next/_config.yml</code>中修改成自己的图标</p>
<p>就是很多分辨率的，三四个要改都改，算了改。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea日常使用</title>
    <url>/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="替换文字"><a href="#替换文字" class="headerlink" title="替换文字"></a>替换文字</h2><p>command + R ：当前文件替换<br>command + shift + R ：全局文件替换</p>
<h2 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h2><p>换行符：LF<br>编码：UTF-8<br>提交代码之后中文乱码：设置里 File Encodings 里的都选UTF-8，Transparent native-to-ascii conversion（透明转换为ascii）不勾选。</p>
<h2 id="变量高亮"><a href="#变量高亮" class="headerlink" title="变量高亮"></a>变量高亮</h2><p>变量写操作颜色设置：Settings-&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Code -&gt; identifier under caret(write) -&gt; 设置底色</p>
<p>变量读操作颜色设置：Settings-&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Code -&gt; identifier under caret -&gt; 设置底色</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql实战</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>1、注意直接from a and b 是相当于inner join，没有的不显示。</p>
<p>2、原来inset error的话，自增减也会消耗掉1个，update不会消耗，但是inset duplicate会消耗。</p>
<p>3、项目代码里，sql置select出一条，也就是只用一个对象接收时，必须得加limit 1，不然select出多条就会报错。</p>
<p>5、可以select * from table where (条件1 or 条件2) and 条件3;</p>
<p>6、where嵌套表查询，必须给被嵌套的表取别名。</p>
<p>7、update和insert的时候，注意not null的，注意唯一键。</p>
<p>8、sql用联表查询，相当于inner join，那么其中一个表没有的话就不会显示，要注意。所以用left join，条件放在on还是where里的选择：要留下右表为null，左表不为null的记录的话就on，不要的话用where。</p>
<p>9、注意left join的一对多关系，会复制显示多行，用group_concat把多行字段合并就可以显示一行，但要加group by。</p>
<p>10、sql不要写太复杂，最好把计算的工作交给代码而不是数据库。</p>
<p>11、sql查询，如果是gmt_create&lt;某个时间，会很慢，最好加一个&gt;某个时间。</p>
<p>12、where中时间&gt;”2022-10-10”，不管大于小于，意思都是加个00:00:00.</p>
<p>15、不成文的规定：mysql单表数据量大于2000w行，性能会明显下降。<br>详解：<a href="https://blog.csdn.net/Edwin_Hu/article/details/124897224">https://blog.csdn.net/Edwin_Hu/article/details/124897224</a></p>
<p>16、如果对geometry字段加了空间索引，那么该字段不能为null。</p>
<h2 id="1-mysql增删改查"><a href="#1-mysql增删改查" class="headerlink" title="1.mysql增删改查"></a>1.mysql增删改查</h2><h3 id="a-登录"><a href="#a-登录" class="headerlink" title="a.登录"></a>a.登录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">登录：</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p密码  <span class="operator">/</span><span class="operator">/</span>连本机的</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span>, Host, Password <span class="keyword">FROM</span> mysql.user;  <span class="operator">/</span><span class="operator">/</span>查看用户</span><br><span class="line"></span><br><span class="line">添加新用户：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">修改密码：</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;liuxuan14&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span><span class="operator">=</span>password(<span class="string">&#x27;1998&#x27;</span>);</span><br><span class="line">为用户授权：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>允许访问所有数据库下的所有表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定数据库下的指定表</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> test.test <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>只拥有查询权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;新用户名&#x27;</span>@<span class="string">&#x27;指定ip&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;新用户密码&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;  <span class="operator">/</span><span class="operator">/</span>刷新权限</span><br><span class="line"></span><br><span class="line">删除用户：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> liuxuan<span class="variable">@localhost</span>；</span><br><span class="line"></span><br><span class="line">连接远程数据库：</span><br><span class="line">MySQL 连接远程数据库（<span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span>），端口“<span class="number">3306</span>”，用户名为“root”，密码“<span class="number">123456</span>”</span><br><span class="line">mysql <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.5</span><span class="number">.116</span> <span class="operator">-</span>P <span class="number">3306</span> <span class="operator">-</span>u root <span class="operator">-</span>p123456</span><br><span class="line">mysql <span class="operator">-</span>h ip <span class="operator">-</span>P 端口 <span class="operator">-</span>A <span class="operator">-</span>u name  <span class="operator">-</span>p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database name</span><br></pre></td></tr></table></figure>

<h3 id="b-建表"><a href="#b-建表" class="headerlink" title="b.建表"></a>b.建表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `mytable`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `app_id` bigint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;应用id&#x27;,</span><br><span class="line">   `time` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;时间&#x27;,</span><br><span class="line">   `date` DATE,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">   UNIQUE KEY `idx_app` (`app_id`) USING BTREE</span><br><span class="line">   KEY `idx_ip` (`machine_ip`) USING BTREE,</span><br><span class="line">   KEY `idx_app_machineid` (`app_id`,`machine_id`) USING BTREE</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;表名&#x27;;</span><br><span class="line"></span><br><span class="line">AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</span><br><span class="line">PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</span><br><span class="line">ENGINE 设置存储引擎，CHARSET 设置编码。</span><br><span class="line"></span><br><span class="line">表结构：desc name；</span><br><span class="line">建表语句：show create tablename；</span><br></pre></td></tr></table></figure>

<p>注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释：comment</span><br><span class="line">create table test1 ( </span><br><span class="line">    field_name int comment &#x27;字段的注释&#x27; </span><br><span class="line">)comment=&#x27;表的注释&#x27;;</span><br><span class="line">修改表的注释：</span><br><span class="line">alter table test1 comment &#x27;修改后的表的注释&#x27;;</span><br><span class="line">修改字段的注释：</span><br><span class="line">alter table test1 modify column field_name int comment &#x27;修改后的字段注释&#x27;; </span><br><span class="line">查看表注释：</span><br><span class="line">show  create  table  test1; </span><br><span class="line">查看字段注释：</span><br><span class="line">show  full  columns  from  test1; </span><br></pre></td></tr></table></figure>

<p>索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唯一索引：</span><br><span class="line">UNIQUE KEY</span><br><span class="line">1  主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</span><br><span class="line">2  主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。</span><br><span class="line">3   唯一性索引列允许空值， 而主键列不允许为空值。</span><br><span class="line">4   主键可以被其他表引用为外键，而唯一索引不能。</span><br><span class="line">5   一个表最多只能创建一个主键，但是可以创建多个唯一索引。</span><br><span class="line">6   主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。</span><br><span class="line">7   在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。</span><br></pre></td></tr></table></figure>

<h3 id="c-添加一个字段"><a href="#c-添加一个字段" class="headerlink" title="c.添加一个字段"></a>c.添加一个字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tablename </span><br><span class="line">add `app_name` varchar(16) NOT NULL DEFAULT &#x27;app&#x27;;</span><br><span class="line">// 可以一次加多行，用,隔开</span><br><span class="line"></span><br><span class="line">删除字段：</span><br><span class="line">alter table tablename</span><br><span class="line">drop column `app_name`</span><br></pre></td></tr></table></figure>

<p>给现有的表格插入一列，自带固定值（所有行都写入）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table grade add newcolumn varchar(3) default &quot;sor&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="d-修改数据"><a href="#d-修改数据" class="headerlink" title="d.修改数据"></a>d.修改数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tablename set 字段=&#x27;修改的值&#x27; where 条件；</span><br><span class="line">多个字段中间加,</span><br></pre></td></tr></table></figure>

<h3 id="e-删除"><a href="#e-删除" class="headerlink" title="e.删除"></a>e.删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删库：drop database name;</span><br><span class="line">删表：drop table name；</span><br><span class="line"></span><br><span class="line">mysql删除一行：</span><br><span class="line">delete from 表 where 条件；</span><br><span class="line"></span><br><span class="line">delete from tableName [where ..] [order by ..] [limit ..]</span><br></pre></td></tr></table></figure>

<h3 id="f-添加一行"><a href="#f-添加一行" class="headerlink" title="f.添加一行"></a>f.添加一行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//个别字段</span><br><span class="line">insert into tablename (app_id,machine_id,machine_ip,ctime,use_perc) values(?,?,?,?,?),(...);   //对应字段加，可一次性加多行</span><br><span class="line"></span><br><span class="line">//全部字段（主键也得有，不知道该是啥，就输入0，自己来自增）</span><br><span class="line">insert into student values(0, &quot;li&quot;, 23);</span><br><span class="line"></span><br><span class="line">insert into 表名 values(...),(..);  //可一次性加多行，一行全部数都有</span><br><span class="line"></span><br><span class="line">insert into 表名 set 列名=&#x27;&#x27;, ...;</span><br><span class="line">insert into user_info set user_id=123,user_name=“你好”,status=1,years=15；</span><br></pre></td></tr></table></figure>

<p><strong>⚠️insert时，表名后面的()里的列名，不能用双引号阔起来，可以用``，可以都不加</strong></p>
<h2 id="2-渤海"><a href="#2-渤海" class="headerlink" title="2.渤海"></a>2.渤海</h2><p>两张表，一张Customer，有ID、NAME、CITY（用户城市）。一张Card，有ID、CID（卡编号）、BAL（卡内余额）。</p>
<p>同一个用户可能有多张卡片，现在需要连接两张表，查找并打印出北京地区个人持有账户总额最高的客户，若存在多个，则按照用户姓名的字母顺序进行排序。</p>
<p>顺序：select from where group by having order by</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select re.`Customer Name`,re.sum_val from</span><br><span class="line">( SELECT c2.NAME as &quot;Customer Name&quot;,sum(c.bal) as sum_val FROM Card as c left join Customer as c2 on c.ID = c2.ID where c2.CITY = &quot;beijing&quot; GROUP BY c.ID ) as re </span><br><span class="line">where re.sum_val = ( SELECT max(sum_value) from</span><br><span class="line">( SELECT sum(c3.bal) as sum_value FROM Card as c3 left join Customer as c4 on c3.ID = c4.ID where c4.CITY = &quot;beijing&quot; GROUP BY c3.ID ) as t1 )</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select Customer.name as &#x27;Customer Name&#x27; from Customer join Card on Customer.id = Card.id where Customer.city = &#x27;beijing&#x27; group by Customer.id having sum(Card.bal) = (select max(sum_bal) from (     select sum(bal) as sum_bal from Customer join Card     on Customer.id = Card.id  where Customer.city = &#x27;beijing&#x27;  group by Customer.id) as t);</span><br><span class="line"></span><br><span class="line">(as 后面的别名的&#x27;&#x27;不是必须的,as也不是必须的)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证：</span><br><span class="line">drop table if exists Customer;</span><br><span class="line">CREATE TABLE `Customer` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`name` varchar(14) NOT NULL,</span><br><span class="line">`city` varchar(32) NOT NULL);</span><br><span class="line"></span><br><span class="line">INSERT INTO Customer VALUES(1,&#x27;刘一&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">INSERT INTO Customer VALUES(2,&#x27;刘二&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">INSERT INTO Customer VALUES(3,&#x27;刘三&#x27;,&#x27;tianjin&#x27;);</span><br><span class="line"></span><br><span class="line">drop table if exists Card;</span><br><span class="line">CREATE TABLE `Card` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`cid` int NOT NULL,</span><br><span class="line">`bal` int NOT NULL);</span><br><span class="line"></span><br><span class="line">INSERT INTO Card VALUES(1,11,100);</span><br><span class="line">INSERT INTO Card VALUES(1,12,100);</span><br><span class="line">INSERT INTO Card VALUES(2,13,200);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在用进行嵌套查询的时候，子查询执行出来的的结果是需要作为一个派生表来给上一级进行查询使用的，所以子查询的结果必须要有一个别名，这里“别名”的使用可以理解为是用作临时变量记录子查询的结果</span><br></pre></td></tr></table></figure>

<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>select from where group by having order by</p>
<p>from后可以是单表，也可以是几张表join连接后的表</p>
<p>where是单表，group by having根据字段进行分组。两个可以一起用。先where 再group by。<br>having可选，限制显示行</p>
<p>注意having 和where的区别，</p>
<p>order by 是最后对显示的行根据某一字段进行排序，因此在最后。</p>
<h2 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h2><p><code>select distinct 字段 from table</code></p>
<p><code>distinct</code>是加在<code>select</code>后面的，后面如果有多个字段，意思就是只有多个字段不是完全一样就ok</p>
<h2 id="limit限制个数"><a href="#limit限制个数" class="headerlink" title="limit限制个数"></a>limit限制个数</h2><p>不一定非得搭配order by</p>
<p><code>select 字段 from table limit n;</code>    //表示输出前n个</p>
<p><code>select 字段 from table limit start,n;</code>  // 表示输出从start开始n个，0是第一个，limit0,1 表示第一个</p>
<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p><code>where id&gt;3;</code>        <code>where id between 2 and 3</code></p>
<p><code>where id!=3</code></p>
<p><code>where age!=&#39;&#39;;     //不为空</code></p>
<p><code>and 且 or 或</code></p>
<p><code>where university in (&#39;北京大学&#39;,&#39;复旦大学&#39;,&#39;山东大学&#39;);</code></p>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><code>where university like &#39;%北京%&#39;;    //里面包含北京</code></p>
<p>_表示任意字符<br><code>where name like &#39;__u_uan%&#39;;</code></p>
<p>转义字符\，查第二个字符是_的：<br><code>where name like &#39;_\__%&#39;</code></p>
<p>也可以用escape指定转义字符：<br><code>where name like &#39;_$__%&#39; escape &#39;$&#39;</code></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>select count(gender),round(avg(gpa),1) from user_profile where gender=&#39;male&#39;;</code></p>
<p>round函数，round(a,b)返回a值保留到小数点b位</p>
<p><code>(count(q.question_id)/count(distinct(q.device_id)))</code><br>平均每个device_id有多少question行，注意去重。关于行的平均。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p><code>from table group by a,b   //两个字段</code></p>
<p>如果对显示字段有条件 <code>group by a having 条件 </code></p>
<p>分组应用场景一般求分组后对多行的个数、平均之类的。</p>
<p>用<code>group by having</code> 出现<code>Unknown column xxx in having clause</code>错误，原因：<code>having</code>之后的筛选字段不是<code>select</code>后面的了，因此找不到。</p>
<p><code>having</code>筛选和<code>where</code>筛选不一样，<code>having</code>只能用select后的字段，where可以用表里的所有字段。<br>（关于where里的字段，如果是两张表查询，并且两张表都有某个字段，select使用了某一个，where里还是得加是哪个表的这个字段，也就是说where里用的和select显示的没关系。除非select里as了，这样where里是直接可以用这个as后的名字了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个例子：分组可以理解为首先根据分组字段分组，然后分别计算</span><br><span class="line">根据用户+天分组计算记录数量</span><br><span class="line">但是分组之后多行有不同的status。该显示哪个？</span><br><span class="line"></span><br><span class="line">select count(*) as num, name, status day from table</span><br><span class="line">group by name, day</span><br><span class="line">having num=3</span><br><span class="line">order by day desc;</span><br></pre></td></tr></table></figure>


<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>在group by having 之后，<code>order by a asc/desc</code></p>
<h2 id="两表连接（连接查询）"><a href="#两表连接（连接查询）" class="headerlink" title="两表连接（连接查询）"></a>两表连接（连接查询）</h2><p>连接的前提：两张表中有一个字段一样，也就是on后面要加的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inner join：理解为“有效连接”，两张表中都有的数据才会显示</span><br><span class="line">left join：理解为“有左显示”，比如on a.field=b.field，则显示a表中存在的全部数据及a、b中都有的数据，a中有、b中没有的数据以null显示</span><br><span class="line">right join：理解为“有右显示”，比如on a.field=b.field，则显示b表中存在的全部数据及a、b中都有的数据，b中有、a中没有的数据以null显示</span><br><span class="line">full join：理解为“全连接”，两张表中所有数据都显示，实际就是inner +(left-inner)+(right-inner)</span><br></pre></td></tr></table></figure>

<p>注意：连接后，还可以用where限制显示的的行<br><code>SELECT    * FROM A a, B b WHERE a.id = b.pid</code>  相当于是<br><code>SELECT    * FROM A a INNER JOIN B b ON a.id = b.pid</code><br>where隐性连接， join显性连接<br>join = inner join</p>
<p>注意：对于两张表中同一字段，select后要表明用谁的。</p>
<p>join谁前谁后无所谓，</p>
<p>连接就是要进行的查询需要根据另一张表分组也好显示也好，连接之后就可以相当于一张表操作，再where，或者group by having 分组之类的。</p>
<p>注意：可以多张表连接，inner join.. on.. 之后，相当于一张表，再inner join.. on.. 就是再连接一张表</p>
<p><a href="https://www.nowcoder.com/practice/5400df085a034f88b2e17941ab338ee8?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0">一个三表连接例子</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select universit, difficult_level, </span><br><span class="line">(count(qp.question_id)/count(distinct(qp.device_id)))</span><br><span class="line">//求用户做题数的平均</span><br><span class="line">as avg_answer_cnt</span><br><span class="line">from user_profile as u inner join </span><br><span class="line">question_practice_detail as qp</span><br><span class="line">on u.device_id=qp.device_id</span><br><span class="line">inner join question_detail as qd</span><br><span class="line">on qp.question_id=qd.question_id</span><br><span class="line">//连接完，三张表相当于一张表，可进行操作</span><br><span class="line">group by university, difficult_level</span><br><span class="line">having 可加条件</span><br><span class="line">order by university asc;</span><br></pre></td></tr></table></figure>

<h2 id="union-和-union-all和or（组合查询）"><a href="#union-和-union-all和or（组合查询）" class="headerlink" title="union 和 union all和or（组合查询）"></a>union 和 union all和or（组合查询）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。</span><br><span class="line">1、对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。</span><br><span class="line">2、对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。</span><br></pre></td></tr></table></figure>

<p>union是连接两个select where语句，去重，union all不去重</p>
<p>or是where里，结果和union一样，也是去重的。</p>
<h2 id="计算20岁以下和25岁以上的用户数量（条件函数）"><a href="#计算20岁以下和25岁以上的用户数量（条件函数）" class="headerlink" title="计算20岁以下和25岁以上的用户数量（条件函数）"></a>计算20岁以下和25岁以上的用户数量（条件函数）</h2><p>自制可分组字段</p>
<p>想成一个分组问题，就像根据gender男女分组，只不过这个需要自己来构建一个字段来进行分组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">case when age&gt;=25 then &#x27;25岁以及上&#x27;</span><br><span class="line">else &#x27;25岁以下&#x27; end      //构建一个用于分组的字段</span><br><span class="line">as age_cut,</span><br><span class="line">count(device_id) as number</span><br><span class="line">from user_profile</span><br><span class="line">group by age_cut;</span><br></pre></td></tr></table></figure>

<p>case when then else end 语句</p>
<p>用来将一个字段按范围变成另一个字段，可用来分组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, gender,</span><br><span class="line">case when age&gt;=20 and age&lt;=24 then &#x27;20-24岁&#x27;</span><br><span class="line">when age&gt;=25 then &#x27;25岁以上&#x27;</span><br><span class="line">when age&lt;20 then &#x27;20岁以下&#x27;</span><br><span class="line">else &#x27;其他&#x27; end</span><br><span class="line">from user_profile;</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>day(2021-09-01)  month(  )   year(  )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date是2021-08-01 格式</span><br><span class="line">Select day(date) as day, count(question_id) as question_cnt</span><br><span class="line">From question_practice_detail</span><br><span class="line">where year(date)=2021 and month(date)=08</span><br><span class="line">相当于：where substr(date,1,7)=&#x27;2021-08&#x27;</span><br><span class="line">相当于：where date like&#x27;2021-08%&#x27;</span><br><span class="line">Group by day</span><br></pre></td></tr></table></figure>

<h2 id="用户的平均次日留存率"><a href="#用户的平均次日留存率" class="headerlink" title="用户的平均次日留存率"></a>用户的平均次日留存率</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    count(id) / </span><br><span class="line">    (select count(distinct device_id, date) from question_practice_detail)</span><br><span class="line">    as avg_ret</span><br><span class="line">from</span><br><span class="line">    (select</span><br><span class="line">        a.device_id as id</span><br><span class="line">        ,a.date as date1 </span><br><span class="line">        ,lead(a.date,1) over(partition by device_id order by a.date) as date2</span><br><span class="line">    from </span><br><span class="line">        (select distinct device_id, date from question_practice_detail) a</span><br><span class="line">    ) b </span><br><span class="line">    #嵌套查询，一定要取别名</span><br><span class="line">where DATEDIFF(date2,date1) =1</span><br></pre></td></tr></table></figure>

<h2 id="varchar-能存多少"><a href="#varchar-能存多少" class="headerlink" title="varchar 能存多少"></a>varchar 能存多少</h2><p>要确定mysql版本，一般一个汉字2个字节，50即可存25个汉字。<br>4.0版本以下，varchar(50)，指的是50字节，如果存放UTF8汉字时，只能存16个（每个汉字3字节）<br>5.0版本以上，varchar(50)，指的是50字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放50个.</p>
<p>mysql版本查询命令有：1、输入“select version();”命令，按回车键，即可查看当前mysql版本；2、输入“status”命令，按回车键，即可查看当前mysql版本。</p>
<h2 id="Mysql中key-、primary-key-、unique-key-与index区别"><a href="#Mysql中key-、primary-key-、unique-key-与index区别" class="headerlink" title="Mysql中key 、primary key 、unique key 与index区别"></a>Mysql中key 、primary key 、unique key 与index区别</h2><p>一、key：索引被用来快速找出在一个列上用一特定值的行。增加数据库的查询速度，InnoDB采用B+树和哈希两种数据结构的方式为表添加索引。</p>
<p>没有索引，MySQL不得不首先以第一条记录开始然后读完整个表直到它找出相关的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KEY `idx_type` (`type`)  </span><br></pre></td></tr></table></figure>

<p>key 是数据库的物理结构，它包含两层意义和作用<br>约束（偏重于约束和规范数据库的结构完整性），<br>索引（index）（辅助查询用的）。</p>
<p>二、primary key 有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个主键索引；    </p>
<p>PRIMARY KEY 约束：<br>唯一标识数据库表中的每条记录；<br>主键必须包含唯一的值；<br>主键列不能包含 NULL 值；<br>每个表都应该有一个主键，并且每个表只能有一个主键。（PRIMARY KEY 拥有自动定义的 UNIQUE 约束）</p>
<p>三、unique key 也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个唯一索引；</p>
<p>UNIQUE 约束：唯一标识数据库表中的每条记录。<br>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。<br>（每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束）</p>
<p>四、foreign key 也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index；</p>
<p>可见，mysql的key是同时具有constraint和index的意义，这点和其他数据库表现的可能有区别。</p>
<p>（至少在Oracle上建立外键，不会自动建立index），因此创建key也有如下几种方式：<br>（1）在字段级以key方式建立， 如 create table t (id int not null primary key);<br>（2）在表级以constraint方式建立，如create table t(id int, CONSTRAINT pk_t_id PRIMARY key (id));<br>（3）在表级以key方式建立，如create table t(id int, primary key (id));</p>
<p>其它key创建类似，但不管那种方式，既建立了constraint，又建立了index，只不过index使用的就是这个constraint或key。</p>
<hr>
<p>五、 index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；</p>
<p>因此，索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）。如，create table t(id int,index inx_tx_id (id));</p>
<p>摘自：<a href="https://www.cnblogs.com/chenxiaomeng/p/15582771.html">https://www.cnblogs.com/chenxiaomeng/p/15582771.html</a></p>
<p>一文搞懂mysql索引：<a href="https://zhuanlan.zhihu.com/p/500248981">https://zhuanlan.zhihu.com/p/500248981</a></p>
<p>添加索引sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.PRIMARY  KEY(主键索引)</span><br><span class="line">mysql&gt;ALTER  TABLE  `table_name`  ADD  PRIMARY  KEY (  `column`  )</span><br><span class="line"></span><br><span class="line">2.UNIQUE(唯一索引)</span><br><span class="line">mysql&gt;ALTER  TABLE  `table_name`  ADD  UNIQUE (`column` )</span><br><span class="line"></span><br><span class="line">3.INDEX(普通索引)</span><br><span class="line">mysql&gt;ALTER  TABLE  `table_name`  ADD  INDEX index_name (  `column`  )</span><br><span class="line"></span><br><span class="line">4.FULLTEXT(全文索引)</span><br><span class="line">mysql&gt;ALTER  TABLE  `table_name`  ADD  FULLTEXT ( `column` )</span><br><span class="line"></span><br><span class="line">5.多列索引</span><br><span class="line">mysql&gt;ALTER  TABLE  `table_name`  ADD  INDEX index_name (  `column1`,  `column2`,  `column3`  )</span><br></pre></td></tr></table></figure>

<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>什么时候需要加单列索引？<br>查询比较频繁，并且不是那种枚举型的字段查询的时候，比如说id，gmt_create这些字段查询比较频繁，加索引，相当于是做了个排序，更好查找。</p>
<p>什么时候需要多列索引（联合索引）？<br>比如根据开始时间+结束时间查询比较多，就加这两个的联合索引。</p>
<p>sql语句添加索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table myTable</span><br><span class="line">add key `idx_gmt_create_gmt_modify` (`gmt_create`,`gmt_modify`);</span><br></pre></td></tr></table></figure>

<p>sql语句删除索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table myTable</span><br><span class="line">drop key `idx_gmt_create_gmt_modify`;</span><br></pre></td></tr></table></figure>

<p>修改索引就先删除再添加。</p>
<p>多列索引的列顺序至关重要，一般是将选择性最高的列放到索引最前列，比如根据a查询比较多，还有根据a、b查询比较多，还有根据a、b、c查询比较多。那么索引的顺序就是a b c。</p>
<p>索引可以理解成排好序的数据结构。组合索引可以这样理解，比如（a,b,c），abc都是排好序的，在任意一段a的下面b都是排好序的，任何一段b下面c都是排好序的。</p>
<p>最左前缀原则：从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where a=3 and b=45 and c=5 .... 这种三个索引顺序使用中间没有断点，全部发挥作用；</span><br><span class="line">where a=3 and c=5... 这种情况下b就是断点，a发挥了效果，c没有效果</span><br><span class="line">where b=3 and c=4... 这种情况下a就是断点，在a后面的索引都没有发挥作用，这种写法联合索引没有发挥任何效果；</span><br><span class="line">where b=45 and a=3 and c=5 .... 这个跟第一个一样，全部发挥作用，abc只要用上了就行，跟写的顺序无关（a,b,c）多列索引使用的示例，说明：（a,b,c）组合索引和(a,c,b）是不一样的</span><br><span class="line"></span><br><span class="line">原文链接：https://blog.csdn.net/cstp321/article/details/124631534</span><br></pre></td></tr></table></figure>

<p>🤔总结：联合索引，建立索引里面字段的顺序重要，(a,b,c)和(a,c,b)是不一样的，sql里where谁先where谁后无关紧要，只要用上就行。<br>像枚举的字段就没必要加了。</p>
<p>参考：<a href="https://blog.csdn.net/cstp321/article/details/124631534">https://blog.csdn.net/cstp321/article/details/124631534</a></p>
<h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h2><p>在mysql中，可通过关键字auto_increment为列设置自增属性，只有整型列才能设置此属性，每个表只能定义一个auto_increment列，并且必须在该列上定义主键约束（primary key）或候选键（unique）。</p>
<p>ENGINE=MyISAM 是选择存储引擎<br>DEFAULT CHARSET=gbk 默认字符集<br>AUTO_INCREMENT=2 是设定该字段为启始自增字段，从2开始。<br>并且执行show create table name 看建表语句时，这个值是下一个主键id。</p>
<h2 id="NOT-NULL-DEFAULT-‘’-COMENT"><a href="#NOT-NULL-DEFAULT-‘’-COMENT" class="headerlink" title="NOT NULL DEFAULT ‘’ COMENT"></a>NOT NULL DEFAULT ‘’ COMENT</h2><p>insert时，对象中的某属性如果为null，表设置的not null，那时会报错的，因此需要考虑如果允许传入null，就别not null，default ‘’ 或者default null 得了。</p>
<p>也就是：<br>建表时，not null 和 default null（或者default别的）是分开的。<br>如果not null，就不能传null，但是可以不传。<br>not null不传，有默认值，会设置为默认值。<br>not null不传，但是没有default，会报错：<br>insert into student1 (name) values (“liu”);<br>ERROR 1364 (HY000): Field ‘m_id’ doesn’t have a default value。<br>如果没有default，就不能不传。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `student1`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `name` varchar(3) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">   `m_id` int NOT NULL,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COMMENT=&quot;student&quot;;</span><br></pre></td></tr></table></figure>

<p>所以说：<br>如果 NOT NULL，就不能传null。<br>如果没有default，就不能不传。<br>not null的话，其实default就没什么用了，除非不传。</p>
<h2 id="分库分表实践"><a href="#分库分表实践" class="headerlink" title="分库分表实践"></a>分库分表实践</h2><p>数据库性能瓶颈：<br>① 数据库连接 数据库连接是非常稀少的资源,MySQL数据库默认100个连接，单机最大1500连接。如果一个库里既有用户相关的数据又有商品、订单相关的数据，当海量用户同时操作时,数据库连接就很可能成为瓶颈。</p>
<p>② 数据量 MySQL单库数据量在5000万以内性能比较好，超过阈值后性能会随着数据量的增大而变弱。MySQL单表的数据量是500w-1000w之间性能比较好，超过1000w性能也会下降。</p>
<p>③ 硬件问题 因为单个服务的磁盘空间是有限制的，如果并发压力下所有的请求都访问同一个节点，肯定会对磁盘IO造成非常大的影响。</p>
<p>分库分表方案是对关系型数据库数据存储和访问机制的一种补充。<br>分库：将一个库的数据拆分到多个相同的库中，访问的时候访问一个库<br>分表：把一个表的数据放到多个表中，操作对应的某个表就行</p>
<p>拆分方式：<br>① 垂直拆分，专库专用按业务拆分。按照业务模块进行切分，将不同模块的表切分到不同的数据库中。按照字段将大表拆分成小表。<br>优点：<br>1.拆分后业务清晰（专库专用按业务拆分）<br>2.数据维护简单，按业务不同，业务放到不同机器上<br>缺点:<br>1.如果单表的数据量，写读压力大<br>2.受某种业务决定，或者被限制，也就是说一个业务往往会影响到数据库的瓶颈（性能问题，如双十一抢购）<br>3.部分业务无法关联join，只能通过java程序接口去调用，提高了开发复杂度</p>
<p>② 水平拆分，将一张大表按照一定的切分规则，按照行切分成不同的表或者切分到不同的库中<br>优点：<br>1.单库/单表的数据保持在一定量（减少），有助于性能提高<br>2.提高了系统的稳定性和负载能力<br>3.拆分表的结构相同，程序改造较少。<br>缺点:<br>1.数据的扩容很有难度维护量大<br>2.拆分规则很难抽象出来<br>3.分片事务的一致性问题部分业务无法关联join，只能通过java程序接口去调用</p>
<p>阿里TDDL<br>水平分库分表后，总的逻辑库代表总表，几个物理库，需要配置路由算法（根据字段路由，一般是对某几位取模）</p>
<p>链接：<a href="https://baijiahao.baidu.com/s?id=1708707864255381575&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1708707864255381575&amp;wfr=spider&amp;for=pc</a></p>
<h2 id="left-join的on和where"><a href="#left-join的on和where" class="headerlink" title="left join的on和where"></a>left join的on和where</h2><p>多表连接查询<br>内连接（inner join） 取交集<br>左外连接（left join）<br>右外连接（right join）<br>交叉连接（cross join）- 笛卡尔积<br>全连接（full join）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内连接(取两表交集)</span><br><span class="line">SELECT * FROM tab1 a inner join tab2 b on a.age = b.age</span><br><span class="line">等同于</span><br><span class="line">SELECT * FROM tab1 a ,tab2 b where  a.age = b.age</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如说左连接：</span><br><span class="line">SELECT * FROM tab1 a left join tab2 b on a.age = b.age and b.name = &#x27;张三&#x27;;</span><br><span class="line">首先必须要用一个两张表的字段进行连接。</span><br><span class="line"></span><br><span class="line">1.搞清楚连接后显示结果</span><br><span class="line">on后面是连接条件，你可以想象成两张表左右并起来，</span><br><span class="line">然后用各一个字段将结果比对起来，</span><br><span class="line">那自然会存在左边字段有这个值，但是右边没有的情况</span><br><span class="line">这种情况，inner join只会显示两边都有的，left join显示左边全部，</span><br><span class="line">那么右边没有值的怎么办，设null，以此类推right join</span><br><span class="line">一对多的情况，不管哪边多，都会复制，显示多行</span><br><span class="line">（左连接显示a表全部，... 也体现在这儿）</span><br><span class="line"></span><br><span class="line">2.on里面还有右表的字段=某个值是搞什么？</span><br><span class="line">on后面加的你就当做是限制条件，但是left join的话，</span><br><span class="line">左表是不看这个条件的，也就是说left join on里的条件只对右表起作，</span><br><span class="line">比如说右表根据这个on条件只剩下一行，右表不满足on条件的置为null，</span><br><span class="line">同时如果是一对多的情况，会同时对右表不满足条件的行取消复制，</span><br><span class="line">出于左表全显示的原则，会对右表字段不满足条件的行只留下一行，并且置null</span><br><span class="line">像链接中的例子，不是一对多，自然就是右边不满足的置null，</span><br><span class="line">但是条件放在where里就会一行都不显示</span><br><span class="line">（左连接显示a表全部，... 也体现在这儿）</span><br><span class="line"></span><br><span class="line">3.on后面只有一个右表某字段=某值？</span><br><span class="line">首先连接表没有on条件是不行的，如果只有某表字段=某值，</span><br><span class="line">从结果来看是把这个字段当做了连接字段，</span><br><span class="line">那么是右表的字段还是左表的字段=某值，都一样，</span><br><span class="line">都相当于是2，限制了显示行数。</span><br><span class="line"></span><br><span class="line">4.如果是一对多的情况？</span><br><span class="line">比如a表的某字段=某值只有一条，b表该字段=某值有多条。</span><br><span class="line">a left join b，on右表条件，左表的行会重复用，也就是多条中左表的字段是一样的。</span><br><span class="line">不管哪边一对多，多会首先复制行。</span><br><span class="line">（如果左表本身有行是多条一摸一样，那么取消复制后会保留吧，未测试）</span><br><span class="line">*一对多复制行情况，用group_concat把多行字段合并就可以显示一行。</span><br><span class="line">但是必须要加group by，不然默认对所有group by，怎么也是只显示一行。</span><br><span class="line"></span><br><span class="line">5.on和where</span><br><span class="line">on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</span><br><span class="line">（加条件，不满足行取消复制且对都不满足的留一行置为null）</span><br><span class="line">where条件是在临时表生成好后，再对临时表进行过滤的条件。</span><br><span class="line">（加条件筛选行）</span><br><span class="line">on条件是在存储引擎读取数据集（IO读）时用到，where条件是在存储引擎拿到数据集后对数据进行筛选时用到。</span><br><span class="line">所以left join，右表条件可以放on里，左表条件可以放where里。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.原则</span><br><span class="line">(1)先根据连接字段把两张表并起来，根据连接类型，看是否填null，是否复制（一对多情况）</span><br><span class="line">(2)再根据on里加的条件，对哪边进行筛选行，left join只能筛选右边，填null，和取消复制</span><br><span class="line">(3)生成了临时表，再根据where条件筛选总行</span><br><span class="line"></span><br><span class="line">7.a inner join b 和 from a, b where</span><br><span class="line">where是创建两张表的笛卡尔积（所有可能的组合）之后条件筛选。</span><br><span class="line">inner join 是获取两个表中字段匹配关系的记录。</span><br><span class="line">有些数据库系统会识别出 WHERE连接并自动转换为 INNER JOIN。</span><br><span class="line">在这些数据库系统中，WHERE 连接与INNER JOIN 就没有性能差异。</span><br><span class="line"></span><br><span class="line">8.多张表left join</span><br><span class="line">考虑到数据量的包含关系，都展示的放在最左边，然后后面的两张表的包含关系，就不紧要了。</span><br><span class="line">比如a left join b on .. left join c on ..</span><br><span class="line">a里有，b不一定有；a里有c不一定有；b里有c不一定有也不用管。a包含b和c就好了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/qq_52596258/article/details/119221530">https://blog.csdn.net/qq_52596258/article/details/119221530</a></p>
<p>连接之后，一对多的关系测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `student`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `name` varchar(3) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">   `m_id` int NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&quot;a&quot;;</span><br><span class="line"></span><br><span class="line">insert into student values(1, &quot;liu&quot;, 11);</span><br><span class="line">insert into student values(2, &quot;oo&quot;, 22);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `grade`(</span><br><span class="line">   `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">   `course` varchar(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">   `grade` int NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">   `m_id` int NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;tableB&#x27;;</span><br><span class="line"></span><br><span class="line">insert into grade values(1, &quot;math&quot;, 100, 11);</span><br><span class="line">insert into grade values(2, &quot;english&quot;, 200, 11);</span><br><span class="line">insert into grade values(3, &quot;math&quot;, 50, 22);</span><br><span class="line"></span><br><span class="line">select distinct stu.name, stu.m_id, grade.course, grade.grade</span><br><span class="line">from student as stu left join grade</span><br><span class="line">on stu.m_id = grade.m_id;</span><br><span class="line">（整体来distinct）</span><br><span class="line"></span><br><span class="line">select * from student left join grade on student.m_id=grade.m_id;</span><br><span class="line">(一对多，左边复制，显示多行)</span><br><span class="line"></span><br><span class="line">select * from student left join grade on student.m_id=grade.m_id and course=&quot;english&quot;;</span><br><span class="line">(左边全显示，复制的不满足条件的删除行，只留一行（不管是null还是满足的）一对一的置null)</span><br><span class="line"></span><br><span class="line">select * from student left join grade on student.m_id=grade.m_id and course=&quot;mat&quot;;</span><br><span class="line">（留下两行，右表均为null）</span><br></pre></td></tr></table></figure>
<p>结果确实是重复的：<br>+——+——+———+——-+<br>| name | m_id | course  | grade |<br>+——+——+———+——-+<br>| liu  |   11 | english |   200 |<br>| liu  |   11 | math    |   100 |<br>| oo   |   22 | math    |    50 |<br>+——+——+———+——-+</p>
<p>测试加dintinct进行过滤的可能：<br>多个字段，直接在name上加distinct，显示的还是name重复的。<br>但是查询字段中去掉course、grade后，就不会有重复的。</p>
<p>看样子在使用distinct时，对多个查询字段中的某一个打括号，去重时没有用的。 只能要不查一个distinct，差多个distinct多个。对select多个字段中的一个打distinct，也是按照多个字段去重，所以distinct打()没意义。</p>
<p>distinct的原理是group by。</p>
<h2 id="mysql分区"><a href="#mysql分区" class="headerlink" title="mysql分区"></a>mysql分区</h2><p>一.InnoDB逻辑存储结构</p>
<p>InnoDB所有数据都被逻辑地存放在表空间，表空间又由段，区，页组成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）段：segment，常见的段有数据段、索引段、回滚段等，在InnoDB存储引擎中，对段的管理都是由引擎自身所完成的。</span><br><span class="line"></span><br><span class="line">（2）区：extent 区是由连续的页组成的空间，无论页的大小怎么变，区的大小默认总是为1MB。</span><br><span class="line">为了保证区中的页的连续性，InnoDB存储引擎一次从磁盘申请4-5个区，InnoDB页的大小默认为16kB，即一个区一共有64（1MB/16kB=64）个连续的页。</span><br><span class="line">每个段开始，先用32页（page）大小的碎片页来存放数据，在使用完这些页之后才是64个连续页的申请。这样做的目的是，对于一些小表或者是undo类的段，可以开始申请较小的空间，节约磁盘开销。</span><br><span class="line"></span><br><span class="line">（3）页是：page，InnoDB磁盘管理的最小单位。默认大小为16KB，可以通过参数innodb_page_size来设置。</span><br><span class="line">常见的页类型有：数据页，undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页，未压缩的二进制大对象页，压缩的二进制大对象页等。</span><br></pre></td></tr></table></figure>

<p>二、分区</p>
<p>分区,不同于上面的区，意思是指将同一表中不同行的记录分配到不同的物理文件中，几个分区就有几个.idb文件，不是我们刚刚说的区。MySQL在5.1时添加了对水平分区的支持。</p>
<p>MySQL数据库的分区是局部分区索引，一个分区中既存了数据，又放了索引。也就是说，每个区的聚集索引和非聚集索引都放在各自区的（不同的物理文件）。目前MySQL数据库还不支持全局分区。</p>
<p>无论哪种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。</p>
<p>三、分区类型</p>
<p>目前MySQL支持一下几种类型的分区，RANGE分区，LIST分区，HASH分区，KEY分区。</p>
<p>range分区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANGE分区主要用于日期列的分区，比如交易表啊，销售表啊等。可以根据年月来存放数据。年月日用一个int表示。</span><br><span class="line"></span><br><span class="line">CREATE TABLE `m_test_db`.`Order` (</span><br><span class="line">    `id` INT NOT NULL AUTO_INCREMENT,    </span><br><span class="line">    `partition_key` INT NOT NULL,    </span><br><span class="line">    `amt` DECIMAL(5) NULL,    </span><br><span class="line">    PRIMARY KEY (`id`, `partition_key`))    </span><br><span class="line">    PARTITION BY RANGE(partition_key)   PARTITIONS 5(      </span><br><span class="line">        PARTITION part0 VALUES LESS THAN (201901),       </span><br><span class="line">        PARTITION part1 VALUES LESS THAN (201902),       </span><br><span class="line">        PARTITION part2 VALUES LESS THAN (201903),       </span><br><span class="line">        PARTITION part3 VALUES LESS THAN (201904),      </span><br><span class="line">        PARTITION part4 VALUES LESS THAN (201905)</span><br><span class="line">        ) ;</span><br></pre></td></tr></table></figure>

<p>list分区：<br>LIST分区和RANGE分区很相似，只是分区列的值是离散的，不是连续的。LIST分区使用VALUES IN，因为每个分区的值是离散的，因此只能定义值。</p>
<p>hash分区：<br>说到哈希，那么目的很明显了，将数据均匀的分布到预先定义的各个分区中，保证每个分区的数量大致相同。</p>
<p>key分区：<br>KEY分区和HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用数据库提供的函数进行分区。</p>
<p>转自：<a href="https://www.yisu.com/zixun/494057.html">https://www.yisu.com/zixun/494057.html</a></p>
<p><code>select max_pt(&#39;tableName&#39;)</code> 对于分区的表，此函数返回该分区表的一级分区的最大值，按字母排序，且该分区下有对应的数据文件。</p>
<p>返回值：最大的一级分区的值。<br>难道是odps专用？<br><a href="https://www.jianshu.com/p/3f1486f42792">https://www.jianshu.com/p/3f1486f42792</a></p>
<h2 id="mysql-decimal数据类型"><a href="#mysql-decimal数据类型" class="headerlink" title="mysql decimal数据类型"></a>mysql decimal数据类型</h2><p>MySQLDECIMAL数据类型用于在数据库中存储精确的数值。例如会计系统中的货币数据。</p>
<p><code>column_name DECIMAL(P,D);</code><br>P是表示有效数字数的精度。P范围为1〜65。<br>D是表示小数点后的位数。D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。</p>
<p>DECIMAL(6,2) 表示最多可以存储6位数字，小数位数为2位。</p>
<p>更多：<a href="https://www.jb51.net/article/205498.htm">https://www.jb51.net/article/205498.htm</a></p>
<h2 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h2><p>1、where里用的字段和在select里有没有显示无关；多表查询，多表中有同一字段，尽管select用了其中一个，但是也得在where中注明用的是哪个。</p>
<p>2、group by 相当于根据一个或多个字段来分组来分别计算，不能直接显示非分组字段，可以对非分组字段进行函数运算后输出。</p>
<pre><code>eg:
select course, grade from grade group by course;  报错
select course, max(grade) from grade group by course;  正确
</code></pre>
<p>group by是对where之后的表进行group by。</p>
<p>3、mysql查询里的数字字符串可以不加””，但是非数字字符串就得加””。</p>
<p>4、mysql条件判断实现类似 num=a==b?a:b</p>
<pre><code>select if((select m_id from grade where m_id=1) is null, 1, 2);
</code></pre>
<p>5、一个十六进制数，转换为二进制后的各位都代表一项，求这个数代表的项list：用concat_ws + if + cast + conv + &amp;与运算完美解决。<br><code>concat_ws(&#39;&#39;, if(cast(conv(cast(power(10, 2) as bigint), 2, 10) as bigint) &amp; cast(conv(16进制数, 16, 10) as bigint)&gt;0, &quot;某项 &quot;, &quot;&quot;), if...）</code></p>
<h2 id="mysql-group-by"><a href="#mysql-group-by" class="headerlink" title="mysql group by"></a>mysql group by</h2><p>场景：想要对某个字段去重，但是又要展示其他字段，用group by。</p>
<p>1、显示第一条数据：解决方法:any_value(id)</p>
<p>any_value()会选择被分到同一组的数据里第一条数据的指定列作为返回数据。</p>
<p><code>select course, any_value(grade) from grade group by course;</code></p>
<p>2、聚合显示所有的，分隔符隔开，并且去重：group_concat()</p>
<p>group_concat() 会将分组中多个列的字符串聚合起来，并用特定的符号进行分隔。一定要与group by搭配使用<br>group_concat()会忽略null。</p>
<p><code>select course, group_concat(distinct grade order by grade asc separator &#39;,&#39;) from grade group by course;</code><br>事实证明：int字段也可以进行连接显示。<br>order by后面可以是本字段，也可以是其他字段。</p>
<p>✅ 使用left join + group_concat的case</p>
<p>group_concat如果不搭配group by使用，那么势必是只显示一行。</p>
<p>left join用group by的话：left join on先建表，然后where筛选，然后group_concat group by 对表做变动，然后having筛选。</p>
<p>如果只是用group_concat，应该是这个字段合起来，其他字段随意了。所以如果where加的好，确实是只想看一行，就用。</p>
<p>如果group_concat里的也在where里的话，并且where里的条件是想看在不在group_concat的数组里，如果先where再group_concat聚合，达不到查找的效果。这样的筛选放在having里用trim标签 + having + foreach or + find_in_set函数解决就可以。</p>
<h2 id="mysql函数"><a href="#mysql函数" class="headerlink" title="mysql函数"></a>mysql函数</h2><p>1、进制转换 conv(num, from_base, to_base)</p>
<p><code>select conv(16, 10, 16);</code></p>
<p>另外，几个特定进制转换函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex(num)  10转16进制</span><br><span class="line">oct(num)  10转8进制</span><br><span class="line">bin(num)  10转2进制</span><br></pre></td></tr></table></figure>

<p>2、多列合并显示 concat() &amp; concat_ws()</p>
<p>concat(str1, str2, str3) 将多个字段合并起来，没有分隔符。concat()函数中要连接的数据中含有null，最后返回的是null。<br><code> select course, concat(grade,m_id) from grade;</code></p>
<p>concat_ws(‘,’, str1, str2, str3) 将多个字段按照分隔符连接，如果分隔符为null，则结果为null。函数会忽略null值，但是不会忽略空字符串。<br><code> select course, concat_ws(&#39;:&#39;,grade,m_id) from grade;</code></p>
<hr>
<p>还可以用来和普通字符串做连接。</p>
<p>concat(“名字是”, name)  没有分隔符<br>concat_ws(“,”, “名字是”, name)  有分隔符，第一个参数必须是分隔符</p>
<p>3、幂运算power/pow<br><code>select power(10, 2)</code></p>
<p>4、ifnull(expr1,expr2)<br>假如expr1不为NULL，则 IFNULL() 的返回值为expr1; 否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。<br>例如：算总数，可能因为左连接使得字段为null，这时候为null想展示0。使用：ifnull(num, 0)</p>
<p>5、ISNULL(expr)<br>如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select isnull(1+1) ; -- 0</span><br><span class="line">select isnull(1/0);  -- 1</span><br></pre></td></tr></table></figure>

<p>6、NULLIF(expr1,expr2)<br>如果expr1 = expr2 成立，那么返回值为NULL，否则返回值为expr1。这和CASE  WHEN expr1 = expr2 THEN NULL ELSE   expr1 END相同。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT NULLIF(1,1);    -- Null</span><br><span class="line">SELECT   NULLIF(1,2);  -- 1</span><br></pre></td></tr></table></figure>

<p>6、substr函数<br>从一个内容中，按照指定条件，「截取」一个字符串。这个内容可以是数值或字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(obj，start，length)</span><br><span class="line"></span><br><span class="line">obj：从哪个内容中截取，可以是数值或字符串。</span><br><span class="line">start：从哪个字符开始截取（1开始，而不是0开始）</span><br><span class="line">length：截取几个字符。</span><br><span class="line"></span><br><span class="line">select substr(&quot;12345&quot;, 2, 3);  //得到234</span><br></pre></td></tr></table></figure>

<p>7、多行合并显示</p>
<p>场景：select某个字段，然后想把找出来的这个字段拼成数组 a,b,c 形式。</p>
<p><code>select group_concat(name) from student;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| group_concat(name) |</span><br><span class="line">+--------------------+</span><br><span class="line">| liu,oo,li          |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>事实证明：group_concat函数并不是必须搭配group by。<br>*⚠️但是不搭配，就默认时根据所有列group by，只会显示一行，如果想要的是就统计显示一行，就用。不然必须加group by。</p>
<p>多种用法：<br>换分隔符：<br><code>select group_concat(name separator &#39;;&#39;) from student;</code><br>去重：<br><code>select group_concat(distinct name separator &#39;;&#39;) from student;</code><br>排序（根据本字段/其他字段都可以）：<br><code>select group_concat(distinct name order by id  desc separator &#39;;&#39;) from student;</code></p>
<p>8、分隔字符串substring_index</p>
<p>作用：<br>substring_index(str,delim,count)<br>str:要处理的字符串<br>delim:分隔符<br>count:计数<br>返回一个 str 的子字符串，在 delimiter 出现 count 次的位置截取。<br>如果 count &gt; 0，从则左边数起，且返回位置前的子串；<br>如果 count &lt; 0，从则右边数起，且返回位置后的子串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUBSTRING_INDEX(&#x27;www.mysql.com&#x27;, &#x27;.&#x27;, 2);</span><br><span class="line">        -&gt; &#x27;www.mysql&#x27;</span><br><span class="line">mysql&gt; SELECT SUBSTRING_INDEX(&#x27;www.mysql.com&#x27;, &#x27;.&#x27;, -2);</span><br><span class="line">        -&gt; &#x27;mysql.com&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="is-null-和-null"><a href="#is-null-和-null" class="headerlink" title="is null 和 = null"></a>is null 和 = null</h2><p>首先，where之后id=1 不需要用==。</p>
<p>其次，筛选是否为null的行，不能用=和!=，因为null 表示什么也不是， 不能=、&gt;、&lt; … 所有的判断，结果都是false。无论=null，还是！=null，筛选出来的都是0行empty。</p>
<p>！！！所以：筛选null，得用is null和is not null。</p>
<h2 id="运算符-和-＜＞-以及-和-＜-＞-的区别"><a href="#运算符-和-＜＞-以及-和-＜-＞-的区别" class="headerlink" title="运算符 != 和 ＜＞ 以及 = 和 ＜=＞ 的区别"></a>运算符 != 和 ＜＞ 以及 = 和 ＜=＞ 的区别</h2><p>1、!=和&lt;&gt;<br>在MySQL中!= 和 &lt;&gt; 的功能一致，在sql92规范中建议是：!=，新的规范中建议为: &lt;&gt;。</p>
<p>2、= 和 &lt;=&gt;<br>is 专门用来判断是否为 NULL，而 = 则是用来判断非NULL以外的所有数据类型使用。而 &lt;=&gt; 则是前两者合起来。</p>
<p>也就是说：&lt;=&gt;运算符相当于封装了= 和 is ，既可以判断 非NULL值，也可以用来判断NULL值。</p>
<p>当col1，col2两个可能存在NULL值的列需要进行相等比较时，可以使用 col1 &lt;=&gt; col2，可以把null=null的也关联起来。</p>
<h2 id="三种条件判断"><a href="#三种条件判断" class="headerlink" title="三种条件判断"></a>三种条件判断</h2><p>1、语法：if(表达式，值1，值2)<br>当表达式的值为真时，返回值1，否则返回值2</p>
<p><code>select if(grade&gt;60, &quot;及格&quot;, &quot;不及格&quot;) from grade;</code></p>
<p>2、语法：ifNull(值1，值2)<br>当值1不为null时，返回值1，否则返回值2</p>
<p>3、语法：case 表达式 when 条件1 then 值1 when 条件2 then 值2 …  else 值n end。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select course, </span><br><span class="line">case grade </span><br><span class="line">when 100 then &quot;一百&quot; </span><br><span class="line">when 200 then &quot;二百&quot;</span><br><span class="line">else &quot;不知道&quot; end as &quot;分数&quot;</span><br><span class="line">from grade;</span><br></pre></td></tr></table></figure>

<h2 id="三种找出某字段包含某字符串的记录的方法"><a href="#三种找出某字段包含某字符串的记录的方法" class="headerlink" title="三种找出某字段包含某字符串的记录的方法"></a>三种找出某字段包含某字符串的记录的方法</h2><p>1、instr函数<br>instr(字段， 字符串) 返回字符串str的位置，没找到则返回0.<br><code>select * from student where instr(name, &quot;liu&quot;)&gt;0;</code><br>//查找名字中包含liu的<br><code>select * from student where locate( &quot;li&quot;, name)&gt;0</code><br>//一样的效果<br>//后面不加&gt;0也可以</p>
<p>select substr(“aabbcc”, “a”);  //无返回 ？？</p>
<p>2、用like<br><code>select * from student where name like &quot;%liu%&quot;;</code>  //liu前面没有也算</p>
<p>3、find_in_set<br>find_in_set(str,strlist)<br>str 要查询的字符串<br>strlist 字段名 参数以”,”分隔 如 “1,2,6,8,10,22”<br>返回strlist中str所在的位置索引（索引值从1开始），strlist必须以”,”分割开。like是广泛的模糊匹配，字符串中没有分隔符，Find_IN_SET 是精确匹配，字段值以英文”,”分隔。<br><code>select find_in_set(&quot;a&quot;, &quot;b,a,aa&quot;);</code> //返回2<br>//不适合用于查询某字段包含某字符串，适合用于字段中是,隔开的字符串list，查询该字符串list中有没有包含这个字符串的（也可以不加&gt;0），还会返回字符串在list中的位置。</p>
<h2 id="REPLACE-和-DUPLICATE"><a href="#REPLACE-和-DUPLICATE" class="headerlink" title="REPLACE 和 DUPLICATE"></a>REPLACE 和 DUPLICATE</h2><p>一般入库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into user_info （user_id,user_name,status,years）values (123,&#x27;你好’,1,15）</span><br><span class="line">或者</span><br><span class="line">insert into user_info set user_id=123,user_name=“你好”,status=1,years=15；</span><br><span class="line"></span><br><span class="line">insert into user_info （user_id,user_name,status,years）values （123,‘你好’,1,15）,(456,“你好”,2,16)；</span><br></pre></td></tr></table></figure>

<p>在某些业务场景中，入库操作一般入库前会去检索下，看数据是否已在表中进行Updata/Insert ，避免数据冲突。</p>
<p>✅duplicate用法：<br>首先，要想实现某个键或者多个键重复时，更新，需要对这些键加主键索引（一个）或者唯一索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table student1</span><br><span class="line">add unique key `name_m_id` (`name`,`m_id`);</span><br></pre></td></tr></table></figure>

<p>其次，执行插入/更新语句。<br>先添加个字段：<br><code>alter table student1 add </code>age<code> tinyint(4) NOT NULL DEFAULT 23;</code><br>执行时，已有列变成了默认值23.<br>如果增加列时不加default，也对已有列设置了默认值0.<br>但是再插入，如果没传没有默认值的列就不行。</p>
<p>场景：name和m_id加了唯一索引，想要插入一列，如果这俩字段在表里有，就更新age，如果没有，就插入一条。</p>
<p><code>insert into student1 (name, m_id, age, age1) values(&quot;wan&quot;,22, 24, 24)  on duplicate key update age = values(age);</code></p>
<p>inset into 后面的就按如果要插入一条要怎么写来写，要传入哪些字段。然后什么时候重复是在这个语句里看不到的，得看唯一索引有哪些字段。然后on duplicate key update 后面的，就是如果重复了要更新哪些字段。</p>
<p>发现：虽然duplicate不会改变主键，但是会消耗主键，下一个插入的主键id会隔开。</p>
<p>✅replace用法：<br><code>replace into student1 (name, m_id, age, age1) values (&quot;wan&quot;, 22, 25, 25);</code></p>
<p>就是把insert换成replace，如果出现唯一索引或者主键重复时，则delete老记录，再insert。</p>
<p>✅区别：<br>ON DUPLICATE KEY UPDATE：如果插入行出现唯一索引或者主键重复时，则执行旧的update；如果不会导致唯一索引或者主键重复时，就直接添加新行。</p>
<p>REPLACE：如果插入行出现唯一索引或者主键重复时，则delete老记录，而录入新的记录；如果不会导致唯一索引或者主键重复时，就直接添加新行。</p>
<p>1、在没有主键或者唯一索引重复时，replace与insert on deplicate udpate相同。<br>2、在主键或者唯一索引重复时，replace是delete老记录，而录入新的记录，所以原有的所有记录会被清除，这个时候，如果replace语句的字段不全的话，有些原有的比如c字段的值会被自动填充为默认值。</p>
<p>1、duplicate update则只执行update标记之后的sql，它保留了所有字段的旧值，只更新update后面的语句；<br>2、而replace没有保留旧值，直接删除再insert新值，原有的所有记录会被清除，如果replace语句的字段不全的话，有些原有的比如c字段的值会被自动填充为默认值。注意没有默认值的话必须得传入。</p>
<p>转自：<a href="http://www.136.la/jingpin/show-183061.html">http://www.136.la/jingpin/show-183061.html</a></p>
<h2 id="explain解析sql语句"><a href="#explain解析sql语句" class="headerlink" title="explain解析sql语句"></a>explain解析sql语句</h2><p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</p>
<p>在select语句之前增加explain关键字，执行后MySQL就会返回执行计划的信息，而不是执行sql。但如果from中包含子查询，MySQL仍会执行该子查询，并把子查询的结果放入临时表中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from student1;</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | student1 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<p>① id列<br>sql语句执行的顺序。<br>id列的编号是select的序列号，有几个select就有几个id，并且id是按照select出现的顺序增长的，id列的值越大优先级越高，id相同则是按照执行计划列从上往下执行，id为空则是最后执行。</p>
<p>② select_type列<br>表示对应行是简单查询还是复杂查询。</p>
<p>1）simple：不包含子查询和union的简单查询<br>2）primary：复杂查询中最外层的select<br>3）subquery：包含在select中的子查询（不在from的子句中，在where里）<br>4）derived：包含在from子句中的子查询。mysql会将查询结果放入一个临时表中，此临时表也叫衍生表<br>5）union：在union中的第二个和随后的select，UNION RESULT为合并的结果</p>
<p>③ table列<br>表示当前行访问的是哪张表。当from中有子查询时，外面查询语句的table列的格式为<derivedN>，表示当前查询依赖id=N行的查询，所以先执行id=N行的查询，当有union查询时，UNION RESULT的table列的值为&lt;union1,2&gt;，1和2表示参与union的行id。</derivedN></p>
<p>④ partitions列<br>查询将匹配记录的分区。 对于非分区表，该值为 NULL。</p>
<p>⑤ type列<br>此列表示关联类型或访问类型。也就是MySQL决定如何查找表中的行。依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</p>
<p>1）NULL：MySQL能在优化阶段分解查询语句，在执行阶段不用再去访问表或者索引。例如：explain select 1;<br>2) system、const：表最多有一个匹配行，const用于primary key 或者unique索引。因为只匹配一行数据，所以很快。（可以通过show warnings命令查看结果）。system是const的一个特例，表示表里表仅有一行的system。const表示查出数据只有一行，但是用limit 1不算。不是主键或者唯一键不算。(就是表示用唯一键/主键查出来一条)<br>3) eq_ref：主键或唯一键索引被连接使用（from a, b where a.c=b.c 或者 join on），最多只会返回一条符合条件的记录。简单的select查询不会出现这种type。<br>4) ref：相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一索引的部分前缀，索引和某个值比较，会找到多个符合条件的行。<br>5) range：通常出现在范围查询中，比如in、between、大于、小于等。使用索引来检索给定范围的行。<br>6) index：扫描全索引拿到结果，一般是扫描某个二级索引，二级索引一般比较少，所以通常比ALL快一点。该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的)<br>（没明白）<br>7) ALL：全表扫描，扫描聚簇索引的所有叶子节点.</p>
<p>⑥ possible_keys列<br>此列显示在查询中可能用到的索引。如果该列为NULL，则表示没有相关索引，可以通过检查where子句看是否可以添加一个适当的索引来提高性能。</p>
<p>⑦ key列<br>此列显示MySQL在查询时实际用到的索引。在执行计划中可能出现possible_keys列有值，而key列为null，这种情况可能是表中数据不多，MySQL认为索引对当前查询帮助不大而选择了全表查询。如果想强制MySQL使用或忽视possible_keys列中的索引，在查询时可使用force index、ignore index。</p>
<p>⑧ key_len列<br>此列显示MySQL在索引里使用的字节数，通过此列可以算出具体使用了索引中的那些列。索引最大长度为768字节，当长度过大时，MySQL会做一个类似最左前缀处理，将前半部分字符提取出做索引。当字段可以为null时，还需要1个字节去记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key_len计算规则：</span><br><span class="line">字符串：</span><br><span class="line">char(n)：n个数字或者字母占n个字节，汉字占3n个字节</span><br><span class="line">varchar(n)：  n个数字或者字母占n个字节，汉字占3n+2个字节。+2字节用来存储字符串长度。</span><br><span class="line"></span><br><span class="line">数字类型：</span><br><span class="line">tinyint：1字节   smallint：2字节   int：4字节   bigint：8字节</span><br><span class="line"></span><br><span class="line">时间类型</span><br><span class="line">date：3字节    timestamp：4字节     datetime：8字节</span><br></pre></td></tr></table></figure>

<p>⑨ ref列<br>此列显示key列记录的索引中，表查找值时使用到的列或常量。常见的有const、字段名</p>
<p>⑩ rows列<br>此列是MySQL在查询中估计要读取的行数。注意这里不是结果集的行数。</p>
<p>⑪ Extra列<br>此列是一些额外信息。常见的重要值如下：</p>
<p>1）Using index：使用覆盖索引（如果select后面查询的字段都可以从这个索引的树中获取，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值，这种情况一般可以说是用到了覆盖索引）。<br>2）Using where：使用 where 语句来处理结果，并且查询的列未被索引覆盖。<br>3）Using index condition：查询的列不完全被索引覆盖，where条件中是一个查询的范围。<br>4）Using temporary：MySQL需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的。<br>5）Using filesort：将使用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。<br>6）Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。</p>
<p>————————————————<br>原文链接：<a href="https://blog.csdn.net/fsdfkjai/article/details/121770629">https://blog.csdn.net/fsdfkjai/article/details/121770629</a><br><a href="https://blog.csdn.net/asd051377305/article/details/113979657">https://blog.csdn.net/asd051377305/article/details/113979657</a></p>
<h2 id="show-warnings-和-show-errors"><a href="#show-warnings-和-show-errors" class="headerlink" title="show warnings 和 show errors"></a>show warnings 和 show errors</h2><p>SHOW WARNINGS 是一个诊断语句，它显示有关在当前会话中执行语句所导致的状况（错误、警告和注释）的信息。警告是为 DML 语句（如 INSERT、UPDATE 和 LOAD DATA）以及 DDL 语句（如 CREATE TABLE 和 ALTER TABLE）生成的。</p>
<p>show warnings：显示上一条命令的警告信息。<br>show errors：显示上一条命令的错误信息。</p>
<h2 id="项目中的一个错误记录"><a href="#项目中的一个错误记录" class="headerlink" title="项目中的一个错误记录"></a>项目中的一个错误记录</h2><p>错误详情：<br>Communications link failure<br>The last packet successfully received from the server was 1750000 milliseconds ago. The last packet sent successfully to the server was … milli seconds ago.</p>
<p>背景：<br>高并发并且连续地访问数据库。<br>疑问：<br>这个问题跟高并发连续访问有关吗？<br>这个时间表示什么？上一次连接时间？<br>什么情况下新建一个连接。</p>
<p>错误原因：<br>具体解释是这样的：Mysql服务器默认的“wait_timeout”是8小时【也就是默认的值默认是28800秒】，也就是说一个connection空闲超过8个小时，Mysql将自动断开该connection，通俗的讲就是一个连接在8小时内没有活动，就会自动断开该连接。而应用连接池却认为该连接还是有效的(因为并未校验连接的有效性)，当应用申请使用该连接时，就会导致上面的报错。</p>
<p>这不就是获取到的数据库连接超时了嘛，没错，问题的本质也的确如此，常见的解决办法也很简单，比如说从数据库连接池中获取连接的时候判断下连接状态是否正常，这样就可以避免此类问题的发生</p>
<p>如果连接池中的连接时长超过数据库的配置，那么就会出现数据库已经关闭了该连接，但连接池中依然有效，业务获取到该连接后进行数据库操作，必然会出错。</p>
<p>数据库连接是昂贵的资源，长时间占有会严重影响服务性能，而且还会引起其他线程获取连接超时的问题<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/yuxiao97/article/details/119742632">https://blog.csdn.net/yuxiao97/article/details/119742632</a><br><a href="http://www.manongjc.com/article/64825.html">http://www.manongjc.com/article/64825.html</a></p>
<p>一个解决，也是盖配置：<a href="http://t.zoukankan.com/xbq8080-p-11718513.html">http://t.zoukankan.com/xbq8080-p-11718513.html</a></p>
<p>数据库连接池：<a href="https://blog.csdn.net/zhanglongfei_test/article/details/123983770">https://blog.csdn.net/zhanglongfei_test/article/details/123983770</a></p>
<p>问题：是连接池里的连接空闲太久被数据库关了，还是外面的线程等的时间太久超时了？</p>
<p>🤔看完了总结一下：<br>这种错误的原因在于：数据库连接池还认为连接有效，但是数据库方面已经断开，再访问就会报这个错误，那么那个时间是什么时间呢？<br>是数据库那边上一个收到数据的时间，是多久之前了。<br>是数据库方面报的还会服务器方面报的？</p>
<p>所以，看样子是长时间不访问导致的，跟高并发连续访问负荷大仿佛没什么关系。<br>看看是不是报这个错误的机器很久（大概半小时）没有访问数据库了。</p>
<p>另外，这个问题根源就是配置不一导致的？只能改配置？</p>
<p>还有，上面说了一句，长时间占有会严重影响服务性能，而且还会引起其他线程获取连接超时的问题，其他线程获取连接超时，跟这个不一样吧，这个是连接数据库超时。探讨的是数据库连接超时。</p>
<h2 id="几个count"><a href="#几个count" class="headerlink" title="几个count"></a>几个count</h2><p>count是个聚合函数</p>
<p>count*、count1、count主键，都表示返回满足条件的结果集的总行数。</p>
<p>count字段，表示返回满足条件的结果集中参数字段不为null的总个数。</p>
<p>count主键，涉及到从引擎返回id，涉及到解析数据行，以及拷贝字段值。</p>
<p>如果表中只有一个字段，<code>count(*)</code>最优。</p>
<p><code>count(*)</code>和<code>count(1)</code>两者比较，主要还要看count(1)所对应的数据字段，如果是聚集索引，比如主键id，肯定比count(1)快，但是差很小，因为sql会自动优化<code>count(*)</code>指定到那个字段。两者执行结果一样。</p>
<p>count(1)就是计算一共有多少符合条件的行，1并不是表示第一个字段，而是表示一个固定值。可以想象成表中有一个字段，是固定值1，count(1)就是计算一共有多少个1.</p>
<p>count(*)执行时，会把星号翻译成字段的具体名字，多一个翻译的过程，比固定值的方式效率稍微低一点。</p>
<p>规范：</p>
<p>1、不要使用count(列名)或count(常量)来代替<code>count(*)</code>，因为<code>count(*)</code>会统计为null的行，count(列名)不会统计null行。</p>
<p>2、count(distinct 列) 计算该列除了null之外的不重复行。count(distinct 列1, 列2) 如果其中一列全为null，另一列即使有不同的值，也返回0.</p>
<p>3、当某一列全为null时，count(列)的返回结果是0，但是sum(列)的返回结果是null，需要注意NPE。可以使用：<code>select if(isnull(sum(col), 0, sum(col))) from table;</code></p>
<h2 id="where、group-by、order-by后面的字段"><a href="#where、group-by、order-by后面的字段" class="headerlink" title="where、group by、order by后面的字段"></a>where、group by、order by后面的字段</h2><p>问题：where、group by、order by 后面的字段和select后面的字段有什么关系？</p>
<p>验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+------+------+</span><br><span class="line">| id | name | m_id |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 | liu  |   11 |</span><br><span class="line">|  2 | oo   |   22 |</span><br><span class="line">|  3 | li   |   33 |</span><br><span class="line">|  4 | wen  |    0 |</span><br><span class="line">|  5 | he   |    0 |</span><br><span class="line">|  8 | le   |    0 |</span><br><span class="line">| 10 | lo   |    0 |</span><br><span class="line">| 11 | x    |    1 |</span><br><span class="line">| 12 | xx   |    2 |</span><br><span class="line">+----+------+------+</span><br><span class="line">1.</span><br><span class="line">select id as name from student where name = &quot;liu&quot;;</span><br><span class="line">//用的是表里的name字段</span><br><span class="line"></span><br><span class="line">select id as ids from student where ids = 1;</span><br><span class="line">ERROR 1054 (42S22): Unknown column &#x27;ids&#x27; in &#x27;where clause&#x27;</span><br><span class="line">//where里无法用select后面as的字段</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">select id as m_id , count(*) from student group by m_id;</span><br><span class="line">ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;test.student.id&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br><span class="line">//group by后面用的是表里的m_id，而不是select as的m_id，id(select的字段)和m_id(group by的字段)无关，且根据m_id分组后有多个，所以会报错。</span><br><span class="line"></span><br><span class="line">select m_id count(*) from student group by m_id;</span><br><span class="line">//虽然没有select m_id，但是正常输出了m_id对应的count</span><br><span class="line"></span><br><span class="line">select id as ids from student group by ids;</span><br><span class="line">//根据id分组。</span><br><span class="line"></span><br><span class="line">select name, count(1) from student group by id;</span><br><span class="line">//正常输出，证明group by后只有一个的字段是可以出现在select后的。</span><br><span class="line"></span><br><span class="line">select name, count(1) from student group by m_id;</span><br><span class="line">ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;test.student.name&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br><span class="line">//group by后不只有一个的字段是不可以出现在select后的</span><br><span class="line"></span><br><span class="line">select any_value(name), count(1) from student group by m_id;</span><br><span class="line">//正常输出</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">select * from student left join grade on student.m_id=grade.m_id group by m_id;</span><br><span class="line">ERROR 1052 (23000): Column &#x27;m_id&#x27; in group statement is ambiguous</span><br><span class="line">//两张表里都有的字段，且都select出来，得指明哪张表的</span><br><span class="line"></span><br><span class="line">select student.m_id from student left join grade on student.m_id=grade.m_id group by m_id;</span><br><span class="line">//按照m_id分组</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">select name from student order by id;</span><br><span class="line">//正常输出根据id排序的</span><br><span class="line"></span><br><span class="line">select name as id from student order by id;</span><br><span class="line">//输出根据name排序的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论：<br>1、where后面的字段必须得是表里的字段，不能是select as的字段。</p>
<p>2、group by可以用表里的字段，也可以用select as的字段，但是如果两者一样，用的是表里的字段。也就是说，把表字段select as为表里没有的名字，可以用这个名字group by。<br>select后面可以不出现group by后面的字段。<br>group by后只有一个的字段是可以出现在select后的。<br>group by后不只有一个的字段是不可以出现在select后的，加了any_value才能输出。</p>
<p>3、两张表left join后group by，如果select 两张表的同一字段，group by后面需要指明哪张表的，如果select出了一张表的，可以不加。<br>即使select了一张表的，但是这个字段是join on后面的，也得指明。</p>
<p>4、select里面可以出现与order by字段无关的字段。</p>
<p>5、select as后面的字段，不能拿来直接在select里又用。<br>例如：<code>select id as a, a+1 as b from table;</code> 这样不对。</p>
<p>⚠️其他的查看tips</p>
<p>实战总结：<br>mysql where后面使用的字段，只能是表里的字段，不能是select as后面的，不能直接用，还是得用as前面的，用了后面的相当于是null，啥都查不出来，还有的表里的字段就可能是null，记得用ifnull函数，不然也一样查不出来。</p>
<p>实战总结：<br>形成规范：select多张表的字段，as一下，where里指明哪张表的。group by和order by不指明哪张表的，直接用as后面的和表字段不一样的。除非group by和order by后面的不在select里，指明哪张表的。</p>
<h2 id="模糊查询-1"><a href="#模糊查询-1" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;if test=&quot;cityList != null and cityList.size() &gt; 0&quot;&gt;</span><br><span class="line">    &lt;foreach collection=&quot;cityList&quot; open=&quot;(&quot; clos=&quot;)&quot; item=&quot;city&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">        city like concat(#&#123;city&#125;, &quot;%&quot;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql技巧</title>
    <url>/2022/09/25/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/mysql%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="mysql日期函数"><a href="#mysql日期函数" class="headerlink" title="mysql日期函数"></a>mysql日期函数</h2><p>✅datepart()</p>
<p>获取日期中的年月日<br>datepart(‘2022-11-11 12:12:12’, ‘yyyy’)<br>得到：2022，也可以是mm、dd</p>
<p>✅datetrunc()</p>
<p>获取日期的指定起始日期，比如一天的开始<br>datetrunc(‘2022-11-11 12:12:12’, ‘yyyy‘)<br>得到：2022-01-01 00:00:00</p>
<p>✅quarter()</p>
<p>获取日期的季度<br>quarter(‘2022-11-11 00:00:00’)<br>得到：4</p>
<p>✅subdate函数</p>
<p>MySQL中的SUBDATE()函数用于从给定日期减去某间隔时间。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBDATE(date, INTERVAL expr, unit)</span><br><span class="line"></span><br><span class="line">此函数接受以下三个参数：</span><br><span class="line">日期：第一个指定的日期。</span><br><span class="line">expr：要减去的时间/日期间隔的值。负的表示该时间之后</span><br><span class="line">单位：间隔的类型。MICROSECOND\SECOND\MINUTE\HOUR\DAY\WEEK\MONTH\QUARTER\YEAR</span><br></pre></td></tr></table></figure>

<p>例子：<br><code>select subdate(&quot;2020-11-25&quot;, INTERVAL 30 DAY)</code></p>
<p>今天的日期：<br><code>select curdate();  2022-10-30</code><br>现在的时间：<br><code>select curtime();   13:13:54</code></p>
<p>✅mysql计算时间差函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.timestampdiff(interval, datetime1,datetime2)</span><br><span class="line">返回（时间2-时间1）的时间差，结果单位由interval参数给出</span><br><span class="line">select timestampdiff(MINUTE,&#x27;2012-10-01&#x27;,&#x27;2013-01-13&#x27;); # 149760</span><br><span class="line"></span><br><span class="line">2.天数差函数 datediff</span><br><span class="line">语法：传入两个日期参数，比较DAY天数，第一个参数减去第二个参数的天数值。</span><br><span class="line">select datediff(‘2013-01-13’,‘2012-10-01’); # 104</span><br><span class="line"></span><br><span class="line">3.时间差函数：timediff</span><br><span class="line">语法：timediff(time1,time2)</span><br><span class="line">结果：返回两个时间相减得到的差值，time1-time2，如果其中一个是null，返回也是null。</span><br><span class="line">select timediff(‘2018-05-21 14:51:43’,‘2018-05-19 12:54:43’);</span><br><span class="line"></span><br><span class="line">4.其他求时间的函数</span><br><span class="line">select now(); //2022-11-26 16:18:45</span><br><span class="line">select curdate(); //2022-11-26</span><br><span class="line">select curtime();</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/weixin_53370274/article/details/122122628">https://blog.csdn.net/weixin_53370274/article/details/122122628</a></p>
<p>✅日期转换为时间戳</p>
<p>10位的时间戳精确到s<br>13位的时间戳精确到ms毫秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNIX_TIMESTAMP函数:日期转时间戳(10位)</span><br><span class="line">select unix_timestamp(now()); //1669452093</span><br><span class="line"></span><br><span class="line">FROM_UNIXTIME函数：时间戳转日期（第二个参数非必填，默认：%Y-%m-%d %H:%i:%s）</span><br><span class="line">select from_unixtime(unix_timestamp(now()));</span><br><span class="line">select from_unixtime(unix_timestamp(now()), &#x27;%Y~%m~%d %H:%i:%S&#x27;);  //2022~11~26 16:48:38</span><br></pre></td></tr></table></figure>

<p>✅日期和字符串相互转化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日期转化为指定格式字符串：</span><br><span class="line">select date_format(now(),&#x27;%Y-%m-%d %H:%i:%S&#x27;); //2022-11-26 16:45:59</span><br><span class="line"></span><br><span class="line">指定格式字符串转化为日期：</span><br><span class="line">select str_to_date(&#x27;2022-11-29&#x27;, &#x27;%Y-%m-%d %H:%i:%S&#x27;); //2022-11-29 00:00:00</span><br></pre></td></tr></table></figure>

<h2 id="mySQL-with-as用法"><a href="#mySQL-with-as用法" class="headerlink" title="mySQL - with as用法"></a>mySQL - with as用法</h2><p>如果一整句查询中多个子查询都需要使用同一个子查询的结果，那么就可以用with as，将共用的子查询提取出来，加个别名。后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用。</p>
<p>构造数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 分类表</span><br><span class="line">CREATE TABLE category ( cid VARCHAR ( 32 ) PRIMARY KEY, cname VARCHAR ( 50 ) );</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE products (</span><br><span class="line">	pid VARCHAR ( 32 ) PRIMARY KEY,</span><br><span class="line">	pname VARCHAR ( 50 ),</span><br><span class="line">	price INT,</span><br><span class="line">	flag VARCHAR ( 2 ),-- 是否上架标记为：1表示上架、0表示下架</span><br><span class="line">	category_id VARCHAR ( 32 ),</span><br><span class="line">	FOREIGN KEY ( category_id ) REFERENCES category ( cid ) </span><br><span class="line">);</span><br><span class="line">-- 分类数据</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c001&#x27;,&#x27;家电&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c002&#x27;,&#x27;鞋服&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c003&#x27;,&#x27;化妆品&#x27;);</span><br><span class="line">INSERT INTO category(cid,cname) VALUES(&#x27;c004&#x27;,&#x27;汽车&#x27;);</span><br><span class="line"></span><br><span class="line">-- 商品数据</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p001&#x27;,&#x27;小米电视机&#x27;,5000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p002&#x27;,&#x27;格力空调&#x27;,3000,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br><span class="line">INSERT INTO products(pid, pname,price,flag,category_id) VALUES(&#x27;p003&#x27;,&#x27;美的冰箱&#x27;,4500,&#x27;1&#x27;,&#x27;c001&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询两个商品的平均价格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH xm_gl AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT avg( price ) FROM xm_gl;</span><br></pre></td></tr></table></figure>

<p>使用with as还可以创建多个临时表，但是要注意同一个查询语句前写一个with就够了，另外子查询需要逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH a AS ( SELECT * FROM category WHERE cname = &#x27;家电&#x27; ),</span><br><span class="line">b AS ( SELECT * FROM products WHERE pname IN ( &#x27;小米电视机&#x27;, &#x27;格力空调&#x27; ) ) </span><br><span class="line">SELECT * FROM	a	LEFT JOIN b ON a.cid = b.category_id;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、with as 相当于一个临时表，但是不同于视图（create table as），不会存储起来，要与select配合使用。<br>2、同一个select前可以有多个临时表，写一个with就可以，用逗号隔开，最后一个with语句不要用逗号。</p>
<p>摘自：<a href="https://zhuanlan.zhihu.com/p/397195826">https://zhuanlan.zhihu.com/p/397195826</a></p>
<p>实战总结：<br><code>with as</code>不能单独加<code>;</code>一句单独使用，需要后面跟select一起使用。第一个<code>with as</code>得到的临时表可以在第二个临时表里用。好处是可以分步骤生成表，不用嵌套很多层。</p>
<p>如果<code>create table as</code> ，是要加在<code>with as</code>之前的。</p>
<h2 id="mysql-case-when-用法"><a href="#mysql-case-when-用法" class="headerlink" title="mysql case when 用法"></a>mysql case when 用法</h2><p>MySQL 的 case when 的语法有两种：</p>
<p>简单函数<br><code>CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END</code></p>
<p>搜索函数<br><code>CASE WHEN [expr] THEN [result1]…ELSE [default] END</code></p>
<p>简单函数用法：根据case字段when已知可能值，then列出已知装备（也可以是表的某个字段）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    CASE NAME</span><br><span class="line">        WHEN &#x27;德莱文&#x27; THEN</span><br><span class="line">            &#x27;斧子&#x27;</span><br><span class="line">        WHEN &#x27;德玛西亚-盖伦&#x27; THEN</span><br><span class="line">            &#x27;大宝剑&#x27;</span><br><span class="line">        WHEN &#x27;暗夜猎手-VN&#x27; THEN</span><br><span class="line">            &#x27;弩&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;无&#x27;</span><br><span class="line">    END &#x27;装备&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>搜索函数用法：case when 某个字段的函数 then某值（也可以是表的字段）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># when 表达式中可以使用 and 连接条件</span><br><span class="line">SELECT</span><br><span class="line">    NAME &#x27;英雄&#x27;,</span><br><span class="line">    age &#x27;年龄&#x27;,</span><br><span class="line">    CASE</span><br><span class="line">        WHEN age &lt; 18 THEN</span><br><span class="line">            &#x27;少年&#x27;</span><br><span class="line">        WHEN age &lt; 30 THEN</span><br><span class="line">            &#x27;青年&#x27;</span><br><span class="line">        WHEN age &gt;= 30</span><br><span class="line">        AND age &lt; 50 THEN</span><br><span class="line">            &#x27;中年&#x27;</span><br><span class="line">        ELSE</span><br><span class="line">            &#x27;老年&#x27;</span><br><span class="line">    END &#x27;状态&#x27;</span><br><span class="line">FROM</span><br><span class="line">    user_info;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://www.cnblogs.com/chenduzizhong/p/9590741.html">https://www.cnblogs.com/chenduzizhong/p/9590741.html</a></p>
<h2 id="mysql批量删除大量数据"><a href="#mysql批量删除大量数据" class="headerlink" title="mysql批量删除大量数据"></a>mysql批量删除大量数据</h2><p>假设有一个表(syslogs)有1000万条记录，需要在业务不停止的情况下删除其中statusid=1的所有记录，差不多有600万条， 直接执行 DELETE FROM syslogs WHERE statusid=1 会发现删除失败，因为lock wait timeout exceed的错误。</p>
<p>因为这条语句所涉及的记录数太多，因此我们通过LIMIT参数分批删除，比如每10000条进行一次删除，那么我们可以利用 MySQL这样的语句来完成:<br><code>DELETE FROM syslogs WHERE status=1 ORDER BY statusid LIMIT 10000;</code></p>
<p>如果要用order by 必须要和 limit 联用，否则被优化掉。然后分多次执行就可以把这些记录成功删除。</p>
<p>注意：<br>执行大批量删除的时候注意要使用上limit。因为如果不用limit，删除大量数据很有可能造成死锁。<br><strong>如果delete的where语句不在索引上，可以先找主键，然后根据主键删除数据库。</strong><br>平时update和delete的时候最好也加上limit 1 来防止误操作。</p>
<p>mybatis中的delete语句可以有返回，返回结果int是删除的条数，如果没删除，返回0.</p>
<h2 id="delete和truncate，drop的区别"><a href="#delete和truncate，drop的区别" class="headerlink" title="delete和truncate，drop的区别"></a>delete和truncate，drop的区别</h2><p>1、delete删除数据的原理:(delete属于DML语句)</p>
<p>表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放。<br>这种删除表的优点是：支持回滚，后悔了可以恢复数据，可以带where条件删除部分数据，灵活性强。<br>缺点：删除效率比较低</p>
<p><code>delete from user;  //删除user表中的数据，但是这种删除数据的方式有点慢。</code></p>
<p>2、truncate删除数据的原理:(DDL)</p>
<p>可以理解为，drop table然后再create table。<br>效率比较高，表被一次截断，物理删除<br>优点：快速，不走事务，不会锁表，也不会产生大量日志写入日志文件<br>缺点：不支持回滚，只能删除表中所有数据，不能删单条数据<br>如果说公司项目里面有一张大表，数据非常多，几亿条记录：<br>删除的时候，使用delete，也许执行一个小时才能删除完，效率极其低；<br>可以选择使用truncate删除表中的数据。只需要不到1s的时间就能删除结束，效率较高。<br>但是使用truncate之前，必须仔细询问客户是否真的需要删除，并警告删除之后不可恢复。</p>
<p><code>truncate table user; //删除user表中的数据，快速。</code></p>
<p><strong>truncate和delete的差异</strong></p>
<blockquote>
<p>1、truncate是DDL语句，它不存在所谓的“事务回滚”；<br>delete是DML语句，它执行完是可以rollback的。<br>2、truncate table返回值是0；<br>delete from table返回值是被删除的行数。<br>3、InnoDB支持一个表一个文件时：<br>truncate会一次性把表干掉，且不会激活触发器，速度非常快；<br>delete from table则会一行一行删除，会激活触发器，速度比较慢。<br>delete数据，是要记录日志的，truncate表不需要记录日志。<br>4、当表中有列被其它表作为外键(foreign key)时：<br>truncate会是失败； delete则会成功。<br>5、当表中有自增列时：<br>truncate会使得自增列计数复原；<br>delete所有数据后，自增列计数并不会复原，而是保持原来的顺序自增。</p>
</blockquote>
<p>3、drop删除表操作</p>
<p>truncate和delete是删除表中的数据，表还在。</p>
<p><code>drop table 表名；// 删除表，不是删除表中的数据</code></p>
<p>转自：<a href="https://blog.csdn.net/jike11231/article/details/126551510">https://blog.csdn.net/jike11231/article/details/126551510</a><br><a href="https://blog.csdn.net/jkzyx123/article/details/127223589">https://blog.csdn.net/jkzyx123/article/details/127223589</a></p>
<h2 id="mysql的空间"><a href="#mysql的空间" class="headerlink" title="mysql的空间"></a>mysql的空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型	    占用空间	  取值范围</span><br><span class="line">tinyint	      1个字节	    -128~127</span><br><span class="line">smallint	2个字节	    -32768~32767</span><br><span class="line">mediumint	3个字节	    -223~ 223 - 1</span><br><span class="line">int	        4个字节	    -231~ 231- 1</span><br><span class="line">bigint	    8个字节	    -263~ 263- 1</span><br></pre></td></tr></table></figure>

<p>mysql数据类型及占用空间：<a href="https://blog.csdn.net/why_still_confused/article/details/125945285">https://blog.csdn.net/why_still_confused/article/details/125945285</a></p>
<h2 id="分库分表的表怎么查询"><a href="#分库分表的表怎么查询" class="headerlink" title="分库分表的表怎么查询"></a>分库分表的表怎么查询</h2><p>逻辑库查询暂不支持join查询。</p>
<h2 id="Lindorm云原生多模数据库"><a href="#Lindorm云原生多模数据库" class="headerlink" title="Lindorm云原生多模数据库"></a>Lindorm云原生多模数据库</h2><p>Lindorm是面向物联网、互联网、车联网等设计和优化的云原生多模超融合数据库，支持宽表、时序、文本、对象、流、空间等多种数据的统一访问和融合处理，并兼容SQL、HBase/Cassandra/S3、TSDB、HDFS、Solr、Kafka等多种标准接口和无缝集成三方生态工具，适用于日志、监控、账单、广告、社交、出行、风控等场景，Lindorm也是为阿里巴巴核心业务提供支撑的数据库之一。</p>
<p><a href="https://help.aliyun.com/document_detail/174640.html">https://help.aliyun.com/document_detail/174640.html</a></p>
<h2 id="mysql查出来的数据转换为json格式-用ResultSet"><a href="#mysql查出来的数据转换为json格式-用ResultSet" class="headerlink" title="mysql查出来的数据转换为json格式 用ResultSet"></a>mysql查出来的数据转换为json格式 用ResultSet</h2><p>单纯mysql语句没得办法。<br>只能在java里操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.ResultSetMetaData;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">import org.json.JSONArray;</span><br><span class="line">import org.json.JSONObject;</span><br><span class="line"></span><br><span class="line">public class MysqlToJSON &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/ontology&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String pwd = &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            Connection con =DriverManager.getConnection(url,user,pwd);</span><br><span class="line">            Statement stet = con.createStatement();</span><br><span class="line"></span><br><span class="line">            String sql = &quot;select * from class_tab&quot;;</span><br><span class="line">            ResultSet rs = stet.executeQuery(sql);</span><br><span class="line">            ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">            int columnCount= metaData.getColumnCount();</span><br><span class="line">            JSONArray array = new JSONArray();</span><br><span class="line">            while(rs.next())&#123;</span><br><span class="line">                JSONObject jsonObj = new JSONObject();</span><br><span class="line">                for(int i = 1; i &lt;= columnCount;i++)&#123;</span><br><span class="line">                    String columnName = metaData.getColumnLabel(i);</span><br><span class="line">                    String value =rs.getString(columnName);</span><br><span class="line">                    jsonObj.put(columnName, value);</span><br><span class="line">                &#125;</span><br><span class="line">                array.put(jsonObj);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;转换JSON数据：&quot;);</span><br><span class="line">            System.out.println(array.toString());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mysql的json数据格式"><a href="#mysql的json数据格式" class="headerlink" title="mysql的json数据格式"></a>mysql的json数据格式</h2><p>mysql5.7以上提供了一种新的字段格式json，大概是mysql想把非关系型和关系型数据库一口通吃，所以推出了这种非常好用的格式，这样，我们的很多基于mongoDB的业务都可以用mysql去实现了。当然了，5.7的版本只是最基础的版本，对于海量数据的效率是远远不够的，不过这些都在mysql8.0解决了。</p>
<p>✅创建表，插入数据</p>
<p>先创建一个简单的含json格式的数据库表，其中json_value就为json格式的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `dept` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `dept` varchar(255) DEFAULT NULL,</span><br><span class="line">  `json_value` json DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert into dept VALUES(1,&#x27;部门1&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门1&quot;, &quot;deptId&quot;: &quot;1&quot;, &quot;deptLeaderId&quot;: &quot;3&quot;&#125;&#x27;);</span><br><span class="line">insert into dept VALUES(2,&#x27;部门2&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门2&quot;, &quot;deptId&quot;: &quot;2&quot;, &quot;deptLeaderId&quot;: &quot;4&quot;&#125;&#x27;);</span><br><span class="line">insert into dept VALUES(3,&#x27;部门3&#x27;,&#x27;&#123;&quot;deptName&quot;: &quot;部门3&quot;, &quot;deptId&quot;: &quot;3&quot;, &quot;deptLeaderId&quot;: &quot;5&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure>

<p>✅基础查询操作</p>
<p>如果json字符串不是数组，则直接使用<code>$.字段名</code><br>如果json字符串是数组<code>[Array]</code>，则直接使用<code>$[对应元素的索引id]</code></p>
<p>使用 <code>json字段名-&gt;’$.json属性’</code> 进行查询条件<br>举个例子：如果想查询deptLeaderId=5 的数据，那么sql语句如下：<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39;;</code></p>
<p>多条件查询，想查dept为“部门3”和deptLeaderId=5的数据，sql如下：<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39; and dept=&#39;部门3&#39;;</code></p>
<p>json中的多条件查询，想查询json格式中deptLeaderId=5和deptId=5的数据:<br><code>SELECT * from dept WHERE json_value-&gt;&#39;$.deptLeaderId&#39;=&#39;5&#39; and json_value-&gt;&#39;$.deptId&#39;=&#39;5&#39;;</code></p>
<p>两个有json字段的表关联查询，一样的：<br><code>SELECT * from dept,dept_leader  WHERE dept.json_value-&gt;&#39;$.deptLeaderId&#39;=dept_leader.json_value-&gt;&#39;$.id&#39; ;</code></p>
<p>转自：mysql之json操作以及一些json函数：<br><a href="http://events.jianshu.io/p/40b153000fb2">http://events.jianshu.io/p/40b153000fb2</a></p>
<h2 id="mysql表数据迁移"><a href="#mysql表数据迁移" class="headerlink" title="mysql表数据迁移"></a>mysql表数据迁移</h2><p>不是一个库只能先select出来，然后构造insert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从一个表复制数据，然后把数据插入到另一个新表中：</span><br><span class="line">create  table 新表  as select * from 旧表</span><br><span class="line"></span><br><span class="line">INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中：</span><br><span class="line">insert into 新表 (select * from 旧表)</span><br><span class="line"></span><br><span class="line">只复制希望的列插入到另一个已存在的表中：</span><br><span class="line">insert into 新表(字段1, 字段2, 字段n)  select  字段1, 字段2, 字段n from 旧表</span><br></pre></td></tr></table></figure>


<h2 id="mysql中geometry类型的插入"><a href="#mysql中geometry类型的插入" class="headerlink" title="mysql中geometry类型的插入"></a>mysql中geometry类型的插入</h2><p>得加个<code>geoFromText(‘lineString(...)’)</code></p>
<p>geometry那篇博客里也有。</p>
<p>MySQL中地理位置数据扩展geometry的使用心得：<br><a href="https://cloud.tencent.com/developer/article/2074765">https://cloud.tencent.com/developer/article/2074765</a></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>项目相关</title>
    <url>/2021/09/02/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/project%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="修改路由"><a href="#修改路由" class="headerlink" title="修改路由"></a>修改路由</h2><p>![image-20210901112055198](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210901112055198.png)</p>
<p>路由字符串可随意修改，后面跟action下的文件里的函数名就好。</p>
<p>注意后面跟的create和文件名没关系，文件名可以改成别的。</p>
<p>文件里的函数名必须是是Create，需要大写。</p>
<p>访问的接口的create可大写可小写。</p>
<h2 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h2><p>首先查看端口占用，再更改配置</p>
<p>![image-20210901112159550](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210901112159550.png)</p>
<h2 id="post请求怎么通过url访问"><a href="#post请求怎么通过url访问" class="headerlink" title="post请求怎么通过url访问"></a>post请求怎么通过url访问</h2><p>post请求当然无法通过url访问，内容不在url里，而在body里。</p>
<p>用curl</p>
<h2 id="访问网址的脚本"><a href="#访问网址的脚本" class="headerlink" title="访问网址的脚本"></a>访问网址的脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;访问时间是：`date &#x27;+%Y%m%d %H:%M:%S&#x27;`--$code---&gt;$url&quot; &gt;&gt; result.log</span><br><span class="line">n=0</span><br><span class="line">max=11</span><br><span class="line">while(($n&lt;max))</span><br><span class="line">do</span><br><span class="line">    curl &#x27;https://www.baidu.com/&#x27; //访问url</span><br><span class="line">    n=($n+1)</span><br><span class="line">    sleep 1s</span><br><span class="line">done</span><br><span class="line">#while循环访问url,直到状态码为200跳出循环</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">result.log</span><br><span class="line">n=0</span><br><span class="line">max=20</span><br><span class="line"><span class="meta">while(($</span><span class="bash">n&lt;max))</span></span><br><span class="line">do</span><br><span class="line">    echo -e &quot;times:$n, time:`date &#x27;+%Y%m%d %H:%M:%S&#x27;`&quot; &gt;&gt; new.log</span><br><span class="line">    curl &#x27;http://10.12.205.134:8182/pt/idproducer/v2/create?appid=10001&#x27;&gt;&gt;new.log</span><br><span class="line">    echo -e &quot;\n&quot;&gt;&gt;new.log</span><br><span class="line">    </span><br><span class="line">    echo -e &quot;times:$n, time:`date &#x27;+%Y%m%d %H:%M:%S&#x27;`&quot; &gt;&gt; old.log</span><br><span class="line">    curl &#x27;http://10.12.205.134:8182/pt/idproducer/create?appid=3&#x27;&gt;&gt;old.log</span><br><span class="line">    echo -e &quot;\n&quot;&gt;&gt;old.log</span><br><span class="line">    n=($n+1)</span><br><span class="line">    sleep 1s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>不加次数时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">n=0</span><br><span class="line">max=3600</span><br><span class="line"><span class="meta">while(($</span><span class="bash">n&lt;max))</span></span><br><span class="line">do</span><br><span class="line">    curl &#x27;http://10.229.66.155:2010/pt/idproducer/v2/create?appid=10001&#x27;&gt;&gt;new.log</span><br><span class="line">    echo -e &quot;\n&quot; &gt;&gt; new.log</span><br><span class="line">    curl &#x27;http://10.229.66.155:2010/pt/idproducer/create?appid=13&#x27;&gt;&gt;old.log</span><br><span class="line">    echo -e &quot;\n&quot; &gt;&gt; old.log</span><br><span class="line">    n=$n+1</span><br><span class="line">    sleep 1s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="快速计算的脚本"><a href="#快速计算的脚本" class="headerlink" title="快速计算的脚本"></a>快速计算的脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo -n &quot;please input your name and age:&quot;</span><br><span class="line">read name age</span><br><span class="line">echo &quot;welcome $name, your age is $age&quot;</span><br><span class="line"></span><br><span class="line">read -p &quot;please input your name and age:&quot; name age</span><br><span class="line">echo &quot;welcome $name, your age is $age&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo -n &quot;please input your maxid and oldstep and newstep:&quot;</span><br><span class="line">read maxid oldstep newstep</span><br><span class="line">declare -i a=$maxid+$oldstep*5000000</span><br><span class="line">declare -i b=$a/$newstep</span><br><span class="line">echo &quot;after calcu is: $b&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>proto buffer的java使用</title>
    <url>/2022/03/19/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/protocolbuffer/</url>
    <content><![CDATA[<h3 id="pb介绍"><a href="#pb介绍" class="headerlink" title="pb介绍"></a>pb介绍</h3><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<br>protocol buffer和xml、json类似，也可以作为开发中的一种数据交换格式，只不过相较xml和json，protocol buffer的优点更明显，它更小、更快、更简单。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/yubo_725/article/details/52219489">https://blog.csdn.net/yubo_725/article/details/52219489</a></p>
<p>————————————————</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="文件本地转换"><a href="#文件本地转换" class="headerlink" title="文件本地转换"></a>文件本地转换</h4><p>可以使用用ProtocolBuffer的编译器实现.protocaol文件到,java文件的转换。</p>
<p>首先我们需要去Google的网站上下载Protocol Buffer的编译器：<a href="https://developers.google.com/protocol-buffers/docs/downloads">https://developers.google.com/protocol-buffers/docs/downloads</a></p>
<p>在Java中使用ProtocolBuffer的步骤大致分为下面这几点：</p>
<p>（1）编写.proto文件，定义消息类型</p>
<p>（2）使用ProtocolBuffer的编译器，将.proto文件编译成对应的java文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.msg;</span><br><span class="line"> </span><br><span class="line">option java_outer_classname = <span class="string">&quot;PersonBean&quot;</span>;</span><br><span class="line"> </span><br><span class="line">message Person &#123;</span><br><span class="line">    required string name = <span class="number">1</span>;</span><br><span class="line">    required int32 age = <span class="number">2</span>;</span><br><span class="line">    optional string gender = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存到一个Person.proto文件中，其中package指定了包名，和java中的包名类似，option java_outer_classname = “PersonBean”;这句指定了编译器在编译.proto文件时，输出的java类的类名，接着使用message定义了一个名为Person的消息，里面包含3个成员变量，其中用required修饰的变量代表必须的，optional修饰的变量代表是可选的，这里定义消息的形式跟java中定义类非常相似。</p>
<p>下面需要用ProtocolBuffer的编译器来编译上面的消息，我们从google的网站上下载下来的是一个protoc.exe文件，将该文件跟上面定义的消息文件Person.proto放在同一个目录下，然后在命令行中进入该目录，执行下面的命令：</p>
<p><code>protoc.exe --java_out=./ Person.proto</code><br>就在当前目录下生成了对应的java文件PersonProto.java</p>
<h4 id="socket线上传输"><a href="#socket线上传输" class="headerlink" title="socket线上传输"></a>socket线上传输</h4><p>在lib目录下引入了protobuf-java-2.5.0.jar包，这个包就是用来对ProtocolBuffer消息进行序列化和反序列化的.</p>
<p>服务端，定义一个Server类，用于处理客户端发送过来的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.server;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.demo.constant.Constants;</span><br><span class="line"><span class="keyword">import</span> com.demo.msg.PersonBean;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.ByteString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(Constants.PORT);</span><br><span class="line">        System.out.println(<span class="string">&quot;server started...&quot;</span>);</span><br><span class="line">        Socket socket = ss.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;a client connected!&quot;</span>);</span><br><span class="line">        <span class="comment">//从输入流中解析出Person对象，反序列化，byte流-&gt;java对象</span></span><br><span class="line">        PersonBean.Person person = PersonBean.Person.parseFrom(ByteString.readFrom(socket.getInputStream()));</span><br><span class="line">        <span class="keyword">if</span>(person != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server received data:\n&quot;</span> + person.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端，定义一个Client类，用于生成一个Person类对象并发送给Server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.client;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.demo.constant.Constants;</span><br><span class="line"><span class="keyword">import</span> com.demo.msg.PersonBean;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, Constants.PORT);</span><br><span class="line">        <span class="comment">//构造一个Person对象</span></span><br><span class="line">        PersonBean.Person person = PersonBean.Person.newBuilder().setName(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">                .setAge(<span class="number">20</span>).setGender(<span class="string">&quot;male&quot;</span>).build();</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//将Person对象写到输出流中。序列化为字节流</span></span><br><span class="line">        os.write(person.toByteArray());</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">//这里注意一定要关闭流，否则服务端会报错</span></span><br><span class="line">        os.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;client send person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的PORT为常量，定义在Constants类中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.constant;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9988</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个使用ProtocolBuffer来进行数据发送和接收的java程序就完成了。</p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>前面的例子中，序列化只是序列化为了字节流，反序列化也是字节流到java对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student.Builder buidler = Student.newBuilder();</span><br><span class="line">buidler.setName(<span class="string">&quot;Frank&quot;</span>);</span><br><span class="line">buidler.setNumber(<span class="number">123456</span>);</span><br><span class="line">buidler.setHobby(<span class="string">&quot;music&quot;</span>);</span><br><span class="line">Student student = buidler.build();</span><br><span class="line">System.out.println(student.toString());</span><br></pre></td></tr></table></figure>

<p><code>student.toByteArray();</code>  Student是pb文件名，而不是java文件名。builder是啥？</p>
<p>这个方法会得到byte[]，我们可以将它送到文件流中进行传输，这也是它的终极目的。也就是我们将protoc对象序列化成了字节流数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] array = student.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Student student1 = Student.parseFrom(array);</span><br><span class="line">    System.out.println(student1.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>array是之前序列化后产生的byte数据，现在通过Student的静态方法parseFrom()可以数据反序列成Student对象。</p>
<p>除了开始的阶段编写.proto文件，然后再把.proto文件编译成java文件麻烦点，其余的步骤甚至比json转换的更便利。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>明白了，使用pb之前，是一定要使用本地转换的，在socket中传输的一定是字节流。在字节流与java对象中间应该是有pb文件的。  PersonBean.Person。用的都是pb的文件名。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/briblue/article/details/53187780">https://blog.csdn.net/briblue/article/details/53187780</a></p>
<p><a href="https://blog.csdn.net/yubo_725/article/details/52219489">https://blog.csdn.net/yubo_725/article/details/52219489</a></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2022/04/13/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/redis/</url>
    <content><![CDATA[<h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>redis：内存存储（速度快）、远程操作（可以与多个客户端连接）、持久化（服务器重启可保持重启前的数据）、可扩展（主从复制、分片）</p>
<h4 id="mac安装redis"><a href="#mac安装redis" class="headerlink" title="mac安装redis"></a>mac安装redis</h4><p>✅brew install redis 安装<br>✅brew info redis 查看安装路径<br>✅启动redis：<br>方式一：使用brew启动 brew services start redis<br>方式二：进入redis的bin目录，输入redis-server<br>✅关闭redis服务<br>方式一：redis-cli SHUTDOWN<br>方式二：redis-cli进入再输入SHUTDOWN<br>✅查看redis是否在运行：ps axu|grep redis<br>✅客户端连接redis：redis-cli -h 127.0.0.1 -p 6379<br>连接后执行ping命令，检测redis服务是否启动<br>✅redis.conf配置文件说明：<br>redis默认是前台启动，如果相以守护进程（后台方式）运行，可以在配置文件中将daemonize no修改为yes。</p>
<blockquote>
<p>守护进程（后台进程）与前台进程：<br>前台进程是在终端中运行的，终端关闭进程也就消失。<br>守护进程是运行在后台的一种特殊进程，不受终端控制，也不需要终端的交互。<br>Linux中大多数服务器是用守护进程实现的，比如web服务器http等。</p>
</blockquote>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>keys * 查看所有key的内容<br>exits key  查看key是否存在<br>set key value  设置key的内容<br>get key  获取key的内容<br>flushdb  删除当前数据库中所有key<br>flushall  删除所有数据库中key</p>
<p>服务器相关命令：<br>ping  测试连接是否存活，返回pong代表有响应<br>echo  输出信息<br>select num  选择数据库，0-15<br>quit  退出连接<br>dbsize  返回当前数据库中key的数量<br>info  获取服务的相关信息</p>
<p>设置键命令：<br>setex key seconds value 设置值并设置有效期，已存在会覆盖<br>pexpire key millisecond 设置有效时间，毫秒为单位，必须是已经存在的key<br>setnx key value 不存在时放入<br>exists key 是否存在该key<br>ttl key 以秒为单位显示过期时间<br>pttl key 以毫秒为单位显示过期时间</p>
<h4 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h4><p>string：可存储字符串、整数、浮点数<br>list：一个链表，每个节点包含一个字符串<br>set：包含字符串的无序收集容器<br>hash：包含键值的无序散列表<br>zset：有序集合，元素排列顺序由分值大小决定</p>
<h4 id="redis-hset"><a href="#redis-hset" class="headerlink" title="redis hset"></a>redis hset</h4><p>Redis Hset 命令用于为哈希表中的字段赋值 。<br>如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。<br>如果字段已经存在于哈希表中，旧值将被覆盖。<br>hset myhashset key value</p>
<h4 id="redis-list相关"><a href="#redis-list相关" class="headerlink" title="redis list相关"></a>redis list相关</h4><p>往list的右边加一个值<br>rpush mylist value<br>如果列表不存在则新建，如果key不是列表类型，返回错误。<br>lrange mylist  从左边一个一个遍历展示<br>llen mylist 返回长度</p>
<h4 id="noauth-authentication-required"><a href="#noauth-authentication-required" class="headerlink" title="noauth authentication required"></a>noauth authentication required</h4><p>认证问题，需要输入密码<br>auth “password“</p>
<h4 id="keys命令模糊查询"><a href="#keys命令模糊查询" class="headerlink" title="keys命令模糊查询"></a>keys命令模糊查询</h4><p><code>*通配符：keys *hh*</code><br><code>?单个通配符：keys hel？？</code>  忘了最后两个字母<br><code>[]通配符：keys hell[opt]</code>  最后一个字母可能是o p t中的一个</p>
<h4 id="redis-setex命令"><a href="#redis-setex命令" class="headerlink" title="redis setex命令"></a>redis setex命令</h4><p>为指定的key设置值及其过期时间，如果已存在，则替换<br>setex key 10 value   //10s后过期<br>ttl key  //还有多少时间过期</p>
<h4 id="misconf-redis-is-configured-to-save-RDB"><a href="#misconf-redis-is-configured-to-save-RDB" class="headerlink" title="misconf redis is configured to save RDB"></a>misconf redis is configured to save RDB</h4><p>error原因：强制关闭redis快照导致不能持久化<br>解决：config set stop-writes-on-bgsave-error no</p>
<h4 id="Jedis和redisTemplate"><a href="#Jedis和redisTemplate" class="headerlink" title="Jedis和redisTemplate"></a>Jedis和redisTemplate</h4><p>Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。</p>
<p>SpringDataRedis相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用如：SpringCache</p>
<p>jedis连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //连接本地的 Redis 服务</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;);</span><br><span class="line">        System.out.println(&quot;连接成功&quot;);</span><br><span class="line">        //查看服务是否运行</span><br><span class="line">        System.out.println(&quot;服务正在运行: &quot;+jedis.ping());</span><br><span class="line">        long time=0;</span><br><span class="line">        long TestNum=100;</span><br><span class="line">        for(int i=0;i&lt;TestNum;i++)&#123;</span><br><span class="line">            long timeS=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            jedis.set(&quot;jedis-s&quot;+i,&quot;jedis&quot;+i);</span><br><span class="line">            long timeE=System.currentTimeMillis();</span><br><span class="line">            time+=timeE-timeS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;总时间：&quot;+time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redisTemplate连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest(classes = ServiceApplication.class)</span><br><span class="line">public class RedisTemplateTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void T()&#123;</span><br><span class="line">        long time=0;</span><br><span class="line">        long TestNum=100;</span><br><span class="line">        for(int i=0;i&lt;TestNum;i++)&#123;</span><br><span class="line">            long timeS=System.currentTimeMillis();</span><br><span class="line">            redisUtils.set(&quot;RedisTemplateTest&quot;,&quot;redi&quot;+i);</span><br><span class="line">            long timeE=System.currentTimeMillis();</span><br><span class="line">            time+=timeE-timeS;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;总时间：&quot;+time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_37208934/article/details/95201211">https://blog.csdn.net/qq_37208934/article/details/95201211</a></p>
<h4 id="redisTemplate-opsForHash"><a href="#redisTemplate-opsForHash" class="headerlink" title="redisTemplate.opsForHash()"></a>redisTemplate.opsForHash()</h4><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）。</p>
<p>存入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map以map集合的形式添加键值对</span><br><span class="line">&lt;String, String&gt; maps = new HashMap();</span><br><span class="line">maps.put(&quot;1&quot;,&quot;星期一&quot;);</span><br><span class="line">maps.put(&quot;2&quot;,&quot;星期二&quot;);</span><br><span class="line">maps.put(&quot;3&quot;,&quot;星期三&quot;);</span><br><span class="line">maps.put(&quot;4&quot;,&quot;星期四&quot;);</span><br><span class="line">redisTemplate.opsForHash().putAll(&quot;day:week&quot;, maps);</span><br><span class="line"></span><br><span class="line">也可以单个存入：</span><br><span class="line">redisTemplate.opsForHash().put(&quot;redisKey&quot;,&quot;key1&quot;,&quot;value1&quot;);</span><br><span class="line">redisTemplate.opsForHash().put(&quot;redisKey&quot;,&quot;key1&quot;,&quot;value2&quot;);</span><br><span class="line">map中key相同替换value</span><br><span class="line">返回值为void</span><br><span class="line"></span><br><span class="line">获取redisKey对应的map中key对应的值：</span><br><span class="line">Object o = redisTemplate.opsForHash().get(&quot;redisKey&quot;, &quot;key1&quot;);</span><br><span class="line">如果没有返回null</span><br><span class="line"></span><br><span class="line">获取key对应的所有map键值对：</span><br><span class="line">Map hashValue = redisTemplate.opsForHash().entries(&quot;redisKey&quot;);</span><br><span class="line"></span><br><span class="line">获取key对应的map中所有的键：</span><br><span class="line">Set hashValue = redisTemplate.opsForHash().keys(&quot;redisKey&quot;);</span><br><span class="line"></span><br><span class="line">获取key对应的map中所有的值:</span><br><span class="line">List hashValue = redisTemplate.opsForHash().values(&quot;redisKey&quot;);</span><br><span class="line"></span><br><span class="line">判断key对应的map中是否有指定的键:</span><br><span class="line">Boolean aBoolean = redisTemplate.opsForHash().hasKey(&quot;redisKey&quot;, &quot;mapKey&quot;);</span><br><span class="line"></span><br><span class="line">获取key对应的map的长度:</span><br><span class="line">Long hashValue = redisTemplate.opsForHash().size(&quot;redisKey&quot;);</span><br><span class="line"></span><br><span class="line">如果key对应的map不存在，则新增到map中，存在则不新增也不覆盖:</span><br><span class="line">redisTemplate.opsForHash().putIfAbsent(&quot;redisKey&quot;, &quot;mapKey&quot;, &quot;mapValue&quot;);</span><br><span class="line">返回值为Boolean。</span><br><span class="line">这个方法会判断key是否有值，如果没有就直接插入，返回true；如果有值的话就不会插入，返回false。</span><br><span class="line">返回的是是否成功写入了。</span><br><span class="line"></span><br><span class="line">直接以map集合的方式添加key对应的值:</span><br><span class="line">map中key已经存在，覆盖替换</span><br><span class="line">map中key不存在，新增</span><br><span class="line">Map newMap = new HashMap();</span><br><span class="line">newMap.put(&quot;map4&quot;,&quot;map4&quot;);</span><br><span class="line">newMap.put(&quot;map5&quot;,&quot;map5&quot;);</span><br><span class="line">redisTemplate.opsForHash().putAll(&quot;hashValue&quot;,newMap);</span><br><span class="line"></span><br><span class="line">以集合的方式获取map键对应的map值：</span><br><span class="line">List list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;mapKey1&quot;);</span><br><span class="line">list.add(&quot;mapKey2&quot;);</span><br><span class="line">List hashValue = redisTemplate.opsForHash().multiGet(&quot;redisKey&quot;, list);</span><br><span class="line"></span><br><span class="line">获取指定key对应的map集合中，指定键对应的值的长度:</span><br><span class="line">Long aLong = redisTemplate.opsForHash().lengthOfValue(&quot;redisKey&quot;, &quot;mapKey&quot;);</span><br><span class="line"></span><br><span class="line">使redisKey对应的map中，键mapKey对应的值以long1自增:</span><br><span class="line">Long increment = redisTemplate.opsForHash().increment(&quot;redisKey&quot;, &quot;mapKey&quot;, 1);</span><br><span class="line">第三个参数可以是long型，也可以是double型。</span><br><span class="line"></span><br><span class="line">匹配获取键值对：（跟get有啥不同？）</span><br><span class="line">ScanOptions.NONE为获取全部键对</span><br><span class="line">ScanOptions.scanOptions().match(“map1”).build()，匹配获取键位map1的键值对</span><br><span class="line">Cursor&lt;Map.Entry&lt;Object,Object&gt;&gt; cursor = redisTemplate.opsForHash().scan(&quot;hashValue&quot;,ScanOptions.scanOptions().match(&quot;map1&quot;).build());</span><br><span class="line">//Cursor&lt;Map.Entry&lt;Object,Object&gt;&gt; cursor = redisTemplate.opsForHash().scan(&quot;hashValue&quot;,ScanOptions.NONE);</span><br><span class="line">while (cursor.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Object, Object&gt; entry = cursor.next();</span><br><span class="line">    System.out.println(&quot;entry.getKey() = &quot; + entry.getKey());</span><br><span class="line">    System.out.println(&quot;entry.getValue() = &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除key对应的map中的键值对：</span><br><span class="line">Long delete = redisTemplate.opsForHash().delete(&quot;redisKey&quot;, &quot;map1&quot;, &quot;map2&quot;);</span><br><span class="line">删除了两个，可以一个或多个</span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; entries = redisTemplate.opsForHash().entries(&quot;day:week&quot;);</span><br></pre></td></tr></table></figure>

<p>scan:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scan和keys两个命令都是模糊查询，最大的区别就是keys会阻塞，而scan不会阻塞</span><br></pre></td></tr></table></figure>

<p>更多方法：<a href="https://blog.csdn.net/weixin_43167662/article/details/123232840">https://blog.csdn.net/weixin_43167662/article/details/123232840</a></p>
<h4 id="redisTemplate-opsForGeo"><a href="#redisTemplate-opsForGeo" class="headerlink" title="redisTemplate.opsForGeo()"></a>redisTemplate.opsForGeo()</h4><p>redis关于geo位置计算的api。有个key，value相当于<code>map&lt;member, Point&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//首先注入redisTemplate</span><br><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">//将指定的地理空间位置（纬度、经度、名称）添加到指定的key和member中</span><br><span class="line">Long addedNum = redisTemplate.opsForGeo().add(key, new Point(x,y), member);</span><br><span class="line">// key和msg为字符串，Point是springframework.data.geo下的</span><br><span class="line"></span><br><span class="line">//根据key和多个member返回坐标点</span><br><span class="line">List&lt;Point&gt; points = redisTemplate.opsForGeo().position(key, String... members);</span><br><span class="line"></span><br><span class="line">//返回两个给定位置之间的距离，单位参数可以不加</span><br><span class="line">//如果某个member没有，会报空指针错误</span><br><span class="line">Distance distance = redisTemplate.opsForGeo().distance(key,member1,member2, RedisGeoCommands.DistanceUnit.KILOMETERS);</span><br><span class="line">//Distance是springframework.data.geo.matrics包下的</span><br><span class="line"></span><br><span class="line">//以给定的经纬度为中心，返回键包含的位置元素当中，与中心的距离不超过给定最大距离的所有位置元素，并给出所有位置元素与中心的平均距离</span><br><span class="line">//如果某个member没有，也会报错</span><br><span class="line">Circle circle = new Circle(new Point(114.05, 22.55), new Distance(200, Metrics.KILOMETERS));</span><br><span class="line">GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo()</span><br><span class="line">    .radius(&quot;geo&quot;,circle);</span><br><span class="line">----------------</span><br><span class="line">GeoResults: </span><br><span class="line">&#123;averageDistance: 51.367149999999995 KILOMETERS, </span><br><span class="line">results: GeoResult [content: RedisGeoCommands.GeoLocation(name=深圳, point=Point [x=114.049998, y=22.550001]), distance: 3.0E-4 KILOMETERS],GeoResult [content: RedisGeoCommands.GeoLocation(name=广州, point=Point [x=113.270001, y=23.130001]), distance: 102.734 KILOMETERS]&#125;</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">//以给定的经纬度为中心，个数限制为rags的点，距离为distance</span><br><span class="line">RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates().sortAscending().limit(5);</span><br><span class="line">GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = redisTemplate.opsForGeo()</span><br><span class="line">    .radius(&quot;geo&quot;,circle,args);</span><br><span class="line"></span><br><span class="line">//用坐标的member和距离替代上面的circle</span><br><span class="line">Distance distance = new Distance(200,Metrics.KILOMETERS);</span><br><span class="line">RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates().sortAscending().limit(5);</span><br><span class="line">GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;  results = redisTemplate.opsForGeo()</span><br><span class="line">        .radius(&quot;geo&quot;,&quot;深圳&quot;,distance,args);</span><br><span class="line"></span><br><span class="line">//获取距离member坐标指定半径的点</span><br><span class="line">GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;  results = redisTemplate.opsForGeo()</span><br><span class="line">        .radius(key,member,radius); //radius是double类型</span><br><span class="line"></span><br><span class="line">//删除member</span><br><span class="line">Long removeNum = redisTemplate.opsForGeo().remove(key, String... members);</span><br></pre></td></tr></table></figure>

<p>redis的geo实战：<a href="https://blog.csdn.net/weixin_39274753/article/details/107783674">https://blog.csdn.net/weixin_39274753/article/details/107783674</a></p>
<h4 id="可视化工具another-redis"><a href="#可视化工具another-redis" class="headerlink" title="可视化工具another redis"></a>可视化工具another redis</h4><p>下载地址：<a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">https://github.com/qishibo/AnotherRedisDesktopManager/releases</a></p>
<p>连接：输入 地址host , 端口，密钥</p>
<p>可视化：key，服务器版本，使用内存，运行状态，使用到的库等信息</p>
<p>支持三种文本格式，分别是 text,json , unserialize</p>
<p>用法参考：<a href="https://zhuanlan.zhihu.com/p/220209936">https://zhuanlan.zhihu.com/p/220209936</a></p>
<h4 id="redisTemplate-opsForList"><a href="#redisTemplate-opsForList" class="headerlink" title="redisTemplate.opsForList()"></a>redisTemplate.opsForList()</h4><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 2^32-1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取指定范围内的值：</span><br><span class="line">List&lt;Object&gt; res = redisTemplate.opsForList().range(K key, long start, long end)</span><br><span class="line">(&quot;rightList&quot;, 0, -1);  //获取所有值</span><br><span class="line"></span><br><span class="line">获取list长度:</span><br><span class="line">Long res = redisTemplate.opsForList().size(key)</span><br><span class="line"></span><br><span class="line">获取指定位置的值（index从左往右，从0开始）:</span><br><span class="line">Object res = redisTemplate.opsForList().index(key, index)</span><br><span class="line"></span><br><span class="line">移除key中最左的一个值，并返回：</span><br><span class="line">Object res = redisTemplate.opsForList().leftPop(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">指定过期时间后删除key中最左的一个值：</span><br><span class="line">redisTemplate.opsForList().leftPop(&quot;key&quot;,1,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">移除k1中最右的值，并将移除的值插入k2中最左侧：</span><br><span class="line">redisTemplate.opsForList().rightPopAndLeftPush(&quot;key1&quot;, &quot;key2&quot;);</span><br><span class="line">k1和k2不是同一个key时，k1右侧移除，k2左侧插入，k2不存在时则新增一个然后在插入</span><br><span class="line">k1和k2是同一个key时，相当于把最右侧的值移到了最左侧</span><br><span class="line">加定时的：</span><br><span class="line">redisTemplate.opsForList().rightPopAndLeftPush(&quot;list&quot;, &quot;list2&quot;,1,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">从最右侧移除一个值，并返回：</span><br><span class="line">Object res = redisTemplate.opsForList().rightPop(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">左推入：</span><br><span class="line">Long res = redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;a&quot;);</span><br><span class="line"></span><br><span class="line">从集合左边开始在v值后边插入新值v1：</span><br><span class="line">Long res = redisTemplate.opsForList().leftPush(K key, V v, V v1)</span><br><span class="line">有多个v值时，从左边开始查到第一个v值即可，不存在v时，不插入新值v1</span><br><span class="line"></span><br><span class="line">从左边批量插入新值：</span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;j&quot;, &quot;q&quot;, &quot;k&quot;);</span><br><span class="line">Long res = redisTemplate.opsForList().leftPushAll(&quot;list&quot;, strings);</span><br><span class="line"></span><br><span class="line">可变参数插入新值：</span><br><span class="line">leftPushAll(K key, V… values)</span><br><span class="line">redisTemplate.opsForList().leftPushAll(&quot;list&quot;, &quot;j&quot;, &quot;q&quot;, &quot;k&quot;);</span><br><span class="line"></span><br><span class="line">如果key存在，从左边插入新值：</span><br><span class="line">redisTemplate.opsForList().leftPushIfPresent(&quot;list&quot;, &quot;j&quot;);</span><br><span class="line"></span><br><span class="line">右推入略。</span><br><span class="line"></span><br><span class="line">在指定坐标位置插入(替换)新值：</span><br><span class="line">redisTemplate.opsForList().set(&quot;key&quot;,2,&quot;e&quot;);</span><br><span class="line">index不存在，报错（ERR index out of range）</span><br><span class="line">key不存在，报错（ERR no such key）</span><br><span class="line">从左侧插入</span><br><span class="line"></span><br><span class="line">移除从左/右的第一个值为value：</span><br><span class="line">redisTemplate.opsForList().remove(&quot;key&quot;, n, value);</span><br><span class="line">count&gt; 0：删除等于从左到右移动的值的第一个元素；</span><br><span class="line">count&lt; 0：删除等于从右到左移动的值的第一个元素；</span><br><span class="line">count = 0：删除等于value的所有元素。</span><br><span class="line"></span><br><span class="line">trim(K key, long long1, long long2）</span><br><span class="line">截取集合元素，并将其保留为key对应的新值</span><br></pre></td></tr></table></figure>

<p>来自：<a href="https://blog.csdn.net/weixin_43658899/article/details/121040307">https://blog.csdn.net/weixin_43658899/article/details/121040307</a></p>
<h4 id="redisTemplate-opsForValue"><a href="#redisTemplate-opsForValue" class="headerlink" title="redisTemplate.opsForValue()"></a>redisTemplate.opsForValue()</h4><p>普通缓存类型，String</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void set(K key, V value)</span><br><span class="line">新增一个字符串类型的值，key是键，value是值</span><br><span class="line">redisTemplate.opsForValue().set(&quot;stringkey&quot;, &quot;stringvalue&quot;);</span><br><span class="line"></span><br><span class="line">void set(K key, V value, long timeout, TimeUnit unit)</span><br><span class="line">新增一个字符串类型的值，并且设置变量值的过期时间.</span><br><span class="line">redisTemplate.opsForValue().set(&quot;timeoutkey&quot;, &quot;timeoutvalue&quot;, 10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">Boolean setIfAbsent(K key, V value)</span><br><span class="line">如果键不存在则新增,存在则不改变已经有的值。</span><br><span class="line">redisTemplate.opsForValue().setIfAbsent(&quot;newkey&quot;, &quot;newvalue&quot;);</span><br><span class="line"></span><br><span class="line">V get(Object key)</span><br><span class="line">获取key对应的值</span><br><span class="line">redisTemplate.opsForValue().get(&quot;stringkey&quot;);</span><br><span class="line"></span><br><span class="line">String get(K key, long start, long end)</span><br><span class="line">截取key键对应值的字符串，从开始下标位置开始到结束下标的位置(包含结束下标)的字符串。下标从1开始，如果stringkey对应的值为value，那么下面这个方法返回为：al</span><br><span class="line">redisTemplate.opsForValue().get(&quot;stringkey&quot;, 2, 3);</span><br><span class="line"></span><br><span class="line">V getAndSet(K key, V value)</span><br><span class="line">获取原来key键对应的值并重新赋新值</span><br><span class="line">redisTemplate.opsForValue().getAndSet(&quot;stringkey&quot;, &quot;newvalue&quot;);</span><br><span class="line"></span><br><span class="line">Long increment(K key, long delta)</span><br><span class="line">Double increment(K key, double delta) </span><br><span class="line">以增量的方式将值存储在变量中，第二个参数为递增因子</span><br><span class="line">redisTemplate.opsForValue().set(&quot;doublevalue&quot;, 1);</span><br><span class="line">redisTemplate.opsForValue().increment(&quot;doublevalue&quot;, 1.2);//以1.2递增，递增后为2.2</span><br><span class="line">redisTemplate.opsForValue().increment(&quot;doublevalue&quot;, 1);//以1递增，递增后为3.2</span><br><span class="line"></span><br><span class="line">Integer append(K key, String value)</span><br><span class="line">在原有的值基础上新增字符串到末尾</span><br><span class="line">redisTemplate.opsForValue().append(&quot;stringkey&quot;, &quot;appendValue&quot;);</span><br><span class="line"></span><br><span class="line">Long size(K key)</span><br><span class="line">获取指定字符串的长度</span><br><span class="line">Long size = redisTemplate.opsForValue().size(&quot;stringkey&quot;);</span><br></pre></td></tr></table></figure>

<p>来自：<a href="https://blog.csdn.net/xinghui_liu/article/details/120986171">https://blog.csdn.net/xinghui_liu/article/details/120986171</a></p>
<h4 id="redisTemplate基础操作"><a href="#redisTemplate基础操作" class="headerlink" title="redisTemplate基础操作"></a>redisTemplate基础操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定缓存失效时间</span><br><span class="line">Boolean redisTemplate.expire(key, timeout, TimeUnit)</span><br><span class="line"></span><br><span class="line">根据key获取过期时间</span><br><span class="line">Long redisTemplate.getExpire(key, TimeUnit)</span><br><span class="line">返回0代表永久有效</span><br><span class="line"></span><br><span class="line">判断key是否存在</span><br><span class="line">Boolean redisTemplate.hasKey(key)</span><br><span class="line"></span><br><span class="line">删除缓存</span><br><span class="line">public void delete(String... key) &#123;</span><br><span class="line">    if (key != null &amp;&amp; key.length &gt; 0) &#123;</span><br><span class="line">        if (key.length == 1) &#123;</span><br><span class="line">            redisTemplate.delete(key[0]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>shell常规</title>
    <url>/2023/02/20/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/shell/</url>
    <content><![CDATA[<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> !/bin/bash  #表示当前脚本使用的shell解释器为bash</span><br><span class="line">echo &quot;hello!&quot;</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">sum=$(($a+$b))  #注意=前后不能有空格</span><br><span class="line">multi=$(($a*$b))</span><br><span class="line">echo $sum</span><br><span class="line">echo $multi</span><br><span class="line">res=`expr $a \* $b`  #注意\*前后有空格</span><br><span class="line">echo $res</span><br></pre></td></tr></table></figure>

<p>shell用法：<a href="https://blog.csdn.net/weixin_28836875/article/details/113707668">https://blog.csdn.net/weixin_28836875/article/details/113707668</a></p>
<p>expr命令：expr命令计算给定表达式并显示其相应的输出，其被使用用于：基本操作像加法、减法、乘法、除法和模等等整数，求值正则表达式，字符串操作，如子字符串，字符串长度等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加法：expr 12 + 9</span><br><span class="line"></span><br><span class="line">乘法：expr 12 \* 2</span><br></pre></td></tr></table></figure>

<p>对shell脚本中的变量执行操作，注意保存成.sh文件并赋权限755再执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Enter two numbers&quot;</span><br><span class="line">read x </span><br><span class="line">read y</span><br><span class="line">sum=`expr $x + $y`</span><br><span class="line">echo &quot;Sum = $sum&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>spring入门案例</title>
    <url>/2021/08/25/myblog/spring/Spring%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="Spring入门案例"><a href="#Spring入门案例" class="headerlink" title="Spring入门案例"></a>Spring入门案例</h1><h2 id="0-java基础"><a href="#0-java基础" class="headerlink" title="0.java基础"></a>0.java基础</h2><h3 id="a-java版本"><a href="#a-java版本" class="headerlink" title="a.java版本"></a>a.java版本</h3><p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p>
<p>Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。</p>
<blockquote>
<p>Java的三个版本 : JAVASE(标准版),JAVAEE(企业版),JAVAME(微型版).</p>
<p>java是一个平台。他包括了，java语言，java开发环境(jdk)。java有三个版本<br>j2se(标准版),j2ee(企业版),j2me(微型版)<br>不管哪个版本，都是java语言实现的一个框架。之所以要分版本，是因为3个版本是针对不同问题，设计的解决方案。<br>j2EE是java的企业级开发版本，其实换句话说就是用来做web开发的java框架。javaEE通过设定统一的标准来解决web开发的问题，javaEE的接口，抽象类，规定了web开发所需要实现的流程。整个web的开发，有2层，第1层是服务器容器，比如tomcat，weblogic。他们在javaEE的规范下，实现套接字的连接，封装消息等等，第2层是业务，而这一层是你要做的，通过tomcat封装的消息，进行相应的业务处理。服务器容器的开发由大型的产商开发，而我们通常做的开发是在服务器容器上的业务开发，正是sun的javaEE统一了规范(比如用servlet)我们的业务代码，能和comcat进行很好的通讯。</p>
</blockquote>
<p>J2SE是标准版本，J2ME是手机方向的，J2EE是网站开发方向的。</p>
<blockquote>
<p>从JDK 5.0开始 J2EE 改名为 java EE，J2SE 改名为 java SE，J2ME 改名成 java ME.java EE 是java的企业版，主要面向web应用，尤其是企业级开发</p>
</blockquote>
<h3 id="b-jdk版本"><a href="#b-jdk版本" class="headerlink" title="b.jdk版本"></a>b.jdk版本</h3><p>Java Development Kit（JDK）是太阳微系统针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。</p>
<p>作为Java语言的SDK，普通用户并不需要安装JDK来运行Java程序，而只需要安装JRE（Java Runtime Environment）。而程序开发者必须安装JDK来编译、调试程序。</p>
<p>JDK是个Java开发的工具包，Java是门编程语言。</p>
<p>JDK8或者JDK1.8是由于自从JDK1.5/JDK5命名方式改变后遗留的新旧命令方式问题。所以JDK8或者JDK1.8也是同一个东西。</p>
<blockquote>
<p>JDK1.4 正则表达式，异常链，NIO，日志类，XML解析器，XLST转换器<br>JDK1.5 自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环<br>JDK1.6 提供动态语言支持、提供编译API和卫星HTTP服务器API，改进JVM的锁，同步垃圾回收，类加载<br>JDK1.7 提供GI收集器、加强对非Java语言的调用支持（JSR-292,升级类加载架构<br>JDK8 Lambda 表达式、方法引用、默认方法、新工具、Stream API、Date Time API 、Optional 类、Nashorn, JavaScript 引擎<br>JDK9 1、集合加强；2、私有接口方法；3、垃圾收集机制；4、I/O流加强；5、JShell工具<br>JDK10 1、局部变量类型推断；2、线程本地握手；3、GC改进和内存管理；<br>JDK11 1、字符串加强；2、HttClient Api；3、用于 Lambda 参数的局部变量语法；4、ZGC<br>JDK12 1、Switch Expressions；2、Shenandoah GC；<br>JDK13 1、switch优化更新；2、文本块升级；3、重新实现旧版套接字API；4、核心库/java.util中：I18N；5、取消使用未使用的内存<br>JDK14 1、switch优化变更为最终版；2、垃圾回收相关；3、instanceof的模式匹配（预览版）；4、删除了安全库java.security.acl API；5、货币格式（优化）<br>JDK15</p>
</blockquote>
<h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><p>Spring是一个开源框架，Spring是2003年兴起的轻量级java开发框架，它是为了解决企业级开发的复杂性而创建的。Spring的用途不仅限于服务器端的开发，从简单性、可测试性、低耦合的角度而言任何java应用都可以在spring中受益。</p>
<p>简单的来说Spring就是轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。</p>
<blockquote>
<p>javaBean：<br>符合一定规范编写的Java类，不是一种技术，而是一种规范。针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其他的程序员或者框架使用。这些约定包括：getXXX，setXXX，isXXX，addXXX。</p>
</blockquote>
<h3 id="Spring解决什么："><a href="#Spring解决什么：" class="headerlink" title="Spring解决什么："></a>Spring解决什么：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。</span><br><span class="line"></span><br><span class="line">针对上述问题，需要考虑：1.Servlet、Service以及Dao对象的创建时间、创建数量。2.Servlet、Service以及Dao之间的依赖关系。</span><br><span class="line"></span><br><span class="line">spring：</span><br><span class="line">用来处理对象的创建、以及对象之间依赖关系的一个开发框架。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将对象的创建交给它去完成。</span><br></pre></td></tr></table></figure>

<p>非侵入式设计：引入了框架，对现有的类结构没有影响。</p>
<h3 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h3><p>Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，控制正转:对象的创建由我们自己创建)</p>
<p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。</p>
<p><strong>二者区别:</strong><br>控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。<br>依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</p>
<h3 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h3><p>面向切面编程。切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。</p>
<h2 id="2-Mac下spring配置"><a href="#2-Mac下spring配置" class="headerlink" title="2.Mac下spring配置"></a>2.Mac下spring配置</h2><p>配置Spring不管在哪个环境下都是大同小异，下载Spring-framework，解压缩，然后导入使用的项目即可。</p>
<p>spring3.x与jdk1.7兼容，spring4.x与jdk1.8才兼容，IDEA默认下的JDK使用1.8版本。</p>
<blockquote>
<p>直接通过IDEA创建项目选择spring模版<br>发现：没有spring模板，打开设置-&gt;plugins-&gt;搜索spring assistant-&gt;安装后重启</p>
<p>依然没有，没法了</p>
</blockquote>
<p>![image-20210825183129555](/Users/liuxuan14/Library/Application Support/typora-user-images/image-20210825183129555.png)</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。Spring Boot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>Spring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<h2 id="新建spring工程"><a href="#新建spring工程" class="headerlink" title="新建spring工程"></a>新建spring工程</h2><p>idea新建maven工程，选择模版maven-archetype-quikstart，依赖：spring-core、spring-beans、spring-context。</p>
<p>archetype的意思就是模板原型的意思，原型是一个Maven项目模板工具包。</p>
<p>maven-archetype-quickstart：在这个项目里，除了pom.xml外，没有其他的xml了，但是有main、test两个包，包里放了一个App、AppTest类。</p>
<p>maven-archetype-webapp：在这个项目里，有WEB-INF目录，并且有web.xml和一个index.jsp。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>shellのleecode</title>
    <url>/2022/02/15/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/shell%E5%88%B7%E9%A2%981/</url>
    <content><![CDATA[<h2 id="193-有效的电话号码"><a href="#193-有效的电话号码" class="headerlink" title="193.有效的电话号码"></a>193.有效的电话号码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。</span><br><span class="line"></span><br><span class="line">你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</span><br><span class="line"></span><br><span class="line">你也可以假设每行前后没有多余的空格字符。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">假设 file.txt 内容如下：</span><br><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br><span class="line">你的脚本应当输出下列有效的电话号码：</span><br><span class="line">987-123-4567</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<p>匹配符合规则的字符串，所以使用正则表达式来检索符合要求的字符串即可。需要用正则表达式中的普通字符、特殊字符、限定符、定位符来描述对应的规律。</p>
<p>正则表达式的重点有三：特殊字符、限定字符、定位符<br>特殊字符：勿忘加上转义符’&#39;<br>限定字符：限定字符出现的次数，掌握它也就get了精华<br>定位符：字面意思</p>
<p>表达 (xxx) xxx-xxxx 的正则：<br><code>^\([0-9][0-9][0-9]\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</code><br>优化：<code>^\([0-9]&#123;3&#125;\) [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</code></p>
<p>表达 xxx-xxx-xxxx 的正则：<br><code>^[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</code><br>优化：<code>^[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</code></p>
<p>同时表示xxx-xxx-xxxx和 (xxx) xxx-xxxx 的正则：<br>使用特殊字符()和|。用最外面一个()来标记一个表达式，使用|来指明两项之间的任意选择。<br><code>^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</code><br>使用grep -p的话，-P 使用 Perl 拓展正则，主要是为了支持\d匹配数字。<br><code>grep -P &#39;^(\(\d&#123;3&#125;\) |\d&#123;3&#125;-)\d&#123;3&#125;-\d&#123;4&#125;$&#39; file.txt</code></p>
<p>最终：<br><code>grep -P &#39;^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#39; file.txt</code><br>或<br><code>awk &#39;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/&#39; file.txt</code><br>或<br><code>gawk &#39;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/&#39; file.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">限定符	表达含义</span><br><span class="line">*	出现次数&gt;=0</span><br><span class="line">+	出现次数&gt;=1</span><br><span class="line">?	出现次数 0 or 1, 等价&#123;0,1&#125;</span><br><span class="line">&#123;n&#125;	出现次数=n</span><br><span class="line">&#123;n,&#125;	出现次数&gt;=n</span><br><span class="line">&#123;n, m&#125;	n=&lt; 出现次数&lt;= m</span><br><span class="line"></span><br><span class="line">定位符	表达含义</span><br><span class="line">^	字符串开始的位置</span><br><span class="line">$	字符串结束的位置</span><br><span class="line">\b	限定单词(字)的字符，常用来确定一个单词，可以结合两个‘\b’使用</span><br><span class="line">\B	限定非单词(字)边界的字符，用的很少</span><br></pre></td></tr></table></figure>


<h2 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192. 统计词频"></a>192. 统计词频</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。</span><br><span class="line">为了简单起见，你可以假设：</span><br><span class="line">words.txt只包括小写字母和 &#x27; &#x27; 。</span><br><span class="line">每个单词只由小写字母组成。</span><br><span class="line">单词间由一个或多个空格字符分隔。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br><span class="line">输出：</span><br><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure>

<p><code>cat words.txt | tr -s &#39; &#39; &#39;\n&#39; | sort | uniq -c | sort -r | awk &#39;&#123; print $2, $1 &#125;&#39;</code></p>
<p>1️⃣切割：句子变为单词<br>tr 命令用于转换或删除文件中的字符<br>-s：缩减连续重复的字符成指定的单个字符</p>
<p>2️⃣排序单词<br>sort命令即可</p>
<p>3️⃣统计单词出现次数<br>uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。<br>-c：在每列旁边显示该行重复出现的次数。</p>
<p>4️⃣排序单词出现次数<br>sort -r：以相反的顺序来排序<br>-n 按数字排序</p>
<p>5️⃣打印<br>awk ‘{print $2, $1}’</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leecode</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite</title>
    <url>/2022/12/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/sqlite/</url>
    <content><![CDATA[<h2 id="什么是sqlite"><a href="#什么是sqlite" class="headerlink" title="什么是sqlite"></a>什么是sqlite</h2><p>SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。</p>
<p>它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p>
<hr>
<p>sqlite的优点：</p>
<p>&lt;1&gt; 不需要一个单独的服务器进程或操作的系统（无服务器的）<br>&lt;2&gt; SQLite 不需要配置，这意味着不需要安装或管理。<br>&lt;3&gt; 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。<br>&lt;4&gt; SQLite 是非常小的，是轻量级的，完全配置时小于 400KB<br>&lt;5&gt; SQLite 是自给自足的，这意味着不需要任何外部的依赖。<br>&lt;6&gt; SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</p>
<h2 id="安装sqlite"><a href="#安装sqlite" class="headerlink" title="安装sqlite"></a>安装sqlite</h2><p>linux和macOS，基本都系统预装了。<br>输入<code>sqlite3</code>检查是否安装。</p>
<p>如果未安装，下载网址：<a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a><br>下载<code>sqlite-autoconf-*.tar.gz。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xvzf sqlite-autoconf-3071502.tar.gz</span><br><span class="line">$ cd sqlite-autoconf-3071502</span><br><span class="line">$ ./configure --prefix=/usr/local</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h2 id="sqlite命令"><a href="#sqlite命令" class="headerlink" title="sqlite命令"></a>sqlite命令</h2><p><code>.show </code>命名，查看 SQLite 命令提示符的默认设置。</p>
<p>更改配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt;.header on    </span><br><span class="line">sqlite&gt;.mode column</span><br><span class="line">sqlite&gt;.timer on</span><br></pre></td></tr></table></figure>

<p>创建数据库：<br><code>$ sqlite3 DatabaseName.db </code> 或 <code>sqlite&gt;.open test.db </code></p>
<p>创建的数据库文件位于 sqlite3 命令同一目录下。<br>打开已存在数据库也是用 .open 命令，以上命令如果 test.db 存在则直接会打开，不存在就创建它。</p>
<p><code>.databases</code> 展示数据库列表<br><code>.quit</code> 退出<br><code>testDB.db .dump &gt; testDB.sql</code> 导出完整的数据库到文本文件中<br><code>testDB.db &lt; testDB.sql</code> 恢复db文件</p>
<p><code>attach database file_name AS database_name;</code> 将同一文件夹下的db文件附加进来，并给个别名。<br>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加。</p>
<p><code>detach database &#39;database_name&#39;;</code> 断开给定名称的连接，而其余的仍然有效</p>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE database_name.table_name(</span><br><span class="line">   ID INT PRIMARY KEY     NOT NULL,</span><br><span class="line">   NAME           TEXT    NOT NULL,</span><br><span class="line">   AGE            INT     NOT NULL,</span><br><span class="line">   ADDRESS        CHAR(50),</span><br><span class="line">   SALARY         REAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>.tables</code> 查看创建的表</p>
<p><code>.schema tableName</code> 得到表的完整信息（建表语句）</p>
<h2 id="java使用sqlite"><a href="#java使用sqlite" class="headerlink" title="java使用sqlite"></a>java使用sqlite</h2><p>SQLite相比大多数数据库而言，具有免安装等优势，广泛应用于测试、Android等领域。通过一个.db文件就能实现数据库连接、DDL操作语句、DML命令。</p>
<p>导入<code>sqlite-jdbc</code>依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.xerial&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.40.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>软件：DB Browser for SQLite</p>
<p>sqlite没有像mysql使用comment增加字段/表名注释，使用–注释内容。</p>
<p>✅建表、插入、查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.liuxuan.service;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-01-20 09:41</span><br><span class="line"> **/</span><br><span class="line">@Service</span><br><span class="line">public class SqliteService &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;/Users/liuxuan/Downloads/test.db&quot;;</span><br><span class="line">        Connection conn = createConnection(filePath);</span><br><span class="line">        // 创建表</span><br><span class="line">        String query = &quot;create table if not exists table_test (\n&quot; +</span><br><span class="line">                &quot;id integer PRIMARY KEY AUTOINCREMENT,\n&quot; +</span><br><span class="line">                &quot;num INTEGER(11),\n&quot; +</span><br><span class="line">                &quot;`desc` varchar(10) not null);&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            stmt.executeUpdate(query);</span><br><span class="line">            stmt.close();</span><br><span class="line">//            conn.commit();</span><br><span class="line">//            conn.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;建立表存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 插入数据</span><br><span class="line">        String sql = &quot;insert into table_test (num, desc) &quot; +</span><br><span class="line">                &quot;values(1, &#x27;one&#x27;);&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            stmt.executeUpdate(sql);</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;插入数据存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 查询数据</span><br><span class="line">        try &#123;</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            ResultSet rs = stmt.executeQuery( &quot;SELECT * FROM table_test;&quot; );</span><br><span class="line">            while (rs.next() ) &#123;</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                int num = rs.getInt(&quot;num&quot;);</span><br><span class="line">                String desc = rs.getString(&quot;desc&quot;);</span><br><span class="line">                System.out.println(id + &quot;,&quot; + num + &quot;,&quot; + desc);</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;查询数据存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 分页查询 用commons-dbutils包下的QueryRunner</span><br><span class="line">        String selectSql = &quot;select * from table_test&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;SqliteDO&gt; list = selectList(selectSql, conn, SqliteDO.class, 1, 10);</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            System.out.println(&quot;查询数据list存在异常！&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据库连接</span><br><span class="line">     **/</span><br><span class="line">    public static Connection createConnection(String filePath) &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class.forName(&quot;org.sqlite.JDBC&quot;);</span><br><span class="line">            conn = DriverManager.getConnection(String.format(&quot;jdbc:sqlite:%s&quot;, filePath));</span><br><span class="line">        &#125;catch(ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(&quot;不存在sqlite驱动包！&quot;);</span><br><span class="line">        &#125;catch (SQLException e)&#123;</span><br><span class="line">            System.out.println(&quot;与sqlite数据库连接失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; selectList(String sql, Connection connection, Class&lt;T&gt;objType, int currentPage, int pageSize) throws SQLException &#123;</span><br><span class="line">        sql = sql + &quot; limit ?,?&quot;;</span><br><span class="line">        QueryRunner queryRunner = new QueryRunner();</span><br><span class="line">        List&lt;T&gt; dataList = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(objType), pageSize * (currentPage - 1), pageSize);</span><br><span class="line">        return dataList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class SqliteDO &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private Integer num;</span><br><span class="line">        private String desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程安全</p>
<p>sqlite是线程安全的，可以多线程插入。</p>
<p>✅sqlite在java中批量插入数据巨慢</p>
<p>开始是插入一条就构造一条insert语句，一条一条插入，慢。<br>后来改成多线程插入，还是慢。<br>再后来，一条insert语句插入1000条，快了很多。</p>
<p>一个说事务控制批量插入的：<br><a href="https://www.cnblogs.com/xiao-tangyuan/p/9556114.html">https://www.cnblogs.com/xiao-tangyuan/p/9556114.html</a></p>
<hr>
<p>SQLite——Java使用：<br><a href="https://blog.csdn.net/qq_38322527/article/details/125717093">https://blog.csdn.net/qq_38322527/article/details/125717093</a></p>
<p>SQLite数据库基本使用（Java）：<br><a href="https://blog.csdn.net/weixin_44102521/article/details/119884521">https://blog.csdn.net/weixin_44102521/article/details/119884521</a></p>
<p>查询获取list：<br><a href="https://m.runoob.com/sqlite/sqlite-java.html?ivk_sa=1024320u">https://m.runoob.com/sqlite/sqlite-java.html?ivk_sa=1024320u</a></p>
<p>sqlite没有comment：<br><a href="https://blog.csdn.net/qinxu0611/article/details/128609756">https://blog.csdn.net/qinxu0611/article/details/128609756</a></p>
<p>SQLite 线程安全和并发：<br><a href="https://www.cnblogs.com/feng9exe/p/10682567.html">https://www.cnblogs.com/feng9exe/p/10682567.html</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn和mapreduce模型</title>
    <url>/2022/04/23/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/yarn%E5%92%8Cmapreduce/</url>
    <content><![CDATA[<h3 id="mapreduce"><a href="#mapreduce" class="headerlink" title="mapreduce"></a>mapreduce</h3><p>谷歌三剑客：GFS（高富帅）、bigtable、mapreduce（名人）</p>
<p>层次：GFS最底层文件系统、在往上是BigTable文件模型、再往上是算法MapReduce</p>
<p>map：拆解<br>reduce：组合</p>
<p>mapreduce类似于赛百味：得到数据（input）、切分（split）、把数据归类（map）、组装（shuffle）、交付（reduce）</p>
<p>例子：mapreduce做单词出现数的统计，每个步骤都是并行的过程。</p>
<p><img src="https://img-blog.csdnimg.cn/f7410910fe5e4976b6496ee312260cf4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="tu"></p>
<p>例子：mapreduce实现倒排索引，记录每个单词出现的位置<br><img src="https://img-blog.csdnimg.cn/55a12ac4d4a949d18ebc39338fdb0a39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>mapreduce架构：<br>首先是用户进程（user program）协调和定义程序怎么运行，负责拆解worker，其中一个master worker（作为用户的代理来协调整个过程）。</p>
<p><img src="https://img-blog.csdnimg.cn/6e02cd00a6b543d9bed5d582a23af7f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>mapreduce本质就是分支法。</p>
<h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><p>另一种资源协调者，hadoop1.x中负责资源管理的是一JobTracker。</p>
<p>yarn负责大数据计算中的：资源管理、程序调度。</p>
<p>主要由两个核心部分构成：ResourceManager（统揽全局）、NodeManager（管理每个计算机节点上的资源调度）<br>ResourceManager中有两个部分：ApplicationManager、ResourceScheduler</p>
<p>1.作业提交阶段：client向整个集群提交job，申请job_id，ResourceManager返回job资源提交路径和job_id，client收到后发送jar包到指定路径HDFS。client提交后向ResourceManager提交执行请求，ResourceManager创建一个ApplicationManager来管理这个job。</p>
<p>2.作业初始化阶段：ApplicationManager将job提交到ResourceScheduler中，ResourceScheduler维护一个job队列，等待执行。可以执行时，ResourceScheduler通知ApplicationManager有一个NodeManager可以执行job。ApplicationManager在NodeManager中开辟容器Container，Container中启动ApplicationMaster，ApplicationMaster获取HDFS上的文件，生成Task（可以是mapTask，也可以是reduceTask）。</p>
<p>3.任务分配阶段：ApplicationMaster向ResourceManager申请运行Task的任务资源，ResourceManager将Task任务分配给空闲的NodeManager，NodeManager创建用于执行Task的容器Container。</p>
<p>4.任务运行阶段：ApplicationMaster通知所有接收到Task计算任务的NodeManager启动计算，NodeManager进行计算。执行完成后，向ResourceManager申请Container运行新的Task。所有的Task执行完毕后，ApplicationMaster向ResourceManager申请注销自己。</p>
<p>5.作业完成阶段：框架更新任务的进度和状态。</p>
<p><img src="https://img-blog.csdnimg.cn/9d376a8d36394947951162090fcd08a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1Pa4y1t7nf?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1Pa4y1t7nf?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p>
<h3 id="mapreduce与yarn"><a href="#mapreduce与yarn" class="headerlink" title="mapreduce与yarn"></a>mapreduce与yarn</h3><p>mapreduce的流程：</p>
<p>1.首先用户程序 (JobClient) 提交了一个 job，job 的信息会发送到 Job Tracker 中，Job Tracker 是 Map-reduce 框架的中心，他需要与集群中的机器定时通信 (heartbeat), 需要管理哪些程序应该跑在哪些机器上，需要管理所有 job 失败、重启等操作，需要分配在每个 TaskTracker 上运行的 map 和 reduce 任务。</p>
<p>2.TaskTracker 是 Map-reduce 集群中每台机器都有的一个部分，他做的事情主要是监视自己所在机器的资源情况。 </p>
<p>3.TaskTracker 同时监视当前机器的 tasks 运行状况。TaskTracker 需要把这些信息通过 heartbeat 发送给 JobTracker，JobTracker 会搜集这些信息以给新提交的 job 分配运行在哪些机器上。上图虚线箭头就是表示消息的发送 - 接收的过程。</p>
<hr>
<p>MapReduce存在的问题：</p>
<p>1.JobTracker 是 Map-reduce 的集中处理点，存在单点故障。</p>
<p>2.JobTracker 完成了太多的任务，造成了过多的资源消耗，当 map-reduce job 非常多的时候，会造成很大的内存开销，潜在来说，也增加了 JobTracker fail 的风险，这也是业界普遍总结出老 Hadoop 的 Map-Reduce 只能支持 4000 节点主机的上限。</p>
<p>3.在 TaskTracker 端，以 map/reduce task 的数目作为资源的表示过于简单，没有考虑到 cpu/ 内存的占用情况，如果两个大内存消耗的 task 被调度到了一块，很容易出现 OOM (内存溢出：需要的内存空间大于系统分配的内存空间)。</p>
<p>4.在 TaskTracker 端，把资源强制划分为 map task slot 和 reduce task slot, 如果当系统中只有 map task 或者只有 reduce task 的时候，会造成资源的浪费，也就是前面提过的集群资源利用的问题。</p>
<p>5.源代码层面分析的时候，会发现代码非常的难读，常常因为一个 class 做了太多的事情，代码量达 3000 多行，，造成 class 的任务不清晰，增加 bug 修复和版本维护的难度。</p>
<p>6.从操作的角度来看，现在的 Hadoop MapReduce 框架在有任何重要的或者不重要的变化 ( 例如 bug 修复，性能提升和特性化 ) 时，都会强制进行系统级别的升级更新。更糟的是，它不管用户的喜好，强制让分布式集群系统的每一个用户端同时更新。这些更新会让用户为了验证他们之前的应用程序是不是适用新的 Hadoop 版本而浪费大量时间。</p>
<p>总结：从业界使用分布式系统的变化趋势和 hadoop 框架的长远发展来看，MapReduce 的 JobTracker/TaskTracker 机制需要大规模的调整来修复它在可扩展性，内存消耗，线程模型，可靠性和性能上的缺陷。</p>
<hr>
<p>yarn：</p>
<p>从 0.23.0 版本开始，Hadoop 的 MapReduce 框架完全重构，发生了根本的变化。新的 Hadoop MapReduce 框架命名为 MapReduceV2 或者叫 Yarn。</p>
<p>重构根本的思想是将 JobTracker 两个主要的功能分离成单独的组件，这两个功能是资源管理和任务调度 / 监控。新的ResourceManager 资源管理器全局管理所有应用程序计算资源的分配，每一个应用的 ApplicationMaster 负责相应的调度和协调。一个应用程序无非是一个单独的传统的 MapReduce 任务或者是一个 DAG( 有向无环图 ) 任务。ResourceManager 和每一台机器的节点管理服务器能够管理用户在那台机器上的进程并能对计算进行组织。</p>
<p>老的MapReduce主要包括Job Tracker和Task Tracker，YARN中主要是三个组件：Resource Manager、Node Manager和Application Master。Resource Manager负责全局资源分配，Application Master每个节点（job？）一个，负责当前节点的调度和协调。Node Manager是每台机器的代理，监控应用程序的资源使用情况，并汇报给Resource Manager。因此与老的MapReduce相比，YARN把资源管理与任务调度的工作分离开来，减少了MapReduce中Job Tracker的压力。</p>
<p>ResourceManager：是一个中心的服务，它做的事情是调度、启动每一个 Job 所属的 ApplicationMaster、另外监控 ApplicationMaster 的存在情况。ResourceManager 负责作业与资源的调度。接收 JobSubmitter 提交的作业，按照作业的上下文 (Context) 信息，以及从 NodeManager 收集来的状态信息，启动调度过程，分配一个 Container 作为 App Mstr.</p>
<p>NodeManager：功能比较专一，就是负责 Container 状态的维护，并向 RM 保持心跳。</p>
<p>ApplicationMaster：负责一个 Job 生命周期内的所有工作，类似老的框架中 JobTracker。但注意每一个 Job（不是每一种）都有一个 ApplicationMaster，它可以运行在 ResourceManager 以外的机器上。</p>
<hr>
<p>yarn的优势：</p>
<p>1 YARN大大减少了Job Tracker的资源消耗，并且让监测每个Job子任务状态的程序分布式化了。<br>2 YARN中Application Master是一个可变更部分，用户可以对不同编程模型编写自己的AppMst，让更多类型的编程模型能跑在Hadoop集群中。<br>3 老的框架中，Job Tracker一个很大的负担就是监控Job下任务的运行状况，现在由Application Master去做，而Resource Manager是监测Application Master的运行状况，如果出问题，会将其在其他机器上重启。</p>
<p>出处：<br><a href="https://www.jianshu.com/p/9523999e13cf">https://www.jianshu.com/p/9523999e13cf</a><br><a href="https://blog.csdn.net/hahachenchen789/article/details/80527706">https://blog.csdn.net/hahachenchen789/article/details/80527706</a></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/11/27/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是用工厂方法代替new操作的一种模式。例如，Executors创建线程池ExecutorService的方法，就是工厂模式。</p>
<p>工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A()，工厂模式也是用来创建实例对象。使用工厂模式创建实例对象，会给你系统带来更大的可扩展性和尽量少的修改量（降低耦合）。</p>
<h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>简单工厂模式不属于GOF的23种经典设计模式，相当于一种编程习惯。</p>
<p>简单工厂模式包含如下三种角色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象产品：定义了产品的规范，描述了产品的主要特性和功能。（可以是接口）</span><br><span class="line">具体产品：实现或者继承抽象产品的子类。</span><br><span class="line">具体工厂：提供了创建产品的方法，使用者通过该方法来获取产品。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在工厂方法中根据类型创建不同的具体对象</span><br><span class="line">**/</span><br><span class="line">public class SimpleCoffeeFactory &#123;</span><br><span class="line">	// 根据type判断类型，实例化并返回对应对象</span><br><span class="line">    public Coffee createCoffee(String type) &#123;</span><br><span class="line">        Coffee coffee = null;</span><br><span class="line">        if(&quot;americano&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new AmericanoCoffee();</span><br><span class="line">        &#125; else if(&quot;latte&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂处理创建对象的细节，一旦有了工厂，后期如果需要对象直接从工厂中获取即可。这样也就解除了和实现类的耦合，不需要关注创建对象的细节，但同时又产生了新的耦合。后期如果再添加新的类，就必须修改工厂类的代码，违反了开闭原则。</p>
<hr>
<p>静态工厂模式：在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleCoffeeFactory &#123;</span><br><span class="line">    public static Coffee createCoffee(String type) &#123;</span><br><span class="line">        Coffee coffee = null;</span><br><span class="line">        if(&quot;americano&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new AmericanoCoffee();</span><br><span class="line">        &#125; else if(&quot;latte&quot;.equals(type)) &#123;</span><br><span class="line">            coffee = new LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        return coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>针对简单工厂模式的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<p>工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂、具体工厂、抽象产品、具体产品。</p>
<p>四个角色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</span><br><span class="line">具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</span><br><span class="line">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 抽象工厂</span><br><span class="line">**/</span><br><span class="line">public interface CoffeeFactory &#123;</span><br><span class="line">    Coffee createCoffee();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 具体工厂</span><br><span class="line">* </span><br><span class="line">* 抽象产品为coffee，具体产品为LatteCoffee和AmericanCoffee</span><br><span class="line">* 这种工厂模式可以通过不同的具体工厂创建出不同的具体产品</span><br><span class="line">**/</span><br><span class="line">public class LatteCoffeeFactory implements CoffeeFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AmericanCoffeeFactory implements CoffeeFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要增加产品类时不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点，但要相应地增加工厂类。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>优点：<br>在获取对象时只需要知道具体工厂的名称就可以得到对应的对象，无须知道具体创建过程；在系统增加新的类时只需要添加对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
<p>缺点：<br>每增加一个类就要增加一个对应的具体工厂类，增加了系统的复杂度。</p>
<h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）隶属于设计模式中的创建型模式，用于产品族的构建。抽象工厂是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂是指当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体情况下，创建<strong>多个产品族</strong>中的产品对象。</p>
<p>工厂模式中的每一个形态都是针对一定问题的解决方案，工厂方法针对的是多个产品系列结构；而抽象工厂模式针对的是多个产品族结构，一个产品族内有多个产品系列。</p>
<p>抽象工厂模式的主要角色如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</span><br><span class="line">具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class="line">抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class="line">具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 抽象工厂</span><br><span class="line">**/</span><br><span class="line">public interface DessertFactory &#123;</span><br><span class="line">    Coffee createCoffee();</span><br><span class="line">    Dessert createDessert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 具体工厂</span><br><span class="line">**/</span><br><span class="line">public class AmericanDessertFactory implements DessertFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new MatchaMousse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ItalyDessertFactory implements DessertFactory &#123;</span><br><span class="line">    public Coffee createCoffee() &#123;</span><br><span class="line">        return new LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">    public Dessert createDessert() &#123;</span><br><span class="line">        return new Tiramisu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h3 id="四、模式扩展（简单工厂-配置文件解除耦合）"><a href="#四、模式扩展（简单工厂-配置文件解除耦合）" class="headerlink" title="四、模式扩展（简单工厂+配置文件解除耦合）"></a>四、模式扩展（简单工厂+配置文件解除耦合）</h3><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接获取即可。</p>
<p>创建配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">american=cn.com.supercoder.pattern.AmericanCoffee</span><br><span class="line">latte=cn.com.supercoder.pattern.LatteCoffee</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CoffeeFactory &#123;</span><br><span class="line">    private static Map&lt;String,Coffee&gt; map = new HashMap();</span><br><span class="line">    // 加载配置文件</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties p = new Properties();</span><br><span class="line">        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            // 遍历Properties集合对象</span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            for (Object key : keys) &#123;</span><br><span class="line">                // 根据键获取值（全类名）</span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                // 获取Class对象</span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                // 实例化对象</span><br><span class="line">                Coffee obj = (Coffee) clazz.newInstance();</span><br><span class="line">                // 将对象以键值对的形式存入map</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 获取对象时直接根据配置文件中的key获取对应的对象</span><br><span class="line">	**/</span><br><span class="line">    public static Coffee createCoffee(String name) &#123;</span><br><span class="line">        return map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a href="https://blog.csdn.net/qq_45867375/article/details/124597130">https://blog.csdn.net/qq_45867375/article/details/124597130</a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发压测工具</title>
    <url>/2021/08/19/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="1-ab压测工具"><a href="#1-ab压测工具" class="headerlink" title="1.ab压测工具"></a>1.ab压测工具</h2><p>ab是apache自带的压力测试工具。ab进行的一切测试本质上是基于HTTP的。</p>
<h3 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h3><p>yum -y install httpd-tools</p>
<p>版本信息：ab -V</p>
<p>ab -n1000 -c100 <a href="https://www.imooc.com/">https://www.imooc.com/</a>   请求1000次,每次并发100;</p>
<h3 id="输出信息说明"><a href="#输出信息说明" class="headerlink" title="输出信息说明"></a>输出信息说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server Software:        web服务器软件及版本</span><br><span class="line">Server Hostname:        表示请求的URL中的主机部分名称</span><br><span class="line">Server Port:            被测试的Web服务器的监听端口</span><br><span class="line"> </span><br><span class="line">Document Path:          请求的页面路径</span><br><span class="line">Document Length:        页面大小</span><br><span class="line"> </span><br><span class="line">Concurrency Level:      并发数</span><br><span class="line">Time taken for tests:   测试总共花费的时间</span><br><span class="line">Complete requests:      完成的请求数</span><br><span class="line">Failed requests:        失败的请求数，这里的失败是指请求的连接服务器、发送数据、接收数据等环节发生异常，以及无响应后超时的情况。对于超时时间的设置可以用ab的-t参数。如果接受到的http响应数据的头信息中含有2xx以外的状态码，则会在测试结果显示另一个名为“Non-2xx responses”的统计项，用于统计这部分请求数，这些请求并不算是失败的请求。</span><br><span class="line">Write errors:           写入错误</span><br><span class="line">Total transferred:      总共传输字节数，包含http的头信息等。使用ab的-v参数即可查看详细的http头信息。</span><br><span class="line">HTML transferred:       html字节数，实际的页面传递字节数。也就是减去了Total transferred中http响应数据中头信息的长度。</span><br><span class="line">Requests per second:    每秒处理的请求数，服务器的吞吐量，等于：Complete requests / Time taken for tests</span><br><span class="line">Time per request:       平均数，用户平均请求等待时间</span><br><span class="line">Time per request:       服务器平均处理时间</span><br><span class="line">Transfer rate:          平均传输速率（每秒收到的速率）。可以很好的说明服务器在处理能力达到限制时，其出口带宽的需求量。</span><br><span class="line"> </span><br><span class="line">Connection Times (ms)	压力测试时的连接处理时间。</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0   67 398.4      9    3009			</span><br><span class="line">Processing:    49 2904 2327.2   2755   12115</span><br><span class="line">Waiting:       48 2539 2075.1   2418   12110</span><br><span class="line">Total:         53 2972 2385.3   2789   12119</span><br></pre></td></tr></table></figure>

<p>Connect 无法送出要求、目标主机连接失败、要求的过程中被中断。<br>Length 响应的内容长度不一致 ( 以 Content-Length 头值为判断依据 )。<br>Exception 发生无法预期的错误。 </p>
<h3 id="发生错误"><a href="#发生错误" class="headerlink" title="发生错误"></a>发生错误</h3><p>并发大时：apr_socket_recv: Connection reset by peer (104)</p>
<p>解决：ab -n 100000 -c20000 <strong>-r <a href="http://xxxxurl/">http://xxxxurl/</a></strong></p>
<h2 id="2-charles"><a href="#2-charles" class="headerlink" title="2.charles"></a>2.charles</h2><p>使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。<br><a href="https://blog.csdn.net/linjpg/article/details/77839281">https://blog.csdn.net/linjpg/article/details/77839281</a></p>
<p>参考:</p>
<p><a href="https://blog.csdn.net/feiwutudou/article/details/80334099">https://blog.csdn.net/feiwutudou/article/details/80334099</a></p>
<p><a href="https://blog.csdn.net/weixin_34381666/article/details/91546268">https://blog.csdn.net/weixin_34381666/article/details/91546268</a></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>demo上传到github</title>
    <url>/2022/04/05/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
    <content><![CDATA[<h4 id="1-看一下与github的连接"><a href="#1-看一下与github的连接" class="headerlink" title="1.看一下与github的连接"></a>1.看一下与github的连接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没安装git的话，brew install git 安装一下</span><br><span class="line"></span><br><span class="line">设置ssh：</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br><span class="line">~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key，添加到github</span><br><span class="line"></span><br><span class="line">验证连接：ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">设置用户名和邮箱：</span><br><span class="line">git config --global user.name &quot;jadeliuliu&quot;</span><br><span class="line">git config --global user.email &quot;xxxxx@163.com&quot;</span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<h4 id="2-代码push到github"><a href="#2-代码push到github" class="headerlink" title="2.代码push到github"></a>2.代码push到github</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init  初始化该文件夹</span><br><span class="line">git add</span><br><span class="line">git commit 这样已经将要更改的文件提交到版本库中，但是呢还没有真正提交到网站上去</span><br><span class="line">github新建仓库</span><br><span class="line">关联github仓库：</span><br><span class="line">git remote add origin git@github.com:用户名/仓库名.git</span><br><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br><span class="line">上面的两个命令结果一样，只是协议不一样，第一个速度会比较快。只是第一次提交项目时需要</span><br><span class="line">git push -u origin master 提交到github</span><br></pre></td></tr></table></figure>

<h4 id="3-git中使用ssh和http协议的区别"><a href="#3-git中使用ssh和http协议的区别" class="headerlink" title="3.git中使用ssh和http协议的区别"></a>3.git中使用ssh和http协议的区别</h4><p>git可以使用四种主要的协议来传输资料: 本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 git 协议。其中，本地协议由于目前大都是进行远程开发和共享代码所以一般不常用，而git协议由于缺乏授权机制且较难架设所以也不常用。</p>
<p>最常用的便是SSH和HTTP(S)协议。git关联远程仓库可以使用http协议或者ssh协议。</p>
<p><strong>【优缺点】</strong></p>
<p><strong>ssh：</strong></p>
<ul>
<li>一般使用22端口；</li>
<li>通过先在本地生成SSH密钥对再把公钥上传到服务器；</li>
<li>速度相较慢点</li>
</ul>
<p><strong>https：</strong></p>
<ul>
<li>一般使用443端口；</li>
<li>通过用户名/密码授权，可用性比较高；</li>
<li>速度相较快点</li>
</ul>
<p>一般企业防火墙会打开80和443这两个http/https协议的端口，因此在架设了企业防火墙的时候使用http就可以很好的绕开安全限制使用git了，很方便；而对于ssh来说，企业防火墙很可能没打开22端口。</p>
<p><strong>【使用区别】</strong></p>
<p><strong>clone项目：</strong></p>
<p>　　**使用ssh方式时，需要配置ssh key，即要将生成的SSH密钥对的公钥上传至服务器；<br>**</p>
<p>　　<strong>使用http方式时，没有要求，可以直接克隆下来。</strong></p>
<p><strong>push项目：</strong></p>
<p>　　<strong>使用ssh方式时，不需要验证用户名和密码，*<em>**之前配置过ssh key，(如果你没设置密码)**</em>*直接push即可；</strong></p>
<p>　　<strong>使用http方式时，需要验证用户名和密码。</strong></p>
<p> <strong>总结：</strong></p>
<p>HTTPS利于匿名访问，适合开源项目，可以方便被别人克隆和读取(但没有push权限)；</p>
<p>SSH不利于匿名访问，比较适合内部项目，只要配置了SSH公钥极可自由实现clone和push操作。</p>
<h4 id="4-github中的repository和project"><a href="#4-github中的repository和project" class="headerlink" title="4.github中的repository和project"></a>4.github中的repository和project</h4><pre><code>Github上边的repositories翻译为代码仓库，可以保存多个代码工程和项目的代码，资源，文本、图片......等;

而projects可以翻译为项目板，是project-boards的简写。简单说，可以理解为工作计划表之类的书签，制定一下工作计划，Bug，流程什么的。
</code></pre>
<h4 id="5-git-add-之后取消加入"><a href="#5-git-add-之后取消加入" class="headerlink" title="5.git add 之后取消加入"></a>5.git add 之后取消加入</h4><p>如果已经执行了git add dir_name</p>
<p>此时需要撤销 add操作，则需执行如下命令</p>
<p>git rm -r dir_name –cached</p>
<p>由于目录已经添加到git 暂存（stage）中了，所以需要加–cached参数</p>
<p>git reset .   撤销全部git add</p>
<p>git rm 与 git reset的区别<br>git rm：用于从工作区和索引中删除文件<br>git reset：用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如：git add,git commit等)。</p>
<p><em>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br>git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了</em></p>
<h4 id="6-main和master？"><a href="#6-main和master？" class="headerlink" title="6.main和master？"></a>6.main和master？</h4><p>在2020年10月1日，你创建的任何新仓库都将使用main作为默认分支，而不是master。</p>
<p>参考：<a href="https://www.cnblogs.com/wannananana/p/12059806.html">https://www.cnblogs.com/wannananana/p/12059806.html</a></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java基础入门》之多线程</title>
    <url>/2021/11/30/myblog/JAVA/%E3%80%8Ajava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E3%80%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在程序设计中，多线程就是指一个应用程序中有多条并发执行的线索，每条线索称为一个线程，它们交替执行，彼此间可以进行通信。</p>
<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在一个操作系统中，每个独立执行的程序都可称为一个进程。</p>
<p>在多任务操作系统中，表面上看是支持进程并发执行的，但实际上并不是在同一时刻运行的。计算机的应用程序都是由CPU执行的，一个CPU在某个时间点只能执行一个进程，操作系统能在极短的时间内在不同的进程之间进行切换，所以给人以同时执行多个程序的感觉。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>多线程看似是同时并发执行的，其实是和进程一样，也是由CPU控制并轮流执行的，只不过CPU运行速度非常快。</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在Java中，可以通过三种方式来实现多线程</p>
<p>1.继承Thread类，重写run()方法。</p>
<p>2.实现Runnable接口，重写run()方法。</p>
<p>3.实现Callable接口，重写call()方法，并使用Future来获取call()方法的返回结果。</p>
<h3 id="Thread类实现多线程"><a href="#Thread类实现多线程" class="headerlink" title="Thread类实现多线程"></a>Thread类实现多线程</h3><p>Thread类是java.lang包下的一个线程类，用来实现Java多线程。</p>
<p>第一步：创建一个Thread线程类的子类（子线程），同时重写Thread类的run()方法。</p>
<p>第二步：创建该子类的实例对象，并通过调用start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个继承Thread线程类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建子线程有参构造方法,name是线程名字</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写Thread类的run()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//2.创建MyThread1实例对象</span></span><br><span class="line">		MyThread1 thread1 = <span class="keyword">new</span> MyThread1(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//调用start方法启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		MyThread1 thread2 = <span class="keyword">new</span> MyThread1(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		<span class="comment">//调用start方法启动线程</span></span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>currentThread()是Thread类的静态方法，用来获取当前线程对象，getName方法用来获取线程名称。</p>
<p>结果是：两个线程实例交互运行。</p>
<h3 id="Runnable接口实现多线程"><a href="#Runnable接口实现多线程" class="headerlink" title="Runnable接口实现多线程"></a>Runnable接口实现多线程</h3><p>Thread类实现多线程的局限性：因为Java只支持类的单继承，如果某个类已经继承了其他父类，就无法再继承Thread类来实现多线程。因此，考虑通过实现Runnable接口来实现多线程。</p>
<p>第一步：创建一个Runnable接口的实现类，同时重写接口中的run方法。</p>
<p>第二步：创建Runnable接口的实现类对象。</p>
<p>第三步：使用Thread有参构造方法创建线程实例，并将Runnable接口的实现类的实例对象作为参数传入。</p>
<p>第四步：调用线程实例的start方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个实现Runnable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//重写run方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//2.创建Runnable接口实现类的实例对象</span></span><br><span class="line">		MyThread2 myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">		<span class="comment">//3.使用Thread(Runnable target, String name)构造方法创建线程对象</span></span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//4.调用线程对象的start方法启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable接口中只有一个抽象的run方法，该接口属于JDK8中定义的函数式接口，在使用中可以直接通过Lambda表达式的方式简洁地实现线程实例。</p>
<h3 id="Callable接口实现多线程"><a href="#Callable接口实现多线程" class="headerlink" title="Callable接口实现多线程"></a>Callable接口实现多线程</h3><p>Thread类和Runnable接口实现多线程，重写run方法，由于该方法没有返回值，因此无法从多个线程中获取返回结果。因此，JDK5开始，java提供了一个Callable接口，来满足这种既能创建多线程又可以有返回值的需求。</p>
<p>与Runnable不同，这次传入Thread类有参构造方法的是Runnable接口的子类FutureTask对象作为参数，对象中封装了带有返回值的Callable接口实现类。</p>
<p>第一步：创建一个Callable接口的实现类，同时重写Callable接口的call方法</p>
<p>第二步：创建Callable接口的实现类对象。</p>
<p>第三步：通过FutureTask线程结果处理类的有参构造方法来封装Callable接口实现类对象。</p>
<p>第四步：使用参数为FutureTask类对象的Thread有参构造方法创建Thread线程实例。</p>
<p>第五步：调用线程实例的start方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.cocurrent.*;</span><br><span class="line"><span class="comment">//1.定义一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//重写call方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i++,<span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+<span class="string">&quot;的run方法在运行&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">														ExecutionException</span>&#123;</span><br><span class="line">		<span class="comment">//2.创建Callable接口的实现类对象</span></span><br><span class="line">		MyThread3 myThread3 = <span class="keyword">new</span> MyThread3();</span><br><span class="line">		<span class="comment">//3.使用FutureTask封装Callable接口</span></span><br><span class="line">		FutureTask&lt;Object&gt;ft1 = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread3);</span><br><span class="line">		<span class="comment">//4.使用Thread()构造方法创建线程对象</span></span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(ft1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		<span class="comment">//5.启动线程</span></span><br><span class="line">		thread1.start();</span><br><span class="line">		FutureTask&lt;Object&gt;ft2 = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread3);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(ft2, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		thread2.start();</span><br><span class="line">		<span class="comment">//通过FutureTask对象的方法管理返回值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;thread1返回结果：&quot;</span>+ft1.get());</span><br><span class="line">		System.out.println(<span class="string">&quot;thread2返回结果：&quot;</span>+ft2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask类用来封装和管理返回结果，直接父接口是RunnableFuture，RunnableFuture接口是实现自Runnable接口和Future接口。</p>
<p>Future接口时JDK5提供的用来管理线程执行返回结果的，共有五个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> 参数)</span>   <span class="comment">//由于取消任务，参数为true表示可以取消正在执行的任务</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span>    <span class="comment">//判断是否被取消成功</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span>    <span class="comment">//判断任务是否已经完成</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span>     <span class="comment">//获取执行结果，这个方法会发生阻塞，一直等到任务执行完毕才返回执行结果</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> time, TumeUnit unit)</span>  <span class="comment">//由于在指定时间内获取执行结果</span></span></span><br></pre></td></tr></table></figure>

<h3 id="三种方法的对比分析"><a href="#三种方法的对比分析" class="headerlink" title="三种方法的对比分析"></a>三种方法的对比分析</h3><p>Callable接口的方法有返回值，并且可以声明抛出异常。</p>
<p>若是想要多个线程共享一个数据，则由于继承Thread的方法需要创建多个子类的线程对象，无法共享类内的private变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyThread1().start();</span><br><span class="line"><span class="keyword">new</span> MyThread1().start();</span><br></pre></td></tr></table></figure>

<p>创建多线程时，如果没有通过构造方法指定线程名称，则系统会默认生成线程名称。</p>
<p>为了确保多个线程共享一个数据，用Runnable接口实现，程序只创建一个类的对象，而是创建多个thread类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread2 myThread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread2, <span class="string">&quot;线程2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>因此，Runnable接口或Callable接口实现多线程相比于继承Thread类来说，好处在于：</p>
<p>（1）适合多个线程处理同一个共享资源的情况，体现面向对象设计思想。</p>
<p>（2）避免Java单继承的局限，若类已继承某父类，则还可以实现接口。</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>main方法中创建并启动几个新线程后，主线程随之结束，但是，虽然主线程结束了，但整个Java程序并未结束，对java程序来说，只要还有前台线程在运行，这个进程就不会结束。如果一个进程中只有后台线程运行，这个进程就会结束。</p>
<p>新创建的线程默认是前台线程，如果某个线程对象在启动之前调用了setDaemon(true)语句，这个线程就变成一个后台线程。</p>
<p>判断是否是后台线程：<code>th.isDaemon()</code></p>
<p><code>th.setDaemon(true);   thread.start();  </code>  //一定是在start启动之前</p>
<p>整个进程结束，JVM会通知后台线程结束，由于后台线程从接收指令到做出响应，需要一定的时间，结束后台进程会有一定的延迟。</p>
<h2 id="线程的生命周期及状态转换"><a href="#线程的生命周期及状态转换" class="headerlink" title="线程的生命周期及状态转换"></a>线程的生命周期及状态转换</h2><p>在Java中，任何对象都有生命周期，线程也不例外，Thread对象创建完成时，线程的生命周期便开始了，当执行完毕或抛出异常或错误时，生命周期便结束。</p>
<p><img src="https://img-blog.csdnimg.cn/ca388386e5024a2d9bdcc74eafa835bc.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><em><strong>新建状态</strong></em>：创建一个线程对象后，仅仅由JVM为其分配了内存，没有表现出任何线程的动态特征。</p>
<p><em><strong>就绪状态</strong></em>：线程对象调用start方法之后，等待JVM调度，此时并未运行。</p>
<p><em><strong>运行状态</strong></em>：线程对象获得JVM调度，如果存在多个CPU，则允许多个线程并行运行。</p>
<p><em><strong>阻塞状态</strong></em>：线程运行过程中，发出I/O请求时，该线程进入阻塞状态。当线程运行过程中获取同步锁时，却被另一个线程获取，此时JVM把当前线程存到对象的锁池中，该线程进入阻塞状态。此时，JVM不会给线程分配CPU，直到线程重新进入就绪状态，才有机会转换到运行状态。</p>
<p><em><strong>等待状态</strong></em>：当处于运行状态的线程调用了限制的方法后，如wait()方法、join()方法，当前线程进入等待状态。<br>处于等待状态的线程无法立即争夺CPU使用权，需要等待其他线程执行特定的操作后，才有机会再次争夺，将等待状态变为运行状态。<br><code>wait()</code>方法：等待其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法，来唤醒当前等待中的线程。<br><code>join()</code>方法：必须等待其他加入的线程终止。</p>
<p><em><strong>定时等待状态</strong></em>：类似等待状态，执行<code>sleep(long millis)、wait(long timeout)、join(long millis)</code>等方法。必须等待其他相关线程执行完特定操作<strong>或</strong>限时时间结束后，才有机会再次争夺CPU，进入运行状态。</p>
<p><em><strong>终止状态</strong></em>：线程的run()方法或者call()方法执行完毕，或线程抛出一个未捕获的异常（Exception）、错误（Error），线程进入终止状态。一旦进入终止状态，线程将不再拥有运行的资格，也不能再转换到其他状态，生命周期结束。</p>
<h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>Java虚拟机会按照特定的机制为程序中的每个线程分配CPU的使用权，这种机制叫做线程的调度。</p>
<p>计算机中线程的调度有两种模型：<br>1、分时模型：所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU时间片。<br>2、抢占式调度模式：让可运行池中所有就绪状态的线程争抢CPU的使用权，优先级高的线程获得CPU概率更大。</p>
<p>Java虚拟机默认采用抢占式调度模式，特定需求下需要改变模式，由程序自己来控制CPU的调度。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的优先级用1-10之间的整数来表示，数字越大优先级越高。除了直接用数字外，还可用Thread类中提供的三个静态常量表示线程的优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//用lambda表达式创建线程？</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出i+&quot;</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;优先级较低的线程&quot;</span>);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出j+&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;优先级较高的线程&quot;</span>);</span><br><span class="line">		<span class="comment">//设置线程的优先级</span></span><br><span class="line">		th1.setPriority(Thread.MIN_PRIORITY);  <span class="comment">//MIN=1 NORM=5  MAX=10</span></span><br><span class="line">		th2.setPriority(<span class="number">10</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>将正在执行的线程暂停，将CPU使用权让给其他线程，这是可以使用静态方法sleep(long millis)，该方法使得线程进入休眠等待状态，这样其他线程就可以得到执行的机会。sleep(long millis)方法会声明抛出InterruptedException异常，因此在调动该方法时应该捕获异常，或者声明抛出异常。休眠时间结束后，线程才会转换到就绪状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出i+&quot;</span>+i);</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						<span class="comment">//在该线程执行过程中进入睡眠状态，让其他线程先执行</span></span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()</span><br><span class="line">						+<span class="string">&quot;正在输出j+&quot;</span>+j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><p><code>Thread.yield();</code> 使当前正在运行的线程暂停，但不会阻塞该线程，只是将线程转换成就绪状态，让线程的调度器重新调度一次。Thread的yield方法，在线程类实现内使用。</p>
<p>相当于让占着CPU的线程让步，交出CPU，大家重新抢占一次，因此，也有可能自己再抢到。</p>
<h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>当某个线程a中调用其他线程b的join方法时，线程a将被阻塞，线程b插队优先执行，直到线程b执行完成后，线程a才会完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输入：&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="comment">//创建线程</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1(), <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;输入&quot;</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">				th1.join();  <span class="comment">//th1插队执行，main阻塞，在th1执行完才会继续执行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除join无参数的线程插队方法外，Thread还提供了带有时间参数的线程插队方法<code>join(long millis)</code>。表示需要等待插队的线程执行指定时间后，才可以继续执行其他线程。</p>
<p>mian函数本身也算是一个主线程。</p>
<h2 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h2><p>多线程同步：限制某个资源在同一时刻只能被一个线程访问。</p>
<p>Runnable接口实现多线程，适合多个线程处理同一个共享资源的情况。但是共享的时候会出现线程安全的问题。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>Java提供了线程同步机制，当多个线程使用同一共享资源时，可以将<strong>处理共享资源的操作代码</strong>放置在一个使用synchronized关键字来修饰的代码块中，这段代码块被称作同步代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="comment">//操作共享资源代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock是一个锁对象，是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞，等锁对象的标志位被置为1，新线程才能进入同步代码块执行其中的代码。（好比公共电话亭，前一个打完出来，后面的人才能进去）。</p>
<p>同步代码块中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是相同的。锁对象的创建代码不能放在run()方法中，否则每个线程运行到run()方法都会创建一个新对象，这样每个线程都会有一个不同的锁，每个锁有自己的标志位，无法同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多线程模拟售票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 13:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SaleThread saleThread = <span class="keyword">new</span> SaleThread();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaleThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();  <span class="comment">//定义任意一个对象，用作同步代码块的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个文件中可以有多个class类，但只能有一个含mian函数的类，并且文件名需要和含main函数的类的名字相同。</p>
</blockquote>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法前面也可以使用synchronized关键字来修饰，被修饰的方法为同步方法，它能实现和同步代码块同样的功能。</p>
<p><code>[修饰符] synchronized 返回值类型 方法名(参数)&#123;&#125;</code></p>
<p>被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 13:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_Thread1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SaleThread1 saleThread = <span class="keyword">new</span> SaleThread1();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaleThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;    <span class="comment">//在run方法中调用synchronized修饰的同步方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            saleTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块的锁是自己定义的任意类型的对象。同步方法的锁是当前调用该方法的对象，也就是this指向的对象。同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。当一个线程执行该方法，其他的线程就不能进入该方法。</p>
<p>有时，需要同步的方法是静态方法，静态方法不需要创建对象就可用类名调用，静态同步方法的锁是该方法所在类的class对象，该对象可以直接用<code>类名.class</code>的方式来获取。</p>
<p>同步代码块和同步方法：解决了多线程访问共享数据时的线程安全问题，即加锁来使同一时间只有一个线程执行。</p>
<p>弊端：线程在执行同步代码时每次都会判断锁的状态，消耗资源，效率较低。</p>
<h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>synchronized同步代码块和同步方法使用一种封闭式的锁机制，但是它无法中断一个正在等候获得锁的线程，也无法通过轮询得到锁。</p>
<p>JDK5开始，java提供了一个功能更强大的Lock锁，Lock锁与synchronized隐式锁在功能上基本相同，最大的优势在于Lock锁可以让某个线程在持续获取同步锁失败后返回，不再继续等待，使用起来更加灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Lock锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 14:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tset_Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockThread saleThread = <span class="keyword">new</span> LockThread();</span><br><span class="line">        <span class="comment">//创建并开启4个线程，模拟四个售票窗口</span></span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(saleThread, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个lock锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lo = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lo.lock();</span><br><span class="line">            <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);  <span class="comment">//模拟售票耗时过程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +<span class="string">&quot;正在发售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lo.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock</code>接口的实现类：<code>ReentrantLock</code>。</p>
<p>还有<code>tryLock()</code>方法用来判断某个线程锁是否可用。</p>
<blockquote>
<p>注意：不管是同步代码块、同步方法还是同步锁，锁对象都是几个线程共享的，不能在run方法中定义，都是在run方法之外定义。同步方法中，只创建一个对象，一个对象代表锁对象。</p>
</blockquote>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>两个线程都需要对方所占用的锁，但是都无法释放自己所拥有的锁。</p>
<h2 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h2><p>控制多个线程按照一定的顺序轮流执行，此时就需要让线程间进行通信，保证线程任务的协调进行。</p>
<p>Java在Object类中提供了<code>wait()、notify()、notifyAll()</code>等方法用于解决线程间的通信问题。所有类都是Object类的子类或间接子类，因此任何类都可直接用这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>  <span class="comment">//使当前线程进入等待状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>  <span class="comment">//唤醒此同步锁上等待的第一个调用wait()方法的线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span>  <span class="comment">//唤醒此同步锁上调用wait()方法的所有线程</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法的调用者都是<strong>同步锁对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程间通信</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-11-30 15:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Commu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个集合类，模拟存储生产的商品</span></span><br><span class="line">        List&lt;Object&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录线程执行前统一的起始时间start</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建一个生产者线程，由于生产商品并存入商品集合</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;=<span class="number">1000</span>)&#123;  <span class="comment">//控制执行时间</span></span><br><span class="line">                <span class="comment">//使用synchronized关键字同步商品生产和消费</span></span><br><span class="line">                <span class="keyword">synchronized</span> (goods)&#123;</span><br><span class="line">                    <span class="comment">//有商品就让生产者等待</span></span><br><span class="line">                    <span class="keyword">if</span>(goods.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            goods.wait();</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//生产者继续生产商品</span></span><br><span class="line">                        num++;</span><br><span class="line">                        goods.add(<span class="string">&quot;商品&quot;</span>+num);</span><br><span class="line">                        System.out.println(<span class="string">&quot;生产商品&quot;</span>+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis()-start&lt;=<span class="number">1000</span>)&#123;  <span class="comment">//控制执行时间</span></span><br><span class="line">                <span class="comment">//使用synchronized关键字同步商品生产和消费</span></span><br><span class="line">                <span class="keyword">synchronized</span> (goods)&#123;</span><br><span class="line">                    <span class="comment">//商品不足就唤醒生产者进行生产</span></span><br><span class="line">                    <span class="keyword">if</span>(goods.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        goods.notifyAll();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//继续消费商品</span></span><br><span class="line">                        num++;</span><br><span class="line">                        goods.remove(<span class="string">&quot;商品&quot;</span>+num);</span><br><span class="line">                        System.out.println(<span class="string">&quot;消费商品&quot;</span>+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        <span class="comment">//同时启动生产者和消费者两个线程，并统一执行100ms时间</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，实现供需有序、均衡，按照先生产后消费的顺序轮流执行。</p>
<p>注意：wait函数中，可有时间，时间到了，也可以自动唤醒处于等待状态的线程。唤醒的方式：其他线程notify唤醒 或 时间到。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>前面的多线程中，复杂任务会频繁手动式地创建、管理线程，线程对象使用了大量的内存，在大规模应用中，创建、分配和释放多线程对象会产生大量内存管理开销。为此，Java提供了线程池来创建多线程，进一步优化线程管理。</p>
<h3 id="Executor接口实现线程池管理"><a href="#Executor接口实现线程池管理" class="headerlink" title="Executor接口实现线程池管理"></a>Executor接口实现线程池管理</h3><p>从JDK5开始，java.util.concurrent包下增加了Executor接口及其子类，允许使用线程池技术来管理线程并发问题。</p>
<p>Executor接口提供一个常用的ExecutorService子接口，通过该子接口可以方便地管理线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuxuan.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: multithread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liuxuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2021-12-01 12:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.定义一个实现Runnable接口或者Callable接口的实现类，同时重写run()或者call()方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread4</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.1重写Callable接口的call()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i++&lt;<span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                              +<span class="string">&quot;的call()方法在运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_Pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">//2.创建Runnable接口或者Callable接口的实现类对象</span></span><br><span class="line">        MyThread4 myth = <span class="keyword">new</span> MyThread4();</span><br><span class="line">        <span class="comment">//3.使用Executors线程执行器类创建可扩展的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//4.将Callable接口实现类对象提交到线程池进行管理</span></span><br><span class="line">        Future&lt;Object&gt;res1 = executor.submit(myth);</span><br><span class="line">        Future&lt;Object&gt;res2 = executor.submit(myth);</span><br><span class="line">        <span class="comment">//5.关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">//对于有返回值的线程任务，获取执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;thread-1返回结果：&quot;</span>+res1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;thread-2返回结果：&quot;</span>+res2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池executor系统给名字pool-1.该线程池中管理有两个默认生成名称的线程thread-1和thread-2.</p>
<p>线程池通过Executors的newCachedThreadPool方法创建，Executors是JDK5增加的线程执行器工具类，提供四种方法创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newCachedThreadPool()    创建一个可扩展线程池的执行器。适合由于启动许多短期任务的应用程序。</span><br><span class="line">newFixedThreadPool(<span class="keyword">int</span> n)     创建固定线程数量线程池的执行器。</span><br><span class="line">newSingleThreadExecutor()     创建一个只执行一个任务的单线程</span><br><span class="line">newScheduledThreadPool(<span class="keyword">int</span> size)    创建一个定长线程池，支持定时及周期性任务执行。</span><br></pre></td></tr></table></figure>

<h3 id="CompletableFuture类实现线程池管理"><a href="#CompletableFuture类实现线程池管理" class="headerlink" title="CompletableFuture类实现线程池管理"></a>CompletableFuture类实现线程池管理</h3><p>使用Callable接口实现多线程时，会用到FutureTask类对线程执行结果进行管理和获取，该类获取结果时是通过阻塞或者轮询的方式，消耗过多资源。</p>
<p>JDK8增加了一个强大的函数式异步编程辅助类CompletableFuture，该类同时实现了Future接口和CompletionStage接口（Java8增加的线程任务完成结果接口），可以简化异步编程。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>《java并发编程的艺术》笔记</title>
    <url>/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h2><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程，时间片一般几十毫秒。</p>
<p>上下文切换是指切换前需要保存上一个任务的状态。</p>
<p>由于线程有创建和上下文切换的开销，并发执行的速度不一定比串行快。</p>
<p>上下文每1s切换1000多次。</p>
<p>如何减少上下文切换？<br>1、无锁并发编程，多线程竞争锁时会引起上下文切换，可以将数据id根据hash算法取模分段，不同线程处理不同段的数据。<br>2、CAS算法，Atomic包下，不需要加锁。<br>3、避免创建不需要的线程。每次从waiting到runnable都需要进行一次上下文切换。<br>4、协程：在单线程中实现多任务调度，维持多个任务间的切换。</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h3><p>线程a和线程b互相等待对方释放锁。</p>
<p>一旦出现死锁，业务可感知，使用jstack命令dump线程。</p>
<p>避免死锁的几个方法：<br>1、避免一个线程同时获取多个锁。<br>2、避免一个线程在锁内同时占用多个资源。<br>3、尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制<br>4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败。</p>
<h3 id="3-资源限制"><a href="#3-资源限制" class="headerlink" title="3.资源限制"></a>3.资源限制</h3><p>并发编程时的资源限制：<br>硬件限制：带宽的上传/下载速度（2Mb/s）、硬盘读写速度、CPU处理速度<br>软件限制：数据库连接数、socket连接数<br>例如：线程数比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p>
<p>使用等待超时模式模拟数据库连接池：<br><a href="https://blog.csdn.net/m0_52043808/article/details/125759727">https://blog.csdn.net/m0_52043808/article/details/125759727</a></p>
<p>受到资源限制时，并发执行可能会编程串行执行，但是增加了上下文切换和资源调度的时间，比串行还慢。</p>
<p>如何解决？<br>1、对于硬件约束，考虑使用集群并行执行程序，不同机器处理不同数据。<br>2、对于软件限制，考虑使用资源池将资源复用。</p>
<h3 id="4-jstack命令dump线程"><a href="#4-jstack命令dump线程" class="headerlink" title="4.jstack命令dump线程"></a>4.jstack命令dump线程</h3><h4 id="✅什么是jstack？"><a href="#✅什么是jstack？" class="headerlink" title="✅什么是jstack？"></a>✅什么是jstack？</h4><p>如果有一天，你的Java程序长时间停顿，也许是它病了，需要用jstack拍个片子分析分析，才能诊断具体什么病症，是死锁综合征，还是死循环等其他病症。</p>
<p>jstack是JVM自带的Java堆栈跟踪工具，它用于打印出给定的java进程ID、core file、远程调试服务的Java堆栈信息.</p>
<pre><code>1、jstack命令用于生成虚拟机当前时刻的线程快照。
2、线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。
3、线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
4、如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
5、另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
</code></pre>
<h4 id="✅怎么用："><a href="#✅怎么用：" class="headerlink" title="✅怎么用："></a>✅怎么用：</h4><p>首先使用 jps命令查看需要打印线程栈的java进程号pid。<br>然后 jstack pid。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-F	当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">-m	如果调用到本地方法的话，可以显示C/C++的堆栈</span><br><span class="line">-l	除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br></pre></td></tr></table></figure>

<p>输出解读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;jstack 9348</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000018da5881000 nid=0x34c8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">[通过 jstack查看线程栈信息时通常看到的最多的是RUNNABLE,BLOCKED,WAITING和TIMED_WAITING这几种状态，</span><br><span class="line">我们一般看不到线程的NEW和TERMINATED状态，是因为在代码的运行过程中这两种状态只占很小一部分，</span><br><span class="line">我们捕捉到这两种状态前这两种状态已经一闪而过了。</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002e7e800 nid=0x2a1c in Object.wait() [0x0000000002f7f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"></span><br><span class="line">其中开头是线程名称，后面的为线程信息：</span><br><span class="line"> #1 表示当前线程ID，从 main线程开始，JVM 根据线程创建的顺序为线程编号.</span><br><span class="line">prio 是priority优先级的缩写，表名了当前线程的优先级，取值范围为[1-10]，默认为 5。在虚拟机进行线程调度的时候会参考该优先级为线程分配计算资源，这个数值越低越有优先获取到计算资源，一般不设置直接使用默认的优先级。</span><br><span class="line">os_prio为线程对应系统的优先级。</span><br><span class="line">nid 本地线程编号NativeID的缩写,对应JVM 虚拟机中线程映射在操作系统中的线程编号。我们可以使用 top 查看进程对应的线程情况进行相关映射。</span><br></pre></td></tr></table></figure>

<p>nid表示的是线程对应的系统本地的线程编号.</p>
<h4 id="✅案例：jstack-分析死锁问题"><a href="#✅案例：jstack-分析死锁问题" class="headerlink" title="✅案例：jstack 分析死锁问题"></a>✅案例：jstack 分析死锁问题</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法进行下去</p>
<p>死锁demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 死锁demo</span><br><span class="line"> */</span><br><span class="line">public class DeathLockTest &#123;</span><br><span class="line">    private static Lock lock1 = new ReentrantLock();</span><br><span class="line">    private static Lock lock2 = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public static void deathLock() &#123;</span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //设置线程名字，方便分析堆栈信息</span><br><span class="line">        t1.setName(&quot;mythread-jay&quot;);</span><br><span class="line">        t2.setName(&quot;mythread-tianluo&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、在终端中输入jsp查看当前运行的java程序<br>2、使用 jstack -l pid 查看线程堆栈信息<br>3、分析堆栈信息</p>
<p>会出现：Found one Java-level deadlock: 信息。</p>
<p>当一个线程占有一个锁的时候，线程堆栈会打印一个－locked&lt;0x22bffb60&gt;<br>当一个线程正在等在其他线程释放该锁，线程堆栈会打印一个－waiting to lock&lt;0x22bffb60&gt;<br>当一个线程占有一个锁，但又执行在该锁的wait上，线程堆栈中首先打印blocked,然后打印－waiting on &lt;0x22c03c60&gt;</p>
<h4 id="✅案例：分析CPU过高"><a href="#✅案例：分析CPU过高" class="headerlink" title="✅案例：分析CPU过高"></a>✅案例：分析CPU过高</h4><p>导致CPU过高的demo程序，一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有个导致CPU过高程序的demo，死循环</span><br><span class="line"> */</span><br><span class="line">public class JstackCase &#123;</span><br><span class="line"> </span><br><span class="line">     private static ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Task task1 = new Task();</span><br><span class="line">        Task task2 = new Task();</span><br><span class="line">        executorService.execute(task1);</span><br><span class="line">        executorService.execute(task2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Object lock = new Object();</span><br><span class="line"> </span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                long sum = 0L;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    sum += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、jps 命令获取目标 java 进程号<br>2、在服务器上，我们可以通过top命令查看各个进程的cpu使用情况，它默认是按cpu使用率由高到低排序的，拿到pid<br>top -Hp pid 【奇怪，不能用，只能top -p pid】<br>通过top -Hp pid可以查看该进程下，各个线程的cpu使用情况<br>3、把线程pid换成nid<br>将该线程好打印成 16进制的<br><code>printf &quot;%x\n&quot; 19343</code><br>4、jstack -l [PID] &gt;/tmp/log.txt<br>一般在生成环境，我们可以把这些堆栈信息打到一个文件里，再回头仔细分析<br>jstack 进程pid | grep -10 线程<br>nid<br>可以看到目标线程的线程堆栈信息了</p>
<p>转自：<br><a href="https://blog.csdn.net/weixin_44588186/article/details/124680586">https://blog.csdn.net/weixin_44588186/article/details/124680586</a><br>【jstack案例】<br><a href="https://blog.csdn.net/qq_19922839/article/details/115379649">https://blog.csdn.net/qq_19922839/article/details/115379649</a><br>【里面还有pstree 查看进程树，jvm 监控工具Liberica Mission Control】</p>
<h4 id="✅dump线程"><a href="#✅dump线程" class="headerlink" title="✅dump线程"></a>✅dump线程</h4><p>线程dump的目的是转存线程快照。快照中是当前JVM所有线程正在执行方法的堆栈信息。</p>
<p>通过线程dump来分析定位线程出现长时间停顿的原因，如线程死锁、线程死循环、线程请求外部资源长时间等待等。</p>
<p>可以用arthas获取dump文件，dump文件很大，几个G，可以用IDEA打开，或者用其他分析工具。arthas也可以输出所有线程。</p>
<p>线程dump：<a href="https://blog.csdn.net/HaierFiller/article/details/117367228">https://blog.csdn.net/HaierFiller/article/details/117367228</a></p>
<h2 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h2><p>.java代码 -编译为- .class字节码文件 -加载到- jvm -执行字节码- 转化为汇编语言在cpu执行。</p>
<p>java的并发机制依赖于jvm的实现和cpu的执行。</p>
<h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1.volatile"></a>1.volatile</h3><h4 id="✅volatile底层"><a href="#✅volatile底层" class="headerlink" title="✅volatile底层"></a>✅volatile底层</h4><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。</p>
<p>首先，了解一下cpu处理逻辑：<br>为了提高处理速度，cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。</p>
<p>处理器 - 高速缓存 - 缓存   \<br>处理器 - 高速缓存 - 一致性  - 总线 - 主内存<br>处理器 - 高速缓存 - 协议   /</p>
<p>存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。<br>对字段操作都需要先从主存读取数据加载进工作内存, 工作内存对这个副本数据进行操作<br>volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现</p>
<p>对volatile声明的变量进行写操作会发生什么：<br>1、jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线/缓存，保证不会同时多个cpu修改共享变量。<br>2、多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。</p>
<p>volitale的使用优化：<br>jdk7中的LinkedTransferQueue，使用volitale时，采用追加字节的方式优化出队入队效率。</p>
<p>为什么？<br>因为处理器的高速缓存行是64个字节宽，不支持部分填充缓存行。这样头节点和尾节点在一个高速缓存行中，多处理器下，一个处理器修改头节点，会将整个缓存行锁定，在缓存一致性的作用下，导致其他处理器不能访问自己高速缓存行中的尾节点。<br>节点追加到64字节，可以避免头尾节点加载到同一个缓存行中，修改时不会相互锁定。</p>
<p>注意：缓存行非64字节的别这么做，共享变量不会被频繁写的话别这么做。</p>
<h4 id="✅volatile使用"><a href="#✅volatile使用" class="headerlink" title="✅volatile使用"></a>✅volatile使用</h4><p>⚠️注意：volatile能保证可见性，但不能保证原子性。<br>在 volatile 字段上进行了非原子类操作，会idea提示：<code>Non-atomic operations on volatile fields</code><br>比如：count++ 就是非原子操作，分三步：<br>1、从主存读取 i<br>2、在寄存器中进行加一运算, 自增操作, 此时已经修改工作内存中的值<br>3、将计算后的值赋给 i, 也就是刷回主存</p>
<p><strong>可见性</strong></p>
<p>volatile和static的可见性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。<br>static不能知道变化，它的可见性：可访问。</p>
<p>volatile修饰的共享变量对其他线程具有可见性，可以保证线程安全。<br>static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<p>static线程安全测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count = 0;</span><br><span class="line"></span><br><span class="line">    private static void count() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            es.execute(VolatileDemo::count);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(&quot;end...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        System.out.println(&quot;cost:&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个缓存线程池进行对static字段进行自增，结果不是100.<br>t1线程与 t2线程读取 count 值, 然后同步修改为 1, 再写回内存, 写了两遍 1。</p>
<p>因此，static修饰的变量确实可以在线程间通信, 对各个线程都是可见的。但是不能保证线程安全。</p>
<p>那么用volatile，相当于每次修改volatile变量都需要重新读取数据。<br>但是结果依然不是100.</p>
<p>volatile的可见性测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非原子性</strong></p>
<p>t1线程与t2线程同时从主存中读取了count = 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<p>怎么解决？<br>synchronized关键字，或者 atomic原子类 + volatile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private volatile static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">private static void count() &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-12 20:14</span><br><span class="line"> **/</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testVolatile() throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、static修饰的变量是静态变量, 表示不管对象有多少实例, 只有这一个变量, 强调变量的唯一性<br>2、volatile是基于JMM与MESI提出的一种内存一致性解决方案, 强调的是对共享变量的修改是可见的, 变量值是唯一的<br>3、volatile 可以保证对其所修饰的共享变量的原子性操作是线程安全的</p>
<p>转自：<br>volatile的可见性和非原子性：<a href="https://www.codenong.com/js5a773b9fb9cb/">https://www.codenong.com/js5a773b9fb9cb/</a></p>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2.synchronized"></a>2.synchronized</h3><p>synchronized之前被称为重量级锁，但是java se 1.6 对synchronized进行优化：减少获取锁和释放锁带来的性能消耗而引入偏向锁、轻量级锁。</p>
<h4 id="✅synchronized锁三种形式"><a href="#✅synchronized锁三种形式" class="headerlink" title="✅synchronized锁三种形式"></a>✅synchronized锁三种形式</h4><p>1.对于普通同步⽅法：锁的是当前实例对象，通常指this，所有的普通同步⽅法⽤的都是同⼀把锁，即实例对象本身。</p>
<p>2.对于静态同步⽅法：锁的是当前类的Class对象。</p>
<p>3.对于同步⽅法块：锁的是synchronized 括号内的对象。</p>
<p>⚠️几个锁的区别：<br>1.静态方法同步和静态代码块同步：所有的静态同步⽅法⽤的也是同⼀把锁——类对象本身，⼀旦⼀个静态同步⽅法获取锁后，其他的静态同步⽅法都必须等待该⽅法释放锁后才能获取锁。（和实例没关系）</p>
<p>2.静态同步和普通同步：具体实例对象this和唯⼀模板Class，这两把锁是两个不同的对象，所以静态同步⽅法与普通同步⽅法之间是不会有竞态条件的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-17 14:11</span><br><span class="line"> **/</span><br><span class="line">//资源类</span><br><span class="line">class Phone&#123;</span><br><span class="line">    //1.静态方法（加锁）</span><br><span class="line">    public static synchronized void sendEmail() &#123;</span><br><span class="line">        //暂停几秒钟线程</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendEmail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.普通方法（加锁）</span><br><span class="line">    public synchronized void sendSMS() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendSMS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 普通方法不加锁</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主方法</span><br><span class="line">public class SynchronizedDemo&#123;</span><br><span class="line">    //一切程序的入口，主线程</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone = new Phone();//资源类1</span><br><span class="line">        Phone phone2 = new Phone();//资源类2</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅synchronized锁的实现原理"><a href="#✅synchronized锁的实现原理" class="headerlink" title="✅synchronized锁的实现原理"></a>✅synchronized锁的实现原理</h4><p>反编译命令：<code>javap -v -p *.class &gt; 类.txt </code>（将进⾏输出到txt中）</p>
<p>synchronized在jvm中的实现原理：jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。</p>
<p><strong>同步代码块：</strong></p>
<p>同步代码块是通过monitorenter和monitorexit指令实现的。</p>
<p>monitorenter：在编译后插入到同步代码块的开始位置，会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。</p>
<p>monitorexit：代表执行完synchronized代码块之后，要从对象监视器中退出，也就是释放锁。</p>
<p><strong>同步普通⽅法：</strong></p>
<p>1.同步普通⽅法反编译后的结构：可以看到在synchronized修饰实例方法中，不会再有monitorenter和monitorexit指令，而是在这个方法上多了一个ACC_SYNCHRONIZED的flag。</p>
<p>2.调用普通方法的流程：当程序在运行时，调用method()方法时，会检查该方法是否有ACC_SYNCHRONIZED访问标识，如果有，则表明该方法是同步方法，这时候该线程会先尝试去获取该方法对应的监视器（monitor）对象，如果获取成功，则继续执行该method()方法。</p>
<p>3.在执行期间，任何其他线程都不能再获取该方法监视器的使用权，直到该方法正常退出或者抛出异常，才会释放，其他线程可以重新获得该监视器。</p>
<p><strong>同步静态方法：</strong></p>
<p>synchronized修饰静态方法和实例方法没有区别，都是增加一个ACC_SYNCHRONIZED的flag，静态方法只是比实例方法多一个ACC_STATIC标识代表这个方法是静态的。</p>
<p><strong>阿里开发手册说明：</strong></p>
<p>⾼并发时，同步调⽤应该去考量锁的性能损耗。<br>1.能⽤⽆锁数据结构，就不要⽤有锁；<br>2.能锁区块，就不要锁整个⽅法体；<br>3.能⽤对象锁，就不要⽤类锁；</p>
<p>参考：<br>synchronized三种加锁方式：<a href="https://blog.csdn.net/weixin_38963649/article/details/126139304">https://blog.csdn.net/weixin_38963649/article/details/126139304</a></p>
<h4 id="✅java对象头"><a href="#✅java对象头" class="headerlink" title="✅java对象头"></a>✅java对象头</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>HotSpot虚拟机的对象头包括三部分信息：<br>1、mark word 2、元类指针 3、数组长度<br>普通对象头有两个区域（1，2）、数组对象头有三个区域（1,2,3）</p>
<p><strong>Mark Word</strong></p>
<p>这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位。</p>
<p>Java对象头一般占有2个机器码（64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
<p><strong>指向类的指针</strong></p>
<p>该指针在32位JVM的长度是32Bit，64是64bit<br>它主要指向类的数据，也就是指向方法区中的位置。</p>
<p><strong>数组长度</strong></p>
<p>只有数组对象保存了这部分数据<br>该数据在32位和64位JVM都是32bit</p>
<p>参考：<br>java对象头以及打印对象头：<a href="https://blog.csdn.net/sumengnan/article/details/125035218">https://blog.csdn.net/sumengnan/article/details/125035218</a><br>java对象头以及锁升级过程：<a href="https://www.cnblogs.com/Alei777/p/16308553.html">https://www.cnblogs.com/Alei777/p/16308553.html</a></p>
<h4 id="✅锁的升级与对比"><a href="#✅锁的升级与对比" class="headerlink" title="✅锁的升级与对比"></a>✅锁的升级与对比</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。<br>在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。<br>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>偏向锁</strong></p>
<p>背景：<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁原理：<br>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁释放和升级：<br>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。<br>1、首先暂停拥有偏向锁的线程<br>2、然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；<br>3、如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁（升级为轻量级锁），最后唤醒暂停的线程。</p>
<p>关闭偏向锁<br>偏向锁在Java 6和Java 7里是默认启用，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：<br><code>-XX:-UseBiasedLocking=false</code></p>
<p><strong>轻量级锁</strong></p>
<p>升级为轻量级锁后，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>轻量级锁 -&gt; 重量级锁 的方式有两种：</p>
<p>1 若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p>
<p>2 另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p>
<p>自旋会消耗CPU，一旦重量级锁，就不会恢复为轻量级锁。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p><strong>几种锁的对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">锁	优点	缺点	使用场景</span><br><span class="line">偏向锁	加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳秒级的差距	如果线程间存在锁竞争，会带来额外的撤销消耗	适用于只有一个线程访问同步块场景</span><br><span class="line">轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	如果始终得不到锁竞争的线程，会自旋消耗CPU	追求响应时间、同步块执行非常快</span><br><span class="line">重量级锁	线程不使用自旋，不会消耗CPU	线程阻塞，响应时间缓慢	追求吞吐量、同步块执行速度较快</span><br></pre></td></tr></table></figure>

<p>参考：<br>《书中内容》：<a href="https://blog.csdn.net/Hello_mengkebao/article/details/119874999">https://blog.csdn.net/Hello_mengkebao/article/details/119874999</a></p>
<p><strong>总结：锁的升级过程</strong></p>
<p>JVM一般是这样使用锁和Mark Word的：</p>
<p>1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p>
<p>2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p>
<p>3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p>
<p>4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p>
<p>5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p>
<p>6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p>
<p>7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p>
<h3 id="3-Atomic原子操作"><a href="#3-Atomic原子操作" class="headerlink" title="3.Atomic原子操作"></a>3.Atomic原子操作</h3><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p>
<h4 id="✅处理器如何实现原子操作"><a href="#✅处理器如何实现原子操作" class="headerlink" title="✅处理器如何实现原子操作"></a>✅处理器如何实现原子操作</h4><p>首先处理器会自动保证<strong>基本的内存操作的原子性</strong>。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的。</p>
<p>但是<strong>复杂的内存操作处理器是不能自动保证其原子性的</strong>，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p>
<p>首先我们要明确一点：a++是三步操作（取数，加一，赋值），而计算机和Java都只保证一步操作的原子性，多步操作是不保证原子性的。所以a++不是原子性的。想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>⚠️volitale保证可见性为什么不能实现i++的线程安全？</p>
<blockquote>
<p>可见性是指瞬时可见性，是指那一时刻的可见性。放在这个例子里，就是指当线程1把（a=0，a++）的结果a=1刷回到主存中时，所有目前有a这个变量的缓存此时都应该变为a=1，而不是使用原来的值。所以，线程2也执行加一后，还没有写回到缓存中，保存在寄存器中，线程2缓存里面的a=0被置为无效，所以线程2又从主存中取得a=1替换掉了自己缓存中的a=0，然后线程2将a=1写入自己的缓存中，随后a=1又一次被立刻刷回到主存中。最后主存中的值还是a=1。</p>
</blockquote>
<p><strong>总线锁</strong></p>
<p>总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p><strong>缓存锁</strong></p>
<p>总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>不能使用缓存锁的情况：<br>1、第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行。<br>2、有些处理器不支持缓存锁定</p>
<h4 id="✅java如何实现原子操作"><a href="#✅java如何实现原子操作" class="headerlink" title="✅java如何实现原子操作"></a>✅java如何实现原子操作</h4><p><strong>循环CAS</strong></p>
<p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。（像改密码需要先验证旧密码一样）</p>
<p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<p>CAS仍然存在<strong>三大问题</strong>。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p>
<p>1、ABA问题<br>CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>2、循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p>3、只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证<strong>引用对象之间的原子性</strong>，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">count.incrementAndGet(); //原子自增</span><br><span class="line">int i = count.get();</span><br><span class="line">boolean suc = count.compareAndSet(i, ++i); //cas</span><br></pre></td></tr></table></figure>

<p><strong>使用锁实现原子操作</strong></p>
<p>使用锁机制实现原子操作锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<p>参考：<br>书的笔记：<a href="https://zhuanlan.zhihu.com/p/412363896">https://zhuanlan.zhihu.com/p/412363896</a><br>jdk中的原子操作类：<a href="https://www.jianshu.com/p/a47285790467">https://www.jianshu.com/p/a47285790467</a><br>cas原理、synchronized悲观锁和cas乐观锁：<a href="https://www.cnblogs.com/huansky/p/15746624.html">https://www.cnblogs.com/huansky/p/15746624.html</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>几个java实现多线程安全的操作：<br>1、synchronized加锁<br>2、Volatile关键字<br>3、CAS</p>
<h2 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h2><h3 id="1-java内存模型的基础"><a href="#1-java内存模型的基础" class="headerlink" title="1.java内存模型的基础"></a>1.java内存模型的基础</h3><h4 id="✅并发编程的两个关键问题"><a href="#✅并发编程的两个关键问题" class="headerlink" title="✅并发编程的两个关键问题"></a>✅并发编程的两个关键问题</h4><p>1、线程之间如何通信：<br>通信是指线程之间以何种机制来交换信息<br>通信机制有两种：共享内存和消息传递</p>
<p>2、线程之间如何同步：<br>同步：指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<p>java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个过程对程序员完全透明。</p>
<h4 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h4><p>堆内存：实例域、静态域、数组元素；在线程之间共享。<br>栈内存：局部变量、方法定义参数、异常处理器参数；不在线程之间共享，没有内存可见性问题。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见</p>
<p>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(抽象概念)，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证<br>两个线程要通信，要经历下面2个步骤：<br>线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>线程B到主内存中去读取线程A之前已更新过的共享变量</p>
<h4 id="✅从源代码到指令序列的重排序"><a href="#✅从源代码到指令序列的重排序" class="headerlink" title="✅从源代码到指令序列的重排序"></a>✅从源代码到指令序列的重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序</p>
<p>重排序分3种类型，第一种属于编译器重排，后两种属于处理器重排：<br>编译器优化的重排序<br>指令级并行的重排序<br>内存系统的重排序</p>
<p>JMM通过禁止特定类型的编译器重排序和处理器重排序（插入特定类型的内存屏障），提供内存可见性保证。</p>
<p>处理器利用写缓冲区来临时保存向内存写入的数据。但是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。例如a=1，先写在缓冲区，然后下一个语句用了a，然后缓冲区才将a=1写入主内存。这就算重排序了。</p>
<h4 id="✅happens-before"><a href="#✅happens-before" class="headerlink" title="✅happens-before"></a>✅happens-before</h4><p>JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系（一种阐述内存可见性的概念）。就是要求前一个操作的执行结果对后一个操作可见。并不意味着操作A就一定在操作B之前执行。</p>
<p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p>
<h3 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2.重排序"></a>2.重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h4 id="✅数据依赖性"><a href="#✅数据依赖性" class="headerlink" title="✅数据依赖性"></a>✅数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<br>数据依赖可分为：读后写、写后读、写后写。</p>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</p>
<h4 id="✅as-if-serial语义"><a href="#✅as-if-serial语义" class="headerlink" title="✅as-if-serial语义"></a>✅as-if-serial语义</h4><p>一个概念，意思是：不管怎么重排序，单线程的程序的执行结果不能被改变</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<p>意思就是，编译器和处理器为了提高单线程的并行度，会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<h4 id="✅重排序对多线程的影响"><a href="#✅重排序对多线程的影响" class="headerlink" title="✅重排序对多线程的影响"></a>✅重排序对多线程的影响</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    Public void reader() &#123;</span><br><span class="line">        if (flag) &#123; // 3</span><br><span class="line">        int i = a * a; // 4</span><br><span class="line">    ……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.</p>
<p>操作1和操作2没有数据依赖关系，且操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两对操作重排序.</p>
<p>对线程A的两个操作进行重排序：<br>1、线程A首先写标记变量flag<br>2、随后线程B读这个变量。由于条件判断为真，线程B将读取变量a<br>3、此时，变量a还没有被线程A写入，多线程程序的语义被重排序破坏</p>
<p>对线程B的两个操作进行重排序：<br>1、由于操作3和操作4存在控制依赖关系，执行线程B的处理器可提前读取并计算a*a<br>2、然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer，ROB)的硬件缓存中<br>3、当操作3的条件判断为真时，就把该计算结果写入变量i中，多线程程序的语义被重排序破坏</p>
<h3 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3.顺序一致性"></a>3.顺序一致性</h3><p>数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序</p>
<p>顺序一致性：如果程序是正确同步的，程序的执行将具有顺序一致性(即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)【是一个理想化的概念】</p>
<h4 id="✅顺序一致性模型"><a href="#✅顺序一致性模型" class="headerlink" title="✅顺序一致性模型"></a>✅顺序一致性模型</h4><p>在顺序一致性模型（理论参考模型）中（不管有没有同步）：<br>任意时刻最多只有一个线程可以连接到内存。<br>一个线程的所有操作按程序的顺序串行执行。<br>每个操作必须立即对任意线程可见。<br>所有线程都只能看到一个一致的整体执行顺序。</p>
<blockquote>
<p>JMM中没有上述保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致</p>
</blockquote>
<h4 id="✅同步程序的执行效果"><a href="#✅同步程序的执行效果" class="headerlink" title="✅同步程序的执行效果"></a>✅同步程序的执行效果</h4><p>在JMM中，临界区（一个同步块儿）内的代码可以重排序(因为JMM目的是在不改变程序执行结果的前提下，尽可能优化编译器和处理器)。</p>
<p>结果是：重排序提高了执行效率，而且没有改变程序的执行结果。</p>
<h4 id="✅未同步程序的执行效果"><a href="#✅未同步程序的执行效果" class="headerlink" title="✅未同步程序的执行效果"></a>✅未同步程序的执行效果</h4><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致（一致也没意义）。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行性能会产生很大的影响。</p>
<p>JMM不保证单线程内的操作会按程序顺序执行。所有线程看到的操作顺序可能不一致。执行顺序可能是：2-3-4-1，语义被破坏。可能是4的右边-1-2-3-4的左边，语义被破坏。</p>
<h4 id="✅处理器总线事务"><a href="#✅处理器总线事务" class="headerlink" title="✅处理器总线事务"></a>✅处理器总线事务</h4><p>总线事务包括读事务（内存-处理器）和写事务（处理器-内存），中间都要通过总线，总线会同步试图并发使用总线的事务，一次只有一个事务可以操作总线访问内存。</p>
<p>所以，一次最多只有一个处理器可以访问内存，这保证了单个总线事务之中的内存读写（读跟写，不是i++）具有原子性。</p>
<p>但是：32位的处理器上，对long型和double型这俩64位的数据的写操作拆分成了两个写事务，会分配在不同的总线事务中执行。所以不具有原子性。</p>
<h3 id="4-volatile的内存语义"><a href="#4-volatile的内存语义" class="headerlink" title="4.volatile的内存语义"></a>4.volatile的内存语义</h3><h4 id="✅volatile的特性："><a href="#✅volatile的特性：" class="headerlink" title="✅volatile的特性："></a>✅volatile的特性：</h4><p>1、可见性：对volatile变量的单个读写，相当于是用同一个锁对单个读写方法做了同步。对volatile变量的读，总能看到最后的写入。被volatile修饰的变量对所有线程总是立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中。</p>
<p>2、原子性：对单个volatile变量的读写（64位的long和double类型也是）具有原子性，volatile++的复合操作不具有原子性。</p>
<h4 id="✅volatile变量读写实现线程之间通信"><a href="#✅volatile变量读写实现线程之间通信" class="headerlink" title="✅volatile变量读写实现线程之间通信"></a>✅volatile变量读写实现线程之间通信</h4><p>volatile变量的写、读，与锁的释放、获取有相同的内存效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    a = 1;//1</span><br><span class="line">    flag = true;//2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reader() &#123;</span><br><span class="line">    if (flag) &#123;  //3</span><br><span class="line">        int i = a; //4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 happens-before 2  (执行顺序可能在一个临界区内重排序)<br>3 happens-before 4<br>2 happens-before 3 （volatile带来的）<br>so: 1 happens-before 4</p>
<p>疑问：1.2没有数据依赖，可能被重排序。<br>指令重排使得执行顺序不会变成：2-3-4-1 吗？ 下面给答案。</p>
<h4 id="✅volatile写读的内存语义"><a href="#✅volatile写读的内存语义" class="headerlink" title="✅volatile写读的内存语义"></a>✅volatile写读的内存语义</h4><p>线程 - 本地内存 - 主内存</p>
<p>1、当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量（那个a）值刷新到主内存。（实质就是A向接下来要读这个volatile变量的某个线程发出了消息（我对共享变量做出的修改））</p>
<p>2、当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。（实质就是接受了之前某个线程发出的消息）</p>
<p>3、A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信</p>
<h4 id="✅volatile内存语义的实现-禁止指令重排。"><a href="#✅volatile内存语义的实现-禁止指令重排。" class="headerlink" title="✅volatile内存语义的实现-禁止指令重排。"></a>✅volatile内存语义的实现-禁止指令重排。</h4><p>背景：上面实现线程间通信那一小节，疑惑的是1.2是不是能重排序，3.4是不是能重排序。在这里给出答案，</p>
<p>为了实现volatile的内存语义，JMM会限制重排序类型。</p>
<p>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。</p>
<p>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。</p>
<p>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>那么，如何实现限制指令重排？<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>尽管内存屏障会降低效率，但是JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h4 id="✅JSR-133增强volatile的内存语义"><a href="#✅JSR-133增强volatile的内存语义" class="headerlink" title="✅JSR-133增强volatile的内存语义"></a>✅JSR-133增强volatile的内存语义</h4><p>Java内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存模型远比想象要更难。JSR133为Java语言定义了一个新的内存模型，它修复了早期内存模型中的缺陷。为了实现JSR133，final和volatile的语义需要重新定义。</p>
<p>旧的内存模型中，volatile的写读没有锁的释放和获取的内存语义，也就是实现线程之间通信那一小节里，会指令重排。</p>
<p>JSR-133，严格限制编译器和处理器对volatile变量与普通变量的重排序，确保了volatile的写读有锁的释放和获取的内存语义。</p>
<p>volatile与锁对比：<br>锁在功能上比volatile更强大，可以确保整个临界区代码具有原子性。volatile只能对单个volatile变量读写具有原子性。（所以不能单纯用volatile实现计数器）<br>在可伸缩性和执行性能上，volatile更具有优势。</p>
<h3 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h3><p>达到效果：线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立即变得对B线程可见。</p>
<h4 id="✅锁释放和获取的内存语义"><a href="#✅锁释放和获取的内存语义" class="headerlink" title="✅锁释放和获取的内存语义"></a>✅锁释放和获取的内存语义</h4><p>1、当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。（实质上是线程A向接下来要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。）</p>
<p>2、当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器锁保护的临界区代码必须从主内存中读取共享变量。（实质上是线程B接受了之前某个线程发出的（在释放这个锁对共享变量锁做的修改的）消息。）</p>
<p>3、线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h4 id="✅锁内存语义的实现"><a href="#✅锁内存语义的实现" class="headerlink" title="✅锁内存语义的实现"></a>✅锁内存语义的实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();                 // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();          // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronized(AQS) 。AQS使用一个整型的volatile变量（state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。</p>
<p><strong>公平锁：</strong></p>
<p>加锁方法首先读取volatile变量state。<br>释放锁的最后写volatile变量state。</p>
<p>效果：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取到同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p><strong>非公平锁：</strong></p>
<p>非公平锁的释放和公平锁的释放完全一致。</p>
<p>加锁：用了：<code>unsafe.compareAndSwapInt(this, stateOffset, expect, update);</code></p>
<p>该方法以原子操作的方式更新state变量，也就是compareAndSet() (CAS)操作。JDK文档对该方法说明如下：如果当前状态值等于预期值，则以原子方式同步状态设置为给定更新的值。此操作具有volatile读和写的内存语义。<br>（编译器不能对CAS与CAS前面和后面任意内存操作重排序。）</p>
<p>CAS具有volatile读写内存语义的实现方式：lock前缀<br>intel手册对lock前缀的说明：<br>对内存的读-改-写操作原子执行。（总线锁定/缓存锁定）<br>禁止该指令，与之前的读和写指令重排序<br>把写缓冲区的所有数据刷新到内存中<br>上面的2、3两点所具有的内存屏障的效果，足以同时实现volatile读和volatile写的内存语义。所以JDK文档说CAS 具有volatile读和volatile写的内存语义对于处理器也是符合的。</p>
<p><strong>总结：</strong><br>释放锁-获取锁的内存语义的实现方式总结 ：<br>利用volatile变量的写-读所具有的内存语义<br>利用CAS所附带的volatile读和volatile写的内存语义</p>
<h4 id="✅concurrent包的实现"><a href="#✅concurrent包的实现" class="headerlink" title="✅concurrent包的实现"></a>✅concurrent包的实现</h4><p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器实现同步的关键。同时volatile变量的读/写和CAS可以实现线程之间的通信。这些特性就是Java整个concurrent包的基石。</p>
<p>concurrent包的通用化实现模式：<br>1、声明共享变量volatile<br>2、使用CAS的原子条件更新来实现线程之间的同步<br>3、配合volatile的读/写和CAS具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）、非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中基础类都是使用这个模式来实现的，而concurrent包中的高层类又是依赖于这些基础类。</p>
<p>图示concurrent包的实现示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/332bc0544764bd13d7ddb4ac4e73871f.png"></p>
<h3 id="6-final域的内存语义"><a href="#6-final域的内存语义" class="headerlink" title="6.final域的内存语义"></a>6.final域的内存语义</h3><p>文中探讨的变量对线程可见，是保证线程安全的方式，如果不可见，那就要同步加锁，反言之，加锁也是为了变量对线程可见。</p>
<h4 id="✅final域的重排序规则"><a href="#✅final域的重排序规则" class="headerlink" title="✅final域的重排序规则"></a>✅final域的重排序规则</h4><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。</p>
<p>写普通域的操作可能被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值，很可能obj对象还没有构造完成，初始值1还没有写入普通域i。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。</p>
</blockquote>
<blockquote>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
</blockquote>
<p>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<blockquote>
<p>编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。</p>
</blockquote>
<blockquote>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i;  //普通变量</span><br><span class="line">    final int j;  //final变量</span><br><span class="line">    static FinalExample obj;</span><br><span class="line">    public FinalExample() &#123; //构造函数</span><br><span class="line">        i = 1; //写普通域</span><br><span class="line">        j = 2; //写final域</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程B执行</span><br><span class="line">        FinalExample object = obj; //读对象引用</span><br><span class="line">        int a = object.i; //读普通域</span><br><span class="line">        int b = object.j; //读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅final域为引用类型"><a href="#✅final域为引用类型" class="headerlink" title="✅final域为引用类型"></a>✅final域为引用类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">    final int[] intArray; //final是引用类型</span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    public FinalReferenceExample() &#123; //构造函数</span><br><span class="line">        intArray = new int[1]; //1</span><br><span class="line">        intArray[0] = 1; //2</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerOne() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalReferenceExample(); //3</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerTwo() &#123; //写线程B执行</span><br><span class="line">        obj.intArray[0] = 2; //4</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程C执行</span><br><span class="line">        if (obj != null) &#123; //5</span><br><span class="line">            int temp1 = obj.intArray[0]; //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在<strong>构造函数内</strong>对一个final引用的对象的成员域的写入(2)，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量(3)，这两个操作之间不能重排序。</p>
<p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="✅为什么含final的对象引用不能从构造函数内“溢出”"><a href="#✅为什么含final的对象引用不能从构造函数内“溢出”" class="headerlink" title="✅为什么含final的对象引用不能从构造函数内“溢出”"></a>✅为什么含final的对象引用不能从构造函数内“溢出”</h4><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int                          i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1; //1写final域</span><br><span class="line">        obj = this; //2 this引用在此“逸出”</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123;  //线程B</span><br><span class="line">        if (obj != null) &#123; //3</span><br><span class="line">            int temp = obj.i; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作2使得对象还未完成构造前就为线程B可见。这里的操作1和操作2之间可能被重排序。线程B看到了此时的final域可能还没有被初始化。</p>
<p>final不同于普通变量达到的效果是：在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="✅处理器中如何实现final语义"><a href="#✅处理器中如何实现final语义" class="headerlink" title="✅处理器中如何实现final语义"></a>✅处理器中如何实现final语义</h4><p>本来应该要插入内存屏障的。<br>X86处理器不会对写-写操作做重排序，X86处理器不会对存在间接依赖关系的操作做重排序，也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障！（普通变量也有依赖关系吧，也有final语义？）</p>
<h4 id="✅JSR-133为什么要增强final的语义"><a href="#✅JSR-133为什么要增强final的语义" class="headerlink" title="✅JSR-133为什么要增强final的语义"></a>✅JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h3 id="7-happens-before"><a href="#7-happens-before" class="headerlink" title="7.happens-before"></a>7.happens-before</h3><h4 id="✅设计初衷"><a href="#✅设计初衷" class="headerlink" title="✅设计初衷"></a>✅设计初衷</h4><p>设计内存模型JMM的初衷：让程序员易于理解，易于编程，提供内存可见性保证。对编译器和处理器的束缚越少越好，方便它们优化来提高性能。</p>
<p>JMM 对于这两种类型的重排序做了不同的处理：<br>对于有数据依赖的重排序，JMM 要求编译器和处理器禁止这种重排序<br>对于没有数据依赖的重排序，JMM 要求编译器和处理器不做处理</p>
<p>JMM 的 happens - before 向程序员提供了足够强的内存可见性保证，但是其中有些内存可见性保证其实不一定存在，【比如 int a=1; int b=2; 这个就只是可见，不保证执行顺序，但也是happens-before】。</p>
<p>JMM 对于编译器和处理器的优化已经尽可能少了。JMM 其实在遵循一个规则：单线程下或者已经同步的多线程下（synchronized，volatile等），只要不改变程序的执行结果，编译器和处理器想要怎么优化都可以。【比如 对于volatile 变量，如果编译器分析后认定这个变量只会被单线程访问，不存在多线程的可见性问题，那么编译器就会把 volatile 变量当作普通变量进行处理】。</p>
<h4 id="✅happens-before的定义"><a href="#✅happens-before的定义" class="headerlink" title="✅happens-before的定义"></a>✅happens-before的定义</h4><p>JSR - 133中提出，JSR - 133 使用 happens - before 关系来向程序员提供跨线程的内存可见性保证。</p>
<p>1、如果一个操作 happens - before 另一个操作，那么另一个操作的执行结果将对第二个操作可见。</p>
<p>2、两个操作之间存在 happens - before 关系，并不意味这 Java 平台必须要按照 happens - before 规定的顺序来执行。只要重排序之后的结果是不改变的，那么 JMM 是默认不对这种重排序处理的</p>
<p>核心原则是：只要不改变程序的执行结果（<strong>单线程和正确同步的多线程</strong>），编译器和处理器怎么优化都行。程序员对于这两个操作是否真的被重排序并不关心，程序员只需要关系的是程序执行时的语义不能被改变（就是执行结果不能被改变）。</p>
<p>happens - before 给编写正确同步的多线程程序的程序员一个幻觉：正确同步的多线程程序是按照 happens - before 指定的顺序来执行的。实际上不是，但是语义和按顺序执行是一样的。<br>（实际上是可见性，但也是一种假的顺序）</p>
<h4 id="✅happens-before规则"><a href="#✅happens-before规则" class="headerlink" title="✅happens-before规则"></a>✅happens-before规则</h4><p>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。</p>
<p>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。</p>
<p>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。</p>
<p>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C</p>
<p>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。</p>
<p>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<p>⚠️像volitale变量一样，线程a写volatile变量前还写一个共享变量，线程b读那个volatile变量后还读那个共享变量，如何保证共享变量的安全性，因为线程a里的操作可能重排序，是由volitile的内存屏障插入策略和volatile的禁止编译器重排序规则来保证的，其他start方法和join方法也一样。因为重排序了的话，执行结果会不一样。</p>
<p>原书笔记：<a href="https://blog.csdn.net/laohuangaa/article/details/122773633">https://blog.csdn.net/laohuangaa/article/details/122773633</a></p>
<h3 id="8-双重检查锁定与延迟初始化"><a href="#8-双重检查锁定与延迟初始化" class="headerlink" title="8.双重检查锁定与延迟初始化"></a>8.双重检查锁定与延迟初始化</h3><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<p>下面会讲述双重检查锁定为什么错误，以及两种线程安全的延迟初始化方案。</p>
<h4 id="✅双重检查锁定的由来"><a href="#✅双重检查锁定的由来" class="headerlink" title="✅双重检查锁定的由来"></a>✅双重检查锁定的由来</h4><p>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。</p>
<p>因为初始化可能在多线程环境下，它们共用一个对象，是需要一个线程创建就好了。非线程安全的延迟初始化对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) //1：A线程执行</span><br><span class="line">            instance = new Instance(); //2：B线程执行</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化. 导致AB线程都初始化对象。</p>
<p>同步处理来实现线程安全的延迟初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。</p>
<p>因此，双重检查锁定来实现延迟初始化诞生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123; //1</span><br><span class="line">    private static Instance instance; //2</span><br><span class="line">    public static Instance getInstance() &#123; //3</span><br><span class="line">        if (instance == null) &#123; //4:第一次检查</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123; //5:加锁</span><br><span class="line">                if (instance == null) //6:第二次检查</span><br><span class="line">                    instance = new Instance(); //7:问题的根源出在这里</span><br><span class="line">            &#125; //8</span><br><span class="line">        &#125; //9</span><br><span class="line">        return instance; //10</span><br><span class="line">    &#125; //11</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：不会每个线程都加锁，检查instance不为null，那么就不需要执行下面的加锁和初始化操作。获取锁之后，再检查一次是不是为null，因为在第一次判断是否为null时，可能另一个线程正在初始化。<br>（获取锁之前检查一次，获取锁之后检查一次）</p>
<p>但是是错误的：在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h4 id="✅双重检查锁定的问题"><a href="#✅双重检查锁定的问题" class="headerlink" title="✅双重检查锁定的问题"></a>✅双重检查锁定的问题</h4><p>第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<p>memory = allocate();　　// 1<strong>：分配对象的内存空间（引用变量）<br>ctorInstance(memory);　 // 2</strong>：初始化对象<br>instance = memory;　　 // 3**：设置instance指向刚分配的内存地址（赋值引用变量）（这个时候就不为null了）</p>
<p>上面3行伪代码中的2和3之间，可能会被重排序，因为这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</p>
<p>如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<strong>线程B将会访问到一个还未初始化的对象</strong>。</p>
<p>如何解决，来实现线程安全的延迟初始化：<br>1） 不允许2和3重排序。<br>2）允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<h4 id="✅基于volatile的解决方案"><a href="#✅基于volatile的解决方案" class="headerlink" title="✅基于volatile的解决方案"></a>✅基于volatile的解决方案</h4><p>把instance声明为volatile型，就可以实现线程安全的延迟初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">    private volatile static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Instance();//instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要JDK 5或更高版本（因为从JDK 5开始使用新的JSR-133内存模型规范).</p>
<p>原理：使用了volatile修饰后，2、3将不会重排序。</p>
<h4 id="✅基于类初始化的解决方案"><a href="#✅基于类初始化的解决方案" class="headerlink" title="✅基于类初始化的解决方案"></a>✅基于类初始化的解决方案</h4><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        public static Instance instance = new Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return InstanceHolder.instance; //这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设两个线程并发执行getInstance()方法，但是只有一个线程能获取class对象的初始化锁，然后执行对象初始化。</p>
<p>💡初始化类的时机和原理：</p>
<p>初始化一个类，包括<strong>执行这个类的静态初始化和初始化在这个类中声明的静态字段</strong>。根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：<br>1）T是一个类，而且一个T类型的实例被创建。<br>2）T是一个类，且T中声明的一个静态方法被调用。<br>3）T中声明的一个静态字段被赋值。<br>4）T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。<br>5）T是一个顶级类（Top Level Class），而且一个断言语句嵌套在T内部被执行。</p>
<p>在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化，是情况4.<br>（相当于是用一个工厂类来初始化另一个类？）</p>
<p>Java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口（比如这里多个线程可能在同一时刻调用getInstance()方法来初始化InstanceHolder类）。因此，在Java中初始化一个类或者接口时，需要做细致的同步处理。</p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</p>
<p>（<strong>多个线程初始化类不是创建不同的对象吗？难道初始化类和创建对象不一样？</strong> 是的，先初始化类再创建对象）</p>
<p>对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下：</p>
<p>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化，获取锁之后，初始化维护一个状态，设置state=initialing，然后释放锁。获取不到的话，这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</p>
<p>第2阶段：线程A执行类的初始化（上面的三步），同时线程B获取到初始化锁，发现状态是initialing，然后释放锁。后在初始化锁对应的condition上等待。</p>
<p>第3阶段：线程A获取初始化锁，设置state=initialized后，唤醒在condition中等待的所有线程，释放锁。</p>
<p>第4阶段：线程B获取锁，发现状态是initialed，释放锁，结束类的初始化处理。</p>
<p>所以，线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定能看到。</p>
<p>注意：这里的condition和state标记是本文虚构出来的。</p>
<p><strong>总结：</strong></p>
<p>基于类初始化的方案的实现代码更简洁，但只能对静态字段使用。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。</p>
<p>原书笔记：<a href="https://dandelioncloud.cn/article/details/1462953051467345921/">https://dandelioncloud.cn/article/details/1462953051467345921/</a></p>
<h3 id="9-java内存模型综述"><a href="#9-java内存模型综述" class="headerlink" title="9.java内存模型综述"></a>9.java内存模型综述</h3><h4 id="✅处理器的内存模型"><a href="#✅处理器的内存模型" class="headerlink" title="✅处理器的内存模型"></a>✅处理器的内存模型</h4><p>JMM：相当于是java编译器的内存模型</p>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。内存模型的束缚越少，处理器性能越好。</p>
<p>根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：<br>1、放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）<br>2、在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>3、在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</p>
<p>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，<strong>处理器不会对存在数据依赖性的两个内存操作做重排序</strong>）。</p>
<p>所有处理器内存模型都允许写-读重排序，原因是：使用了写缓存区。写缓存区可能导致写-读操作重排序。都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
<p><strong>虚拟机对不同操作系统反映的一致性：</strong></p>
<p>由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h4 id="✅各种内存模型之间的关系"><a href="#✅各种内存模型之间的关系" class="headerlink" title="✅各种内存模型之间的关系"></a>✅各种内存模型之间的关系</h4><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。</p>
<p>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<p>执行性能越好，易编程性越差。</p>
<h4 id="✅JMM的内存可见性保证"><a href="#✅JMM的内存可见性保证" class="headerlink" title="✅JMM的内存可见性保证"></a>✅JMM的内存可见性保证</h4><p>1、单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2、正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3、未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</p>
<p>最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。如果是写了一半的，那就是线程B写了一半的，并不是null。<br>最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h4 id="✅JSR-133对旧内存模型的修补"><a href="#✅JSR-133对旧内存模型的修补" class="headerlink" title="✅JSR-133对旧内存模型的修补"></a>✅JSR-133对旧内存模型的修补</h4><p>JSR-133对JDK 5之前的旧内存模型的修补主要有两个。</p>
<p>· 增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p>· 增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</p>
<h2 id="第四章-java并发编程"><a href="#第四章-java并发编程" class="headerlink" title="第四章 java并发编程"></a>第四章 java并发编程</h2><p>Java从诞生开始就明智地选择了内置对多线程的支持，这使得Java语言相比同一时期的其他语言具有明显的优势。</p>
<p>线程作为操作系统调度的最小单元，多个线程能够同时执行（多核同时，单核并发），这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。</p>
<h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h3><h4 id="✅什么是线程"><a href="#✅什么是线程" class="headerlink" title="✅什么是线程"></a>✅什么是线程</h4><p>现代操作系统在运行一个程序时，会为其创建一个进程。操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<p>Java程序天生就是多线程程序，使用JMX来查看一个普通的Java程序包含哪些线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取Java线程管理 MXBean</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);</span><br><span class="line">        // 遍历线程信息，仅打印线程 ID 和 线程名称信息</span><br><span class="line">        for (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + threadInfo.getThreadId() + &quot;] &quot; + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅为什么使用多线程"><a href="#✅为什么使用多线程" class="headerlink" title="✅为什么使用多线程"></a>✅为什么使用多线程</h4><p>1、更多的处理器核心<br>如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>
<p>2、更快的响应时间<br>使用多线程技术，将数据一致性不强的操作派发给不同线程处理（消息队列也可以做到），响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<p>3、更好的编程模式<br>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决</p>
<h4 id="✅线程优先级"><a href="#✅线程优先级" class="headerlink" title="✅线程优先级"></a>✅线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。</p>
<p>时间片就是分配给线程的处理器资源，在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</p>
<p>一个计数线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">            private int priority;</span><br><span class="line">            private long jobCount;</span><br><span class="line">            public Job(int priority) &#123;</span><br><span class="line">                    this.priority = priority;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (notStart) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                while (notEnd) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                    jobCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看10s多个不同优先级的计数，操作系统可能会忽略对线程优先级的设定。</p>
<h4 id="✅线程的状态"><a href="#✅线程的状态" class="headerlink" title="✅线程的状态"></a>✅线程的状态</h4><p>线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态（释放锁）。</p>
<p>进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</p>
<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
<p>等待和超时等待的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//该线程在waiting.class实例上等待</span><br><span class="line">static class Waiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (Waiting.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Waiting.class.wait();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该线程不断进行睡眠，超时等待</span><br><span class="line">static class TimeWaiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            SleepUtils.second(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
</blockquote>
<h4 id="✅Daemon线程"><a href="#✅Daemon线程" class="headerlink" title="✅Daemon线程"></a>✅Daemon线程</h4><p>守护线程。</p>
<p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，所有Daemon线程都需要立即终止。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。因此，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h3 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2.启动和终止线程"></a>2.启动和终止线程</h3><p>调用start方法进行启动线程，随着run方法的执行完毕，线程随之终止。</p>
<h4 id="✅构造线程"><a href="#✅构造线程" class="headerlink" title="✅构造线程"></a>✅构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<p>个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。</p>
<p>一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h4 id="✅启动线程"><a href="#✅启动线程" class="headerlink" title="✅启动线程"></a>✅启动线程</h4><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<p>线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h4 id="✅中断线程"><a href="#✅中断线程" class="headerlink" title="✅中断线程"></a>✅中断线程</h4><p>中断，效果是终止一个线程，可以理解为线程的一个标识位属性 （并不能直接终止一个线程），它表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的 interrupt() 方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted() 来进行判断是否被中断。</p>
<p>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep （long millis）方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<p>如下所示的例子中，首先创建了两个线程，SleepThread和BusyThread，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Interrupted &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // sleepThread不停的尝试睡眠</span><br><span class="line">        Thread sleepThread = new Thread(new SleepRunner(), &quot;SleepThread&quot;);</span><br><span class="line">        sleepThread.setDaemon(true);</span><br><span class="line">        // busyThread不停的运行</span><br><span class="line">        Thread busyThread = new Thread(new BusyRunner(), &quot;BusyThread&quot;);</span><br><span class="line">        busyThread.setDaemon(true);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        // 休眠5秒，让sleepThread和busyThread充分运行</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(&quot;SleepThread interrupted is &quot; + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(&quot;BusyThread interrupted is &quot; + busyThread.isInterrupted());</span><br><span class="line">        // 防止sleepThread和busyThread立刻退出</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    static class SleepRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 对于Sleep，如果发生了中断，就会抛出中断异常。抛出后，interrupt的表示位会被重置。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class BusyRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，返回false。而一直忙碌运作的线程BusyThread，中断标识位没有被清除，返回true。</p>
<h4 id="✅过期的suspend-、resume-和stop"><a href="#✅过期的suspend-、resume-和stop" class="headerlink" title="✅过期的suspend()、resume()和stop()"></a>✅过期的suspend()、resume()和stop()</h4><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p>不建议使用的原因主要是：</p>
<p>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br>同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<p>暂停和恢复操作可以用后面提到的等待/通知机制来替代。</p>
<h4 id="✅安全地终止线程"><a href="#✅安全地终止线程" class="headerlink" title="✅安全地终止线程"></a>✅安全地终止线程</h4><p>中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<p>除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<p>方法1：使用中断interrupt方法进行中断。按说是直接中断线程了，没加代码中的判断也应该中断的。❓<br>方法2：使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Shutdown &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runner one = new Runner();</span><br><span class="line">        Thread countThread = new Thread(one, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = new Runner();</span><br><span class="line">        countThread = new Thread(two, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Runner implements Runnable &#123;</span><br><span class="line">        private long i;</span><br><span class="line">            private volatile boolean on = true;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            while (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Count i = &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        public void cancel() &#123;</span><br><span class="line">            on = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。</p>
<p>这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3.线程间通信"></a>3.线程间通信</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。多个线程配合工作，才更有价值。</p>
<h4 id="✅volatile和synchronized关键字"><a href="#✅volatile和synchronized关键字" class="headerlink" title="✅volatile和synchronized关键字"></a>✅volatile和synchronized关键字</h4><p>背景：<br>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性）（就是线程的本地内存），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<p>volatile怎么解决：<br>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<p>sychronized怎么解决：<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>一点sychronized的实现原理：</p>
<p>看字节码文件，monitorenter和monitorexit指令，是对一个对象的监视器的获取，这个获取过程是排他的，一个时刻只有一个线程能够获取到由sychronized保护的对象的监视器。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处（进入同步队列），进入BLOCKED状态。当获锁线程释放了锁，该释放操作唤醒阻塞在同步队列中的线程，重新尝试对监视器的获取。</p>
<h4 id="✅等待-通知机制"><a href="#✅等待-通知机制" class="headerlink" title="✅等待/通知机制"></a>✅等待/通知机制</h4><p>背景：生产者线程修改某个变量的值，消费者线程能够感知到。简单的办法是让消费者线程不断地循环检查变量是否符合预期。但是开销大。</p>
<p>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上。（监视器方法）</p>
<p>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>例子：创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WaitNotify &#123;</span><br><span class="line">    static boolean flag = true;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Wait implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 当条件不满足时，继续wait，同时释放了lock的锁</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + &quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 条件满足时，完成工作</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Notify implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span><br><span class="line">                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; +</span><br><span class="line">                        new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 再次加锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用wait()、notify()以及notifyAll()时需要注意的细节:</p>
<p>1、使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</p>
<p>2、调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列，并释放锁。</p>
<p>3、notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</p>
<p>4、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</p>
<p>5、从wait()方法返回的前提是获得了调用对象的锁。<strong>等待/通知机制依托于同步机制</strong>，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改（也就是flag变量）。</p>
<p>梳理一下等待线程的状态变化：<br>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程获取到锁，从wait方法返回并继续执行。</p>
<p>sleep不会释放锁<br>wait会释放锁</p>
<h4 id="✅等待-通知的经典范式"><a href="#✅等待-通知的经典范式" class="headerlink" title="✅等待/通知的经典范式"></a>✅等待/通知的经典范式</h4><p>范式分为两部分，分别针对等待方（消费者）和通知方（生产者）</p>
<p>等待方遵循如下原则：<br>1、获取对象的锁。<br>2、如果条件不满足（flag变量），那么调用对象的wait()方法，被通知后仍要检查条件。<br>3、条件满足则执行对应的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	while(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下原则：<br>1、获得对象的锁。<br>2、改变条件。<br>3、通知所有等待在对象上的线程。（先改变条件还是先通知都行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	改变条件(flag)</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、flag的目的：相当于是一个线程修改了某个值，另一个线程能感知到，起到一个多线程通信达到什么条件做什么事的效果。<br>2、同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。<br>3、其实这个模式已经是偏底层了。<br>4、flag和lock可以用一个，直接用flag来当锁（就像后面的手写线程池）</p>
<h4 id="✅管道输入-输出流"><a href="#✅管道输入-输出流" class="headerlink" title="✅管道输入/输出流"></a>✅管道输入/输出流</h4><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>例子：printThread线程接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PipedWriter out = new PipedWriter();</span><br><span class="line">        PipedReader in = new PipedReader();</span><br><span class="line">        // 将输出流和输入流进行连接，否则在使用时会抛出IOException</span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);</span><br><span class="line">        printThread.start();</span><br><span class="line">        int receive = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while ((receive = System.in.read()) != -1) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Print implements Runnable &#123;</span><br><span class="line">        private PipedReader in;</span><br><span class="line"></span><br><span class="line">        public Print(PipedReader in) &#123;</span><br><span class="line">            this.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int receive = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ((receive = in.read()) != -1) &#123;</span><br><span class="line">                    System.out.print((char) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h4 id="✅Thread-join-的使用"><a href="#✅Thread-join-的使用" class="headerlink" title="✅Thread.join()的使用"></a>✅Thread.join()的使用</h4><p>如果一个线程A执行了thread.join()语句，其含义是：<br>当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p>
<p>例子：创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Join &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span><br><span class="line">            Thread thread = new Thread(new Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Domino implements Runnable &#123;</span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public Domino(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。</p>
<p>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h4 id="✅ThreadLocal的使用"><a href="#✅ThreadLocal的使用" class="headerlink" title="✅ThreadLocal的使用"></a>✅ThreadLocal的使用</h4><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。它不是线程共有的，而是私有的。即修改不会影响其他线程。一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的值。set()方法设置，get()方法获取设置的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">取出后，(T)value强转即可</span><br></pre></td></tr></table></figure>

<p>例子：一个Profile类，具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Profiler &#123;</span><br><span class="line">    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span><br><span class="line">    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static final void begin() &#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final long end() &#123;</span><br><span class="line">        return System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Cost: &quot; + Profiler.end() + &quot; mills&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法。好处是两个方法的调用不用在一个方法或者类中。</p>
<h3 id="4-线程应用案例"><a href="#4-线程应用案例" class="headerlink" title="4.线程应用案例"></a>4.线程应用案例</h3><h4 id="✅等待超时模式"><a href="#✅等待超时模式" class="headerlink" title="✅等待超时模式"></a>✅等待超时模式</h4><p>在前面等待/通知模式的基础上，如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>范式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对当前对象加锁</span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">	long future = System.currentTimeMillis() + mills;</span><br><span class="line">	long remaining = mills;</span><br><span class="line">	// 当超时大于0并且result返回值不满足要求</span><br><span class="line">	while ((result == null) &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">		wait(remaining);</span><br><span class="line">		remaining = future - System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<p>并且，不是只wait固定的时间就完事，而是循环检查是不是wait够了，够了就直接返回不wait了。</p>
<h4 id="✅一个简单的数据库连接池示例"><a href="#✅一个简单的数据库连接池示例" class="headerlink" title="✅一个简单的数据库连接池示例"></a>✅一个简单的数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。</p>
<p>设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConnectionPool &#123;</span><br><span class="line">	//连接池</span><br><span class="line">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    //构造</span><br><span class="line">    public ConnectionPool(int initialSize) &#123;</span><br><span class="line">        if (initialSize &gt; 0) &#123;</span><br><span class="line">        	//创建数据库连接</span><br><span class="line">            for (int i = 0; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());//该类在后面实现，用于初始化线程池</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void releaseConnection(Connection connection) &#123;</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            synchronized (pool) &#123;</span><br><span class="line">                // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                // 唤醒所有等待，让他们去竞争锁</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在mills内无法获取到连接，将会返回null</span><br><span class="line">    //获取连接</span><br><span class="line">    public Connection fetchConnection(long mills) throws InterruptedException &#123;</span><br><span class="line">        synchronized (pool) &#123;</span><br><span class="line">        	// 该部分代码逻辑为</span><br><span class="line">        	// 当完全超时时，必然会获得一个连接池对象,也即是无线等待时间。当传入mills &gt; 0时，不会走入该分支。因为else分支会处理其中超时情况</span><br><span class="line">        	// 非完全超时时，获得就返回一个连接池对象，不然就返回空</span><br><span class="line">        	</span><br><span class="line">            // 完全超时</span><br><span class="line">            if (mills &lt;= 0) &#123;</span><br><span class="line">            	// 连接池为空</span><br><span class="line">                while (pool.isEmpty()) &#123;</span><br><span class="line">                    //以连接池为通知对象，等待直到被唤醒，不在主动醒来</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                // 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                return pool.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            //未超时 </span><br><span class="line">            else &#123;</span><br><span class="line">                long future = System.currentTimeMillis() + mills;</span><br><span class="line">                long remaining = mills;</span><br><span class="line">                //连接池为空且未超时</span><br><span class="line">                while (pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">                	//以连接池为通知对象，等待remaining毫秒,或者被唤醒</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    // 获取剩余时间，通过它来判断是主动醒来（超时），还是被动唤醒（notify）</span><br><span class="line">                    // 无论是被动还是主动醒来，都尝试获取连接池这个对象锁</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                    // 获得锁以后判断连接池是不是空的，空的的话再判断是否超时，超时就离开循环</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Connection result = null;</span><br><span class="line">                //抢到连接池这个对象锁后，若此时连接池不为空</span><br><span class="line">                if (!pool.isEmpty()) &#123;</span><br><span class="line">                	// 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                // 否则此时为空</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过<strong>动态代理</strong>构造了一个Connection，该Connection的代理实现仅仅是在commit()方法（提交sql）调用时休眠100毫秒，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConnectionDriver &#123;</span><br><span class="line"></span><br><span class="line">    static class ConnectionHandler implements InvocationHandler &#123;</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;</span><br><span class="line">         // 在方法执行之前</span><br><span class="line">        // 当方法是提交时，我们睡眠100毫秒</span><br><span class="line">        if (method.getName().equals(&quot;commit&quot;))&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 执行原本方法，此处就不执行了</span><br><span class="line">       	// Object invoke = method.invoke(vehical, args);</span><br><span class="line">       	</span><br><span class="line">		// 执行方法之后，此处也不处理，直接放回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个Connection的代理，在commit时休眠100毫秒</span><br><span class="line">    public static final Connection createConnection() &#123;</span><br><span class="line">    	// 创建一个代理实例</span><br><span class="line">    	// 类加载器(用哪个类加载器去加载代理对象) + 代理的类(接口，切入点) + 代理方法</span><br><span class="line">    	// 可以理解我们为Connection的&quot;commit&quot;方法，通过JDK的方式代理了一层(AOP)</span><br><span class="line">    	// 返回的就是我们Spring中学习的 代理额外增加的层 + 原本的类对象</span><br><span class="line">        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),new Class &lt;?&gt;[]&#123;</span><br><span class="line">            Connection.class</span><br><span class="line">        &#125;,new ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConnectionPoolTest &#123;</span><br><span class="line">    static ConnectionPool pool = new ConnectionPool(10);</span><br><span class="line">    // 保证所有ConnectionRunner能够同时开始</span><br><span class="line">    static CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">    // main线程将会等待所有ConnectionRunner结束后才能继续执行</span><br><span class="line">    static CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 线程数量，可以修改线程数量进行观察</span><br><span class="line">        int threadCount = 10;</span><br><span class="line">        end = new CountDownLatch(threadCount);</span><br><span class="line">        int count = 20;</span><br><span class="line">        // 用原子记录 获取到的与没有获取到的</span><br><span class="line">        AtomicInteger got = new AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = new AtomicInteger();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        	// 运行线程</span><br><span class="line">            Thread thread = new Thread(new ConnetionRunner(count, got, notGot),</span><br><span class="line">                    &quot;ConnectionRunnerThread&quot;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //运行到这里start值-1，此时为0，因此所有线程不再会被阻塞，开始执行</span><br><span class="line">        start.countDown();</span><br><span class="line">        //主线程阻塞在这里，等待end为0，即等待所有线程结束</span><br><span class="line">        end.await();   //等10个线程都执行完</span><br><span class="line">        System.out.println(&quot;total invoke: &quot; + (threadCount * count));</span><br><span class="line">        System.out.println(&quot;got connection: &quot; + got);</span><br><span class="line">        System.out.println(&quot;not got connection &quot; + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ConnetionRunner implements Runnable &#123;</span><br><span class="line">        int count;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		// got、noteGot因为是引用，所以本质还是原来的那个</span><br><span class="line">        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            this.count = count;</span><br><span class="line">            this.got = got;</span><br><span class="line">            this.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 阻塞在这里，等待start为0</span><br><span class="line">                start.await();  //等10个线程都创建好后一起执行</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当count &gt; 0 时，再次执行</span><br><span class="line">            while (count &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span><br><span class="line">                    // 分别统计连接获取的数量got和未获取到的数量notGot</span><br><span class="line">                    Connection connection = pool.fetchConnection(1000);</span><br><span class="line">                    // 如果获取到了</span><br><span class="line">                    if (connection != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                        	// 创建SQL语句</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            // 执行提交</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                        	// 释放</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            // 获取到got + 1</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                     // 没有获取到</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	// 没有获取到notGot + 1</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                </span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 线程结束 end - 1</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部结束之后，才使main线程从等待状态中返回。</p>
<p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。</p>
<h4 id="✅线程池技术及其示例"><a href="#✅线程池技术及其示例" class="headerlink" title="✅线程池技术及其示例"></a>✅线程池技术及其示例</h4><p>如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p>
<p>线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p>
<p>线程池的好处：<br>1、消除了频繁创建和消亡线程的系统资源开销<br>2、面对过量任务的提交能够平缓的劣化。</p>
<p>线程池接口定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ThreadPool&lt;Job extends Runnable&gt; &#123;</span><br><span class="line">    // 执行一个Job，这个Job需要实现Runnable</span><br><span class="line">    void execute(Job job);</span><br><span class="line"></span><br><span class="line">    // 关闭线程池</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    // 增加工作者线程</span><br><span class="line">    void addWorkers(int num);</span><br><span class="line"></span><br><span class="line">    // 减少工作者线程</span><br><span class="line">    void removeWorker(int num);</span><br><span class="line"></span><br><span class="line">    // 得到正在等待执行的任务数量</span><br><span class="line">    int getJobSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。<br>除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。<br>这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p>
<p>手写一个线程池，不用Executor创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;</span><br><span class="line">    // 线程池最大限制数</span><br><span class="line">    private static final int MAX_WORKER_NUMBERS = 10;</span><br><span class="line">    // 线程池默认的数量</span><br><span class="line">    private static final int DEFAULT_WORKER_NUMBERS = 5;</span><br><span class="line">    // 线程池最小的数量</span><br><span class="line">    private static final int MIN_WORKER_NUMBERS = 1;</span><br><span class="line">    // 这是一个工作列表，将会向里面插入工作</span><br><span class="line">    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();</span><br><span class="line">    // 工作者列表</span><br><span class="line">    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());</span><br><span class="line">    // 工作者线程的数量</span><br><span class="line">    private int workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    // 线程编号生成</span><br><span class="line">    private AtomicLong threadNum = new AtomicLong();</span><br><span class="line">	</span><br><span class="line">    //构造函数</span><br><span class="line">    public DefaultThreadPool() &#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultThreadPool(int num) &#123;</span><br><span class="line">    	// num &gt; max ， 取 max，num &lt; min 取 min。其他取 num</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS:(num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num);</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Job job) &#123;</span><br><span class="line">        if (job != null) &#123;</span><br><span class="line">            // 添加一个工作，然后进行通知</span><br><span class="line">            synchronized (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();   //通知（这里jobs既是flag又是lock）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        for (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addWorkers(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            // 限制新增的Worker数量不能超过最大值</span><br><span class="line">            if (num + this.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - this.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            this.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeWorker(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            if (num &gt;= this.workerNum) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;beyond workNum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 按照给定的数量停止Worker</span><br><span class="line">            int count = 0;</span><br><span class="line">            while (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                if (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getJobSize() &#123;</span><br><span class="line">        return jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化线程工作者</span><br><span class="line">    private void initializeWokers(int num) &#123;</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = new Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.inrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 工作者，负责消费任务</span><br><span class="line">    class Worker implements Runnable &#123;</span><br><span class="line">        // 是否工作</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (running) &#123;</span><br><span class="line">                Job job = null;</span><br><span class="line">                synchronized (jobs) &#123;</span><br><span class="line">                    // 如果工作者列表是空的，那么就wait</span><br><span class="line">                    while (jobs.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            jobs.wait();  //等待</span><br><span class="line">                        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                            // 感知到外部对WorkerThread的中断操作，返回</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 取出一个Job</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                if (job != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        // 忽略Job执行中的Exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void shutdown() &#123;</span><br><span class="line">            running = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Job是要放入线程池的线程，Worker是线程池内执行Job线程的工作线程。里面用了等待通知模式，放入一个job会通知一下，jobs为空了就会等待。</p>
<p>当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p>
<p>添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p>
<p>可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p>
<h4 id="✅一个基于线程池技术的简单Web服务器"><a href="#✅一个基于线程池技术的简单Web服务器" class="headerlink" title="✅一个基于线程池技术的简单Web服务器"></a>✅一个基于线程池技术的简单Web服务器</h4><p>目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取。</p>
<p>大部分Web服务器也都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p>
<p>使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">    // 处理HttpRequest的线程池</span><br><span class="line">    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);</span><br><span class="line">    // SimpleHttpServer的根路径</span><br><span class="line">    static String basePath;</span><br><span class="line">    static ServerSocket serverSocket;</span><br><span class="line">    // 服务监听端口</span><br><span class="line">    static int port = 8080;</span><br><span class="line"></span><br><span class="line">    public static void setPort(int port) &#123;</span><br><span class="line">        if (port &gt; 0) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setBasePath(String basePath) &#123;</span><br><span class="line">         if (basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动SimpleHttpServer，一个客户端请求</span><br><span class="line">    public static void start() throws Exception &#123;</span><br><span class="line">        serverSocket = new ServerSocket(port);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        //accept():3次握手结束，接受连接</span><br><span class="line">        while ((socket = serverSocket.accept()) != null) &#123;</span><br><span class="line">            // 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span><br><span class="line">            threadPool.execute(new HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class HttpRequestHandler implements Runnable &#123;</span><br><span class="line">        private Socket socket;</span><br><span class="line"></span><br><span class="line">        public HttpRequestHandler(Socket socket) &#123;</span><br><span class="line">            this.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            BufferedReader br = null;</span><br><span class="line">            BufferedReader reader = null;</span><br><span class="line">            PrintWriter out = null;</span><br><span class="line">            InputStream in = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                // 由相对路径计算出绝对路径</span><br><span class="line">                String filePath = basePath + header.split(&quot; &quot;)[1];</span><br><span class="line">                out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                 // 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span><br><span class="line">                if (filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;)) &#123;</span><br><span class="line">                    in = new FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while ((i = in.read()) != -1) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] array = baos.toByteArray();</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: image/jpeg&quot;);</span><br><span class="line">                    out.println(&quot;Content-Length: &quot; + array.length);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    System.out.println(&quot;传回！&quot;);</span><br><span class="line">                    socket.getOutputStream().write(array, 0, array.length);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    br = new BufferedReader(new InputStreamReader(new</span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                out.println(&quot;HTTP/1.1 500&quot;);</span><br><span class="line">                out.println(&quot;&quot;);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭流或者Socket</span><br><span class="line">    private static void close(Closeable... closeables) &#123;</span><br><span class="line">        if (closeables != null) &#123;</span><br><span class="line">            for (Closeable closeable : closeables) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleHttpServer提供设置端口和跟路径的方法，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。</p>
<p>在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。Worker处理请求资源生成响应内容后，异步输出内容到客户端。</p>
<p>html页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">&lt;body &gt;</span><br><span class="line">	&lt;h1&gt;第一张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;1.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第二张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;2.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第三张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;3.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    SimpleHttpServer.setBasePath(&quot;C:\Users\Administrator\Desktop\server&quot;);</span><br><span class="line">    SimpleHttpServer.setPort(8080);</span><br><span class="line">    SimpleHttpServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️线程池中的线程不是越多越好：<br>线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p>
<p>原书笔记：<a href="https://blog.csdn.net/weixin_46949627/article/details/127009251">https://blog.csdn.net/weixin_46949627/article/details/127009251</a></p>
<h2 id="第五章-java中的锁"><a href="#第五章-java中的锁" class="headerlink" title="第五章 java中的锁"></a>第五章 java中的锁</h2><p>介绍java并发包中与锁相关的API和组件，以及这些API和组件的使用方式和实现细节。</p>
<h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1.Lock接口"></a>1.Lock接口</h3><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</p>
<h4 id="✅Lock接口和synchronized关键字的对比"><a href="#✅Lock接口和synchronized关键字的对比" class="headerlink" title="✅Lock接口和synchronized关键字的对比"></a>✅Lock接口和synchronized关键字的对比</h4><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p>使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。例如：先获得锁A，然后再获取锁B。</p>
<p>Lock的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock具备的sychronized关键字不具备的特点：<br>1、非阻塞地获取锁<br>2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）<br>3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h4 id="✅Lock接口中的API"><a href="#✅Lock接口中的API" class="headerlink" title="✅Lock接口中的API"></a>✅Lock接口中的API</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void lock()</span><br><span class="line">获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</span><br><span class="line"></span><br><span class="line">void lockInterruptibly() throws InterruptedException	</span><br><span class="line">可中断地获取锁，和 lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</span><br><span class="line"></span><br><span class="line">boolean tryLock()	</span><br><span class="line">尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">boolean tryLock(1ong time,TimeUnit unit) throws InterruptedException	</span><br><span class="line">超时的获取锁，当前线程在以下3种情况下会返回：①当前线程在超时时间内获得了锁 ②当前线程在超时时间内被中断 ③超时时间结束，返回false</span><br><span class="line"></span><br><span class="line">void unlock() </span><br><span class="line">释放锁</span><br><span class="line"></span><br><span class="line">Condition newCondition()	</span><br><span class="line">获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁</span><br></pre></td></tr></table></figure>

<p>随后会详细介绍同步器AbstractQueuedSynchronizer以及常用Lock接口的实现ReentrantLock。Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h3 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2.队列同步器"></a>2.队列同步器</h3><p>队列同步器 AbstractQueuedSynchronizer（AQS，以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器提供的3个方法来对同步状态进行更改，它们能够保证状态的改变是安全的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getState()  获取当前同步状态。</span><br><span class="line">setState(int newState)  设置当前同步状态。</span><br><span class="line">compareAndSetState(int expect,int update)） 使用CAS设置当前状态，该方法能够保证状态</span><br></pre></td></tr></table></figure>

<p>子类通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的静态内部类。同步器自身没有实现任何同步接口，它仅仅是定义了上面同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件：<br>ReentrantLock<br>ReentrantReadWriteLock<br>CountDownLatch</p>
<p>队列同步器与锁的关系：</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<p>1、锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节<br>2、同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h4 id="✅队列同步器的接口与示例"><a href="#✅队列同步器的接口与示例" class="headerlink" title="✅队列同步器的接口与示例"></a>✅队列同步器的接口与示例</h4><p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法。</p>
<p><strong>同步器可重写的方法</strong>，包含两种，一种是获取独占锁，一种是获取共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期，然后通过CAS设置同步状态（非阻塞的？）</span><br><span class="line"> */</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态，此时等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态，返回结果大于等于0，表示获取成功，否则获取失败</span><br><span class="line"> */</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否被当前线程所独占</span><br><span class="line"> */</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义的同步器组件时，将会调用<strong>同步器提供的模板方法</strong>，同步器提供的模板方法分为三类：一是独占式获取与释放同步状态、二是共享式获取与释放同步状态、三是查询同步队列中等待线程的情况。自定义的同步器将使用这些提供的模板方法来实现自己的同步语义。同步器提供的模板方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 如果当前线程获取同步状态成功，则该方法执行完毕，否则，当前线程将会进入</span><br><span class="line"> * 同步队列等待，该方法将会调用重写的tryAcquire方法（区别：一个有返回，一个没有，输入没什么用？）</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 与acquire 相同，但是该方法响应中断，当前线程未获取到同步状态则进入同步队列；如果当前线程被中断，则该方法会抛出异常并返回</span><br><span class="line"> */</span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 该方法在 acquireInterruptibly(int arg) 基础上增加了超时限制，如果当前线程在超时时间内没有获取同步状态，那么将返回false，否则返回true</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态</span><br><span class="line"> * 该方法会在释放同步状态后，将同步队列中第一个节点中的线程唤醒</span><br><span class="line"> */</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与独占式的区别在于，同一时刻可以有多个线程获得同步状态</span><br><span class="line"> */</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与方法acquireShared(int arg) 一样，只是该方法响应中断</span><br><span class="line"> */</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 在方法 acquireSharedInterruptibly(int arg) 基础上，增加了超时限制</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquireShared(arg) &gt;= 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取在同步队列上等待的线程的集合</span><br><span class="line"> */</span><br><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null)</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，独占锁是在同一时刻只能有一个线程获得锁，而其他获取锁的线程只能在同步队列中等待，只有持有锁的线程释放了，其他线程才能获得锁。<strong>独占锁的示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mutex implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类自定义同步器</span><br><span class="line">     */</span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 是否处于独占状态</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() == 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式获取锁，状态为0时获取锁</span><br><span class="line">         * 如果经过CAS设置成功（同步状态设置为1）</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;  //0是期望，1是更新</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式释放锁，只是将状态置为0</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            if (getState() == 0) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 实例化一个 Condition，每个 Condition 都包含一个队列</span><br><span class="line">         */</span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、自定义定义独占锁实现Lock，所以需要实现Lock接口中的API<br>2、自定义同步器作为静态内部类继承自同步器，重写同步器方法，实现独占式获取和释放同步状态<br>3、Lock的API中使用同步器的重写方法/模版方法</p>
<p>在使用自定义同步器Mutex 时，不会直接与内部同步器交互，而是通过Mutex 提供的方法。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<p>Condition是什么？<br>ConditionObject 是AQS的内部类，用来维护等待队列<br>AQS内部实际上有两个队列<br>同步队列：公平/非公平，共享/非共享<br>等待队列：条件等待队列，也就是Condition<br>等待队列中就是用await方法时任务进入的队列（类似之前使用的wait，该队列中的任务只有唤醒才会尝试获取锁，以此减少CPU频繁的获取锁），通过signal唤醒。</p>
<h4 id="✅队列同步器的实现分析"><a href="#✅队列同步器的实现分析" class="headerlink" title="✅队列同步器的实现分析"></a>✅队列同步器的实现分析</h4><p>接下来将从实现角度分析同步器是如何完成线程同步的。<br>主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h5 id="一、同步队列"><a href="#一、同步队列" class="headerlink" title="一、同步队列"></a>一、同步队列</h5><p>同步器依赖内部的同步队列（一个FIFO双向队列,FIFO先进先出）来完成同步状态的管理。</p>
<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node，它也是AQS的内部类）并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p>
<p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect,Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。（只有一个线程获取到同步状态，所以设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。）</p>
<h5 id="二、独占式同步状态获取和释放"><a href="#二、独占式同步状态获取和释放" class="headerlink" title="二、独占式同步状态获取和释放"></a>二、独占式同步状态获取和释放</h5><p>同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态（阻塞型的，相当于是获锁），该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，<strong>线程不会从同步队列中移出</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作。首先tryAcquire非阻塞型地获取，如果获取到直接返回了，获取不到，就构造节点加入同步队列，在同步队列中会一直自旋尝试获取同步状态。</p>
<p>步骤：<br>1、调用自定义同步器实现的 tryAcquire(int arg) 方法，该方法保证线程安全的获取同步状态</p>
<p>2、如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部。</p>
<blockquote>
<p>enq(final Node node) 方法中，同步器通过 “死循环” 来保证节点的正确添加，在 “死循环” 中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。<br>可以看出，enq(final Node node) 方法将并发添加节点的请求通过CAS变得 “串行化” 了。</p>
</blockquote>
<p>3、节点进入同步队列之后，就进入了一个自旋的过程（acquireQueued(Node node,int arg) 方法），每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁，否则依旧留在这个自旋过程中（并会阻塞节点的线程，阻塞线程也就是进入等待，自旋不停？）</p>
<blockquote>
<p>虽然同步队列中每个线程都会自旋，但是只有前驱节点是头节点才能够尝试获取同步状态：<br>头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>维护同步队列的FIFO原则。</p>
</blockquote>
<p>4、如果获取不到则阻塞节点中的线程，而<strong>被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现</strong>。</p>
<blockquote>
<p>节点自旋，发现前驱不是头节点，就进入等待状态，只有线程被中断或前驱节点被释放才会再判断是不是前驱是头节点。前驱是头节点后，获取同步状态，如果获取失败，则进入等待状态。（几个等待状态应该不一样？）</p>
</blockquote>
<p>独占式同步状态获取流程，见P128</p>
<p>5、线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。调用同步器的 release(int arg) 模版方法（内部用tryRelease重写方法）可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点不为空或者状态不是0</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点</span><br><span class="line">            unparkSuccessor(h);  //用来唤醒处于等待状态的线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式同步状态获取和释放过程总结：<br>1、在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被自旋地加入到队列中并在队列中进行自旋<br>2、移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br>3、如果线程被中断，只是会唤醒被阻塞线程，是不会立刻被移出队列的，而是FIFO到该节点才移出。<br>4、不管是获取还是释放，都是模版方法里调用了重写的try方法。acquire是阻塞的，tryAcquire是非阻塞的，试一次，会返回是否成功。</p>
<p>疑问❓：<br>同步队列中节点的自旋和线程被阻塞的关系是什么？自旋发现前驱节点不是头节点或者获取不到同步状态的话，会阻塞线程，阻塞后是依靠前驱节点释放同步状态后唤醒或是中断唤醒还是一直自旋？</p>
<h5 id="三、共享式同步状态获取与释放"><a href="#三、共享式同步状态获取与释放" class="headerlink" title="三、共享式同步状态获取与释放"></a>三、共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读可以是共享锁，可以同时读，写是独占锁，一个在写，其他既不能读也不能写。</p>
<p>在 acquireShared(int arg) 方法中，同步器调用 tryAcquireShared(int arg) 方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 小于零获取锁失败</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 共享模式加入同步队列</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前一个线程为头结点</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将自己设置为头节点同时，传播状态，r就是之前返回的值</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null;</span><br><span class="line">                    // 如果过被当前线程状态为true，就设置当前线程的中断状态</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 逻辑同前</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 逻辑同前</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用releaseShared(int arg)方法可以释放同步状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 成功就修改自己节点状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。因为可能多个线程获取锁，所以，它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h5 id="四、独占式超时获取同步状态"><a href="#四、独占式超时获取同步状态" class="headerlink" title="四、独占式超时获取同步状态"></a>四、独占式超时获取同步状态</h5><p>通过调用同步器的 doAcquireNanos(int arg,long nanosTimeout) 【模版方法】方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<p>在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。</p>
<p>在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。</p>
<p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性。</p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p>
<p>如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待 nanosTimeout 纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object<br>blocker,long nanos)方法返回）。</p>
<p><strong>总结：</strong><br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑：<br>1、acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态<br>2、doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。</p>
<h5 id="五、自定义同步组件——TwinsLock"><a href="#五、自定义同步组件——TwinsLock" class="headerlink" title="五、自定义同步组件——TwinsLock"></a>五、自定义同步组件——TwinsLock</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞。</p>
<p>TwinsLock在同一时刻允许至多两个线程的同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2，其中0表示当前已经有两个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TwinsLock implements Lock &#123;</span><br><span class="line">    private final Sync sync = new Sync(2);</span><br><span class="line"></span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            if (count &lt;= 0) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;count must large than zero.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 在本方法中，用状态去代指资源数目</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int tryAcquireShared(int reduceCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int newCount = current - reduceCount;</span><br><span class="line">                if (newCount &lt; 0 || compareAndSetState(current,newCount)) &#123;</span><br><span class="line">                	// 返回当前剩余资源</span><br><span class="line">                    return newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryReleaseShared(int returnCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                // 当前数目 + 释放数目</span><br><span class="line">                int newCount = current + returnCount;</span><br><span class="line">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">    	// 获取共享锁，state + 1</span><br><span class="line">    	// 使用的是node节点的方法</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 释放共享锁 -1</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 其他接口方法略</span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, @NotNull TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @NotNull</span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、TwinsLock实现Lock接口，提供面向使用者的接口，使用者调用lock()<br>方法获取锁，随后调用unlock()方法释放锁，而同一时刻只能有两个线程同时获取到锁。<br>2、自定义同步器Sync作为静态内部类，该同步器面向线程访问和同步状态控制。共享式获取同步状态。<br>3、重写tryAcquireShared(int reduceCount)等方法，内部用过CAS确保状态的正确设置。acquireShared方法里是判断tryAcquireShared方法返回值大于等于0时，当前线程才获取同步状态。</p>
<p>总结：<br>1、acquireShared方法里输入的int，都是1呢。啥意思？<br>2、同步器作为一个桥梁，连接线程访问以及同步状态控制等底层技术与不同并发组件（比如Lock、CountDownLatch等）的接口语义。</p>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class TwinsLockTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        final Lock lock = new TwinsLock();</span><br><span class="line">        class Worker extends Thread &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 启动10个线程</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Worker w = new Worker();</span><br><span class="line">            w.setDaemon(true);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        // 每隔1秒换行</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程名称成对输出，在同一时刻只有两个线程能够获取到锁。</p>
<p>原书笔记：<a href="https://blog.csdn.net/weixin_46949627/article/details/127078972">https://blog.csdn.net/weixin_46949627/article/details/127078972</a><br><a href="http://t.zoukankan.com/liukaifeng-p-10052596.html">http://t.zoukankan.com/liukaifeng-p-10052596.html</a><br>Lock和sychronized区别：<a href="https://blog.csdn.net/weixin_41010294/article/details/123528508">https://blog.csdn.net/weixin_41010294/article/details/123528508</a></p>
<h3 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3.重入锁"></a>3.重入锁</h3><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>上一节的独占锁示例中，调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。</p>
<p>所以说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</p>
<p>重入锁：在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p>
<h4 id="✅实现重进入"><a href="#✅实现重进入" class="headerlink" title="✅实现重进入"></a>✅实现重进入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<p>1、线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p>
<p>2、锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p>非公平锁获取的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非公平锁获取</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    // 当前线程</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 获取锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 0 代表无锁</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 设置状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置独享锁的拥有者</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    // 如果当前线程是独有线程的线程ID</span><br><span class="line">    &#125; else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 是则增加次数</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //设置</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值.</p>
<p>非公平锁释放的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 减去释放的值</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 如果当前线程不是拥有者</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 如果是 0 则完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        // 抹去拥有者</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h4 id="✅公平与非公平获取锁的区别"><a href="#✅公平与非公平获取锁的区别" class="headerlink" title="✅公平与非公平获取锁的区别"></a>✅公平与非公平获取锁的区别</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<p>对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>【因此，上面的独占锁和共享锁也都是公平的】</p>
<p>测试公平和非公平锁在获取锁时的区别，五个线程循环获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairAndUnfairTest &#123;</span><br><span class="line">    private static Lock fairLock = new ReentrantLock2(true);</span><br><span class="line">    private static Lock unfairLock = new ReentrantLock2(false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void fair() &#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void unfair() &#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void testLock(Lock lock)&#123;</span><br><span class="line">        // 启动5个Job</span><br><span class="line">        for(int i = 0; i &lt; 5;i++)&#123;</span><br><span class="line">            new Job(lock).start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Job extends Thread &#123;</span><br><span class="line">        private Lock lock;</span><br><span class="line"></span><br><span class="line">        public Job(Lock lock) &#123;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 连续2次打印当前的Thread和等待队列中的Thread</span><br><span class="line">                lock.lock();</span><br><span class="line">                ReentrantLock2 reentrantLock2 = (ReentrantLock2) lock;</span><br><span class="line">                System.out.println(&quot;Fair:&quot; + reentrantLock2.isFair() + &quot;,Lock By 【&quot; + Thread.currentThread().getName() + &quot;】，waitting by  &quot; + reentrantLock2.getQueuedThreads().toString());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReentrantLock2 extends ReentrantLock &#123;</span><br><span class="line">        public ReentrantLock2(boolean fair) &#123;</span><br><span class="line">            super(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = new ArrayList&lt;Thread&gt;(super.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。（刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。）</p>
<p>2、公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。</p>
<h4 id="✅读写锁的接口和示例"><a href="#✅读写锁的接口和示例" class="headerlink" title="✅读写锁的接口和示例"></a>✅读写锁的接口和示例</h4><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非线程安全的HashMap作为缓存,使用读写锁的读锁和写锁来保证Cache是线程安全的.Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</p>
<h4 id="✅读写锁的实现分析"><a href="#✅读写锁的实现分析" class="headerlink" title="✅读写锁的实现分析"></a>✅读写锁的实现分析</h4><h5 id="一、读写状态的设计"><a href="#一、读写状态的设计" class="headerlink" title="一、读写状态的设计"></a>一、读写状态的设计</h5><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p>
<p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，如果在一个整型变量上维护多种状态，就一定需要 “按位切割使用” 这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<p>通过位运算可以迅速确定读和写各自的状态，假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF （将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。</p>
<h5 id="二、写锁的获取与释放"><a href="#二、写锁的获取与释放" class="headerlink" title="二、写锁的获取与释放"></a>二、写锁的获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 通过状态计算写锁数量</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    // 锁不为0，说明有读或者写</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // 写锁不存在（说明现在是读锁）或者当前获取线程不是已经获取写锁的线程</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 如果重入次数大于最大冲入数目</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试获取写锁</span><br><span class="line">    // writerShouldBlock：公平锁会调用 hasQueuedPredecessors判断轮得到自己吗，非公平直接返回false去竞争锁</span><br><span class="line">    //  compareAndSetState 失败就会返回false</span><br><span class="line">    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置当前线程拥有锁</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</p>
<p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h5 id="三、读锁的获取与释放"><a href="#三、读锁的获取与释放" class="headerlink" title="三、读锁的获取与释放"></a>三、读锁的获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在 没有其他写线程访问（或者写状态为0） 时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。</p>
<p>获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount() 方法，作用是返回当前线程获取读锁的次数。由于读状态是 所有线程获取读锁次数的总和 ，所以每个线程 各自获取读锁的次数只能选择保存在ThreadLocal中 ，由线程自身维护，于是使获取读锁的实现变得复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        // 获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 读数目+1</span><br><span class="line">        int nextc = c + (1 &lt;&lt; 16);</span><br><span class="line">        // 溢出</span><br><span class="line">        if (nextc &lt; c)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 现在是写状态 且 拥有者不是自己</span><br><span class="line">        if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            return -1;</span><br><span class="line">        // 修改状态</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p>
<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h5 id="四、锁降级"><a href="#四、锁降级" class="headerlink" title="四、锁降级"></a>四、锁降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void processData() &#123;</span><br><span class="line">		//锁住读锁</span><br><span class="line">        readLock.lock();</span><br><span class="line">        // 数据在更新吗</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">			// 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">			// 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">					// 准备数据的流程（略）</span><br><span class="line">                    update = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //开始降级</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	// 锁降级完成，写锁降级为读锁</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">			// 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。<br>这样变更完数据之后，可以多个读线程一起读取数据。</p>
<p>不支持锁升级：有线程获取读锁的时候，不能获取写锁，数据更新对其他线程的可见性。</p>
<h3 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5.LockSupport工具"></a>5.LockSupport工具</h3><p>队列同步器中，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>
<p>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<p>比如说，线程dump结果结果中，有阻塞对象的parkNanos方法能够传递给开发人员阻塞对象的信息。</p>
<p>为什么要加阻塞对象信息？<br>由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p>
<h3 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6.Condition接口"></a>6.Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。</p>
<p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的：<br>1、前置条件不但要获取锁，还要调用<code>Lock.newCondition()</code>获取Condition对象<br>2、等待队列支持多个<br>3、支持超时等待状态<br>4、支持在等待状态中不响应中断（可以对中断不敏感）</p>
<p>总结一下：<br>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列<br>可以直接使用synchronized实现同步<br>可以直接使用Lock实现锁，只不过只有同步队列，里面线程是阻塞状态，没有等待队列</p>
<h4 id="✅Condition接口与示例"><a href="#✅Condition接口与示例" class="headerlink" title="✅Condition接口与示例"></a>✅Condition接口与示例</h4><p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。</p>
<p>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<p>等待通知模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void conditionWait() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void conditionSignal() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Condition对象作为成员变量。通过Lock的newCondition()方法</p>
<p>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>Condition接口方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await() ：造成当前线程在接到信号或被中断之前一直处于等待状态，对中断敏感。</span><br><span class="line">await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span><br><span class="line">awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</span><br><span class="line">awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</span><br><span class="line">awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</span><br><span class="line">signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</span><br><span class="line">signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</span><br></pre></td></tr></table></figure>

<p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程（进入等待队列），直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。有点像线程池。</p>
<p>线程池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    // 添加的下标，删除的下标和数组当前数量</span><br><span class="line">    private int addIndex, removeIndex, count;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition notEmpty = lock.newCondition();</span><br><span class="line">    private Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size) &#123;</span><br><span class="line">        items = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            if (++addIndex == items.length)</span><br><span class="line">                addIndex = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            if (++removeIndex == items.length)</span><br><span class="line">                removeIndex = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以添加方法为例：首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p>
<p>在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p>
<p>⚠️线程的阻塞、等待的区别：<br>在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。<br>相同点：<br>（1）都会暂停线程的执行。<br>区别点：<br>（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。<br>阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。<br>等待状态的主动：线程在同步代码内await，等待其他线程唤醒时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</p>
<h4 id="✅Condition的实现分析"><a href="#✅Condition的实现分析" class="headerlink" title="✅Condition的实现分析"></a>✅Condition的实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。</p>
<p>每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<h5 id="一、等待队列"><a href="#一、等待队列" class="headerlink" title="一、等待队列"></a>一、等待队列</h5><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>等待队列：当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列（每个Condition对象一个）。</p>
<h5 id="二、等待"><a href="#二、等待" class="headerlink" title="二、等待"></a>二、等待</h5><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p>
<p>ConditionObject的await方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 节点是否在同步队列中</span><br><span class="line">    // Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.</span><br><span class="line">    // 如果节点在同步队列中，现在等待重新去获取锁，返回true</span><br><span class="line">    // 一般总是在条件队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        // 暂停自己，等待被唤醒或者被中断</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        // 是否被中断了</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取锁成功且异常模式不为THROW_IE，就修改interruptMode</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 该方法是内部类Condition中的，设置下一个在首位的等待者</span><br><span class="line">    if (node.nextWaiter != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    // 如果interruptMode 不是0，唤醒后报告中断</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。（同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。）</p>
<p>（2）当等待队列中的节点被唤醒，则唤醒节点的线程进入同步队列，开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p>
<h5 id="三、通知"><a href="#三、通知" class="headerlink" title="三、通知"></a>三、通知</h5><p>调用Condition的signal()方法的前置条件是当前线程必须获取了锁，将在等待队列中等待时间最长的节点（首节点），线程安全地移动到同步队列，并使用LockSupport唤醒节点中的线程，然后就竞争锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    // 锁是否处于占用状态</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 获取第一个线程</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        // 唤醒</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p>
<p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。如果未获取到锁，将在同步队列中阻塞。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h2 id="第六章-java并发容器和框架"><a href="#第六章-java并发容器和框架" class="headerlink" title="第六章 java并发容器和框架"></a>第六章 java并发容器和框架</h2><h3 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h4 id="✅为什么使用ConcurrentHashMap"><a href="#✅为什么使用ConcurrentHashMap" class="headerlink" title="✅为什么使用ConcurrentHashMap"></a>✅为什么使用ConcurrentHashMap</h4><p>（1）<strong>HashMap线程不安全会死循环</strong></p>
<p>HashMap 在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(2); // 容量为2的Map</span><br><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    map.put(UUID.randomUUID().toString(),&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;ftf&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&quot;ftf&quot;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure>

<p>HashMap的实现原理：<br>HashMap的主干是一个Entry数组（Entry是以链表的形式存储的）。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。(其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合)。</p>
<p>Entry结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next; // 存储指向下一个Entry的引用，单链表结构。</span><br><span class="line"> </span><br><span class="line">    int hash;	   // 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以：HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>HashMap在put的时候，插入的元素超过了容量(由负载因子决定)的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在其他的元素也在put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p>HashMap的线程不安全主要体现在会造成死循环，数据丢失，数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在Jdk1.8中已经得到解决，然而JDK1.8仍会有数据覆盖这样的问题。</p>
<p>（2）<strong>效率低下的HashTable</strong></p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其它线程也访问HashTable的同步方法时，会进入阻塞或轮询状态，所以竞争越激烈效率越低。</p>
<p>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率。</p>
<p>HashTable的线程都必须竞争同一把锁，假如容器里有多把锁每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其它段的数据也能被其他线程访问。</p>
<h4 id="✅ConcurrentHashMap的结构"><a href="#✅ConcurrentHashMap的结构" class="headerlink" title="✅ConcurrentHashMap的结构"></a>✅ConcurrentHashMap的结构</h4><p>类图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock),在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。<strong>一个Segment里包含一个HashEntry数组</strong>，<strong>每个HashEntry是一个链表结构的元素（一个包含数据的链表）</strong>，每个Segment里守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<h4 id="✅ConcurrentHashMap的初始化与定位"><a href="#✅ConcurrentHashMap的初始化与定位" class="headerlink" title="✅ConcurrentHashMap的初始化与定位"></a>✅ConcurrentHashMap的初始化与定位</h4><p>ConcurrentHashMap初始化方法是通过initialCapacity, loadFactor和concurrencyLevel等几个参数来初始化segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组来实现。</p>
<p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。而且，会使用再散裂算法对元素的hashCode进行一次再散列。</p>
<p>再散列的目的：减少散列冲突，使元素均匀地分布在不同的segmrnt上，提高容器的存取效率。</p>
<h4 id="✅ConcurrentHashMap的操作"><a href="#✅ConcurrentHashMap的操作" class="headerlink" title="✅ConcurrentHashMap的操作"></a>✅ConcurrentHashMap的操作</h4><p>（1）get(key)</p>
<p>经过一次再散列，先定位到segment，然后再通过散列运算定位到元素。<br>不需要加锁，除非读到的值是空的才会加锁重读。原因是：将共享变量（segment大小、HashEntry里的value）定义为volatile。利用volatile在多线程中的可见性，可以被多线程读，保证不会读到过期的值。</p>
<p>（2）put(key, value)</p>
<p>先定位到segment，然后在segment里进行插入操作。分两步：<br>1.是否需要扩容？<br>先判断HashEntry数组是否超过阈值，如果超过了就扩容，扩容之后再插入数据。而HashMap是先插入再扩容，这样不好，因为下次可能就没有数据进来了，那就白扩容了。<br>2.如何扩容？<br>先创建一个容量是原来2倍的数组，然后通过对原数组元素进行再散列后插入到新数组。扩容只会对某个segment进行。</p>
<p>（3）size()</p>
<p>Segment中有一个全局变量count是一个volatile变量，可以累加各个segment的count来计算大小。但是可能累加前count发生了变化，统计结果不准。但是锁住所有的segment再计算也不合适。</p>
<p>在每个segment中有一个volatile修饰的count属性，表示这个segment中的元素个数，先通过2次不加锁的方法统计所有count的总和，如果两次结果不相等，或者容器被修改过了，就将Segment加锁，再进行第三次统计。</p>
<p>ConcurrentHashMap中有一个modCount变量，每次put\remove\clean操作，都会对这个值加一，通过比较这个值，就知道是否容器是否被修改了。</p>
<h3 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2.ConcurrentLinkedQueue"></a>2.ConcurrentLinkedQueue</h3><p>无界线程安全队列。</p>
<p>在并发编程中，有时候需要使用线程安全的对列。如果要实现一个线程安全的对列有2种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的对列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。【锁也是基于CAS和volatile来实现的吧】</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全对列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到对列的尾部；当我们获取一个元素时，它会返回对列头部的元素。它采用了”wait-free”算法(即CAS算法)来实现。</p>
<h4 id="✅ConcurrentLinkedQueue的结构"><a href="#✅ConcurrentLinkedQueue的结构" class="headerlink" title="✅ConcurrentLinkedQueue的结构"></a>✅ConcurrentLinkedQueue的结构</h4><p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素(item)和指向下一个节点(next)的引用组成，节点和节点之间就是通过这个next关联起来，从而组成一张链表结构的对列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p>继承了AbstractQueue，不是阻塞队列。</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成。head、tail、next、item均使用volatile修饰，保证其内存可见性。</p>
<h4 id="✅入队列-offer-E-e"><a href="#✅入队列-offer-E-e" class="headerlink" title="✅入队列:offer(E e)"></a>✅入队列:offer(E e)</h4><p>入队列就是将入队节点添加到对列的尾部。入队主要做两件事情：<br>第一：是将入队节点设置成当前队列尾节点的下一个节点；<br>第二：是更新tail节点，如果tail节点的next不为空，则将入队节点设置为tial节点，成为队尾节点的next节点，如果tail节点的next为空，则将入队节点的设置为tail的next节点。所以tail节点不总是尾节点。【效果是两格两格得跳】</p>
<p>1.定位尾节点<br>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。</p>
<p>2.设置入队节点为尾节点<br>p.casNext(null,n)方法用于将入队节点设置为当前对尾节点的next节点，如果p是null，表示p是当前节点的尾节点，如果不为null，表示有其它线程更新了尾节点，则需要重新获取当前对列的尾节点。</p>
<p>⚠️不是每次入队都更新tail节点：<br>如果将tail节点永远作为尾节点，这样每次都需要循环CAS更新tail节点，而设置一个到尾节点的距离，当tail到尾节点的距离大于某个值（通常为1）的时候再更新tail，这样可以减少更新的次数，提高入队的效率。定位尾节点时就需要增加对volatile变量读操作，但是对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p><strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
<h4 id="✅出队列：poll"><a href="#✅出队列：poll" class="headerlink" title="✅出队列：poll()"></a>✅出队列：poll()</h4><p>不是每次出队都更新head节点，当head中有元素，就直接弹出head的元素，如果没有元素，就弹出head的next，然后更新head节点，head节点变为弹出节点的next节点。【一次走两格】<br>也是通过控制距离的方式，减少CAS更新节点的消耗。</p>
<h3 id="3-阻塞队列"><a href="#3-阻塞队列" class="headerlink" title="3.阻塞队列"></a>3.阻塞队列</h3><p>阻塞对列(BlockingQueue)是一个支持两个附加操作的对列。这两个附加操作支持阻塞的插入和移除方法。</p>
<p>1）支持阻塞的插入方法：意思是当对列满时，对列会阻塞插入元素的线程，直到对列不满。<br>2）支持阻塞的移除方法：意思是当对列为空时，获取元素的线程会等待对列不为空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向对列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------插入和移除操作的4种处理方式--------------</span><br><span class="line"></span><br><span class="line">方法/处理方式    抛出异常    返回特殊值    一直阻塞    超时退出</span><br><span class="line">插入方法        add(e)     offer(e)     put(e)      offer(e,time,unit)</span><br><span class="line">移除方法       remove()    poll()       take()     poll(time,unit)</span><br><span class="line">检查方法      element()    peek()       不可用      不可用</span><br><span class="line"></span><br><span class="line">1）抛出异常：当队列满时，如果再往对列里插入元素，会抛出IllegalStateException(&quot;Queue full&quot;)异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</span><br><span class="line">2）返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有返回null。</span><br><span class="line">3）一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到对列可用或者响应中断退出。当队列为空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</span><br><span class="line">4）超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</span><br></pre></td></tr></table></figure>

<p>如果是无界阻塞队列，队列不可能出现满的情况，岁月使用put和offer永远不会被阻塞，而且使用offer方法时，总返回true。</p>
<h4 id="✅java提供的几种阻塞队列"><a href="#✅java提供的几种阻塞队列" class="headerlink" title="✅java提供的几种阻塞队列"></a>✅java提供的几种阻塞队列</h4><p>ArrayBlockingQueue:    一个由数组结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue是一个用数组实现的有界阻塞队列。</span><br><span class="line">此队列按照先进先出(FIFO)的原则对元素进行排序。</span><br><span class="line">默认情况下不保证线程公平的访问队，即不保证先阻塞线程先访问队列。</span><br><span class="line"></span><br><span class="line">如果想保证公平性，可以用可重入锁来实现</span><br><span class="line">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue&lt;&gt;(1000, true);</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue:    一个由链表结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedBlockingQueue是一个用链表实现的有界阻塞队列。</span><br><span class="line">此队列的默认和最大长度为Inter.MAX_VALUE。</span><br><span class="line">此队列按照先进先出的原则对元素进行排序。</span><br></pre></td></tr></table></figure>

<p>PriorityBlockingQueue:    一个支持优先级排序的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</span><br><span class="line">默认情况下元素采取自然顺序升序排列。</span><br><span class="line">也可以自定义实现compareTo()方法来指定元素排序规则，</span><br><span class="line">或者初始化PriorityBlockingQueue时，指定构造参数(Comparator)来对元素进行排序。</span><br><span class="line">需要注意的是不能保证同优先级元素的排序。</span><br></pre></td></tr></table></figure>

<p>DelayQueue:    一个使用优先级队列实现的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DelayQueue是一个支持延时获取元素的无界阻塞队列.</span><br><span class="line">队列使用PriorityQueue来实现。</span><br><span class="line">队列中的元素必须实现Delayed接口，在创建元素时可以指定多久（元素存在了多久）才能从队列中获取当前元素。</span><br><span class="line">只有在延迟期满时才能从队列里提取元素。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line">1）缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素时，表示缓存有效期到了。</span><br><span class="line">2）定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimeQueue就是使用DelayQueue实现的。</span><br><span class="line"></span><br><span class="line">a.如何实现Delayed接口</span><br><span class="line">DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</span><br><span class="line"></span><br><span class="line">第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。</span><br><span class="line"></span><br><span class="line">private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">private class ScheduledFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; &#123;</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, long ns) &#123;</span><br><span class="line">    super(r, result);</span><br><span class="line">    this.time = ns;</span><br><span class="line">    this.period = 0;</span><br><span class="line">    this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒</span><br><span class="line"></span><br><span class="line">public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">    return unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第三步：实现compareTo()方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。</span><br><span class="line"></span><br><span class="line">public int compareTo(Delayed other) &#123;</span><br><span class="line">    if (other == this) // compare zero ONLY if same object</span><br><span class="line">        return 0;</span><br><span class="line">    if (other instanceof ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        long diff = time - x.time;</span><br><span class="line">        if (diff &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        else if (diff &gt; 0)</span><br><span class="line">            return 1;</span><br><span class="line">        else if (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            return -1;</span><br><span class="line">        else</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">            other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    return (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b. 如何实现延时阻塞队列</span><br><span class="line">延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</span><br><span class="line"></span><br><span class="line">public RunnableScheduledFuture take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture first = queue[0];</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return finishPoll(first);</span><br><span class="line">                else if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; queue[0] != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中的变量leader是一个等待获取队列头部元素的线程。</span><br><span class="line">如果leader不等于空，表示已经有线程在等待获取队列的头元素。</span><br><span class="line">所以，使用await()方法让当前线程等待信号。</span><br><span class="line">如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</span><br></pre></td></tr></table></figure>

<p>SynchronousQueue:    一个不存储元素的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</span><br><span class="line">它支持公平访问队列.</span><br><span class="line">默认情况下线程采用非公平性策略访问队列。创建公平性访问的SynchronousQueue，如果设置true，则等待的线程会采用先进先出的顺序访问队列。</span><br><span class="line">负责把生产者线程处理的数据直接传递给消费者线程。</span><br><span class="line">队列本身并不存储任何元素，非常适合传递性场景。</span><br><span class="line">SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</span><br><span class="line">有点像go的channel</span><br></pre></td></tr></table></figure>

<p>LinkedTransferQueue:    一个由链表结构组成的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。</span><br><span class="line">相对于其它阻塞队列，linkedTransferQueue多了tryTransfer和transfer方法。</span><br><span class="line"></span><br><span class="line">（1）transfer方法</span><br><span class="line">如果当前有消费者正在等待接收元素(消费者使用take()方法或带有时间限制的poll()方法时)，</span><br><span class="line">transfer方法可以把生产者传入的元素立刻transfer(传输)给消费者。</span><br><span class="line">如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</span><br><span class="line">会让CPU自旋等待消费者消费元素。</span><br><span class="line">因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其它线程。</span><br><span class="line"></span><br><span class="line">（2）tryTransfer方法</span><br><span class="line">tryTransfer方法是用来试探生产者传入的元素是否能直接传递给消费者。</span><br><span class="line">如果没有消费者等待接收元素，则返回false。</span><br><span class="line">和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，</span><br><span class="line">而transfer方法是必须等到消费者消费了才返回。</span><br><span class="line"></span><br><span class="line">对于带有时间限制的tryTransfer(E e,long timeout,TimeUnit unit)方法，</span><br><span class="line">试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回。</span><br><span class="line">如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true.</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingDeque:    一个由链表结构组成的双向阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。</span><br><span class="line">所谓双向队列指的是可以从队列的两端插入和移出元素。</span><br><span class="line">双向队列因为多了个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</span><br><span class="line">相比其它的阻塞队列，LinkedBlockingDeque多了addFirst,addLast,offerFirst,offerLast,peekFirst和peekLast等方法，</span><br><span class="line">以First单词结尾的方法，表示插入，获取(peek)或移除双端队列的第一个元素。</span><br><span class="line">以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。</span><br><span class="line">另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst.</span><br><span class="line"></span><br><span class="line">在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外双向阻塞队列可以运用在&quot;工作窃取&quot;模式中。</span><br></pre></td></tr></table></figure>

<h4 id="✅阻塞队列的实现原理"><a href="#✅阻塞队列的实现原理" class="headerlink" title="✅阻塞队列的实现原理"></a>✅阻塞队列的实现原理</h4><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源代码发现ArrayBlockingQueue使用了Condition来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">notEmpty = lock.newCondition();</span><br><span class="line">notFull = lock.newChonditon();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果队列满：添加元素的时候，通过调用notFull.await()阻塞当前线程；移除元素额时候，用notFull.signal()唤醒在notFull上等待的线程。</li>
<li>如果队列空：读取元素的时候，通过notEmpty.await()阻塞当前线程；当添加元素时，调用notEmpty.signal()唤醒在notEmpty上等待的线程。</li>
</ul>
<p>阻塞生产者await()主要通过LockSupport.park(this)来实现。其中，首先调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p>
<h3 id="4-Fork-Join框架"><a href="#4-Fork-Join框架" class="headerlink" title="4.Fork/Join框架"></a>4.Fork/Join框架</h3><p>Fork/Join框架是Java 7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<h4 id="✅工作窃取-work-stealing-算法"><a href="#✅工作窃取-work-stealing-算法" class="headerlink" title="✅工作窃取(work-stealing)算法"></a>✅工作窃取(work-stealing)算法</h4><p>工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>做一个比较大的任务，可以把这个任务分割成若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。<br>比如A线程负责处理A队列里的任务。但是，有的线程会把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用双端队列，被窃取任务线程永远从双端队列头部拿任务执行，而窃取任务的线程永远从双队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h4 id="✅Fork-Join框架的设计"><a href="#✅Fork-Join框架的设计" class="headerlink" title="✅Fork/Join框架的设计"></a>✅Fork/Join框架的设计</h4><p>步骤1：分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</p>
<p>步骤2：执行任务并合并结果。分割的子任务分别放在双端队列，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p>
<p>Fork/Join使用两个类来完成以上两个事情：</p>
<p>1)ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。<br>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。<br>a.RecursiveAction: 用于没有返回结果的任务。<br>b.RecursiveTask:用于有返回结果的任务。</p>
<p>2）ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p>
<p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程队列的尾部获取一个任务。</p>
<h4 id="✅使用Fork-Join的例子"><a href="#✅使用Fork-Join的例子" class="headerlink" title="✅使用Fork/Join的例子"></a>✅使用Fork/Join的例子</h4><p>计算1+2+3+4的结果：</p>
<p>1.如何fork：设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务</p>
<p>2.如何join：join两个子任务的结果。因为是有结果的任务，因此必须继承RecursiveTask</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"> </span><br><span class="line">    private static final int THRESHOLD = 2;//阈值</span><br><span class="line"> </span><br><span class="line">    private int start;</span><br><span class="line"> </span><br><span class="line">    private int end;</span><br><span class="line"> </span><br><span class="line">    public CountTask(int start,int end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        // 如果任务足够小就计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        if (canCompute)&#123;</span><br><span class="line">            for (int i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">            int middle = (start + end)/2;</span><br><span class="line">            CountTask leftTask = new CountTask(start,middle);</span><br><span class="line">            CountTask rightTask = new CountTask(middle+1,end);</span><br><span class="line"> </span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"> </span><br><span class="line">            // 等待子任务执行完，并得到结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"> </span><br><span class="line">            // 合并子任务</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        // 生成一个计算任务，负责计算 1+2+3+4</span><br><span class="line">        CountTask task = new CountTask(1,4);</span><br><span class="line">        // 执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;魔法革的日志信息：----&gt;&quot;+ result.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork方法是执行，join方法是等待执行完获取运行结果。需要实现computer方法，在这个方法里看怎么拆分任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完成并得到结果。</p>
<h4 id="✅Fork-Join框架的异常处理"><a href="#✅Fork-Join框架的异常处理" class="headerlink" title="✅Fork/Join框架的异常处理"></a>✅Fork/Join框架的异常处理</h4><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (task.isCompletedAbnormally())&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p>
<h4 id="✅Fork-Join框架的实现原理"><a href="#✅Fork-Join框架的实现原理" class="headerlink" title="✅Fork/Join框架的实现原理"></a>✅Fork/Join框架的实现原理</h4><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成的，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<p>（1）fork方法实现原理：</p>
<p>调用ForkJoinTask的fork()方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。</p>
<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>
<p>（2）join方法实现原理</p>
<p>Join方法的主要作用是阻塞当前线程并等待获取结果。</p>
<p>它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：<br>已完成(NORMAL)，被取消(CANCELLED)，信号(SIGNAL)和出现异常(EXCEPTION)。</p>
<p>a. 如果任务状态已完成，则直接返回任务结果。<br>b. 如果任务状态是被取消，则直接抛出CancellationException。<br>c. 如果任务状态是抛出异常，则直接抛出对应的异常。</p>
<p>在doJoin()方法里，首先通过任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。<br>如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h2 id="第七章-java中的13个原子操作类"><a href="#第七章-java中的13个原子操作类" class="headerlink" title="第七章 java中的13个原子操作类"></a>第七章 java中的13个原子操作类</h2><p>多线程同时更新一个变量，通常我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p>
<p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<blockquote>
<p>Unsafe类位于sun.misc包下，它是java实现高并发的基础，通过它可以执行一些不安全的操作，如像C语言一样直接操作内存资源，<br>它提供的这些方法增强了java对底层资源的操作能力，但同时也增加了程序出错的风险.<br>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障相关、数组相关等。</p>
</blockquote>
<blockquote>
<p>CAS(compareAndSwap)即比较并替换，是实现并发算法时常用到的一种技术。CAS底层为一条原子指令cmpxchg，可以保证原子性，Unsafe提供的CAS方法如compareAndSwapInt底层就是CPU指令cmpxchg。<br>CAS在java并发包中的原子类如AtomicInteger，AQS(AbstractQueuedSynchronizer)，ConcurrentHashMap等实现中都有广泛的使用。<br>因此，不管是Atomic还是什么锁里的CAS都依托于Unsafe包里的方法。</p>
</blockquote>
<p>Unsafe类：<a href="https://www.cnblogs.com/strongmore/p/15468423.html">https://www.cnblogs.com/strongmore/p/15468423.html</a></p>
<h3 id="1-原子更新基本类型类"><a href="#1-原子更新基本类型类" class="headerlink" title="1.原子更新基本类型类"></a>1.原子更新基本类型类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicBoolean：原子更新布尔类型。</span><br><span class="line">· AtomicInteger：原子更新整型。</span><br><span class="line">· AtomicLong：原子更新长整型。</span><br><span class="line"></span><br><span class="line">AtomicInteger为例：</span><br><span class="line">· int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</span><br><span class="line"></span><br><span class="line">· int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</span><br><span class="line"></span><br><span class="line">· void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br><span class="line"></span><br><span class="line">·int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    int current = get(); </span><br><span class="line">    int next = current + 1;</span><br><span class="line">    if (compareAndSet(current, next)) </span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Atomic包里的类基本都是使用Unsafe实现的.<br>Unsafe只提供了3种CAS方法：compareAndSwapObject、compare- AndSwapInt和compareAndSwapLong.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object o,  long offset, Object expected, Object x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,  int expected, int x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,  long expected, long x);  </span><br></pre></td></tr></table></figure>

<h3 id="2-原子更新数组"><a href="#2-原子更新数组" class="headerlink" title="2.原子更新数组"></a>2.原子更新数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicIntegerArray：原子更新整型数组里的元素。</span><br><span class="line">· AtomicLongArray：原子更新长整型数组里的元素。</span><br><span class="line">· AtomicReferenceArray：原子更新引用类型数组里的元素。</span><br><span class="line"></span><br><span class="line">AtomicIntegerArray为例：</span><br><span class="line">· int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</span><br><span class="line"></span><br><span class="line">static int[] value = new int[] &#123; 1， 2 &#125;;  </span><br><span class="line">static AtomicIntegerArray ai = new AtomicIntegerArray(value); </span><br><span class="line">ai.getAndSet(0， 3);</span><br><span class="line">System.out.println(ai.get(0)); //3</span><br><span class="line">System.out.println(value[0]);  //1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="3-原子更新引用类型"><a href="#3-原子更新引用类型" class="headerlink" title="3.原子更新引用类型"></a>3.原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">· AtomicReference：原子更新引用类型。</span><br><span class="line">· AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</span><br><span class="line">· AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</span><br><span class="line"></span><br><span class="line">AtomicReference为例：</span><br><span class="line"></span><br><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;user&gt; atomicUserRef = new AtomicReference&lt;user&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;conan&quot;， 15); atomicUserRef.set(user);</span><br><span class="line">        User updateUser = new User(&quot;Shinichi&quot;， 17); atomicUserRef.compareAndSet(user， updateUser);</span><br><span class="line">        System.out.println(atomicUserRef.get().getName());</span><br><span class="line">        System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-原子更新字段类"><a href="#4-原子更新字段类" class="headerlink" title="4.原子更新字段类"></a>4.原子更新字段类</h3><p>更新静态类里的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">· AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</span><br><span class="line">· AtomicLongFieldUpdater：原子更新长整型字段的更新器。</span><br><span class="line">· AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</span><br></pre></td></tr></table></figure>

<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>
<p>AstomicIntegerFieldUpdater例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterTest &#123;</span><br><span class="line"></span><br><span class="line">   // 创建原子更新器，并设置需要更新的对象类和对象的属性</span><br><span class="line">    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class， &quot;old&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User conan = new User(&quot;conan&quot;， 10);</span><br><span class="line">        System.out.println(a.getAndIncrement(conan)); //10</span><br><span class="line">        System.out.println(a.get(conan));  //11</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class User &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public volatile int old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态变量和成员变量：</span><br><span class="line">由static修饰的变量称为静态变量，其实质上就是一个全局变量。</span><br><span class="line">如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；</span><br><span class="line">没有被静态修饰的内容，其实是属于对象的特殊描述。</span><br><span class="line"></span><br><span class="line">成员变量和静态变量的区别：</span><br><span class="line">1.生命周期不同</span><br><span class="line">成员变量随着对象的创建而存在，随着对象被回收而释放。</span><br><span class="line">静态变量随着类的加载而存在，随着类的消失而消失。</span><br><span class="line">2.调用方式不同</span><br><span class="line">成员变量只能被对象调用。</span><br><span class="line">静态变量可以被对象调用，还可以被类名调用。</span><br><span class="line">3.别名不同</span><br><span class="line">成员变量也称为实例变量。</span><br><span class="line">静态变量也称为类变量。</span><br><span class="line">4.数据存储位置不同</span><br><span class="line">成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</span><br><span class="line">静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态方法和非静态方法：</span><br><span class="line">静态方法:是使用static关键字修饰的方法，又叫类方法.属于类的，</span><br><span class="line">不属于对象， 在实例化对象之前就可以通过类名.方法名调用静态方法。</span><br><span class="line">非静态方法：又称为实例方法，成员方法。属于对象的，不属于类的。</span><br><span class="line"></span><br><span class="line">静态方法和非静态方法的区别：</span><br><span class="line">1.调用方法</span><br><span class="line">静态方法中，可以调用静态方法，不能调用非静态方法。在静态方法中，不能使用super和this关键字。不能引用成员变量。</span><br><span class="line">普通方法中，可以调用普通方法，也可以调用静态方法。</span><br><span class="line">2.使用方法</span><br><span class="line">静态方法可以直接调用，类名调用和对象调用。</span><br><span class="line">但是非静态方法只能通过对象调用。（对象名.方法名）</span><br><span class="line">3.生命周期不同</span><br><span class="line">静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。</span><br><span class="line">非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。</span><br><span class="line"></span><br><span class="line">静态方法优点：常住在内存中，调用快捷方便，全剧唯一，用类调用就行。</span><br><span class="line">应用场景：</span><br><span class="line">1. 静态方法最适合工具类中方法的定义；比如文件操作，日期处理方法等.</span><br><span class="line">2. 静态方法适合入口方法的定义；如单例模式，因为从外部拿不到构造函数，所有定义一个静态的方法获取对象非常有必要.</span><br><span class="line">3. 静态变量适合全局变量的定义.（如布尔型静态成员变量做控制符）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态类：</span><br><span class="line">java允许我们在一个类里面定义静态类。比如内部类（nested class）。</span><br><span class="line">把nested class封闭起来的类叫外部类。</span><br><span class="line">在java中，我们不能用static修饰顶级类（top level class）。只有内部类可以为static。</span><br><span class="line">（一般工具类也不是static的，方法是static的）</span><br><span class="line">（一般在一个类里再定义一个类用于包装数据，用public static class）</span><br><span class="line"></span><br><span class="line">静态内部类和非静态内部类的区别：</span><br><span class="line">1.内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。（此话怎样，意思是非静态内部类需要对象.类名，静态内部类需要外部类名.类名）</span><br><span class="line">2.非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。</span><br><span class="line">3.一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。</span><br><span class="line"></span><br><span class="line">class OuterClass&#123;</span><br><span class="line">  private static String msg = &quot;GeeksForGeeks&quot;;</span><br><span class="line">  // 静态内部类</span><br><span class="line">  public static class NestedStaticClass&#123;</span><br><span class="line">    // 静态内部类只能访问外部类的静态成员</span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">     // 试着将msg改成非静态的，这将导致编译错误 </span><br><span class="line">     System.out.println(&quot;Message from nested static class: &quot; + msg); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 非静态内部类</span><br><span class="line">  public class InnerClass&#123;</span><br><span class="line">    // 不管是静态方法还是非静态方法都可以在非静态内部类中访问</span><br><span class="line">    public void display()&#123;</span><br><span class="line">     System.out.println(&quot;Message from non-static nested class: &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Main</span><br><span class="line">&#123;</span><br><span class="line">  // 怎么创建静态内部类和非静态内部类的实例</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    // 创建静态内部类的实例</span><br><span class="line">    OuterClass.NestedStaticClass printer = new OuterClass.NestedStaticClass();</span><br><span class="line">    // 创建静态内部类的非静态方法</span><br><span class="line">    printer.printMessage();  </span><br><span class="line">    // 为了创建非静态内部类，我们需要外部类的实例</span><br><span class="line">    OuterClass outer = new OuterClass();    </span><br><span class="line">    OuterClass.InnerClass inner = outer.new InnerClass();</span><br><span class="line">    // 调用非静态内部类的非静态方法</span><br><span class="line">    inner.display();</span><br><span class="line">    // 我们也可以结合以上步骤，一步创建的内部类实例</span><br><span class="line">    OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();</span><br><span class="line">    // 同样我们现在可以调用内部类方法</span><br><span class="line">    innerObject.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Inner class &#x27;Person&#x27; may be &#x27;static&#x27; </span><br><span class="line">ide提示内部类最好是静态的. 不然不能在所在外部类里直接new一个对象。</span><br><span class="line"></span><br><span class="line">一个类包在另一个外部类里面，叫做内部类，可以和其他内部类重名。</span><br><span class="line">但是和一个类并列在一个类文件里，不是内部类，不能重名。不同于内部类，是可以直接使用的，相当于一个单独的文件，不建议这么做。</span><br></pre></td></tr></table></figure>

<p>静态内部类和非静态内部类：<a href="https://www.jb51.net/article/74838.htm">https://www.jb51.net/article/74838.htm</a></p>
<h2 id="第八章-java中的并发工具类"><a href="#第八章-java中的并发工具类" class="headerlink" title="第八章 java中的并发工具类"></a>第八章 java中的并发工具类</h2><p>JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类提供了在线程间交换数据的一种方法。</p>
<h3 id="1-等待多线程完成的CountDownLatch"><a href="#1-等待多线程完成的CountDownLatch" class="headerlink" title="1.等待多线程完成的CountDownLatch"></a>1.等待多线程完成的CountDownLatch</h3><p>应用场景：等待其他多个线程执行完了，再执行当前线程。</p>
<p>在JDK1.5之后的并发包中提供的CountDownLatch可以实现join的功能，一个countDownLatch的await()方法相当于多个线程的join方法。join线程终止后，其实是调用了<code>this.notifyAll()方法</code>，在JVM里实现的，在JDK里看不到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(1);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(2);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用CountDownLatch的countDown方法时，CountDownLatch的await方法会阻塞当前线程，直到N变为0。可以是N个线程，也可以是1个线程的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<p>超时机制：<code>await(long time, TimeUnit unit)</code>，这个方法等待特定时间后，就会不再阻挡当前线程。</p>
<p>⚠️CountDownLatch不可能重新初始化或者修改其内部计数器的值。</p>
<h3 id="2-同步屏障CyclicBarrier"><a href="#2-同步屏障CyclicBarrier" class="headerlink" title="2.同步屏障CyclicBarrier"></a>2.同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>应用场景：一辆车装10个人，上够10个人才开车。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程和子线程的调度是有CPU决定的，两个线程都有可能先执行。可能是1，2，也可能是2，1.</p>
<p>CyclicBarrier还提供了一个高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在所有线程都到达屏障时，优先执行barrierAction。注意，这个barrierAction不一定是要用cyclicBarrier.await()的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:50</span><br><span class="line"> **/</span><br><span class="line">public class CyclicTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(2, new A());</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class A implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出3-1-2 或者3-2-1.</p>
<h4 id="✅线程的阻塞状态和中断状态"><a href="#✅线程的阻塞状态和中断状态" class="headerlink" title="✅线程的阻塞状态和中断状态"></a>✅线程的阻塞状态和中断状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程的阻塞状态和中断状态</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">wait和notify：</span><br><span class="line">执行了监视器的wait()方法后，放弃锁进入等待状态。</span><br><span class="line">执行了监视器的notify()方法后，让一个线程从等待队列到同步队列，进入阻塞状态。</span><br><span class="line">wait()和notify()方法使用的前提是要获取对象的锁的，也就是在synchronized(obj)&#123;&#125;内。</span><br><span class="line">sleep方法进入定时等待状态，不会释放锁(如果写在synchronized内)。</span><br><span class="line"></span><br><span class="line">sleep和wait区别：</span><br><span class="line">1.sleep是Thread类的方法，是「静态方法」。wait是Object类的方法，调用需要具体的对象。</span><br><span class="line">2.sleep是不释放锁的，解除方法要么是timeout，或者interrupt一下让它抛出InterruptedException。wait是释放锁的，可以被notify/notifyAll恢复，同样也可以timeout或者interrupt。</span><br><span class="line">3.sleep在哪里都可以调用，wait必须在同步方法或同步块里调用，并且同步的对象要跟wait的对象一样。</span><br><span class="line">4.sleep作用只是线程的操作，用于短时间暂停线程，wait/notify可以用作线程间通信，达到资源调度的功能。</span><br><span class="line"></span><br><span class="line">Thread.yield():</span><br><span class="line">yield方法也是Thread类的静态方法，重新分配。</span><br><span class="line">会把当前线程从可运行状态变成就绪状态。</span><br><span class="line">之后会cpu会从众多就绪状态的线程中选择一个来执行。</span><br><span class="line"></span><br><span class="line">thread.join():</span><br><span class="line">join是Thread类方法，非静态，表示等待该线程结束，当前线程才继续执行</span><br><span class="line">join进入等待状态。</span><br><span class="line"></span><br><span class="line">线程中断：</span><br><span class="line">suspend()暂停和resume()继续容易造成死锁，stop()具有固有的不安全性。已废弃。</span><br><span class="line">终止线程的几种方式：</span><br><span class="line">1.设计标记位法：volatile的boolean类型变量来控制</span><br><span class="line">缺点：如果代码并没有这种循环语句，或者线程被其他语句阻塞了，线程可能一直不会去检查标记位。</span><br><span class="line">2.thread.interrupt()方法中断</span><br><span class="line">线程里有一个boolean类型的中断状态，是一个标记位，是存在Native层的。</span><br><span class="line">当使用Thread的interrupt()方法时，线程的中断状态会被设置为true。</span><br><span class="line">一些阻塞方法就会抛出一个异常InterruptedException。如果没有这种阻塞方法，那就什么都不会做。</span><br><span class="line">interrupt()方法是实例方法</span><br><span class="line">还有两个方法：isInterrupted() 和 interrupted() </span><br><span class="line">相同点是这两个都是返回一个boolean值，true表示中断，false表示未被中断。</span><br><span class="line">不同点是interrupted()是静态方法，只能在当前线程调用，判断是true后会清除标记，也就是重置为false。isInterrupted()是实例方法，不会清除标记，所以可以多次判断。</span><br><span class="line"></span><br><span class="line">*在Thread.sleep这些方法，抛出InterruptedException异常后会清除标记位状态。</span><br><span class="line">一个关于中断的例子见下面代码</span><br><span class="line"></span><br><span class="line">*所谓的interrupt线程中断，只是修改了一个标记位，需要我们判断标记位做后续的处理。</span><br><span class="line">如果catch代码块什么都不处理，会继续跑完剩下的代码。所以应该理解为『并不是中断，而是通知你应该自行中断了』</span><br><span class="line">线程不应该交给别的线程中断，应该由自己中断自己，过程中保证资源和变量已合理的处理了（该关的关，该释放的释放）。</span><br><span class="line"></span><br><span class="line">线程阻塞：</span><br><span class="line">阻塞和非阻塞是形容多个线程之间的相互影响的，一个线程占用了临界区资源，那么其他线程必须在临界区外等待。</span><br><span class="line">如果一个线程一直占用不释放资源，那么其他需要该临界区资源的线程都必须一直等待。</span><br><span class="line">非阻塞就是运行多个线程同时进入临界区，只要保证不把数据修改坏就行。</span><br><span class="line"></span><br><span class="line">线程阻塞的场景：</span><br><span class="line">运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</span><br><span class="line">发出I/O请求时，JVM会把该线程置为阻塞状态，I/O处理完毕时，线程重新转入就绪状态。</span><br><span class="line"></span><br><span class="line">线程阻塞和等待的区别：</span><br><span class="line">在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。</span><br><span class="line">相同点：</span><br><span class="line">（1）都会暂停线程的执行。</span><br><span class="line">区别点：</span><br><span class="line">（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。</span><br><span class="line">阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。</span><br><span class="line">等待状态的主动：线程在同步代码内，等待其他线程操作时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</span><br><span class="line"></span><br><span class="line">countDownLatch/cyclicBarrier的await方法进入阻塞状态，会不会释放锁？</span><br><span class="line">经测试，测试代码如下，不会释放锁。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">wait进入等待状态，释放锁。</span><br><span class="line">sleep进入定时等待状态，不释放锁。</span><br><span class="line">await进入阻塞状态，不释放锁。</span><br></pre></td></tr></table></figure>

<p>线程中断的讲解：<a href="https://blog.csdn.net/alcoholdi/article/details/79475029">https://blog.csdn.net/alcoholdi/article/details/79475029</a></p>
<p>关于线程中断的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> </span><br><span class="line">    // 中断目标线程</span><br><span class="line">    public void interrupt() &#123;</span><br><span class="line">        if (this != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"> </span><br><span class="line">        synchronized (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            if (b != null) &#123;</span><br><span class="line">                interrupt0();           // Just to set the interrupt flag</span><br><span class="line">                b.interrupt(this);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 返回目标线程的中断状态	static在这里理解为：只供当前线程使用这个方法</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 判断目标线程是否中断</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个关于中断的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 09:06</span><br><span class="line"> **/</span><br><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        InterruptThread t = new InterruptThread();</span><br><span class="line">        Interrupt2Thread t = new Interrupt2Thread();</span><br><span class="line">//        Interrupt3Thread t = new Interrupt3Thread();</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class InterruptThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 在catch中直接return结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted() + &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //不输出</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt2Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 可以再次调用interrupt恢复中断</span><br><span class="line">                    // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    //interrupt();</span><br><span class="line">                    //如果不在catch里再中断，会一直执行</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">//                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，不会停</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt3Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @SneakyThrows</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                // 可以再次调用interrupt恢复中断</span><br><span class="line">                // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                interrupt();</span><br><span class="line">                //System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，直到在主线程内中断，抛出InterruptedException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试await方法会不会释放锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:33</span><br><span class="line"> **/</span><br><span class="line">public class AwaitTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object lock = 1;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread1 get lock&quot;);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(&quot;thread2 get lock&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier的使用场景：多用于多线程计算数据，最后合并计算结果的场景。<br>一个合并计算结果的例子，用了barrierAction参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 23:02</span><br><span class="line"> **/</span><br><span class="line">public class CyclicDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BankWaterService bankWaterService = new BankWaterService();</span><br><span class="line">        bankWaterService.count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BankWaterService implements Runnable &#123;</span><br><span class="line">        private final CyclicBarrier c = new CyclicBarrier(4, this);  //这里屏障解除后执行本线程。</span><br><span class="line">        private final ExecutorService executor = Executors.newFixedThreadPool(4);</span><br><span class="line">        private final ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        private void count() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                executor.execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        sheetBankWaterCount.put(Thread.currentThread().getName(), 3);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.await();</span><br><span class="line">                            System.out.println(sdf.format(new Date()) + &quot; &quot; + Thread.currentThread().getName());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">                result += sheet.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sdf.format(new Date()) + &quot; &quot; + &quot;result:&quot; + result);</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3.CyclicBarrier和CountDownLatch的区别"></a>3.CyclicBarrier和CountDownLatch的区别</h3><p>1、使用的场景不一样，CyclicBarrier阻塞每个线程（每个线程都等待最后一个线程到达屏障），像分布式问题，屏障清除了，每个线程可以继续做自己的事情；CountDownLatch阻塞等待线程（等待线程等待其他线程完成）向集中式的，最后由等待线程统一处理。</p>
<p>2、CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重弄下执行一次。</p>
<p>3、CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p>
<p>cyclicBarrier线程中断示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 18:37</span><br><span class="line"> **/</span><br><span class="line">public class CyclicInterruptTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(3);</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                //e.printStackTrace();</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">2</span><br><span class="line">true</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明：尽管屏障数是3，但是其中一个中断了的话，其他的await也会跑出异常。被中断的抛出InterruptedException，其他的抛出BrokenBarrierException。</p>
<h3 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4.控制并发线程数的Semaphore"></a>4.控制并发线程数的Semaphore</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>应用场景：Semaphore可以做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库连接数只有10个，这是我们必须控制只有10个线程同时获取数据库连接保持数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int THREAD_COUNT = 30;</span><br><span class="line">private static final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">private static final Semaphore s = new Semaphore(10);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(&quot;save data&quot;);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有30个线程在执行，但是只允许10个线程并发执行。<br>为什么不开始创建10个线程的线程池呢？因为前面需要30个，只是在代码某部分限制10个。<br>构造方法Semaphore(int permits)接收一个整型的数组，表示可用的许可证数量。<br>Semaphore的acquire()方法获取一个许可证，获取不到就阻塞，使用完之后调用release()方法归还许可证。还可以使用tryAcquire()方法尝试获取许可证。</p>
<p>其他方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intavailablePermits():返回信号量中当前可用的许可证数目。</span><br><span class="line">ingetQueueLength():返回正在等待获取许可证的线程数。</span><br><span class="line">booleanhasQueueThreads():是否有线程正在等待获取许可证</span><br><span class="line">void reducePermits(int reduction):减少reduction个许可证，是个protected方法。</span><br><span class="line">Collection getQueuedThreads():返回所有等待获取许可证的线程集合，是个protected方法。</span><br></pre></td></tr></table></figure>

<h3 id="5-线程间交互数据的Exchanger"><a href="#5-线程间交互数据的Exchanger" class="headerlink" title="5.线程间交互数据的Exchanger"></a>5.线程间交互数据的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exhange()方法交换数据，如果第一个线程先执行exhange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都达到同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>应用场景：可用于遗传算法，将两个人作为交配对象，交换两个人的数据。还可以用于校对工作，比如我们需要将纸质银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入之后比对。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 19:23</span><br><span class="line"> **/</span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static final ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(a);</span><br><span class="line">                System.out.println(&quot;B 录入的是:&quot; + exchange + &quot; A录入的是：&quot; + a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(b);</span><br><span class="line">                System.out.println(&quot;A 录入的是:&quot; + exchange + &quot; B录入的是：&quot; + b);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程一个没有执行exchange()方法，则会一直等待，如果单向特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeout, TimeUnit unit)</code>设置最大等待时间。</p>
<p>原书笔记：<a href="https://blog.csdn.net/tianzhonghaoqing/article/details/123976376">https://blog.csdn.net/tianzhonghaoqing/article/details/123976376</a></p>
<h2 id="第九章-java中的线程池"><a href="#第九章-java中的线程池" class="headerlink" title="第九章 java中的线程池"></a>第九章 java中的线程池</h2><p>合理地使用线程池能够带来3个好处：<br>降低资源消耗(通过重复利用已创建的线程降低线程创建和销毁造成的消耗)<br>提高响应速度(当任务到达时，任务可以不需要等到线程创建就能立即执行)<br>提高线程的可管理性(线程池可以进行统一分配、调优和监控线程)</p>
<h3 id="1-线程池的实现原理"><a href="#1-线程池的实现原理" class="headerlink" title="1.线程池的实现原理"></a>1.线程池的实现原理</h3><p>ThreadPoolExecutor执行execute方法分下面4种情况：</p>
<p>1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务，不管已有线程是不是空闲(需要获取全局锁)</p>
<p>2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</p>
<p>3、如果BlockingQueue队列已满，则创建新的线程(非核心线程)来处理任务(需要获取全局锁）</p>
<p>4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法</p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p>
<h3 id="2-线程池的创建"><a href="#2-线程池的创建" class="headerlink" title="2.线程池的创建"></a>2.线程池的创建</h3><p><code>new ThreadPoolExecutor(xxx)</code>，其中参数具体含义如下：</p>
<p>1、corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务(即使其他空闲的基本线程能够执行新任务也会创建，满了不再创建。）如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
<p>2、runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue:基于数组结构的有界阻塞队列，按FIFO原则对元素排序。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue:基于链表结构的有界阻塞队列，FIFO原则，吞吐量高于ArrayBlockingQueue，</span><br><span class="line">静态工厂方法Executors.newFixedThreadPool()使用该队列。</span><br><span class="line"></span><br><span class="line">SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直阻塞。吞吐量高于LinkedBlockingQueue。</span><br><span class="line">静态工厂方法Executors.newCachedThreadPool使用该队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue:一个具有优先级的无限阻塞队列。</span><br></pre></td></tr></table></figure>

<p>3、maximumPoolSize(线程池最大数量)：线程池允许创建的最大线程数，如果队列满了且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用的是无界队列，改参数没效果。</p>
<p>4、ThreadFactory：设置创建线程的工厂，可以给线程命名。</p>
<p>5、RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，则采取一种策略处理提交的新任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbortPolicy(默认)：直接抛出异常。</span><br><span class="line">CallerRunsPolicy：用调用者所在线程来运行任务。</span><br><span class="line">DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span><br><span class="line">DiscardPolicy：不处理，丢弃掉且不抛出异常</span><br></pre></td></tr></table></figure>

<p>6、keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后保持存活的时间(超过该时长，非核心线程就会被回收)</p>
<p>7、TimeUnit(线程活动保持时间的单位)</p>
<h3 id="3-向线程池提交任务"><a href="#3-向线程池提交任务" class="headerlink" title="3.向线程池提交任务"></a>3.向线程池提交任务</h3><ul>
<li>execute()：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>submit()：用于提交需要返回值的任务(返回future类型的对象，该对象可以判断任务是否执行成功且可以通过对象的get()来获取返回值).<br>get()方法会阻塞当前线程直到任务完成。<code>get(long timeout, TimeUnit unit)</code>可阻塞一段时间后立即返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line">    try &#123;</span><br><span class="line">    	Object s = future.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    	// 处理中断异常</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">    	// 处理无法执行任务异常</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	// 关闭线程池</span><br><span class="line">    	executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-关闭线程池"><a href="#4-关闭线程池" class="headerlink" title="4.关闭线程池"></a>4.关闭线程池</h3><p>线程池的shutdown或shutdownNow方法关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。</p>
<p>无法响应中断的线程可能永远无法终止。</p>
<p>shutdown =&gt; 平缓关闭，等待所有已添加到线程池中的任务执行完再关闭<br>shutdownNow =&gt; 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown和shutdownNow：</span><br><span class="line">1、shutdown()</span><br><span class="line">阻止新来的任务提交，对已经提交了的任务不会产生任何影响。</span><br><span class="line">当已经提交的任务执行完后，它会将那些闲置的线程（idleWorks）进行中断，这个过程是异步的。</span><br><span class="line">将线程池的状态改成SHUTDOWN，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的。</span><br><span class="line"></span><br><span class="line">2、shutdownNow()</span><br><span class="line">阻止新来的任务提交，同时会中断当前正在运行的线程，即workers中的线程。</span><br><span class="line">它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。</span><br><span class="line">通过将线程池的状态改成STOP，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的.</span><br><span class="line">一个特例：</span><br><span class="line">一个线程正在sleep状态中，此时执行shutdownNow()，</span><br><span class="line">它向该线程发起interrupt()请求，而sleep()方法遇到有interrupt()请求时，会抛出InterruptedException，并清除中断标志</span><br><span class="line">如果catch了，并没有在catch中再interrupt()，会继续往下执行。</span><br><span class="line">如果向外抛出异常，会中断</span><br></pre></td></tr></table></figure>

<h3 id="5-合理配置线程池"><a href="#5-合理配置线程池" class="headerlink" title="5.合理配置线程池"></a>5.合理配置线程池</h3><p>1、任务的性质：</p>
<p>CPU密集型任务：配置尽可能小的线程(Ncpu+1)，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数能增加上下文切换的次数，带来额外的开销。</p>
<p>IO密集型任务：配置尽可能多的线程(2*Ncpu)，因为CPU使用率并不高，可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p>
<p>混合型任务：可将任务分成IO密集型和CPU密集型任务(两个任务执行时间相差不大时)，然后分别用不同的线程池去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU密集型和IO密集型：</span><br><span class="line">CPU密集型：需非常多CPU计算资源，让每个CPU核心都参与计算，CPU性能充分利用，应避免过多线程上下文切换。</span><br><span class="line">IO密集型：网络、磁盘 IO （与DB、缓存），一旦IO，线程就等待，结束才执行。多设线程数，等待时去做其它事，提高效率。</span><br></pre></td></tr></table></figure>

<p>2、任务的优先级：优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理</p>
<p>3、任务的执行时间：可以交给不同规模的线程池来处理，或者优先级队列。执行时间短的先执行</p>
<p>4、任务的依赖性：比如依赖数据库连接池的任务，线程提交SQL后需要等待数据库返回结果，等待的时间越长，CPU空闲时间就越长(相当于IO密集型任务，应设置较大线程数)</p>
<p>5、建议使用有界队列，可以增加系统稳定性和预警能力，再抛弃任务的时候加监控，无界队列会撑满内存，导致整个系统不能用。</p>
<h3 id="6-线程池的监控"><a href="#6-线程池的监控" class="headerlink" title="6.线程池的监控"></a>6.线程池的监控</h3><p>如果在系统中大量使用线程池，则需要对线程池进行监控，在出现问题时，可根据线程池的使用状况快速定位问题。可使用以下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskCount：线程池需要执行的任务数量</span><br><span class="line">completedTaskCount：线程池在运行过程中已完成的任务数量</span><br><span class="line">largestPoolSize：线程池里曾经创建过的最大线程数量</span><br><span class="line">getPoolSize：线程池的线程数量(线线程池不销毁的话，线程池里的线程不会自动销毁)</span><br><span class="line">getActiveCount：获取活动的线程数</span><br></pre></td></tr></table></figure>

<p>可以继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法进行监控。在执行前、执行后、线程池关闭前监控，比如：任务平均执行时间，最大执行时间，最小执行时间。</p>
<h3 id="7-Executors的线程池："><a href="#7-Executors的线程池：" class="headerlink" title="7.Executors的线程池："></a>7.Executors的线程池：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定长线程池(FixedThreadPool)：用于控制线程最大并发数</span><br><span class="line">只有核心线程</span><br><span class="line">线程数量固定</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br><span class="line"></span><br><span class="line">定时线程池(ScheduledThreadPool)：用于执行定时或周期性的任务</span><br><span class="line">核心线程数量固定</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置10ms后回收</span><br><span class="line">任务队列为延时阻塞队列</span><br><span class="line"></span><br><span class="line">可缓存线程池(CachedThreadPool)：执行大量且耗时少的任务</span><br><span class="line">无核心线程</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置60s后回收</span><br><span class="line">任务队列为不存储元素的阻塞队列</span><br><span class="line"></span><br><span class="line">单线程化线程池(SingleThreadExecutor)：应用于不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作</span><br><span class="line">只有1个核心线程</span><br><span class="line">无非核心线程</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br></pre></td></tr></table></figure>

<p>原书笔记：<a href="https://blog.csdn.net/qq_41398418/article/details/126279652">https://blog.csdn.net/qq_41398418/article/details/126279652</a></p>
<h2 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h2><p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时， 为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h3 id="1-Executor框架"><a href="#1-Executor框架" class="headerlink" title="1.Executor框架"></a>1.Executor框架</h3><h4 id="✅Executor框架的两级调度模型"><a href="#✅Executor框架的两级调度模型" class="headerlink" title="✅Executor框架的两级调度模型"></a>✅Executor框架的两级调度模型</h4><p>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p><strong>两级调度模型</strong>：<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。<br><em>应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</em></p>
<h4 id="✅Executor框架的结构"><a href="#✅Executor框架的结构" class="headerlink" title="✅Executor框架的结构"></a>✅Executor框架的结构</h4><p>Executor框架主要由3大部分组成：</p>
<p>1、任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。</p>
<p>2、任务的执行。包括任务执行机制的核心接口Executor，以及实现自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和<br>ScheduledThreadPoolExecutor）。</p>
<p>3、异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</p>
<hr>
<p>Executor框架的类与接口：</p>
<p>1、Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</p>
<p>2、ExecutorService接口，实现自Executor接口。</p>
<p>3、ThreadPoolExecutor类是线程池的核心实现类，用来执行被提交的任务。</p>
<p>4、ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</p>
<p>5、Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<p>6、Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。</p>
<hr>
<p>使用步骤：</p>
<p>1.创建任务对象：主线程创建实现Runnable或者Callable接口的任务对象。<code>工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））</code></p>
<p>2.任务提交给线程池执行：把Runnable对象直接交给ExecutorService执行<code>（ExecutorService.execute（Runnable command））</code>；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行<code>（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callabletask））</code><br>如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</p>
<p>3.submit的获取结果：主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</p>
<h4 id="✅-Executor框架的成员"><a href="#✅-Executor框架的成员" class="headerlink" title="✅ Executor框架的成员"></a>✅ Executor框架的成员</h4><p>Executor框架的主要成员：ThreadPoolExecutor、<br>ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<hr>
<p>（1） ThreadPoolExecutor</p>
<p>ThreadPoolExecutor可以使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">固定线程数的FixedThreadPool的 API。</span><br><span class="line">适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个线程的SingleThreadExecutor的API.</span><br><span class="line">适用于需要保证顺序地执行各个任务；只要一个线程的应用场景。</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">        threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CachedThreadPool是大小无界的线程池，</span><br><span class="line">适用于执行很多的短期异步任务的小程序，或者 是负载较轻的服务器。</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">        60L, TimeUnit.SECONDS,</span><br><span class="line">        new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（2） ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor可以使用工厂类Executors来创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor。</span><br><span class="line">包含若干个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">适用于需要多个后台线程执行周期任务</span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SingleThreadScheduledExecutor。</span><br><span class="line">只包含一个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（3） Future接口</p>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable 接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或<br>ScheduledThreadPoolExecutor时，会向我们返回一个FutureTask对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api:</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>到目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。</p>
<hr>
<p>（4） Runnable接口和Callable接口</p>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果。</p>
<p>工厂类Executors可以把一个Runnable包装成一个Callable。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Callable&lt;Object&gt; callable(Runnable task) //结果是null</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)  //结果是result</span><br></pre></td></tr></table></figure>

<h3 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2.ThreadPoolExecutor详解"></a>2.ThreadPoolExecutor详解</h3><p>介绍一下Executors创建的三种用的是什么参数</p>
<p>1.FixThreadPool内部使用无界队列LinkedBlockingQueue作为任务队列，队列的容量为Integer.MAX_VALUE，由于是无界队列，所以不会拒绝任务，maximumPool没有意义，可能会造成任务无限堆积，从而导致系统资源耗尽的情况。</p>
<p>2.SingleThreadExecutor：与FixThreadPool类似，只是SingleThreadExecutor的线程数固定为1</p>
<p>3.CachedThreadPool的corePool为空，maximumPoolSize为Integer.MAX_VALUE，keepAliveTime为60L，这意味着线程空闲超过60秒则会进行回收。CachedThreadPool内部使用不存储元素的阻塞队列SynchronousQueue作为任务队列，每个插入操作必须等待另一个线程的移除操作。这意味着如果任务的提交速度高于线程的处理速度，那么CachedThreadPool则会不断的创建新的线程，在极端的情况下，会耗尽CPU和内存资源。</p>
<h3 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3.ScheduledThreadPoolExecutor"></a>3.ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor主要用来执行需要延迟或者定时执行的任务，功能与Timer类似，不同的是Timer只能单线程允许，ScheduledThreadPoolExecutor可以指定多个线程。</p>
<p>ScheduledThreadPoolExecutor执行<code>scheduleAtFixedRate()方法或者scheduleWithFixedDelay()</code>方法时，会把要执行的任务放在一个无界队列DelayQueue中，<code>ScheduledThreadPoolExecutor会把Runable对象封装成ScheduledFutureTask（实现了RunnableScheduledFuture接口）</code>。线程池中的线程从DelayQueue中获取ScheduledFutureTask。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class ScheduledFutureTask&lt;V&gt;</span><br><span class="line">    extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>ScheduledFutureTask内部包含三个成员变量。<br>time：任务要被执行的具体时间<br>sequenceNumber：任务排序编号，如果两个任务的time相同，那么则sequenceNumber较小的会先执行<br>period：任务执行的周期</p>
<hr>
<p>ScheduledThreadPoolExecutor执行任务的流程大体是：<br>1.从DelayQueue中获取ScheduledFutureTask（time大于当前时间的任务）<br>2.执行ScheduledFutureTask<br>3.修改ScheduledFutureTask的time为下次要执行的时间<br>4.将ScheduledFutureTask再次放入DelayQueue中</p>
<h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3.FutureTask"></a>3.FutureTask</h3><p>Future接口和FutureTask实现类代表线程异步执行的结果，可以通过FutureTask.get()方法获取异步返回的结果。</p>
<p>FutureTask类还实现了Runnable接口，因此可以交给Executor执行，也可以直接在当前线程中执行：<code>FutureTask.run()</code>。</p>
<hr>
<p>根据FutureTask.run被执行的时机，FutureTask可处于下面3种状态：<br>未启动：方法还没有被执行之前，FutureTask处于未启动状态<br>已启动：方法被执行的过程中，FutureTask处于已启动状态<br>已完成：方法执行完后正常结束或、取消(即执行FutureTask.cancel)或抛异常，FutureTask处于已完成状态</p>
<hr>
<p>FutureTask状态决定get和cancel方法执行结果：</p>
<p>1.gei方法：如果未启动或已启动状态，get方法将导致调用线程阻塞，如果已完成状态，get方法将导致调用线程立即返回结果或抛出异常。</p>
<p>2.cancel方法：当处于未启动状态，该任务将不会执行，当处于已启动状态，<code>Future.cancel(true)</code>将中断此任务线程来停止任务，<code>Future.cancel(false)</code>将不会对正在执行此任务的线程产生影响，当处于已完成状态时，cancel方法将返回false。</p>
<p>当一个线程需要等待另一个线程把某个任务执行完后并获取结果它才能继续执行，可使用FutureTask。</p>
<hr>
<p>FutureTask的实现：</p>
<p>FutureTask的实现基于AbstractQueuedSynchronizer(AQS是同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列)。java.util.concurrent里的很多阻塞类：ReetrantLock、Semaphore、ReetrantReadWriteLock、CountDownLatch都是基于AQS实现。</p>
<hr>
<p>AQS遗忘的知识：<br>AQS实现的同步器都会包含两种类型的操作：<br>1.acquuire操作，获取同步状态，用来阻塞调用线程。FutureTask中为get方法。<br>2.release操作，释放同步状态，用来解除阻塞线程的阻塞，FutureTask中为run方法和cancel方法。</p>
<hr>
<p>基于复合优先于基础原则，FutureTask的内部私有类Sync继承自AQS。实现了AQS的<code>tryAcquireShared(int) 和 tryReleaseShared(int)</code>.</p>
<p>🤔因为FutureTask涉及到线程的阻塞唤醒也就是同步，所以用AQS。</p>
<h2 id="第十一章-java并发编程实践"><a href="#第十一章-java并发编程实践" class="headerlink" title="第十一章 java并发编程实践"></a>第十一章 java并发编程实践</h2><h3 id="1-生产者和消费者模式"><a href="#1-生产者和消费者模式" class="headerlink" title="1.生产者和消费者模式"></a>1.生产者和消费者模式</h3><p>什么是生产者和消费者模式？</p>
<p>生产者和消费者模式是<strong>通过一个容器来解决生产者和消费者的强耦合问题</strong>。生产者和消费者彼此之间不直接通信，而是<strong>通过阻塞队列来进行通信</strong>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<strong>阻塞队列就相当于一个缓冲区</strong>，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会<strong>找一个第三者出来进行解耦</strong>，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。</p>
<p>获取机器有多少个CPU，来决定线程池大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int corePoolSize = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>


<h3 id="2-多生产者和多消费者场景"><a href="#2-多生产者和多消费者场景" class="headerlink" title="2.多生产者和多消费者场景"></a>2.多生产者和多消费者场景</h3><p>在多核时代，多线程并发处理速度比单线程处理速度更快，所以可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理.</p>
<h3 id="3-线程池就是生产者消费者模式"><a href="#3-线程池就是生产者消费者模式" class="headerlink" title="3.线程池就是生产者消费者模式"></a>3.线程池就是生产者消费者模式</h3><p>Java 中的线程池类其实就是一种生产者和消费者模式的实现方式，但是更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了（不用中转队列），这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>生产者消费者例子：</p>
<p>调用一个远程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口取数据。</p>
<p>再比如：</p>
<p>1.有一些任务，这些任务放在db里，表示完成进程，同时将表的id放入redis队列中。</p>
<p>2.任务处理端，从redis队列中取出id，再用id从数据库读出一个任务进行处理，并更新db中任务完成的进程。</p>
<p>3.因为redis缓存稳定性考虑，定时任务搂db中长时间未完成的任务，将id放入redis队列中。</p>
<h3 id="4-线上问题定位"><a href="#4-线上问题定位" class="headerlink" title="4.线上问题定位"></a>4.线上问题定位</h3><p>看日志、系统状态和 dump 线程。</p>
<p>在 Java 进程这一行里可以看到 CPU 利用率是 300%，不用担心，这个是当前机器所有核加在一起的 CPU 利用率。</p>
<p>jstack命令可以把线程 dump 下来，看看究竟是哪个线程、执行什么代码造成的 CPU 利用率高。</p>
<p>dump 出来的线程 ID（nid）是十六进制的，而我们用 TOP 命令看到的线程 ID 是十进制的，所以要用 printf 命令转换一下进制。然后用十六进制的 ID 去 dump 里找到对应的线程。</p>
<p>十进制转十六进制：<br><code>printf &quot;%x\n&quot; 31558</code></p>
<p><code>netstat -nat | grep 8080 -c</code> 多少台机器连接到本机8080端口</p>
<p><code>ps -eLf|grep java -c</code> 看java线程数</p>
<h3 id="5-异步任务池"><a href="#5-异步任务池" class="headerlink" title="5.异步任务池"></a>5.异步任务池</h3><p>如果一个任务仍进线程池之后，运行线程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在集群环境下不能有效地调度所有机器的任务。所以，结合线程池开发一个异步任务处理池。</p>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p>
<p>每个任务有几种状态，分别是创建（NEW）、执行中（EXECUTING）、RETRY（重试）、挂起（SUSPEND）、中止（TEMINER）和执行完成（FINISH）。</p>
<p>创建：提交给任务池之后的状态。<br>执行中：任务池从数据库中拿到任务执行时的状态。<br>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间。<br>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行。<br>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。<br>执行完成：任务执行结束。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>go-http请求</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/go-http%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>内容丢失</p>
]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记-go入门2.0</title>
    <url>/2021/08/19/myblog/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-go%E5%85%A5%E9%97%A82.0/</url>
    <content><![CDATA[<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">go编译型语言，so函数编写的顺序无关紧要。</span><br><span class="line">goroutine 协程</span><br><span class="line">Go语言里面拥三种类型的函数：</span><br><span class="line">-普通的带有名字的函数</span><br><span class="line">-匿名函数或者 lambda 函数</span><br><span class="line">-方法</span><br><span class="line"></span><br><span class="line">同一种类型返回值和带有变量名的返回值</span><br><span class="line">func name()(int,int)&#123;return a,b&#125;</span><br><span class="line">func name()(a , b int)&#123;return&#125;</span><br><span class="line">不可以：</span><br><span class="line">func name()(a,b int,int)&#123;return&#125;</span><br><span class="line"></span><br><span class="line">定义函数变量：</span><br><span class="line">var fname func()</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">匿名函数篇：</span><br><span class="line">① 函数内部定义函数：闭包</span><br><span class="line">好处：内联在函数中，不需要声明，可直接使用函数的变量</span><br><span class="line">Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量</span><br><span class="line">函数 + 引用环境 = 闭包</span><br><span class="line">一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。</span><br><span class="line">闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。</span><br><span class="line">闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++<span class="number">11</span> 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。</span><br><span class="line"><span class="comment">// C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。</span></span><br><span class="line">在闭包内部修改引用的变量</span><br><span class="line">闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</span><br><span class="line">例子：</span><br><span class="line"><span class="comment">// 准备一个字符串</span></span><br><span class="line">str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := func() &#123; </span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="attr">&quot;hello dude&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用匿名函数</span></span><br><span class="line">foo()</span><br><span class="line">被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</span><br><span class="line"></span><br><span class="line">② 函数内部调用其他函数：函数调用</span><br><span class="line"></span><br><span class="line">③ 函数内部调用参数传过来的函数：回调函数</span><br><span class="line">将一个函数的指针作为参数传递给另一个函数，在外部再定义这个函数的实现。</span><br><span class="line">回调函数例子：</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line">    for _, v := range list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="comment">// 使用匿名函数打印切片内容，可改变传入函数的实现</span></span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">④ 函数内部调用自己这个函数：递归</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>接口篇：</span><br><span class="line">定义接口：</span><br><span class="line"><span class="keyword">type</span> Invoker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 需要实现一个Call方法</span></span><br><span class="line">    Call(<span class="keyword">interface</span>&#123;&#125;)  <span class="comment">//这个传参？？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>结构体实现接口</span><br><span class="line"><span class="keyword">type</span> Struct <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现Invoker的Call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Struct)</span> <span class="title">Call</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;from struct&quot;</span>, p)</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> invoker Invoker</span><br><span class="line"><span class="comment">// 实例化结构体</span></span><br><span class="line">s := <span class="built_in">new</span>(Struct)</span><br><span class="line"><span class="comment">// 将实例化的结构体赋值到接口</span></span><br><span class="line">invoker = s</span><br><span class="line"><span class="comment">// 使用接口调用实例化结构体的方法Struct.Call</span></span><br><span class="line">invoker.Call(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>函数体实现接口</span><br><span class="line">函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当类型方法被调用时，还需要调用函数本体。</span><br><span class="line"><span class="comment">// 函数定义为类型</span></span><br><span class="line"><span class="keyword">type</span> FuncCaller <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="comment">// 实现Invoker的Call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncCaller)</span> <span class="title">Call</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用f()函数本体</span></span><br><span class="line">    f(p)</span><br><span class="line">&#125;</span><br><span class="line">main函数中：</span><br><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> invoker Invoker</span><br><span class="line"><span class="comment">// 将匿名函数转为FuncCaller类型, 再赋值给接口</span></span><br><span class="line">invoker = FuncCaller(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;from function&quot;</span>, v)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用接口调用FuncCaller.Call, 内部会调用函数本体</span></span><br><span class="line">invoker.Call(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TODO:标记部分代码以供将来参考：优化和改进的领域、可能的更改、要讨论的问题等。</span><br><span class="line"></span><br><span class="line">Go语言goroutine和channel使用</span><br><span class="line">goroutine是Go语言中的轻量级线程实现，由Go语言运行时(runtime)管理。使用的时候在函数前面加“<span class="keyword">go</span>”这个单词作为关键词，也是与普通函数的区别了。在函数前面加<span class="keyword">go</span>关键字就可以创建一个新的goroutine进行并发执行。</span><br><span class="line">channel是Go语言提供的goroutine间的通信方式，我们可以使用channel在两个或多个goroutine之家传递消息。channel使用的关键字是用“<span class="keyword">chan</span>”.</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>方法：</span><br><span class="line"><span class="keyword">go</span>语言中函数的概念和c语言中的函数类似，函数名其实是一个指针，而<span class="keyword">go</span>语言的方法是拥有接收者的函数，其实是c++中类的方法的概念。函数是独立存在的，而方法必须有接收者，即必须依附于某个对象。<span class="keyword">go</span>语言使用<span class="keyword">struct</span>来抽象对象。因此方法的接收者可以是<span class="keyword">struct</span>实例或<span class="keyword">struct</span>的指针。</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        name  <span class="keyword">string</span>,</span><br><span class="line">        email <span class="keyword">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Email is %s&quot;</span>, email)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是方法的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Email is %d&quot;</span>, email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go error类型：</span><br><span class="line">见go入门。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对方法的接收者传值：不改变接收者。传地址才改变。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defer：</span><br><span class="line">Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</span><br><span class="line">当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）</span><br><span class="line">defer func()&#123;   &#125;</span><br><span class="line">go func()&#123;   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go中&#123;&#125;后的（）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang入门</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
