<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">mybatis实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-02 21:45:44" itemprop="dateCreated datePublished" datetime="2022-06-02T21:45:44+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-01 12:10:50" itemprop="dateModified" datetime="2023-05-01T12:10:50+08:00">2023-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>1、mybatis <code>&lt;if&gt;</code> 标签不是必须在<code>&lt;where&gt;</code>标签下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select * from table</span><br><span class="line">&lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">        uid = #&#123;uid&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">where status = 0</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    and uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    where uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>

<p>2、mybatis中，<code>select * from in &lt;foreach&gt; #&#123;list&#125;</code>，中的list不能是空，不能为null，会报错。</p>
<p>3、mybatis查出的结果是list，如果结果是一条都没有，那么返回的是空list，而不是null。</p>
<p>4、mybatis sum 如果没有记录，返回的是null，所以要注意mybatis返回结果都用包装类型来接。</p>
<p>5.mybatis查出的Date类型，是毫秒时间戳，可以用String接Date类型，只不过是：2023-01-01 11:11:11.1，所以得用.substring(0,19)，注意该方法string是null不行，位数不够也会报错。</p>
<p>6.mybatis来select，in一个list，如果传入的list是null或者空会报错。<br>null会报错：org.mybatis.spring.MybatisSystemException<br>空list会error sql<br>如果加了<code>&lt;where&gt;</code>标签和<code>&lt;if&gt;</code>标签，会导出所有的。<br><code>&lt;if test=&quot;list != null and list.size() &gt; 0&quot;&gt;</code></p>
<h3 id="mybatis-error"><a href="#mybatis-error" class="headerlink" title="mybatis error"></a>mybatis error</h3><h4 id="✅Mybatis-Exception-Translator-translateExceptionIfPossible"><a href="#✅Mybatis-Exception-Translator-translateExceptionIfPossible" class="headerlink" title="✅Mybatis Exception Translator.translateExceptionIfPossible"></a>✅Mybatis Exception Translator.translateExceptionIfPossible</h4><p>原因：插入时找不到参数，批量插入时传的list为空也会报此问题。</p>
<h3 id="resultMap和resultType"><a href="#resultMap和resultType" class="headerlink" title="resultMap和resultType"></a>resultMap和resultType</h3><p>ResultType和ResultMap都是执行查询语句时返回的结果集。<br>ResultType相对与ResultMap而言更简单一点。只有满足ORM（Object Relational Mapping，对象关系映射）时，即数据库表中的字段名和实体类中的属性完全一致时，才能使用，否则会出现数据不显示的情况。<br>ResultMap和ResultType的功能类似，但是ResultMap更强大一点，ResultMap可以实现将查询结果映射为复杂类型的pojo。</p>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>1.java的基础类型及其包装类int,double和java.lang.Integer,java.lang.Double等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为int，resultType为int ,java.lang.Integer也可以--&gt;</span><br><span class="line">&lt;select id=&quot;countUser&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">    select count(*) from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>2.自己定义的实体类,实体类和数据库字段需要一致，如果不一致需要使用resulMap自定义map，也可以直接使用map。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为实体类，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.entity.User&quot;&gt;</span><br><span class="line">   select * from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.map类型，Dao层的返回类型为<code>Map&lt;String, Object&gt;</code>，key是对应的column值，value是数据中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 返回值为Map&lt;String,Object&gt;，resultType为map--&gt;</span><br><span class="line">&lt;select id=&quot;getUserSelective&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select name,address,salary from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.List集合，其中该集合的类型可以为1,2,3中提到的类型。Dao层的返回类型为<code>List&lt;User&gt;</code>，这里只展示了实体类集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为List&lt;User&gt;，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集的映射是 MyBatis 最强大的特性,通过使用resultMap或resultType可以解决复杂映射问题。基础简单的使用resultType就可以了，但是如果出现table中列和实体类中的属性不一致或者多表级联。那么这时resultMap就可以发挥作用了。</p>
<p>TestDao.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.repository.TestDao&quot;&gt;</span><br><span class="line">    //定义映射</span><br><span class="line">    &lt;resultMap id=&quot;TestResultMap&quot; type=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    //定义返回栏目</span><br><span class="line">    &lt;sql id=&quot;all_colum_without_id&quot;&gt;</span><br><span class="line">        name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;all_colum&quot;&gt;</span><br><span class="line">        name,&lt;include refid=&quot;all_colum_without_id&quot;/&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    //插入语句</span><br><span class="line">    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values (#&#123;name&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //批量插入</span><br><span class="line">    &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;testDOList&quot; separator=&quot;,&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">            (#&#123;item.name&#125;,</span><br><span class="line">            #&#123;item.age&#125;)</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //查询</span><br><span class="line">    &lt;select id=&quot;findById&quot; resultMap=&quot;TestResultMap&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;all_colum&quot;/&gt; from table where id=#&#123;id&#125;</span><br><span class="line">        &lt;if test=&quot;age != null&quot;&gt;</span><br><span class="line">            and age=#&#123;age&#125;</span><br><span class="line">        &lt;if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>TestDao.java接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface TestDao &#123;</span><br><span class="line">    //插入</span><br><span class="line">    Integer insertOne(TestDO testDO);</span><br><span class="line">    //批量插入</span><br><span class="line">    Integer insertBatch(List&lt;TestDO&gt; testDOList);</span><br><span class="line">    //查询</span><br><span class="line">    TestDO findById(Long id, Integer age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdbcType告诉框架如何解析这个属性（对应数据库中的类型），column是数据库中table的列名，property是实体类中对应的属性名字，type是对应的实体类，id=”TestResultMap”是这个resultMap的一个引用标志。</p>
<p>这样使用resultMap就像用resultType对应实体类，在select出来的语句中直接对字段就行as，as为实体类属性名，或驼峰形式就行。</p>
<p>resultMap更复杂的用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wobuaizhi/article/details/83104464">https://blog.csdn.net/wobuaizhi/article/details/83104464</a></p>
<h3 id="返回映射下划线转驼峰"><a href="#返回映射下划线转驼峰" class="headerlink" title="返回映射下划线转驼峰"></a>返回映射下划线转驼峰</h3><p>意思是返回值对应到对象，mysql返回的字段名（app_id），直接映射到对象属性名（appId）。</p>
<p>第一种 Spring Boot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

<p>第二种 mybatis-config.xml配置中加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 全局配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!-- 是否开启自动驼峰命名规则映射</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt; </span><br></pre></td></tr></table></figure>

<h3 id="mybatis-useGeneratedKeys-keyProperty"><a href="#mybatis-useGeneratedKeys-keyProperty" class="headerlink" title="mybatis useGeneratedKeys keyProperty"></a>mybatis useGeneratedKeys keyProperty</h3><p>useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</p>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。</p>
<p>作用：在inset时，可以不用管主键插入多少，而且插入后，还能直接用对象里的值，因为自动返回了。建表时必须设置主键自增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;</span><br><span class="line">    keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DUPLICATE"><a href="#DUPLICATE" class="headerlink" title="DUPLICATE"></a>DUPLICATE</h3><p>duplicate在mybatis中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">    insert into table (id, &lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">    values (0, #&#123;name&#125;)</span><br><span class="line">    ON DUPLICATE KEY UPDATE name=values(name), age=values(age)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">values后面就是插入要查哪些。</span><br><span class="line">update后面是更新要更新哪些</span><br><span class="line">什么时候更新要看表的主键索引和唯一索引</span><br><span class="line">id可选，加了id，就传0</span><br></pre></td></tr></table></figure>

<p>因为更新的时候是不会返回id的，所以要去掉：<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code><br>如果不去掉，会报<code>executorexception: error getting generated key or setting result to parameter object</code></p>
<h3 id="xml里面foreach标签里面的属性separator"><a href="#xml里面foreach标签里面的属性separator" class="headerlink" title="xml里面foreach标签里面的属性separator"></a>xml里面foreach标签里面的属性separator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;if test=&quot;myList != null&quot;&gt;</span><br><span class="line">    AND dm in</span><br><span class="line">    &lt;foreach collection=&quot;myList &quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item , jdbcType=VARCHAR &#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
<p>渲染为sql：<code>AND dm in ( &#39;03&#39; , &#39;04&#39;)</code></p>
<p>如果separator属性为or，渲染为：<code>AND ( dm  = &#39;01&#39;or dm   = &#39;02&#39; or dm   = &#39;03&#39;) </code></p>
<h3 id="where标签的作用"><a href="#where标签的作用" class="headerlink" title="where标签的作用"></a>where标签的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> WHERE</span><br><span class="line"> &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line"> state = #&#123;state&#125;</span><br><span class="line"> &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>如果state参数为空时，最终生成SQL语句为<br>SELECT * FROM hdc WHERE<br>执行会出错，可以在where 后加一个1=1，但是累赘</p>
<p>用<code>&lt;where&gt;...&lt;/where&gt;</code>标签就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectOne&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> &lt;where&gt;</span><br><span class="line">  &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line"> &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>总结：<code>&lt;where&gt;</code>标签，1、在后面if null都是空时，可以自动删除where。2、在后面多个if null，第一个为null时，会自动删掉后面有的and。</p>
<h3 id="trim实现动态sql"><a href="#trim实现动态sql" class="headerlink" title="trim实现动态sql"></a>trim实现动态sql</h3><p>场景：想使用having，having后面用if null标签，如果后面的if null都是null，having会留着，导致出错。</p>
<p>trim 在英语中有“点缀物”，修剪的意思。可以把‘’标签为一个装饰sql的标签。trim标签常用于动态生成sql的场景下。</p>
<p>基本格式：<br><code>&lt;trim prefix=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot;&gt;&lt;/trim&gt;</code><br>prefix：<br>表示在trim包裹的SQL语句前面添加的指定内容。<br>suffix：<br>表示在trim包裹的SQL末尾添加指定内容<br>prefixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定首部内容<br>suffixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定尾部内容</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/425922768">https://zhuanlan.zhihu.com/p/425922768</a></p>
<p>例子(查输入的list的元素是不是在查处的一个list字段里有)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">group by id</span><br><span class="line">&lt;trim prefix=&quot;having&quot; prefixOverrides=&quot;and&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        and</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>


<h3 id="条件构造器QueryWrapper"><a href="#条件构造器QueryWrapper" class="headerlink" title="条件构造器QueryWrapper"></a>条件构造器QueryWrapper</h3><p>QueryWrapper是在使用Mybatis-plus中用到的一种技术，也叫作构造器，能简化sql的操作。MyBatisPlus 依赖：mybatis-plus-boot-starter</p>
<p>首先，Mapper接口需要继承<code>BaseMapper&lt;T&gt;</code>抽象类，加@Mapper注解。</p>
<p>LambdaQueryWrapper和QueryWrapper查询是一样的，但是使用Lambda语法更加方便，更容易理解。</p>
<p>LambdaQueryWrapper和QueryWrapper的区别：<br>首先它们都是Mybatis-plus提供的查询构造器，用于构建查询条件。<br>1、LambdaQueryWrapper支持Lambda表达式作为查询条件，而QuerryWrapper不支持。<br>2、LambdaQueryWrapper可以避免手写错误的字段名，因为它会在编译期间进行类型检查。而QueryWrapper只能在运行时才发现错误。<br>3、LambdaQueryWrapper可以链式调用，更加优雅简洁。而QueryWrapper需要每次重新创建一个实例来添加新的查询条件。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public List&lt;Student&gt; list(Student student)&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Student&gt; lqw = new LambdaQueryWrapper&lt;Student&gt;();</span><br><span class="line">    lqw.eq(Student::getName, student.getName()); </span><br><span class="line">    //也可以：lqw.eq(&quot;name&quot;, student.getName());</span><br><span class="line">    lqw.like(Student::getClass,student.getClass());</span><br><span class="line">    lqw.between(&quot;age&quot;,student.getAge1(),student.getAge2());</span><br><span class="line">    lqw.orderByAsc(&quot;age&quot;);</span><br><span class="line">    List&lt;Student&gt; list = studentDao.list(lqw);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对应sql：<code>select * from student where name = &#39;?&#39; and class like &#39;%?%&#39; and age between &#39;?&#39; and &#39;?&#39; order by &#39;?&#39; asc</code></p>
<p>QueryWrapper其实可以理解成一个放查询条件的盒子，我们把查询条件放在里面，他就会自动按照对应的条件进行查询数据。</p>
<p>根据不同的查询要求，有不同的用法，常用到的比如：eq（相等）、like、and、or、isNull、isNotNull、ne（不相等）、likeRight、between、gt（大于）、lt（小于）等</p>
<hr>
<p>使用QueryWrapper来更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;user&gt; qw = new QueryWrapper&lt;&gt;();</span><br><span class="line">qw.eq(&quot;id&quot;, 1);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setName(&quot;liu&quot;);</span><br><span class="line">int rows = userMapper.update(user, qw);</span><br></pre></td></tr></table></figure>


<h3 id="使用Map接收mybatis结果"><a href="#使用Map接收mybatis结果" class="headerlink" title="使用Map接收mybatis结果"></a>使用Map接收mybatis结果</h3><p>ResultSet是一个表示数据库结果集的接口，在java中用于表示从数据库查询的结果，允许通过行和列的方式访问数据，从而从数据库中检索和操作数据。</p>
<p>但是Mybatis不支持直接用ResultSet接收查询结果。因为Mybatis采用的是物理映射技术，而ResultSet只能获取行列数据，得不到物理映射的结果。</p>
<p>那么除了定义DO，还可以用什么接收mybatis返回的数据呢？ 用Map。</p>
<p>dao接口怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@MapKey(&quot;某字段名&quot;)</span><br><span class="line">Map&lt;String, Object&gt; selectAll();</span><br></pre></td></tr></table></figure>

<p>xml怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;java.util.Map&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>@MapKey 是MyBatis框架的注解，作用是将List结果集转换成key-value形式的Map结果集，方便快速从结果集中查询指定结果。</p>
<p>@MapKey(value=””) 是mybatis的注解，用来映射Map类型的联合查询结果。作用是指定从查询结果的某个字段映射到Map的Key，这个注解是必须的，必须指定一个字段为key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class UserMapper()&#123;</span><br><span class="line"> </span><br><span class="line">    //使用list接收</span><br><span class="line">    //[&#123;id:1111,name:&quot;foo&quot;&#125;,&#123;id:2222,name:&quot;bar&quot;&#125;]</span><br><span class="line">    public List&lt;User&gt; useList();</span><br><span class="line"> </span><br><span class="line">    //使用带有@Mapkey(&quot;id&quot;)的Map&lt;Integer,User&gt;接收</span><br><span class="line">    //&#123;1111:&#123;id:1111,name:&quot;foo&quot;&#125;,2222:&#123;id:2222,name:&quot;bar&quot;&#125;&#125;</span><br><span class="line">    @Mapkey(&quot;id&quot;)</span><br><span class="line">    public Map&lt;Integer,User&gt; useMap();</span><br><span class="line"></span><br><span class="line">    //不想定义DO，直接用List&lt;Map&lt;String, Object&gt;&gt;接收</span><br><span class="line">    //返回的结果Map是字段名：值，跟@MapKey里的value没啥关系</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不能用<code>List&lt;Object&gt;</code>接结果。<br>如果@MapKey中的value是null，会展示一个key为null的map。</p>
<hr>
<p>MyBatis中的动态SQL以及@ResultMap,@MapKey和@Options的使用：<br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/2930425356/">https://www.freesion.com/article/2930425356/</a></p>
<h3 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h3><p>ResultHandler，顾名思义，对返回的结果进行处理，最终得到自己想要的数据格式或类型。也就是说，可以自定义返回类型。可以迭代查询结果集，将其存储在集合中，或执行自定义处理。它是mybatis的一个接口，用来处理结果集，从而获取特定的数据或者操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ResultHandler&lt;T&gt; &#123;</span><br><span class="line">    void handleResult(ResultContext&lt;? extends T&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line">    public void selectGoods(ResultHandler resultHandler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;   </span><br><span class="line">&lt;!DOCTYPE mapper   </span><br><span class="line">PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;  </span><br><span class="line">&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.yht.mybatisTest.dao.GoodsDao&quot;&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;select id=&quot;selectGoods&quot; resultType=&quot;map&quot;&gt;  </span><br><span class="line">        select price,name from goods</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">                                                        </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>selectGoods方法的查询结果是<code>List&lt;Map&gt;</code>，假如现在有这么一个需求：想统计价格低于50的书籍有哪些，价格高于50的书籍有哪些，该怎么处理呢？这个时候就用到了ResultHandler，我们创建一个SelectGoodsResultHandler。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SelectGoodsResultHandler implements ResultHandler&#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, List&lt;String&gt;&gt; resultMap = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void handleResult(ResultContext context) &#123;</span><br><span class="line">        if(resultMap.get(&quot;lowPrice&quot;) == null &amp;&amp; resultMap.get(&quot;highPrice&quot;) == null)&#123;</span><br><span class="line">            List&lt;String&gt; lowList = new ArrayList&lt;String&gt;();</span><br><span class="line">            List&lt;String&gt; highList = new ArrayList&lt;String&gt;();</span><br><span class="line">            resultMap.put(&quot;lowPrice&quot;, lowList);</span><br><span class="line">            resultMap.put(&quot;highPrice&quot;, highList);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Map&lt;String,Object&gt; resultObject = (Map&lt;String, Object&gt;)context.getResultObject();</span><br><span class="line">        BigDecimal price = (BigDecimal) resultObject.get(&quot;price&quot;);</span><br><span class="line">        String name = (String) resultObject.get(&quot;name&quot;);</span><br><span class="line">        if(price.intValue() &lt; 50)&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;lowPrice&quot;)).add(name);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;highPrice&quot;)).add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Map&lt;String, List&lt;String&gt;&gt; getResults()&#123;</span><br><span class="line">        return resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class GoodsDaoTest &#123;</span><br><span class="line">    </span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory = null;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectGoodsTest()&#123;</span><br><span class="line">        </span><br><span class="line">        SqlSession sqlSession = getSqlSessionFactory().openSession(true);</span><br><span class="line">        GoodsDao goodsMapper = sqlSession.getMapper(GoodsDao.class);</span><br><span class="line">        SelectGoodsResultHandler resultHandler = new SelectGoodsResultHandler();</span><br><span class="line">        goodsMapper.selectGoods(resultHandler);</span><br><span class="line">        System.out.println(resultHandler.getResults().toString());;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static SqlSessionFactory getSqlSessionFactory() &#123;</span><br><span class="line">        String resource = &quot;spring-ibatis.xml&quot;;</span><br><span class="line">        if(sqlSessionFactory == null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources</span><br><span class="line">                        .getResourceAsReader(resource));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/51life/p/9633002.html">https://www.cnblogs.com/51life/p/9633002.html</a></p>
<p>mybatis之ResultHandler如何使用：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8773d0e786d8">https://www.jianshu.com/p/8773d0e786d8</a></p>
<h3 id="mybatis传表名"><a href="#mybatis传表名" class="headerlink" title="mybatis传表名"></a>mybatis传表名</h3><p>mybatis 怎么传入表名来控制插入哪个表？<br>在 MyBatis 中，我们可以通过动态 SQL 的方式来传入表名，从而控制插入哪个表。</p>
<p>貝体操作如下：<br>1.在Mapperxml 文件中，使用 parameterType 指定一个参数类型为 string，用于接收要插入的表名。</p>
<p>2.在插入语句中，使用 ＄{} 操作待将该参数传递到 SQL中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void insertIntoTable(@Param(&quot;tableName&quot;) String tableName, ...)</span><br><span class="line"></span><br><span class="line">&lt;insert id=&quot;insertIntoTable&quot;&gt;</span><br><span class="line">    INSERT INTO $&#123;tableName&#125; (column, column2) VALUES (#&#123;value1&#125;, #&#123;value2&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>如果除了表名参数，另一个参数是对象，在xml文件中加对象名.字段名来调用。</p>
<p>3.在调用该方法时，传递要插入的表名即可。<br>String tableName = user;<br>mapper.insertIntoTable (tableName, value1, value2);<br>注意：使用＄{}操作符传递参数，需要注意 SQL 注入的问题，因此需要进行必要的安全措施，如输入参数的参数校验等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/" class="post-title-link" itemprop="url">maven与nexus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-01 22:34:23" itemprop="dateCreated datePublished" datetime="2022-06-01T22:34:23+08:00">2022-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-26 11:08:59" itemprop="dateModified" datetime="2023-03-26T11:08:59+08:00">2023-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ol>
<li><p>优秀的构建工具<br>通过简单的命令，能够完成清理、编译、测试、打包、部署等一系列过程。同时，不得不提的是，Maven是跨平台的，无论是在Windows、还是在Linux或Mac上，都可以使用同样的命令。</p>
</li>
<li><p>依赖管理工具<br>项目依赖的第三方的开源类库，都可以通过依赖的方式引入到项目中来。代替了原来需要首先下载第三方jar，再加入到项目中的方式。从而更好的解决了合作开发中依赖增多、版本不一致、版本冲突、依赖臃肿等问题。<br>具体是怎么实现的呢？Maven通过坐标系统准确的定位每一个构件，即通过坐标找到对应的java类库。</p>
</li>
<li><p>项目信息管理工具<br>能够管理项目描述、开发者列表、版本控制系统地址、许可证等一些比较零散的项目信息。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，还能够轻松获得项目文档、测试报告、静态分析报告、源码版本、日志报告等非常具有价值的项目信息。</p>
</li>
</ol>
<h3 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h3><p>✅常见打包命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true		-- 跳过单测打包</span><br><span class="line">mvn clean install -Dmaven.test.skip=true		-- 跳过单测打包，并把打好的包上传到本地仓库</span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true			-- 跳过单测打包，并把打好的包上传到远程仓库</span><br></pre></td></tr></table></figure>

<p>✅mvn命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mvn -v //查看版本 </span><br><span class="line">mvn archetype:create //创建 Maven 项目 </span><br><span class="line">mvn compile //编译源代码 </span><br><span class="line">mvn test-compile //编译测试代码 </span><br><span class="line">mvn test //运行应用程序中的单元测试 </span><br><span class="line">mvn site //生成项目相关信息的网站 </span><br><span class="line">mvn package //依据项目生成 jar 文件 </span><br><span class="line">mvn install //在本地 Repository 中安装 jar </span><br><span class="line">mvn -Dmaven.test.skip=true //忽略测试文档编译 </span><br><span class="line">mvn clean //清除目标目录中的生成结果 </span><br><span class="line">mvn clean compile //将.java类编译为.class文件 </span><br><span class="line">mvn clean package //进行打包 </span><br><span class="line">mvn clean test //执行单元测试 </span><br><span class="line">mvn clean deploy //部署到版本仓库 </span><br><span class="line">mvn clean install //使其他项目使用这个jar,会安装到maven本地仓库中 </span><br><span class="line">mvn archetype:generate //创建项目架构 </span><br><span class="line">mvn dependency:list //查看已解析依赖 </span><br><span class="line">mvn dependency:tree com.xx.xxx //看到依赖树 </span><br><span class="line">mvn dependency:analyze //查看依赖的工具 </span><br><span class="line">mvn help:system //从中央仓库下载文件至本地仓库 </span><br><span class="line">mvn help:active-profiles //查看当前激活的profiles </span><br><span class="line">mvn help:all-profiles //查看所有profiles </span><br><span class="line">mvn help:effective -pom //查看完整的pom信息</span><br></pre></td></tr></table></figure>



<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><p>maven的依赖管理功能，通过在Pom中指定坐标的形式将jar引入到项目中。jar包就存放在仓库中。</p>
<p>Maven的仓库分为本地仓库和远程仓库。远程仓库分为：中央仓库、私服、其他远程仓库。</p>
<p>当Maven根据坐标寻找构件时，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。</p>
<p>为什么需要私服？</p>
<p>1.一些无法从外部仓库下载的构件，例如内部的项目，可以部署到私服上，以便供其他依赖项目使用。</p>
<p>2.为了节省带宽和时间，在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。当本地Maven项目需要下载构件时，先去私服请求，如果私服没有，则再去远程仓库请求，从远程仓库下载构件后，把构件缓存在私服上。这样，即使暂时没有Internet链接，由于私服已经缓存了大量构件，整个项目还是可以正常使用的。同时，也降低了中央仓库的负荷。</p>
<p>如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。<br>————————————————</p>
<p>总而言之：私服在用户局域网内的特殊远程仓库，私服起到了maven用户与中央仓库的中间作用，私服从中央仓库缓存构件，maven用户从私服下载构件。</p>
<h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><p>nexus就是私服的一种。</p>
<p>nexus是一个强大的maven仓库管理器,它极大的简化了本地内部仓库的维护和外部仓库的访问.</p>
<p>nexus提供了强大的仓库管理功能,构件搜索功能,它基于REST,友好的UI是一个extjs的REST客户端,占用较少的内存,基于简单文件系统而非数据库.</p>
<p>节省外网带宽；加速Maven构建；部署第三方构件；提高稳定性，增强控制；降低中央仓库的负荷；控制和审计；建立本地内部公用仓库。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/youngdeng/p/15098442.html">https://www.cnblogs.com/youngdeng/p/15098442.html</a></p>
<p>如何配置：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b06b2541336">https://www.jianshu.com/p/5b06b2541336</a></p>
<h3 id="配置项目遇到的几个问题"><a href="#配置项目遇到的几个问题" class="headerlink" title="配置项目遇到的几个问题"></a>配置项目遇到的几个问题</h3><p>背景：把之前的包想移动到新创建的一个子包里。</p>
<p>✅父子工程引用的问题</p>
<p>1、Parent怎么能找到childA和childB呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">   &lt;module&gt;childA&lt;/module&gt;</span><br><span class="line">   &lt;module&gt;childB&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>2、pom”继承”的概念</p>
<p>如果分别去在各自的pom里引用包，就会导致pom文件引入的包重复。<br>父pom写好了，子pom就通过<code>&lt;parent&gt;</code>标签继承父pom的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">   &lt;groupId&gt;com.sang.main&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class="line">   &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;  &lt;!--本例中此处是可选的，不是在外层包下的话用--&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p>子pom中引入<code>&lt;parent&gt;</code>标签后，就会从父pom继承<code>&lt;version&gt;</code>等属性了,主pom中把依赖通过<code>&lt;dependecyManagement&gt;</code>引起来，表示子pom可能会用到的jar包依赖，子包引用的话，可以不加version属性，便于统一管理，加了的话表示子包单独用这个版本。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SunFlowerXT/article/details/105531109">https://blog.csdn.net/SunFlowerXT/article/details/105531109</a></p>
<p>✅Junit找不到的问题，test放在main里，结构限定scope为test</p>
<p>✅class notFound 以及 找不到或无法加载主类</p>
<p>项目结构没有安排明白的原因，点project structure，父包下面的main包和test包下的java包啥的都不作为source和test，resource也不作为reesource。子包下面的模块选好。就可以了。</p>
<p>✅打包时注意</p>
<p>打包时注意：</p>
<p>当mvn仓库里缺少jar包，同时又从中央仓库自动下载不下来的时候，就需要自己下载jar包然后放仓库里了，<br>但是有时候只是简单的把jar和source放仓库的文件夹下，并不管用，这个时候你可以用命令把jar把打进去：<br><code>mvn install:install-file -Dfile=D:\xxx.jar -DgroupId=commons-dbcp -DartifactId= commons-dbcp -Dversion= 1.4 -Dpackaging=jar</code><br>-Dfile 是存在本地磁盘里jar 的路径</p>
<p>✅jar包冲突</p>
<p>mvn dependency:tree命令解决jar包冲突<br>当项目出现jar包冲突时,用命令mvn dependency:tree 查看依赖情况<br>mvn dependency:tree 查看依赖树,查看包结构间的依赖<br>mvn dependency:tree &gt;d:/tmp 把结果输出到文件，<br>然后再pom.xml文件里排除掉冲突的jar包</p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/good_good_xiu/article/details/116740333">https://blog.csdn.net/good_good_xiu/article/details/116740333</a></p>
<p>⚠️本地启动项目，有包显红，在maven - root - compile一下。<br>maven中的compile命令是用来将源代码编译成可执行的class文件，或者把它打包成jar文件，以便他人使用。</p>
<p>✅为什么包没有在pom中引入，但是compile编译之后在target文件中却出现了呢。<br>maven会自动寻找依赖并自动加载它们，在某些情况下，即使它们没有在pom文件中显式引入，也会被自动加载到项目中。也有可能其他依赖引入了该包。这些jar包会被编译成class文件，maven把它们放在target目录下，以便正常使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/" class="post-title-link" itemprop="url">Geometry和Coordinate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-21 13:25:10" itemprop="dateCreated datePublished" datetime="2022-05-21T13:25:10+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-08 22:04:08" itemprop="dateModified" datetime="2023-02-08T22:04:08+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LineString与Coordinate"><a href="#LineString与Coordinate" class="headerlink" title="LineString与Coordinate"></a>LineString与Coordinate</h3><p>Geometry对象转换为LineString对象，前面加(LineString)强转。</p>
<p><code>Coordinate coor = new Coordinate(lng, lat);</code><br>//lng、lat是Double类型经度纬度</p>
<p>LineString转换为Coordinate数组：<br><code>Coordinate[] coor = road.getCoordinates();</code></p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>com.vividsolutions.jts.geom下<br>Geometry可以是一系列的点组成的线。<br>数据库中查看需要加：select st_astext(geo) from table;</p>
<p>Geometry里的点：<br><code>Coordinate[] coordinates = geo.getCoordinates();</code></p>
<h3 id="GeometryUtils工具类"><a href="#GeometryUtils工具类" class="headerlink" title="GeometryUtils工具类"></a>GeometryUtils工具类</h3><p>GeometryUtils类属于mil.nga.giat.geowave.core.geotime包。</p>
<p><a target="_blank" rel="noopener" href="https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html">https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html</a></p>
<h3 id="redisTemplate的GEO-API："><a href="#redisTemplate的GEO-API：" class="headerlink" title="redisTemplate的GEO API："></a>redisTemplate的GEO API：</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39274753/article/details/107783674">https://blog.csdn.net/weixin_39274753/article/details/107783674</a></p>
<h3 id="string和geometry的转换"><a href="#string和geometry的转换" class="headerlink" title="string和geometry的转换"></a>string和geometry的转换</h3><p>需要导入jts包。（vividsolution）</p>
<p>WKT，是一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换。它的二进制表示方式，亦即WKB(well-known binary)则胜于在传输和在数据库中存储相同的信息。该格式由开放地理空间联盟(OGC)制定。</p>
<p>WKT可以表示的几何对象包括：点，线，多边形，TIN（不规则三角网）及多面体。可以通过几何集合的方式来表示不同维度的几何对象。<br>几何物体的坐标可以是2D(x,y),3D(x,y,z),4D(x,y,z,m),加上一个属于线性参照系统的m值。<br>以下为几何WKT字串样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POINT(6 10)</span><br><span class="line">LINESTRING(3 4,10 50,20 25)</span><br><span class="line">POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))</span><br><span class="line">MULTIPOINT(3.5 5.6, 4.8 10.5)</span><br><span class="line">MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))</span><br><span class="line">MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))</span><br><span class="line">GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))</span><br><span class="line">POINT ZM (1 1 5 60)</span><br><span class="line">POINT M (1 1 80)</span><br><span class="line">POINT EMPTY</span><br><span class="line">MULTIPOLYGON EMPTY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void geoTest() throws ParseException, com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    //1.string类型转为geometry</span><br><span class="line">    //GeometryFactory工厂，参数一：数据精度 参数二空间参考系SRID</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line"></span><br><span class="line">    //熟知文本WKT阅读器，可以将WKT文本转换为Geometry对象</span><br><span class="line">    WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line"></span><br><span class="line">    //Geometry对象，包含Point、LineString、Polygon等子类</span><br><span class="line">    Geometry geometry = wktReader.read(&quot;POINT (113.53896635 22.36429837)&quot;);</span><br><span class="line">    System.out.println(&quot;geometry:&quot; + geometry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2.geometry对象转为string</span><br><span class="line">    //单纯的一个坐标点，单点可以创建Point，多点可以创建LineString、Polygon等</span><br><span class="line">    Coordinate coordinate = new Coordinate(113.53896635, 22.36429837);</span><br><span class="line">    Point point = geometryFactory.createPoint(coordinate);</span><br><span class="line"></span><br><span class="line">    Polygon polygon = geometryFactory.createPolygon(new Coordinate[]&#123;</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">    &#125;);</span><br><span class="line">    Geometry geometry1 = point;</span><br><span class="line">    Geometry geometry2 = polygon;</span><br><span class="line"></span><br><span class="line">    //WKT输出器，将Geometry对象写出为WKT文本</span><br><span class="line">    WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">    String pointString = wktWriter.write(point);</span><br><span class="line">    System.out.println(&quot;point string: &quot; + pointString);</span><br><span class="line">    String geoString = wktWriter.write(geometry1);</span><br><span class="line">    System.out.println(&quot;geo string: &quot; + geoString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>Java Geometry空间几何数据的处理应用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/An1090239782/article/details/123509504">https://blog.csdn.net/An1090239782/article/details/123509504</a></p>
<p>Geometry在数据库和Java中的应用：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/76343e71d6f1">https://www.jianshu.com/p/76343e71d6f1</a></p>
<h3 id="两个geometry拼接"><a href="#两个geometry拼接" class="headerlink" title="两个geometry拼接"></a>两个geometry拼接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    WKTReader wktReader = new WKTReader();</span><br><span class="line">    Geometry geometry1 = wktReader.read(&quot;LineString(113.53896635 22.36429837, 113.53896645 22.36429847)&quot;);</span><br><span class="line">    Geometry geometry2 = wktReader.read(&quot;LineString(113.53896645 22.36429847, 113.53896655 22.36429857)&quot;);</span><br><span class="line">    Geometry geometry3 = geometry1.union(geometry2);</span><br><span class="line">    System.out.println(geometry3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：MULTILINESTRING ((113.53896635 22.36429837, 113.53896645 22.36429847), (113.53896645 22.36429847, 113.53896655 22.36429857))</p>
<h3 id="jts里的geometry的一些操作"><a href="#jts里的geometry的一些操作" class="headerlink" title="jts里的geometry的一些操作"></a>jts里的geometry的一些操作</h3><p>✅<code>org.locationtech.jts.geom.Geometry.isValid()</code></p>
<p>验证此Geometry是否在拓扑上有效。</p>
<p>✅<code>geo.buffer(distance)</code></p>
<p>buffer(double distance): 加buffer缓冲区<br>buffer(double distance, int quadrantSegments): 加buffer,边界样式</p>
<p>✅<code>geometry1.equals(geometry2)</code> 是否完全重叠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void equalsGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">    WKTReader reader = new WKTReader( geometryFactory );</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.equals(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line"></span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(10 0, 0 0)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.equals(geometry2);//true</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅geometry1.crosses(geometry2) 是否交叉</p>
<p>得有交点。但交点不能是线的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void crossGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    //情景1</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    //情景2</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    //情景3</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(4 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b3 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b3);</span><br><span class="line">    //情景4</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(0 4, 3 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b4 = geometry1.crosses(geometry2);//true</span><br><span class="line">    System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅intersects ：两个对象是否空间相交（至少有一个点）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">boolean b2 = geometry1.intersects(geometry2);//true</span><br></pre></td></tr></table></figure>

<p>geometry的更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaobing1226/article/details/124467098">https://blog.csdn.net/qiaobing1226/article/details/124467098</a></p>
<p>常用的Geometry数据结构和GeometryFactory：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3add14bdee7b">https://www.jianshu.com/p/3add14bdee7b</a></p>
<p>jts使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40294332/article/details/124124361">https://blog.csdn.net/weixin_40294332/article/details/124124361</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaobing1226/article/details/127204644">https://blog.csdn.net/qiaobing1226/article/details/127204644</a></p>
<h3 id="数据库相关的geo操作"><a href="#数据库相关的geo操作" class="headerlink" title="数据库相关的geo操作"></a>数据库相关的geo操作</h3><p>✅mysql空间数据有哪些</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Geometry  空间数据	任意一种空间类型	</span><br><span class="line">Point	点	坐标值	POINT(104.00924 30.46872)</span><br><span class="line">LineString	线	线，由一系列点连接而成	LINESTRING(1 1,  1 1, 1 1)</span><br><span class="line">Polygon	多边形	由多条线组成	POLYGON((1 1, 2 2, 3 3,  4 4, 5 5))</span><br><span class="line">MultiPoint	点集合	集合类，包含多个点	MULTIPOINT(1 1, 2 2, 1 1)</span><br><span class="line">MultiLineString	线集合	集合类，包含多条线	MULTILINESTRING((1 1, 2 2), (1 1, 1 1))</span><br><span class="line">MultiPolygon	多边形集合	集合类，包含多个多边形	MULTIPOLYGON(((0 0, 1 0, 1 1, 0 1, 0 0)), ((1 1, 1 1, 1 1, 1 1, 1 1)))</span><br><span class="line">GeometryCollection	空间数据集合	集合类，可以包括多个点、线、多边形	GEOMETRYCOLLECTION(POINT(1 1), POINT(3 3), LINESTRING(1 1, 2 2))</span><br></pre></td></tr></table></figure>

<p>mysql中几何对象的表达格式：<br>WKT：（Well-known Text）可以通过文本来描述几何对象。<br>WKB（Well-known Binary）通过序列化的字节对象来描述几何对象（一般在数据库中使用）。</p>
<p>常用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ST_GEOMFROMTEXT</span><br><span class="line">用于将几何数据从可读的文本类型转换成内部存储的二进制类型。</span><br><span class="line">ST_ASTEXT</span><br><span class="line">将几何数据转换成可读的文本类型。</span><br><span class="line"></span><br><span class="line">st_union(g1, g2) 将g1和g2合并为一个集合类对象</span><br><span class="line">st_difference(g1, g2)  返回几何对象，该对象表示了几何值g1与g2的点集合差异</span><br><span class="line">st_intersection(g1,g2)  返回几何对象，该对象表示了几何值g1与g2的点集合交集</span><br><span class="line"></span><br><span class="line">st_contains(g1, g2)</span><br><span class="line">g1完全包含g2；返回0: g1未包含g2</span><br><span class="line"></span><br><span class="line">st_crosses(g1, g2), st_intersects(g1, g2)</span><br><span class="line">返回1: g1与g2相交；返回0:g1与g2未相交</span><br><span class="line"></span><br><span class="line">st_disjoint(g1, g2)</span><br><span class="line">是st_crosses的反函数</span><br><span class="line"></span><br><span class="line">st_within(g1, g2)</span><br><span class="line">g1在g2内则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<p>创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对表中的geometry类型的字段进行索引可以优化搜索，mysql中通过对geometry对象的mbr创建索引</span><br><span class="line">创建：</span><br><span class="line">create spatial index i_shape on `t_geo_test`(shape);</span><br><span class="line">删除：</span><br><span class="line">drop index i_shape on `t_geo_test`;</span><br><span class="line"></span><br><span class="line">目前mysql中支持的空间坐标系统没有gcj02,bd09等国内坐标系，</span><br><span class="line">默认使用wgs84地球坐标系，所以在创建几何对象时输入的坐标值尽量使用wgs84坐标，以避免误差。</span><br><span class="line"></span><br><span class="line">mysql中的计算距离，长度，面积等绝对数值的空间计算函数（area(), glength(), st_distance()）存在一定的误差，尽量不要使用。</span><br></pre></td></tr></table></figure>

<p>mysql的geometry相关的函数：<a target="_blank" rel="noopener" href="https://jiuaidu.com/jianzhan/906169/">https://jiuaidu.com/jianzhan/906169/</a></p>
<p>✅创建表时带geometry字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`geo` geometry default null comment &#x27;坐标点&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists `geo_table`(</span><br><span class="line">    `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">    `geo` geometry default null comment &#x27;坐标点&#x27;,</span><br><span class="line">    PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COMMENT=&quot;geo&quot;;</span><br><span class="line"></span><br><span class="line">set @geo = st_geomfromtext(&quot;LineString(104.009241 30.468972,104.009229 30.468961)&quot;);</span><br><span class="line">insert into geo_table values(0, @geo);</span><br><span class="line">select st_astext(geo) from geo_table;</span><br></pre></td></tr></table></figure>

<p>✅Intersects相交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where Intersects(geome1, geo2);</span><br></pre></td></tr></table></figure>

<p>✅mysql根据经纬度计算距离</p>
<p>st_distance_sphere函数返回以米为单位.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select st_distance_sphere(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>st_distance返回的度<br>st_distance 计算的结果单位是度，需要乘111195（地球半径6371000*PI/180）是将值转化为米。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select st_distance(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>直接计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*,ROUND(</span><br><span class="line">6378.138 * 2 * ASIN(</span><br><span class="line">SQRT(</span><br><span class="line">POW( SIN(( 23.129163 * PI()/ 180-latitudes * PI()/ 180 )/ 2 ), 2 )+ COS( 23.129163 * PI()/ 180 )* COS( latitudes * PI()/ 180 )* POW( SIN(( 113.264435 * PI()/ 180-longitudes * PI()/ 180 )/ 2 ), 2 )))* 1000 </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="几个坐标系"><a href="#几个坐标系" class="headerlink" title="几个坐标系"></a>几个坐标系</h3><p>总的来说，坐标系可以分为两大类：地理坐标系（Geographic Coordinate System, GCS）和投影坐标系（Projected Coordinate System, PCS），地理坐标系进行地图投影后就变成了投影坐标系。例如我们常见的世界地图，使用的就是一种 墨卡托投影。</p>
<p>其中地理坐标系又可分为 参心坐标系 和 地心坐标系，常见的地心坐标系有WGS84、GCJ-02、BD-09、GCS2000。</p>
<p>✅WGS84（World Geodetic System 1984）</p>
<p>WGS84是为 GPS 全球定位系统建立的坐标系统，是世界上第一个统一的地心坐标系，因此也被称为大地坐标系、原始坐标系。一般通过GPS记录仪记录下来的经纬度，就是基于WGS84坐标系的数据。</p>
<p>✅GCJ-02（国家测量局02号标准）</p>
<p>GCJ-02 是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统，是在WGS84经纬度的基础上执行加密算法而成（为了数据安全和保密，通过地形图非线性保密处理算法（俗称火星加密）加密）。因为GPS得到的经纬度直接在 GCJ-02 坐标系下会定位到错误的地点，有种到了火星的感觉，因此在坊间也将 GCJ-02 戏称为火星坐标系。</p>
<p>国测局规定，国内出版的各种地图系统（包括电子形式），必须至少采用 GCJ-02 对地理位置进行首次加密的坐标系，高德和Google在国内都是使用 GCJ－02 坐标系，而百度使用的是在 GCJ-02 基础上再一次加密的 BD-09 坐标系。</p>
<p>举个例子，北京天安门中心的GPS经纬度是39°54’26.2”N，116°23’28.4”E，转化为度的单位就是39.907270, 116.391213（提示：小数部分 = 分 / 60 + 秒 / 3600）<br>将 GPS 坐标转换为 GCJ-02 坐标：116.397454,39.908671，才能在高德地图上找到正确的位置。<br>需要注意的是，如果切换到谷歌地图的卫星地图模式，它使用的是WGS84坐标系。</p>
<p>参考：<br>几种坐标系：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/559029832a67">https://www.jianshu.com/p/559029832a67</a><br>地心坐标系和投影坐标系：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62864791">https://zhuanlan.zhihu.com/p/62864791</a></p>
<p>三个坐标总结：WGS84是大地坐标系，这是一种国际通用的坐标，一般的终端设备，如果自己有定位功能，比如车载系统，他们发出的gps坐标就是原始坐标。我们在一些地图应用中使用的定位，比如打车软件，其他自带地图的软件，他们一般都是火星坐标系GCJ02，需要进行一个坐标转换。而百度地图相关的应用，基本都是使用的百度坐标，这个是在火星坐标基础上进行的再次加密，所以它还是与火星坐标有关系。</p>
<p>✅坐标转换</p>
<p>从WGS84坐标系不能直接转BD09，中间需要跨越一个GCJ02，反过来，需要将GCJ02或者BD09转为WGS84就是纠偏算法，相当于逆向解密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">克拉索索夫斯基椭球系数:</span><br><span class="line">public static double pi = 3.1415926535897932384626;</span><br><span class="line">public static double a = 6378245.0;</span><br><span class="line">public static double ee = 0.00669342162296594323;</span><br><span class="line">经纬度偏移值：&#123;105,35&#125;。这个其实是中华人民共和国大地原点坐标。位置在中国陕西省咸阳市下的泾阳县。</span><br></pre></td></tr></table></figure>

<p>转换代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">package org.example.geometry;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * wgs84 84年提出，大地坐标，也是原始坐标。</span><br><span class="line"> * gcj02 02年提出，火星坐标，经过加密算法。大多数非百度中国地图厂商基本都是使用的火星坐标：高德，腾讯，谷歌中国cn</span><br><span class="line"> * bd09  09年提出，百度坐标，经过火星坐标再次加密，相当于对大地坐标经过了二次加密。百度自己使用</span><br><span class="line"> * 一般的算法，没有直接bd09-&gt;wgs84或者wgs84-&gt;bd09，都需要借助wgs84-&gt;gcj02或者gcj02-&gt;wgs84算法推导。</span><br><span class="line"> */</span><br><span class="line">public class GpsTransfer &#123;</span><br><span class="line">    //π的定义</span><br><span class="line">    public static double pi = 3.1415926535897932384626;</span><br><span class="line">    //椭球长半径，依据克拉索索夫斯基椭球系数计算</span><br><span class="line">    public static double a = 6378245.0;</span><br><span class="line">    //第一偏心率的平方</span><br><span class="line">    public static double ee = 0.00669342162296594323;</span><br><span class="line"></span><br><span class="line">    public static double transformLat(double x, double y) &#123;</span><br><span class="line">        double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y</span><br><span class="line">                + 0.2 * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static double transformLon(double x, double y) &#123;</span><br><span class="line">        double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1</span><br><span class="line">                * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0</span><br><span class="line">                * pi)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断是否在中国范围之内</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean outOfChina(double lat, double lon) &#123;</span><br><span class="line">        if (lon &lt; 72.004 || lon &gt; 137.8347)</span><br><span class="line">            return true;</span><br><span class="line">        if (lat &lt; 0.8293 || lat &gt; 55.8271)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 把公式部分抽取出来</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps transform(double lat, double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return new Gps(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double dLat = transformLat(lon - 105.0, lat - 35.0);</span><br><span class="line">        double dLon = transformLon(lon - 105.0, lat - 35.0);</span><br><span class="line">        double radLat = lat / 180.0 * pi;</span><br><span class="line">        double magic = Math.sin(radLat);</span><br><span class="line">        magic = 1 - ee * magic * magic;</span><br><span class="line">        double sqrtMagic = Math.sqrt(magic);</span><br><span class="line">        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);</span><br><span class="line">        dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);</span><br><span class="line">        double mgLat = lat + dLat;</span><br><span class="line">        double mgLon = lon + dLon;</span><br><span class="line">        return new Gps(mgLat, mgLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * wgs84到gcj02转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps wgs84_To_Gcj02(double lat, double lon) &#123;</span><br><span class="line">        return transform(lat, lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 简单的gcj02到wgs84坐标类型转换，只做了一次迭代</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84(double lat, double lon) &#123;</span><br><span class="line">        Gps gps = transform(lat, lon);</span><br><span class="line">        double lontitude = lon * 2 - gps.lon;</span><br><span class="line">        double latitude = lat * 2 - gps.lat;</span><br><span class="line">        return new Gps(latitude, lontitude);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 稍微精确一点的gcj02到wgs84转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84_exact(double lat,double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return gcj02_To_Wgs84(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double initDelta = 0.01;</span><br><span class="line">        double threshold = 0.000001;</span><br><span class="line">        double dLat = initDelta;</span><br><span class="line">        double dLon = initDelta;</span><br><span class="line">        double mLat = lat - dLat;</span><br><span class="line">        double mLon = lon - dLon;</span><br><span class="line">        double pLat = lat + dLat;</span><br><span class="line">        double pLon = lon + dLon;</span><br><span class="line">        double wgsLat = 0;</span><br><span class="line">        double wgsLon = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            wgsLat = (mLat + pLat) / 2;</span><br><span class="line">            wgsLon = (mLon + pLon) / 2;</span><br><span class="line">            Gps tmp = wgs84_To_Gcj02(wgsLat, wgsLon);</span><br><span class="line">            dLat = tmp.lat - lat;</span><br><span class="line">            dLon = tmp.lon - lon;</span><br><span class="line">            if ((Math.abs(dLat) &lt; threshold) &amp;&amp; (Math.abs(dLon) &lt; threshold)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dLat &gt; 0) &#123; pLat = wgsLat; &#125; else &#123; mLat = wgsLat;&#125;</span><br><span class="line">            if (dLon &gt; 0) &#123; pLon = wgsLon; &#125; else &#123; mLon = wgsLon;&#125;</span><br><span class="line"></span><br><span class="line">            if (++i &gt; 1000) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Gps(wgsLat, wgsLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标是在火星坐标基础上做的二次加密</span><br><span class="line">     * @param gg_lat</span><br><span class="line">     * @param gg_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Bd09(double gg_lat, double gg_lon) &#123;</span><br><span class="line">        double x = gg_lon, y = gg_lat;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double bd_lon = z * Math.cos(theta) + 0.0065;</span><br><span class="line">        double bd_lat = z * Math.sin(theta) + 0.006;</span><br><span class="line">        return new Gps(bd_lat, bd_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标与火星坐标逆向转换</span><br><span class="line">     * @param bd_lat</span><br><span class="line">     * @param bd_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps bd09_To_Gcj02(double bd_lat, double bd_lon) &#123;</span><br><span class="line">        double x = bd_lon - 0.0065, y = bd_lat - 0.006;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double gg_lon = z * Math.cos(theta);</span><br><span class="line">        double gg_lat = z * Math.sin(theta);</span><br><span class="line">        return new Gps(gg_lat, gg_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Gps gps = new Gps(39.907270, 116.391213);</span><br><span class="line">        System.out.println(gps);//&#123;39.90727,116.391213&#125;</span><br><span class="line">        Gps gps2 = wgs84_To_Gcj02(gps.lat, gps.lon);</span><br><span class="line">        System.out.println(gps2);//&#123;39.90867122432153,116.39745410656687&#125;</span><br><span class="line">        Gps gps3 = gcj02_To_Wgs84(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps3);//&#123;39.907267736339556,116.3912105466475&#125;</span><br><span class="line">        Gps gps4 = gcj02_To_Wgs84_exact(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps4);//&#123;39.90727046748559,116.39121326184032&#125; 相对一次迭代是精确了，但是好像也不是完全还原</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gps&#123;</span><br><span class="line">    double lat,lon;</span><br><span class="line">    public Gps() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Gps(double lat,double lon)&#123;</span><br><span class="line">        this.lat = lat;</span><br><span class="line">        this.lon = lon;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;&#123;&quot;+lat+&quot;,&quot;+lon+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feinifi/article/details/120547127">https://blog.csdn.net/feinifi/article/details/120547127</a></p>
<h3 id="mysql-java-redis三种地理位置算法"><a href="#mysql-java-redis三种地理位置算法" class="headerlink" title="mysql,java,redis三种地理位置算法"></a>mysql,java,redis三种地理位置算法</h3><p>获取附近信息，以用户当前位置为中心点，指定范围为半径，查询出在该圆圈内的所有信息。</p>
<h4 id="MySQL-基于st-distance函数"><a href="#MySQL-基于st-distance函数" class="headerlink" title="MySQL 基于st_distance函数"></a>MySQL 基于st_distance函数</h4><p>mysql 5.6.1 加入了空间数据支持功能，新增了st_*相关函数，可以非常方便的计算两个地理坐标点的距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	p.* </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		park_info.*,</span><br><span class="line">		st_distance (</span><br><span class="line">			point ( park_info.lng, park_info.lat ),</span><br><span class="line">		point ( 116.403694, 39.913828 ))* 111195 AS distance </span><br><span class="line">	FROM</span><br><span class="line">		park_info park_info </span><br><span class="line">	) p </span><br><span class="line">WHERE</span><br><span class="line">	p.distance &lt; 10000</span><br></pre></td></tr></table></figure>


<h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class DistanceUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 地球半径,单位 km</span><br><span class="line">     */</span><br><span class="line">    private static final double EARTH_RADIUS = 6378137;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据经纬度，计算两点间的距离</span><br><span class="line">     *</span><br><span class="line">     * @param longitude1 第一个点的经度</span><br><span class="line">     * @param latitude1  第一个点的纬度</span><br><span class="line">     * @param longitude2 第二个点的经度</span><br><span class="line">     * @param latitude2  第二个点的纬度</span><br><span class="line">     * @return 返回距离 单位米</span><br><span class="line">     */</span><br><span class="line">    public static double getDistance(double longitude1, double latitude1, double longitude2, double latitude2) &#123;</span><br><span class="line">        // 纬度</span><br><span class="line">        double lat1 = Math.toRadians(latitude1);</span><br><span class="line">        double lat2 = Math.toRadians(latitude2);</span><br><span class="line">        // 经度</span><br><span class="line">        double lng1 = Math.toRadians(longitude1);</span><br><span class="line">        double lng2 = Math.toRadians(longitude2);</span><br><span class="line">        // 纬度之差</span><br><span class="line">        double a = lat1 - lat2;</span><br><span class="line">        // 经度之差</span><br><span class="line">        double b = lng1 - lng2;</span><br><span class="line">        // 计算两点距离的公式</span><br><span class="line">        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +</span><br><span class="line">                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(b / 2), 2)));</span><br><span class="line">        // 弧长乘地球半径, 返回单位: 米</span><br><span class="line">        s =  s * EARTH_RADIUS;</span><br><span class="line">        return Math.round(s * 10000) / 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double distance = DistanceUtils.getDistance(109.49081, 36.596537, 111.128971, 37.524041);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance);</span><br><span class="line">        double distance1 = DistanceUtils.getDistance(109.500603,36.594125, 111.151761,37.52671);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key 停车场地理位置键</span><br><span class="line"> * @param lng 坐标</span><br><span class="line"> * @param lat 坐标</span><br><span class="line"> * @param t 停车场标示</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long addGeo(String key, Double lng, Double lat, T t) &#123;</span><br><span class="line">    RedisGeoCommands.GeoLocation&lt;T&gt; geoLocation = new RedisGeoCommands.GeoLocation&lt;&gt;(t, new Point(lng, lat));</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, geoLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量添加</span><br><span class="line"> * @param key</span><br><span class="line"> * @param list</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long batchAddGeo(String key, List&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt; list) &#123;</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> */</span><br><span class="line">public void removeGeo(String key, T... t) &#123;</span><br><span class="line">    redisTemplate.opsForGeo().remove(key, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取经纬度指定距离内的数据</span><br><span class="line"> *</span><br><span class="line"> * @param lng</span><br><span class="line"> * @param lat</span><br><span class="line"> * @param distance</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt;</span><br><span class="line">getCacheListByPointAndDistance(Double lng, Double lat, Double distance, String key) &#123;</span><br><span class="line">    Circle circle = new Circle(new Point(lng, lat), new Distance(distance, Metrics.KILOMETERS));</span><br><span class="line">    RedisGeoCommands.GeoRadiusCommandArgs args =</span><br><span class="line">            // includeCoordinates：返回结果包含坐标信息</span><br><span class="line">            // includeDistance：返回结果包含具中心坐标距离信息</span><br><span class="line">            // sortAscending：按照距离升序排序</span><br><span class="line">            // sortDescending：按照距离降序排序</span><br><span class="line">            // limit：返回结果数量限制</span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates()</span><br><span class="line">                    .sortAscending();</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt; content =</span><br><span class="line">            redisTemplate.opsForGeo().radius(key, circle, args).getContent();</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Elasticsearch-Geo"><a href="#Elasticsearch-Geo" class="headerlink" title="Elasticsearch Geo"></a>Elasticsearch Geo</h4><p>【toStudy】</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37923316/article/details/108978101">https://blog.csdn.net/m0_37923316/article/details/108978101</a></p>
<h3 id="点到线的最近线段"><a href="#点到线的最近线段" class="headerlink" title="点到线的最近线段"></a>点到线的最近线段</h3><p>使用JTSFactoryFinder 创建GeometryFactory，是在org.geotools.geometry.jts下的。</p>
<p>需要导入的包：gt-main、gt-metadata</p>
<p><code>GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory(null);</code></p>
<p>返回点到线段的最近线段，可能是垂线，不能垂直的话，是点到线段两端点的连线。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testNearest() throws ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    Coordinate coordinate = new Coordinate(1, 1);</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt = &quot;LINESTRING(0 0, 1 0, 2 0)&quot;;</span><br><span class="line">    LineString road = (LineString) reader.read(wkt);</span><br><span class="line">    Coordinate[] shadow = com.vividsolutions.jts.operation.distance.DistanceOp.nearestPoints(road,</span><br><span class="line">            geometryFactory.createPoint(coordinate));</span><br><span class="line">    System.out.println(Arrays.toString(shadow)); //[(1.0, 0.0, NaN), (1.0, 1.0, NaN)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="道格拉斯抽稀"><a href="#道格拉斯抽稀" class="headerlink" title="道格拉斯抽稀"></a>道格拉斯抽稀</h3><p>道格拉斯-普克算法（Douglas-Peuker算法）是我们常用的一种轨迹点的抽稀算法，抽稀出来的点可以尽可能的维持原先轨迹点的大体轮廓，剔除一些非必要的点。</p>
<p>道格拉斯-普克原理：<br>（1）在曲线首尾两点A，B之间连接一条直线AB，该直线为曲线的弦；<br>（2）得到曲线上离该直线段距离最大的点C，计算其与AB的距离d；<br>（3）比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则该直线段作为曲线的近似，该段曲线处理完毕。<br>（4）如果距离大于阈值，则用C将曲线分为两段AC和BC，并分别对两段取信进行1~3的处理。<br>（5）当所有曲线都处理完毕时，依次连接各个分割点形成的折线，即可以作为曲线的近似。</p>
<p>java使用方法：jts是一套用于处理几何要素拓扑关系的函数库，提供了基本二位平面线形图形运算算法实现。</p>
<p>mvn依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jts&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line">Geometry geometry1 = wktReader.read(&quot;lineString(0 0, 1 1, 2 0)&quot;);</span><br><span class="line">Geometry geometry2 = DouglasPeuckerSimplifier.simplify(geometry1, 0.9);</span><br><span class="line">WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">String res = wktWriter.write(geometry2);</span><br><span class="line">System.out.println(res);  //LINESTRING (0 0, 1 1, 2 0)</span><br></pre></td></tr></table></figure>

<p><code>Geometry simplify(Geometry geom, double distanceTolerance)</code>中的参数distanceTolerance是跟首尾点距离比(单纯平方间的距离，不是实际m的距离)。</p>
<p>自己实现道格拉斯抽稀(python)：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/046bcaeb2cb6">https://www.jianshu.com/p/046bcaeb2cb6</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">java多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-21 10:52:08" itemprop="dateCreated datePublished" datetime="2022-05-21T10:52:08+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-01 18:32:22" itemprop="dateModified" datetime="2023-05-01T18:32:22+08:00">2023-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程池Executor、ExecutorService、Executors三者关系"><a href="#线程池Executor、ExecutorService、Executors三者关系" class="headerlink" title="线程池Executor、ExecutorService、Executors三者关系"></a>线程池Executor、ExecutorService、Executors三者关系</h3><p><img src="/images/Executor%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<p>层次关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;&#125;</span><br><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;&#125;</span><br><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125;</span><br><span class="line">public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1.ExecutorService 接口继承了Executor 接口，是Executor 的子接口。</p>
<p>2.Executor接口中定义了execute()方法，用来接收一个Runnable接口的对象，而ExecutorService接口中定义的submit()方法可以接收Runnable和Callable接口对象。</p>
<p>3.Executor接口中execute()方法不返回任何结果，而ExecutorService接口中submit()方法可以通过一个 Future 对象返回运算结果。</p>
<p>4.Executor和ExecutorService除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。<br>比如：调用 shutDown() 方法终止线程池。</p>
<p>5.Executors 是一个工具类，类似于 Collections。Executors 类提供工厂方法用来创建不同类型的线程池。比如:<br>　　 Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池，<br>　　 Executors.newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，<br>　　 Executors.newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>　　 Executors.newScheduledThreadPool(int corePoolSize) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whx20100101/p/9862392.html">https://www.cnblogs.com/whx20100101/p/9862392.html</a></p>
<p>使用Executors还是ExecutorService？<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：<br>AbortPolicy: 直接抛异常<br>CallerRunsPolicy: 用调用者的线程来运行任务<br>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>DiscardPolicy 直接将新任务丢弃</p>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43921491/article/details/115717604">https://blog.csdn.net/weixin_43921491/article/details/115717604</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(...);</span><br><span class="line">executor.submit(()-&gt;单条语句);</span><br><span class="line"></span><br><span class="line">executor.submit(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="线程池java-util-concurrent-ThreadPoolExecutor"><a href="#线程池java-util-concurrent-ThreadPoolExecutor" class="headerlink" title="线程池java.util.concurrent.ThreadPoolExecutor"></a>线程池java.util.concurrent.ThreadPoolExecutor</h3><p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, </span><br><span class="line">int maximumPoolSize, </span><br><span class="line">long keepAliveTime, </span><br><span class="line">TimeUnit unit, </span><br><span class="line">BlockingQueue workQueue,  </span><br><span class="line">RejectedExecutionHandler handler) </span><br><span class="line"></span><br><span class="line">corePoolSize： 线程池维护线程的最少数量 </span><br><span class="line">maximumPoolSize：线程池维护线程的最大数量 </span><br><span class="line">keepAliveTime： 线程池维护线程所允许的空闲时间 </span><br><span class="line">unit： 线程池维护线程所允许的空闲时间的单位 </span><br><span class="line">workQueue： 线程池所使用的缓冲队列 </span><br><span class="line">handler： 线程池对拒绝任务的处理策略 </span><br><span class="line"></span><br><span class="line">unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性： </span><br><span class="line">NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。 </span><br><span class="line"></span><br><span class="line">workQueue可用的队列类是：java.util.concurrent.ArrayBlockingQueue </span><br><span class="line"></span><br><span class="line">handler有四个选择： </span><br><span class="line">（1）ThreadPoolExecutor.AbortPolicy()   抛出java.util.concurrent.RejectedExecutionException异常 </span><br><span class="line">（2）ThreadPoolExecutor.CallerRunsPolicy()  重试添加当前的任务，他会自动重复调用execute()方法 </span><br><span class="line">（3）ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务 （等待队列里面最早进入的）</span><br><span class="line">（4）ThreadPoolExecutor.DiscardPolicy()     抛弃当前的任务 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个任务（ Runnable类型的对象）通过execute(Runnable)方法欲添加到线程池时：<br>1、如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br>2、如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br>3、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量小于maximumPoolSize，建新的线程来处理被添加的任务。<br>4、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 </p>
<p>也就是：处理任务的优先级为：<br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </p>
<p>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 </p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws InterruptedException &#123;</span><br><span class="line">    ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 3, TimeUnit.SECONDS,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(3), new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    class ThreadPoolTask implements Runnable, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 0;</span><br><span class="line">        // 保存任务所需要的数据</span><br><span class="line">        private Object threadPoolTaskData;</span><br><span class="line"></span><br><span class="line">        ThreadPoolTask(Object tasks) &#123;</span><br><span class="line">            this.threadPoolTaskData = tasks;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + getTask());</span><br><span class="line">            try &#123;</span><br><span class="line">                // //便于观察，等待一段时间</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            threadPoolTaskData = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getTask() &#123;</span><br><span class="line">            return this.threadPoolTaskData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 产生一个任务，并将其加入到线程池</span><br><span class="line">            String task = &quot;task@ &quot; + i;</span><br><span class="line">            System.out.println(&quot;put &quot; + task);</span><br><span class="line">            threadPool.submit(new ThreadPoolTask(task));</span><br><span class="line">            // 便于观察，等待一段时间</span><br><span class="line">            Thread.sleep(2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">    // 也可以直接用lambda表达式往线程池里加线程</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + &quot;lambda&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">put task@ 1</span><br><span class="line">pool-1-thread-1start ..task@ 1</span><br><span class="line">put task@ 2</span><br><span class="line">pool-1-thread-2start ..task@ 2</span><br><span class="line">put task@ 3</span><br><span class="line">put task@ 4</span><br><span class="line">put task@ 5</span><br><span class="line">put task@ 6</span><br><span class="line">pool-1-thread-3start ..task@ 6</span><br><span class="line">put task@ 7</span><br><span class="line">pool-1-thread-4start ..task@ 7</span><br><span class="line">put task@ 8</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util....</span><br><span class="line">pool-1-thread-1start ..task@ 3</span><br><span class="line">pool-1-thread-2start ..task@ 4</span><br><span class="line">pool-1-thread-3start ..task@ 5</span><br><span class="line"></span><br><span class="line">因为线程加入线程池很快，线程都还没处理完，所以最开始先2个线程，</span><br><span class="line">然后3个加入队列，然后再来2个，扩大线程池，再一个就抛出异常了，</span><br><span class="line">慢慢队列中的三个会被执行。</span><br><span class="line"></span><br><span class="line">如果是DiscardOldestPolicy策略，就把最早进入队列的怼出去。</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/abcwywht/article/details/54744152">https://blog.csdn.net/abcwywht/article/details/54744152</a></p>
<p>✅规范创建线程池<br>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。目的是规避资源耗尽的风险。FixedThreadPool和SingleThreadPool允许请求队列长度Integer.MAX_VALUE，可能堆积大量请求，OOM。CachedThreadPool允许创建线程数量Integer.MAX_VALUE，可能创建大量线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;Runnable&gt;(6),</span><br><span class="line">                new ThreadFactory() &#123;</span><br><span class="line">                    AtomicInteger id = new AtomicInteger(0);</span><br><span class="line">                    @Override</span><br><span class="line">                    public Thread newThread(Runnable r) &#123;</span><br><span class="line">                        return new Thread(r, &quot;thread-poolName-&quot; + id.incrementAndGet());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        threadPool.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //可以直接用lambda表达式：</span><br><span class="line">        threadPool.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面没加线程池到最大和队列满了该怎么办的参数，可以加。</p>
<h3 id="ThreadPoolExecutor的execute方法和submit方法"><a href="#ThreadPoolExecutor的execute方法和submit方法" class="headerlink" title="ThreadPoolExecutor的execute方法和submit方法"></a>ThreadPoolExecutor的execute方法和submit方法</h3><p>1、execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</p>
<p>2、execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕/取消等操作。</p>
<p>3、submit会对Runnable或Callable入参封装成RunnableFuture对象（同时继承了Runnable接口和Future接口），调用execute方法并返回。FutureTask是实现了RunnableFuture接口</p>
<p>4、通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。（FutureTask则是将catch到的异常存下来，在get的时候再去判断任务执行状态，如果任务状态是异常，则再抛出ExecutionException异常。）</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/happyyear1/article/details/122378013">https://blog.csdn.net/happyyear1/article/details/122378013</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Zhang____/article/details/121866974">https://blog.csdn.net/Mr_Zhang____/article/details/121866974</a></p>
<h3 id="ThreadPoolExecutor的submit返回值Future"><a href="#ThreadPoolExecutor的submit返回值Future" class="headerlink" title="ThreadPoolExecutor的submit返回值Future"></a>ThreadPoolExecutor的submit返回值Future</h3><p>✅Executor接口中的execute方法：<br>这个方法是没有返回值的，而且只接受Runnable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ExecutorService接口中的submit方法：<br>这个方法接收两种参数，Callable和Runnable。返回值是Future。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>✅Callable接口和Runnable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">  V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Runnable &#123;</span><br><span class="line">  public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1、Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值<br>2、Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。</p>
<p>✅Future接口<br>通过他可以获得任务执行的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean var1);</span><br><span class="line"> </span><br><span class="line">    boolean isCancelled();</span><br><span class="line"> </span><br><span class="line">    boolean isDone();</span><br><span class="line"> </span><br><span class="line">    V get() throws InterruptedException, ExecutionException;  //获取返回值</span><br><span class="line"> </span><br><span class="line">    V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅submit(Callable task)实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(2);</span><br><span class="line">        //创建一个Callable，3秒后返回String类型</span><br><span class="line">        Callable myCallable = new Callable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">                return &quot;call方法返回值&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">        Future future = executor.submit(myCallable);</span><br><span class="line">        System.out.println(&quot;提交任务之后，获取结果之前 &quot;+getStringDate());</span><br><span class="line">        System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">        System.out.println(&quot;获取到结果之后 &quot;+getStringDate());</span><br><span class="line">    &#125;</span><br><span class="line">    public static String getStringDate() &#123;</span><br><span class="line">        Date currentTime = new Date();</span><br><span class="line">        SimpleDateFormat formatter = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line">        String dateString = formatter.format(currentTime);</span><br><span class="line">        return dateString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">提交任务之前 09:09:28</span><br><span class="line">提交任务之后，获取结果之前 09:09:29</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取到结果之后 09:09:32</span><br></pre></td></tr></table></figure>

<p>✅get()方法的阻塞性</p>
<p>通过上面的输出可以看到，在调用submit提交任务之后，主线程本来是继续运行了。但是运行到future.get()的时候就阻塞住了，一直等到任务执行完毕，拿到了返回的返回值，主线程才会继续运行。</p>
<p>这里注意一下，他的阻塞性是因为调用get()方法时，任务还没有执行完，所以会一直等到任务完成，形成了阻塞。</p>
<p>任务是在调用submit方法时就开始执行了，如果在调用get()方法时，任务已经执行完毕，那么就不会造成阻塞。</p>
<p>submit多个任务时，总阻塞时间是最长的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Callable myCallable = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">        return &quot;call方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Callable myCallable2 = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;calld2方法执行了&quot;);</span><br><span class="line">        return &quot;call2方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">Future future = executor.submit(myCallable);</span><br><span class="line">Future future2 = executor.submit(myCallable2);</span><br><span class="line">System.out.println(&quot;提交任务之后 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;开始获取第一个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">System.out.println(&quot;获取第一个返回值结束，开始获取第二个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值2: &quot;+future2.get());</span><br><span class="line">System.out.println(&quot;获取第二个返回值结束 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">提交任务之前 14:14:47</span><br><span class="line">提交任务之后 14:14:48</span><br><span class="line">开始获取第一个返回值 14:14:48</span><br><span class="line">calld2方法执行了</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取第一个返回值结束，开始获取第二个返回值 14:14:53</span><br><span class="line">获取返回值2: call2方法返回值</span><br><span class="line">获取第二个返回值结束 14:14:53</span><br></pre></td></tr></table></figure>

<p>✅submit(Runnable task, T result)实现</p>
<p>虽然submit传入Runnable不能直接返回内容，但是可以通过submit(Runnable task, T result)传入一个载体，通过这个载体获取返回值。这个其实不能算返回值了，是交给线程处理一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(2); //不推荐这样创建</span><br><span class="line">    Result res = new Result();</span><br><span class="line">    Future&lt;Result&gt; future = executor.submit(new MyThread(res), res);</span><br><span class="line">    System.out.println(&quot;返回的结果  name: &quot; + future.get().getName()); //新名字</span><br><span class="line">    System.out.println(&quot;原来的Data  name: &quot; + res.getName()); //原来的也变成了新名字</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyThread implements Runnable &#123;</span><br><span class="line">    private Result result;</span><br><span class="line">    public MyThread(Result result) &#123;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.println(&quot;线程  执行:&quot;);</span><br><span class="line">            result.setName(&quot;新名字&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public static class Result &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️T是Runnable里面的属性，创建时传入，线程中赋值，get方法拿到，之前传入的变量也跟着变化。</p>
<p>✅get(long var1, TimeUnit var3)<br>前面都是用的get()方法获取返回值，那么因为这个方法是阻塞的，有时需要等很久。所以有时候需要设置超时时间。</p>
<p>get(long var1, TimeUnit var3)这个方法就是设置等待时间的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future future1 = executor.submit(myCallable);</span><br><span class="line">System.out.println(&quot;开始拿结果 &quot;+getStringDate());</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;返回的结果是： &quot;+future1.get(3, TimeUnit.SECONDS)+ &quot; &quot;+getStringDate());</span><br><span class="line">&#125; catch (TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(&quot;超时了 &quot;+getStringDate());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;结束拿结果 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">过了三秒就抛出超时异常了，主线程继续运行，不会再继续阻塞。</span><br></pre></td></tr></table></figure>


<p>✅execute与submit的异常处理</p>
<p>使用submit方法还有一个特点就是，他的异常可以在主线程中catch到。<br>而使用execute方法执行任务是捕捉不到异常的。<br>用下面这个Runnable来说,这个 里面一定会抛出一个异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable myRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.execute(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用execute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            executor.execute(myRunnable);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不会输出抓到异常那行日志，输出是在线程pool-1-thread-1中，并不是在主线程中。说明主线程的catch不能捕捉到这个异常。异常在线程中直接抛出。</p>
<p>使用submit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">           Future future1= executor.submit(myCallable);</span><br><span class="line">            future1.get();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以抓到异常。得有get方法。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zdx1515888659/article/details/109537577">https://blog.csdn.net/zdx1515888659/article/details/109537577</a></p>
<p>✅项目中的线程池中异常捕获<br>项目中想将线程池中线程的异常在外面捕获到，传递给前端。<br>所以用submit方法，返回Future&lt;?&gt;，在submit方法后直接get，future.get()，有两个异常需要处理：ExecutionException、InterruptException，直接方法上throws出去。调用这个方法的方法要不也throws（给前端透出异常），要不就try..catch..打log（这样无法给前端透出异常）。<br>⚠️注意：用get方法相当于是阻塞了，本来起线程，把要执行的动作交给线程池里的线程(submit)，然后不需要管线程执行完就直接退出干别的了，加了get的话，就要等线程执行完了。如果是大量任务一次交给线程池(线程池里的队列)，需要考虑get带来的阻塞性是否能接受。本来想异步，加了get捕获异常之后，变成同步的了。</p>
<p>🤔线程池中的线程出现异常，get方法这里会报异常，如果是throws，异常抛出到外面，线程池里的其他线程不受影响。外面的方法如果没有catch会中断。</p>
<p>🤔那么问题来了，get超时了的话，线程池中的线程还在继续做吗？<br>首先，countDownLatch超时了是继续做的。<br>future.get(2,TimeUnit.SECOND);<br>如果超时了，线程中断，会报异常TimeOutExcepTion，看是不是要捕获了。<br>即使捕获了，线程也不会继续执行了。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>场景：做多线程并行优化，多线程写入一个文件，首先输入流是可以共享的，只是需要重新定义一个做传递（不管是普通变量还是引用变量），但是for循环里面线程submit完，直接走到主线程上传文件的部分，这时线程池内线程还没往文件里写东西，上传了一个空文件。</p>
<p>想要：做一个同步，知道线程都执行完了，才进行下一步，起到阻塞的作用。</p>
<p>CountDownLatch可以做到，当做一个计数器，计算多少个线程执行完了：</p>
<p>让一些线程阻塞直到另外一些完成后才被唤醒。<br>CountDownLatch主要有两个方法：<br>（1）当一个或多个线程调用await方法时,线程会被阻塞，直到满足条件.<br>（2）其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/li1325169021/article/details/122353217">https://blog.csdn.net/li1325169021/article/details/122353217</a></p>
<p>实例：模拟公司所有员工都下班后，值班人员锁门离开公司。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void closeDoor() throws InterruptedException &#123;</span><br><span class="line">        //创建CountDownLatch,初始容量为10，模拟10名员工</span><br><span class="line">        CountDownLatch countDownLatch=new CountDownLatch(10);</span><br><span class="line">        for (int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;忙完工作，下班。&quot;);</span><br><span class="line">                //计数器减1</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,&quot;员工编号：&quot;+String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t值班人员锁门离开公司&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三步：</p>
<p>1、线程池外定义初始计数：<br>CountDownLatch countDownLatch=new CountDownLatch(10);<br>2、线程池内executorService.submit()的线程new Runnable(){@Overide public void run() {}} run方法内，线程执行完毕后：<br>countDownLatch.countDown();<br>3、最后要进行操作前：<br>countDownLatch.await();</p>
<p>✅countDownLatch超时终止：<br><code>latch.await(10, TimeUnit.SECONDS);  //等待10秒后，如果线程没有执行完，则不再等待，进入后续</code></p>
<p>超时后，线程依然会执行，不会中断。</p>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>1、public interface ScheduledExecutorService extends ExecutorService 延迟或定期执行任务。 </p>
<p>2、schedule 方法使用各种延迟创建任务，并返回一个可用于取消或检查执行的任务对象</p>
<p>3、scheduleAtFixedRate 和 scheduleWithFixedDelay 方法创建并执行某些在取消前一直定期运行的任务</p>
<p>4、所有的 schedule 方法都接受相对延迟和周期作为参数，而不是绝对的时间或日期</p>
<p>5、SheduleExecutorService 是JDK 1.5出来的，比以前的 Timer 性能好</p>
<p>Timer用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    TimerTask task = new TimerTask() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Task performed on: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;later: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer timer = new Timer(&quot;Timer&quot;);</span><br><span class="line"></span><br><span class="line">    long delay = 100L;</span><br><span class="line">    // 第一个参数是TimeTask对象，第二个参数是延迟（只有第二个参数时执行一次），第三个参数是周期执行的周期</span><br><span class="line">    timer.schedule(task, delay, 4000);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timer中，如果任务执行时间&gt;周期，则会等待上一个任务执行完，立马执行第二个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test5() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; run : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果任务执行时间&gt;周期，则会等上一个执行完立马执行下一个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test6() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; go : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与scheduleAtFixedRate：不同的是：这个是等上一个执行完，delay多长时间后，再执行下一个。</p>
<p>✅ScheduledExecutorService对象的创建方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(3);</span><br><span class="line">创建一个线程池，它可安排在给定延迟后运行任务或者定期地执行任务。</span><br><span class="line">corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内。</span><br><span class="line">运行发现有多个线程执行，但是效果一样。</span><br><span class="line"></span><br><span class="line">可以传参ThreadFactory，用来命名和设置守护线程</span><br><span class="line">ScheduledExecutorService executorService2 = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">    Thread t = new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    t.setDaemon(true); //设置为守护线程</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行任务。</span><br><span class="line">可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </span><br><span class="line">同样这是一个无界的任务队列，即虽然线程只有一个，但是新增的任务会在队列中排队等待执行</span><br><span class="line"></span><br><span class="line">3、用ScheduledExecutorService 的实现类 ScheduledThreadPoolExecutor（推荐）</span><br><span class="line">ScheduledExecutorService executorService1 = new ScheduledThreadPoolExecutor(1);</span><br></pre></td></tr></table></figure>

<p>✅规范创建：<br>要使用带有ThreadFactory参数的ScheduledThreadPoolExecutor构造方法创建，这样可以方便设置线程名字。方便出措时回溯。并且提供自定义的ThreadFactory实现或三方实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService3 = new ScheduledThreadPoolExecutor(1, new ThreadFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService executorService4 = new ScheduledThreadPoolExecutor(1,</span><br><span class="line">    new BasicThreadFactory.Builder().namingPattern(&quot;myThread&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure>


<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>用来创建线程的，其中也只是有一个newthread方法。</p>
<p>作用：<br>给线程命名，查看创建线程数<br>给线程设置是否是后台运行<br>设置线程优先级</p>
<p>自定义ThreadFactory：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.factory;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadFactory;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class MyThreadFactory implements ThreadFactory&#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    private boolean isDaemon;</span><br><span class="line"></span><br><span class="line">    public MyThreadFactory(boolean isDaemon)&#123;</span><br><span class="line">        this.isDaemon = isDaemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">        Thread thread =  new MyWorkThread(atomicInteger,r);</span><br><span class="line">        thread.setDaemon(isDaemon);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(new MyThreadFactory(false));</span><br><span class="line">        for (int i=0;i&lt;1000;i++)&#123;</span><br><span class="line">            executorService.execute(new TestRunnable(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private String msg;</span><br><span class="line"></span><br><span class="line">        public TestRunnable(String msg)&#123;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;runnable:&quot;+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅三种创建 ThreadFactory 的方式</p>
<p>第一种 CustomizableThreadFactory<br>Spring 框架提供的 CustomizableThreadFactory。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory springThreadFactory = new CustomizableThreadFactory(&quot;springThread-pool-&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种 ThreadFactoryBuilder<br>Google guava 工具类 提供的 ThreadFactoryBuilder ,使用链式方法创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory guavaThreadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;retryClient-pool-&quot;).build();</span><br><span class="line">//-pool-后面加%d ？</span><br></pre></td></tr></table></figure>

<p>第三种 BasicThreadFactory<br>Apache commons-lang3 提供的 BasicThreadFactory.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory basicThreadFactory = new BasicThreadFactory.Builder().namingPattern(&quot;basicThreadFactory-&quot;).build();</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010648555/article/details/106137206/">https://blog.csdn.net/u010648555/article/details/106137206/</a></p>
<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><p>进程：操作系统结构的基础、操作系统进行资源分配和调度的独立单元<br>线程：进程中独立运行的子任务，程序执行的单元。<br>例如：启动jvm相当于起了一个进程，jvm内：main方法、垃圾回收等相当于多个线程。<br>cpu是运算和控制的中心，在cpu的运行过程中，同一时刻只能执行一个进程。<br>多线程下，cpu在不同的线程之间进行切换，多线程不一定比单线程快。<br>多线程执行时，执行顺序是随机的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);  //休息1s，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">新建Thread线程：</span><br><span class="line">Thread thread = new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;, &quot;name&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h4 id="start、run、join方法"><a href="#start、run、join方法" class="headerlink" title="start、run、join方法"></a>start、run、join方法</h4><p>start： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 </p>
<p>run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>
<p>join方法在线程外使用，表示等待thread线程执行完毕，再继续执行当前join方法所在的线程。在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<p>✅多线程累加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 线程安全的累加</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">/**</span><br><span class="line">    * 创建线程</span><br><span class="line">    */</span><br><span class="line">class CreateThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private final Object lock = new Object(); //使用一个Java对象作为一个锁</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (num &lt;= 100) &#123;</span><br><span class="line">                    System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot;  num: &quot; + num );</span><br><span class="line">                    num++;</span><br><span class="line">                    lock.notifyAll(); //不加也一样</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必须共用一个Runnable</span><br><span class="line">CreateThread myThread1 = new CreateThread();</span><br><span class="line">Thread thread1 = new Thread(myThread1, &quot;thread1&quot;);</span><br><span class="line">Thread thread2 = new Thread(myThread1, &quot;thread2&quot;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程休眠等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws InterruptedException &#123;</span><br><span class="line">    // 线程类还必须放前面</span><br><span class="line">    class CreateThread1 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程执行&quot;);</span><br><span class="line">            Thread.yield(); //线程让步</span><br><span class="line">            System.out.println(&quot;继续执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread thread1 = new Thread(new CreateThread1(), &quot;thread1&quot;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();  //插队执行</span><br><span class="line">    System.out.println(&quot;main线程&quot;);</span><br><span class="line">    Thread.sleep(1000 * 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>单测方法有一个问题，当单测方法结束的时候，里面的线程也要结束，不管是不是执行完成。单测方法结束的时候会把里面的资源释放掉，导致里面的线程提前结束。<br>结论：尽量不要在test中开启线程，开启的话，sleep一下，等线程执行完。</p>
<p>但是在main方法中，main方法执行完以后子线程并不会退出，因为子线程是非守护线程。</p>
<p>首先，JVM程序在什么情况下能够正常退出<br>The Java Virtual Machine exits when the only threads running are all daemon threads.<br>当JVM中不存在任何一个正在运行的非守护线程时，则JVM进程即会退出。<br>main线程是一个非守护线程。只剩下守护线程，就会退出。</p>
<p>什么是守护线程？<br>在Java中有两类线程：</p>
<ul>
<li>User Thread(用户线程)</li>
<li>Daemon Thread(守护线程)</li>
</ul>
<p>JVM中的垃圾回收就是典型的守护线程，当JVM要退出时，如果垃圾回收线程还在运行，导致程序无法退出。这就很尴尬了。守护线程主要是为了给其他的线程提供服务，比如说计时器，清空高速缓存等等操作。当被守护线程死亡，守护线程往往也会死亡，当虚拟机中只剩下守护线程时，虚拟机就会退出，因为此时也没有运行程序的必要了</p>
<p>守护线程经常被用来执行一些后台任务，如果你希望JVM退出时，线程能够正常退出，守护线程是你的首选。<br>守护线程应该永远不去访问固有资源，比如说文件或者数据库，因为它会在任何时候甚至一个操作的中间发生中断。</p>
<h3 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h3><p>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<p>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。</p>
<p>在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</p>
<p>synchronized的作用主要有三个：</p>
<p>原子性：确保线程互斥地访问同步代码；<br>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；<br>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53474063/article/details/112389756">https://blog.csdn.net/m0_53474063/article/details/112389756</a></p>
<p>✅wait方法、notify方法、notifyAll方法</p>
<p>等待池：<br>假设线程 A 调用了锁对象的 wait() 方法，则 A线程就会释放该对象的锁(因为 wait() 方法必须出现在 synchronized 中，所以在执行 wait() 方法之前 A线程就已经拥有了该对象的锁)，同时线程 A进入到了该对象的等待池中。如果有其它线程调用了相同对象的 notifyAll() 方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，重新争夺锁的拥有权。如果另外的一个线程调用了相同对象的 notify() 方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。</p>
<p>锁池：<br>假设线程 A已经拥有了锁，而其它的线程想要调用该对象的 synchronized 方法(或者 synchronized 块)，其他未获得锁的线程在进入对象的 synchronized 方法之前都需要先获得该对象的锁的拥有权，但是该对象的锁目前正被 A线程拥有，所以这些线程就进入了该对象的锁池中。</p>
<h3 id="leeco-按序打印"><a href="#leeco-按序打印" class="headerlink" title="leeco 按序打印"></a>leeco 按序打印</h3><p>三个不同的线程 A、B、C，调用同一个类的三个不同的方法，想要异步调用三个线程，但是实现线程调用类中方法的同步输出。实现异步转同步的操作。<br>线程内run方法里面负责打印。<br>比如先调用second，再调用first，输出的是first-second。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object(); //得定义，不然是null</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 1) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 2) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printSecond.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 3) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            printThird.run();</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leeco-交替打印FooBar"><a href="#leeco-交替打印FooBar" class="headerlink" title="leeco 交替打印FooBar"></a>leeco 交替打印FooBar</h3><p>两个不同的线程将会共用一个 FooBar实例，分别调用两个打印方法，保证线程是交替打印的。<br>需要加循环，循环里面再抢锁。如果不加循环，wait之后进入等待池，其他线程notifyAll，只是告诉其他线程可以抢锁，并不是唤醒其他线程让他们开始抢锁。抢锁这个动作还是需要自己触发的。<br>如果把循环加在synchronized里面就不对了，没有主动触发抢锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    public FooBar(int n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void foo(Runnable printFoo) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 1) &#123; //不需要while，if就行</span><br><span class="line">                //表示的是拿错锁了，释放掉</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    //wait进入锁池，再进来就是重新获锁进来了</span><br><span class="line">                &#125;</span><br><span class="line">                //锁拿对了，就进行处理</span><br><span class="line">                printFoo.run();</span><br><span class="line">                index =2;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void bar(Runnable printBar) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 2) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                index =1;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="synchronized的对象锁和类锁"><a href="#synchronized的对象锁和类锁" class="headerlink" title="synchronized的对象锁和类锁"></a>synchronized的对象锁和类锁</h3><p>上面的两个leeco例子中，因为是创建一个对象进行调用，多线程共享那个lock，所以lock不需要static，只需要对象锁。但是如果创建多个对象调用，就需要类锁了。（比如接口的方法要控制多个请求同步）</p>
<p>synchronized关键字可以用在方法和代码块上。这些方法或者代码块可以使静态的也可以是非静态的。</p>
<p>对象锁-一个对象一把锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁-一个类一把锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized static void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass&#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (DemoClass.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final static Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁：static synchronized 是要控制类的所有实例的并发访问，static synchronized是限制多线程中该类的所有实例同时访问jvm中该类所对应的代码块。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-22 23:44</span><br><span class="line"> **/</span><br><span class="line">public class SynchroObject extends Thread &#123;</span><br><span class="line">    private static volatile int n = 0;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            add();</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(5);</span><br><span class="line">                //测试多线程的private变量，发现多个线程对象的private变量是不同的</span><br><span class="line">                System.out.println(&quot;lock hashcode:&quot; + lock.hashCode());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果同步方法是static的，则多线程正确同步</span><br><span class="line">    //如果同步方法不是static的，则不是正确同步</span><br><span class="line">    private static synchronized void add() &#123;</span><br><span class="line">        n++;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread threads[] = new Thread[100];</span><br><span class="line">        for (int i = 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = new SynchroObject();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.join(); //等待该线程终止</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; n= &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：<br>1、synchronized(this){/<em>区块</em>/} 作用域是当前对象。被synchronized修饰符修饰的实例方法，跟整个方法体被一个synchronized(this) { … } 包围住，意思完全一样。</p>
<p>2、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法。</p>
<p>3、根据java语言的规定，你不能在构造方法上使用synchronized关键字，这是非法的并且会导致编译错误。</p>
<p>转自：synchronized的对象锁和类锁：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZenoLiang/p/14713160.html">https://www.cnblogs.com/ZenoLiang/p/14713160.html</a></p>
<p>✅多线程synchronized变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-06-27 09:15</span><br><span class="line"> **/</span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建并开启4个线程，模拟四个售票窗口</span><br><span class="line">        SaleThread saleThread = new SaleThread();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口1&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口2&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口3&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口4&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SaleThread implements Runnable&#123;</span><br><span class="line">    //大前提：票得是static的，除非创建线程共用一个SaleThread对象</span><br><span class="line">    //不共用Runnable对象的话，且票不是static的，则每个线程各自卖</span><br><span class="line">    private static Integer tickets = 100;  //多线程共享的变量</span><br><span class="line">    //定义任意一个对象，用作同步代码块的锁</span><br><span class="line">    //如果不是static变量，达不到同步效果</span><br><span class="line">    //如果是static变量，多线程对象共享该变量。正确同步。</span><br><span class="line">    //如果上面创建线程用的是同一个SaleThread对象，则不管是不是static的，都是正确同步的。</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                if(tickets&gt;0)&#123;</span><br><span class="line">                    int i = tickets;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        Thread.sleep(1);  //模拟售票耗时过程</span><br><span class="line">                    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果lock是static，则hashcode一样。tickets的hashcode一直在变</span><br><span class="line">                    System.out.println(lock.hashCode() + &quot;  &quot; + tickets.hashCode());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +&quot;正在发售第&quot;+tickets--+&quot;张票&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程共享变量问题"><a href="#多线程共享变量问题" class="headerlink" title="多线程共享变量问题"></a>多线程共享变量问题</h3><p>在并发编程的艺术中探讨了静态变量和成员变量的区别。<br>由static修饰的变量称为静态变量，其实质上就是一个全局变量。<br>本质是说静态变量是类所有对象共享，成员变量是对象专有。</p>
<p>这里探讨一下全局变量和局部变量的区别：</p>
<p>首先各种变量的分类：<br>变量分为全局变量（成员变量）和局部变量，全局变量又分为静态变量和实例变量。<br>所以上边对静态变量和成员变量的区分，应该是静态变量</p>
<p>✅什么是静态变量：<br>1：为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。<br>2：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。<br>3：被static修饰后的值可以直接类名.值进行引用，而无需new一个对象进行调用<br>4：在JVM中，静态变量的加载顺序在对象之前，因此静态变量不依附于对象存在，可以在不实例化类的情况下直接使用静态变量</p>
<p>✅局部变量和全局变量（成员变量）：<br>在方法体中声明的变量叫做：局部变量。<br>在方法体外声明的变量叫做：成员变量。成员变量又可以分为：实例变量和静态变量。</p>
<p>全局变量和局部变量的区别:<br>1，作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等<br>2，内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区<br>3，生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了<br>4，使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。</p>
<p>✅多线程访问全局变量(成员变量)和局部变量：</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class HelloThreadTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        HelloThread r = new HelloThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(r);</span><br><span class="line">        Thread t2 = new Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloThread implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        //int i = 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Hello number: &quot; + i++);</span><br><span class="line"></span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep((long) Math.random() * 1000);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (50 == i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，i是成员变量，则HelloThread的对象r只包含这一个i，两个Thread对象因为由r构造，所以共享了同一个i。</p>
<p>如果i改为在run方法中定义，那么就是局部变量，由于局部变量对于每一个线程来说都有自己的拷贝，所以各个线程之间不再共享同一个变量。</p>
<p>总结：<br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。</p>
<p>如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
<p>转自：<a target="_blank" rel="noopener" href="http://t.zoukankan.com/xiaowenwu-p-5077639.html">http://t.zoukankan.com/xiaowenwu-p-5077639.html</a></p>
<p>⚠️这里所说的全局变量和局部变量，说的是线程对象内的，不是传入线程的是局部变量还是全局变量。猜测：不分传入的是全局变量还是局部变量，都是有拷贝的，因为传入的变量对线程来说是成员变量。</p>
<p>实验：一个ArrayList，对代码块儿来说是局部变量，传入线程中，只读list的hashcode，传入线程前和线程中的hashcode一样。</p>
<p>实验：ArrayList增加一个元素，hashCode会变，改变一个对象的某个属性，hashCode不变。</p>
<h3 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h3><p>成员变量：从上面的例子，如果使用一个Runnable对象创建多个线程，多个线程共享成员变量，多个线程对该变量进行操作是彼此影响的，是线程不安全的。也就是上面加了锁，达到了线程安全。</p>
<p>局部变量：每个线程都会有局部变量的拷贝，一个线程对局部变量的操作不会影响其他线程。（上面的i）</p>
<p>多线程之间就是因为数据共享在多个线程才导致了线程不安全，这就要求线程间的数据需要隔离，从根本上解决了线程安全问题。</p>
<p>因此ThreadLocal：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值(副本)。</p>
<p>✅例子：多个线程共用一个Runnable对象，内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:28</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        int local = 1;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">            local = (int) (Math.random() * 100D);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;threadLocal:&quot; +threadLocal.get());</span><br><span class="line">            System.out.println(&quot;local:&quot; +local);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">threadLocal:40</span><br><span class="line">threadLocal:32</span><br><span class="line">local:95</span><br><span class="line">local:95</span><br></pre></td></tr></table></figure>

<p>每个线程拥有自己的ThreadLocal变量，但是共享local变量。</p>
<p>✅例子：多个线程共同对一个对象进行操作，对象内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:55</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample2 &#123;</span><br><span class="line">    private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    int local = 1;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalExample2 demo = new ThreadLocalExample2();</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                demo.threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">                demo.local = (int) (Math.random() * 100D);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;threadLocal:&quot; +demo.threadLocal.get());</span><br><span class="line">                System.out.println(&quot;local:&quot; +demo.local);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(&quot;线程&quot; + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的效果。</p>
<p>多线程变量共享和隔离，ThreadLocal讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/JokerLJG/article/details/121284966">https://blog.csdn.net/JokerLJG/article/details/121284966</a></p>
<p>线程私有变量的另一个方法：多个对象构造方法传入不同的值：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43209615/article/details/124993090">https://blog.csdn.net/qq_43209615/article/details/124993090</a></p>
<p>SimpleDateFormat不是线程安全的解决：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38816924/article/details/122642680">https://blog.csdn.net/sinat_38816924/article/details/122642680</a></p>
<h3 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h3><p>Runnable是接口。Thread是实现了Runnable接口的类，并进行了扩展，而Thread和Runnable的实质是实现的关系，不是同类东西，所以Runnable或Thread本身没有可比性。</p>
<p>Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。<br>而Thread也是可以的，只不过是多个thread对象共享static变量，或者提交同一个Thread对象，并且static只是可见，还需要加同步才是线程安全的。</p>
<blockquote>
<p>这里只探讨共享变量的问题，想实现线程安全，要么加同步，要么volatile+原子性变量。</p>
</blockquote>
<p>还是卖票：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test3  extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private int ticket = 10;</span><br><span class="line"></span><br><span class="line">        public void run()&#123;</span><br><span class="line">            for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">                synchronized (this)&#123;</span><br><span class="line">                    if(this.ticket&gt;0)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(100);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+&quot;卖票----&gt;&quot;+(this.ticket--));</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] arg)&#123;</span><br><span class="line">            Test3 t1 = new Test3();</span><br><span class="line">            new Thread(t1,&quot;线程1&quot;).start();</span><br><span class="line">            new Thread(t1,&quot;线程2&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaojianting/article/details/97664370">https://blog.csdn.net/zhaojianting/article/details/97664370</a></p>
<h3 id="获取线程池中的线程？"><a href="#获取线程池中的线程？" class="headerlink" title="获取线程池中的线程？"></a>获取线程池中的线程？</h3><p>貌似无法获取线程。<br>但是可以获取线程池中活动的线程数：<br>ThreadPoolExecutor的getActiveCount方法。<br><code>public class ThreadPoolExecutor extends AbstractExecutorService &#123;</code><br><code>public abstract class AbstractExecutorService implements ExecutorService &#123;</code><br><code>public interface ExecutorService extends Executor &#123;</code></p>
<p>ExecutorService先转型一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">System.out.println(((ThreadPoolExecutor)executorService).getActiveCount());  //0</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolTaskExecutor"><a href="#ThreadPoolTaskExecutor" class="headerlink" title="ThreadPoolTaskExecutor"></a>ThreadPoolTaskExecutor</h3><p>ThreadPoolTaskExecutor是一个spring的线程池技术。ThreadPoolTaskExecutor是spring core包中的，而ThreadPoolExecutor是JDK中的JUC。ThreadPoolTaskExecutor是对ThreadPoolExecutor进行了封装处理。</p>
<p>Spring自带的线程池ThreadPoolTaskExecutor：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346086161">https://zhuanlan.zhihu.com/p/346086161</a></p>
<h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><p>Spring内置定时任务调度，主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意须要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay。</p>
<p>Spring内置定时任务调度@Scheduled使用详解：<br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/201373.htm">https://www.jb51.net/article/201373.htm</a></p>
<p>@Scheduled注解：<br><a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-otgzzukq-hc.html">http://www.javashuo.com/article/p-otgzzukq-hc.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/java/" class="post-title-link" itemprop="url">java常规</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 12:00:26" itemprop="dateCreated datePublished" datetime="2022-04-30T12:00:26+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-01 18:07:49" itemprop="dateModified" datetime="2023-05-01T18:07:49+08:00">2023-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>1、sql（dao层）返回的，尽量不要用VO，而使用DO。除非联表查询？dao层查出来的do需要加其他表的一两个字段，可以在原表do的基础上继承封装一下，如果要传入，可以直接输入子类，dao层处理时会自动解析为父类。</p>
<p>2、service里面不要调不想干的dao层方法，而是调dao所在service的方法。</p>
<p>3、继承自同一抽象类的类方法，需要对同一返回处理，并且是串行的，可以输入中用context。</p>
<p>4、main方法是静态方法，同一个类内的方法得加static，不然就是成员方法，成员方法无法在静态方法中调用。</p>
<p>5、运行时异常比如NPE，在方法里throw，不需要在方法上throw了，并且里面方法抛出的异常，可以在外面方法可以catch到。</p>
<p>6、写service什么时候写成类，什么时候写成接口？ 如果对外的话就写接口，如果内部代码用，就service类就行。</p>
<p>7、null不能用来做比较，会报NPE，例如：1 == null，不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer s1 = null;</span><br><span class="line">if(s1 == 1) System.out.println(&quot;不对&quot;);  //报NPE</span><br><span class="line">Integer s1 = 3;</span><br><span class="line">if(null == s1) System.out.println(&quot;对&quot;); //对的</span><br><span class="line">String s1 = null;</span><br><span class="line">if(s1 == &quot;a&quot;) System.out.println(&quot;对&quot;); //String不会NPE</span><br></pre></td></tr></table></figure>

<p>8、如果类报红，没有引用到，尝试更新下仓库：点idea右边maven，点左上角更新圈，更新一下。如果还不行，看一下maven的setting文件对不对。</p>
<p>9、if、while、for关键词的后面和括号之间要有空格，HashMap&lt;Integer, Integer&gt;和变量名之间要有空格。<br>方法名后面到入参的括号不需要空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public voif func(Integer i) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、不要在代码中，特别是主线程中随便Thread.sleep，这样会阻塞住线程。</p>
<p>11、方法返回如果是包装类型Double等，如果用double接，是接不住null的，会报空指针异常。</p>
<p>12、boolean这种类型，如果是一个对象的参数，初始化对象时，会给一个默认值false，但是单独初始化boolean类型，需要给值，不能boolean b;</p>
<p>13、配置可以写在一个接口里 XXXInstance，可以这么取名，直接加类型就行，不用public static。调用的时候就 XXXInstance.SSS。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>private：仅限类本身可见<br>default：类内部、包访问权限<br>protected：类内部、同一个包、子类中访问<br>public：类内部、同一个包、子类、任意位置都能访问</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>✅java: Compilation failed:</p>
<p>报错原因：<br>项目中Java版本不一致，可以查看项目中的jdk配置.<br>1、查看项目的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt;Project </p>
<p>2、查看工程的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt; Modules -&gt; （需要修改的工程名称） -&gt; Sources -&gt;</p>
<p>3、查看idea中Java配置<br>compile 的 java compile中。</p>
<p>✅空指针NPE</p>
<p>空指针(Null Pointer Exception，NPE)<br>空指针异常属于运行时的异常。当Java尝试去调用真实对象上的任何方法时，如果在运行时中，该对象调用的是空引用(Null Reference)，那么就会抛出异常。<br>由于种种原因，开发人员时常会忘记初始化对象和验证对象。这往往是导致空指针异常的根源。<br>例如：对一个为null的对象调用get/set方法，就会NPE。</p>
<p>🤔Optional避免空指针<br>java.util.Optional 是java8中引进的一个新的类，它可以对可能缺失的值进行建模，而不是直接将null赋值给变量。</p>
<p>java引入空指针的危害：<br>1、它是很多问题的错误之源，它是目前开发中最典型的异常。<br>2、它会使代码膨胀，它会使我们的代码充满了深度嵌套的null检查，代码的可读性下降。<br>3、它自身是毫无意义的，null自身没有任何的语义，它表示以一种错误的方式对缺失变量的值建模。<br>4、它破坏了java的哲学，java一直避免引入指针的存在，而唯一的例外就是null指针。<br>5、它破坏了java的类型，null不属于任何类型，这也意味着它可以被赋值给任意引用类型的变量，我们将无法获取这个null值最初的类型是什么。<br>而Optional的出现可以让我们最大程度上规避上述问题。</p>
<p>Optional的使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/aaaPostcard/article/details/123596787">https://blog.csdn.net/aaaPostcard/article/details/123596787</a><br>（感觉只能避免对自己定义的domain产生空指针异常，无法避免从数据库中获取到null，然后操作造成NPE。）</p>
<p>✅ IllegalStateException:Failed to load ApplicationContext</p>
<p>加载类出问题，往下看是哪个类没加载，获取bean出现问题，看是不是当作对象调用了，但是没加@Service。</p>
<p>✅ for循环内通过new来修改引用变量导致的问题</p>
<p>for循环中声明的变量是局部变量，List中存着对象的引用变量，也就是对象在堆中的地址。for循环中通过set方法来改变堆中的变量，没问题，引用变量并不会改变。</p>
<p>但是，for循环中通过new一个新对象来赋值给局部变量，新对象是在堆中创建了，对象地址赋给局部变量，但是List中的值并没有改变。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test10() &#123;</span><br><span class="line">    A a = new A(&quot;lll&quot;);</span><br><span class="line">    List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">    List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">    list2.addAll(list1);</span><br><span class="line">    System.out.println(list2); //[A(name=lll)]</span><br><span class="line">    a.setName(&quot;www&quot;);</span><br><span class="line">    System.out.println(list1); //[A(name=www)]</span><br><span class="line">    System.out.println(list2); //[A(name=www)]</span><br><span class="line"></span><br><span class="line">    for (A u : list2) &#123;</span><br><span class="line">        u.setName(&quot;bbb&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1642360923</span><br><span class="line">        A u1 = new A(&quot;aaa&quot;);</span><br><span class="line">        u = u1;</span><br><span class="line">        u.setName(&quot;aaa&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1343441044</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list2); //[A(name=bbb)]</span><br><span class="line">    System.out.println(list2.get(0).hashCode()); //1642360923</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">class A &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Void-与-void-与-null"><a href="#Void-与-void-与-null" class="headerlink" title="Void 与 void 与 null"></a>Void 与 void 与 null</h3><p>void 是一种基本数据类型。而 Void 是 void 封装类型。<br>Void 之于 void 类似于 Integer 之于 int。但并非如此，Void 比较特别：<br>它不可实例化<br>它没有内置的类型实例，也没有可用的字面值。</p>
<p>声明一个 Void 变量通常是没有什么意义的，因为没有可为其赋值的实例。Void 变量唯一能持有的是 null。Void 一个可用的地方是反射判断方法的返回值时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(m.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">	// 处理返回值为 void 的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也不是必需使用Void.TYPE，也可以用void.class。<br>总结来说，几乎很少会用到 Void 。</p>
<p>null是所有引用类型的默认值，但是要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。</p>
<p>访问一个类里的方法，如果用null赋予的对象访问普通方法，会NullPointerException，而访问static方法，没事，因为访问静态方法不需要实例对象。因此，静态方法的访问，不建议用实例调用，用类调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main m = (Main) null;</span><br><span class="line">System.out.println(m instanceof Main); //返回false</span><br><span class="line">System.out.println(m.getClass()); //空指针</span><br></pre></td></tr></table></figure>

<p>void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        return; //返回void，return可写可不写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void do2() &#123;</span><br><span class="line">        return null; //此处必须返回null 返回其余类型都不好使</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Void.class); //class java.lang.Void</span><br><span class="line">        System.out.println(void.class); //void</span><br><span class="line">        //类似于下面的</span><br><span class="line">        System.out.println(Integer.class); //class java.lang.Integer</span><br><span class="line">        System.out.println(int.class); //int</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void我们到底有什么用呢？其实在泛型出现之前，Void一般用于反射之中。判断方法返回是否为void。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">  public void print(String v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    for(Method method : Test.class.getMethods()) &#123;</span><br><span class="line">      //判断返回值类型 用到了Void类</span><br><span class="line">      if(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有有的时候，并不需要返回值的抽像性设计，比如下面设计的分布式锁：RedisLock.</p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0">https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0</a></p>
<h3 id="Java中包装类型和基本类型的使用场景"><a href="#Java中包装类型和基本类型的使用场景" class="headerlink" title="Java中包装类型和基本类型的使用场景"></a>Java中包装类型和基本类型的使用场景</h3><p>最简单的理解，基本类型有默认值，而包装类型初始为null。然后再根据这两个特性进行分业务使用，在阿里巴巴的规范里所有的POJO类必须使用包装类型，而在本地变量推荐使用基本类型。定义方法的输入输出参数用包装类型。List里用包装类型(,因为List中的泛型必须是引用类型。)，for循环里用包装类型。</p>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>1、整数：包括int、short、byte、long初始值为0。<br>2、浮点型：float、double初始值为0.0<br>3、字符：char初始值为空格，即’’ “，如果输出，在Console上是看不到效果的。<br>4、布尔：boolean初始值为false </p>
<p>基本类型的包装类<br>Integer 、Long、Short、Byte、Character、Double、Float、Boolean、BigInteger、BigDecimal<br>其中BigInteger、BigDecimal没有相对应的基本类型，主要应用于高精度的运算，BigInteger 支持任意精度的整数，<br>BigDecimal支持任意精度带小数点的运算。</p>
<p>基本类型与包装类型的异同：<br>1、在Java中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型则需new关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值，保存在堆栈中能高效的存取；封装类型需要通过引用指向实例，具体的实例保存在堆中；<br>4、初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。<br>6、什么时候该用包装类，什么时候该用基本类型，看基本的业务来定：这个字段允不允许null值，如果允许，则必然要用封装类；否则，基本类型就可以了。如果用到比如泛型和反射调用函数，就需要用包装类！ </p>
<p>转自 <a target="_blank" rel="noopener" href="http://t.zoukankan.com/east7-p-9887722.html">http://t.zoukankan.com/east7-p-9887722.html</a></p>
<h4 id="parseDouble-和valueOf-方法，类型转换"><a href="#parseDouble-和valueOf-方法，类型转换" class="headerlink" title="parseDouble()和valueOf()方法，类型转换"></a>parseDouble()和valueOf()方法，类型转换</h4><p>✅Double类parseDouble()和valueOf()方法的区别（String转Double）</p>
<p>1、Double.parseDouble(java.lang.String)的参数只能是String。Double.valueOf()的参数类型可以是浮点型或者是字符串均可。</p>
<p>2、Double.parseDouble(java.lang.String)把数字类型的字符串转换成double类型，返回是double类型。入参是String。<br>Double.valueOf()方把数字类型的字符串转换成Double类型，返回是Double类型。入参是String或double。</p>
<p>这两个方法里面都不能是Object类型，得先o.toString转为String，再变Double。注意空指针。</p>
<p>✅Double转String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = Double.toString(1.1);  //里面可以是double也可以是Double,为null会NPE</span><br><span class="line"></span><br><span class="line">Double d = 1.1;</span><br><span class="line">String s1 = d.toString();  //Object的toString方法double类型不能用,d为null会NPE</span><br><span class="line"></span><br><span class="line">double d1 = 1.2;</span><br><span class="line">String s1 = String.valueOf(d);  //里面可以是double也可以是Double,可以是null，nul的话输出“null”</span><br></pre></td></tr></table></figure>

<p>✅强制类型转换<br>首先，每个包装类型都有一个valueOf方法，用来把其他类型转换为自己类型。例如：Double d = Double.valueOf(“1”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    System.out.println((double) 1 / 1000); //输出0.001</span><br><span class="line">    System.out.println((double) (1 / 1000)); //输出0.0</span><br><span class="line">    Integer integer = 1;</span><br><span class="line">    System.out.println((double) integer / 1000); //输出0.001</span><br><span class="line"></span><br><span class="line">    //向上取整</span><br><span class="line">    double d = Math.ceil(2.3);</span><br><span class="line">    Integer i = (int) d;</span><br><span class="line">    System.out.println(i); //输出3</span><br><span class="line"></span><br><span class="line">    int x = 1, y = 2;</span><br><span class="line">    double z = x / y; //waring:&#x27;x / y&#x27;: integer division in floating-point context （意思是说这是浮点数的除法）</span><br><span class="line">    System.out.println(z);  //0.0</span><br><span class="line">    double w = 1.0 * x / y;</span><br><span class="line">    System.out.println(w);  //0.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="String-valueOf-1L-和-l-toString"><a href="#String-valueOf-1L-和-l-toString" class="headerlink" title="String.valueOf(1L)和 l.toString"></a>String.valueOf(1L)和 l.toString</h4><p>String.valueOf 入参是Object。<br>String.valueOf 如果传入null，返回是“null”字符串，而不是空null。<br>null.toString() 会报空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Long l = new Long(1L);</span><br><span class="line">String s1 = String.valueOf(l);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">String s2 = l.toString();</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">l = null;</span><br><span class="line">String s3 = String.valueOf(l);</span><br><span class="line">System.out.println(s3);  //null</span><br><span class="line">String s4 = l.toString(); //NullPointerException</span><br><span class="line">System.out.println(s4);</span><br></pre></td></tr></table></figure>

<h4 id="判断小数精确度"><a href="#判断小数精确度" class="headerlink" title="判断小数精确度"></a>判断小数精确度</h4><p>实现思路：用String的split方法，得到小数点后的String，再看大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (&quot;1231312.12&quot;.split(&quot;\\.&quot;)[1].length()==2) &#123;</span><br><span class="line">    System.out.println(&quot;是两位小数&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较两个double的大小"><a href="#比较两个double的大小" class="headerlink" title="比较两个double的大小"></a>比较两个double的大小</h4><p>1.用bigdecimal，传入string类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bdL = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">BigDecimal bdR = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">if (bdL.compareTo(bdR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (bdL.compareTo(bdR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>2.使用Double</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Double dL = 1.33;</span><br><span class="line">Double dR = 1.33;</span><br><span class="line">if (dL.compareTo(dR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (dL.compareTo(dR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>3.在误差范围内允许相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 两实数的差在允许的范围内认为相等既可认为是相等的</span><br><span class="line">Double num1 = 1.222;</span><br><span class="line">Double num2 = 1.222;</span><br><span class="line">if (num1 - num2 &gt; 0.000001)</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br><span class="line">else if (num1 - num2 &lt; -0.0000001)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br></pre></td></tr></table></figure>

<p>4.转换成字符串</p>
<p>可以将double数据转换成string然后借助string的compareTo方法来间接实现比较两个double数据是否相等。注意这种方法只适用于比较精度相同的数据，并且是只能用于比较正数的大小，负数比较结果异常，不过可以用于比较两数是否相等，此时正负数对结果没有影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String strL = String.valueOf(num1);</span><br><span class="line">String strR = String.valueOf(num2);</span><br><span class="line">if (strL.compareTo(strR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (strL.compareTo(strR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>5.使用doubleToLongBits()方法</p>
<p>使用sun提供的Double.doubleToLongBits()方法，该方法可以将double转换成long型数据，从而可以使double按照long的方法（&lt;, &gt;, ==）判断是否大小和是否相等，但是，这种办法还是只能用于比较正数，负数结果异常，比较两数相等与否是没有问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用使用sun提供的Double.doubleToLongBits()方法</span><br><span class="line">long lL = Double.doubleToRawLongBits(num1);</span><br><span class="line">long lR = Double.doubleToRawLongBits(num2);</span><br><span class="line">System.out.println(lL + &quot;:&quot; + lR);</span><br><span class="line">if (lL &lt; lR)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (lL == lR)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_49217297/article/details/124969742">https://blog.csdn.net/qq_49217297/article/details/124969742</a></p>
<h4 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h4><p>1、使用java.math.BigDecimal，四舍五入的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Double value = 1.2355;</span><br><span class="line">BigDecimal bd = new BigDecimal(value);</span><br><span class="line">bd = bd.setScale(2, RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(bd.toString());</span><br><span class="line">System.out.println(bd.doubleValue());</span><br></pre></td></tr></table></figure>

<p>2、使用DecimalFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DecimalFormat df = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(df.format(value));</span><br></pre></td></tr></table></figure>

<p>3、使用NumberFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">//如果不这么做，那么当value的值是100.00的时候返回100</span><br><span class="line">nf.setMaximumFractionDigits(2);</span><br><span class="line">nf.setMinimumFractionDigits(2);</span><br><span class="line">nf.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">//如果想输出的格式用逗号隔开，可以设置成true</span><br><span class="line">nf.setGroupingUsed(false);</span><br><span class="line">System.out.println(nf.format(value));</span><br></pre></td></tr></table></figure>

<p>4、使用java.util.Formatter,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = new Formatter().format(&quot;%.2f&quot;, value).toString();</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>5、使用String.format来实现，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, value));</span><br></pre></td></tr></table></figure>

<p>六、通过运算，不是四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l =(long)(value*100) ;</span><br><span class="line">double d = l/100D;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<p>Java保留两位小数的几种写法总结：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2155412">https://cloud.tencent.com/developer/article/2155412</a></p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>使用场景：比较精确的数字的加减法、小数的四舍五入</p>
<p>首先，浮点数为什么不准确？<br>码农在程序里写的10进制小数，计算机内部无法用二进制的小数来精确的表达。<br>对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n）</p>
<p>试一试如何表达十进制的 0.2 吧。</p>
<p>0.01 = 1/4 = 0.25 ,太大</p>
<p>0.001 =1/8 = 0.125 , 又太小</p>
<p>0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了</p>
<p>0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了</p>
<p>0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大</p>
<p>0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错</p>
<p>0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875<br>已经很逼近了， 就这样吧。</p>
<p>这就是用二进制小数没法精确表达10进制小数的含义。<br>根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值</p>
<p>《Effective Java》在第48条推荐“使用BigDecimal来做精确运算”。</p>
<hr>
<p>float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场啦。</p>
<p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。</p>
<hr>
<h4 id="✅BigDecimal构造方法："><a href="#✅BigDecimal构造方法：" class="headerlink" title="✅BigDecimal构造方法："></a>✅BigDecimal构造方法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal(double val)    将double表示形式转换为BigDecimal *不建议使用</span><br><span class="line">public BigDecimal(int val)　　将int表示形式转换成BigDecimal</span><br><span class="line">public BigDecimal(long)    创建一个具有参数所指定长整数值的对象。 </span><br><span class="line">public BigDecimal(String val)　　将String表示形式转换成BigDecimal *推荐使用</span><br></pre></td></tr></table></figure>
<p>⚠️BigDecimal 不像Double一样可以直接=1.1。 BigDecimal需要new个对象，或者：BigDecimal.ZERO 表示0.0。</p>
<p>为什么不推荐使用Double入参？<br>BigDecimal bDouble = new BigDecimal(2.3);<br>最终输出的数是：2.29999999….</p>
<p>为什么会出现这种情况呢？</p>
<p>JDK的描述：<br>1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p>
<p>2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。</p>
<p>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bDouble1 = BigDecimal.valueOf(2.3); //方法不能传null</span><br><span class="line">BigDecimal bDouble2 = new BigDecimal(Double.toString(2.3));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅BigDecimal用法："><a href="#✅BigDecimal用法：" class="headerlink" title="✅BigDecimal用法："></a>✅BigDecimal用法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a + b =&quot; + a.add(b));</span><br><span class="line">        System.out.println(&quot;a - b =&quot; + a.subtract(b));</span><br><span class="line">        System.out.println(&quot;a * b =&quot; + a.multiply(b));</span><br><span class="line">        System.out.println(&quot;a / b =&quot; + a.divide(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>👋BigDecimal除法可能出现不能整除的情况，比如 4.5/1.3，这时会报错java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p>
<p>其实divide方法有可以传三个参数</p>
<p><code>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) </code><br>第一参数表示除数， 第二个参数表示小数点后保留位数，<br>第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ROUND_CEILING    //向正无穷方向舍入</span><br><span class="line">ROUND_DOWN    //向零方向舍入</span><br><span class="line">ROUND_FLOOR    //向负无穷方向舍入</span><br><span class="line">ROUND_HALF_DOWN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5</span><br><span class="line">ROUND_HALF_EVEN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><span class="line">ROUND_HALF_UP    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6</span><br><span class="line">ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式</span><br><span class="line">ROUND_UP    //向远离0的方向舍入</span><br><span class="line"></span><br><span class="line">四舍五入采用 ROUND_HALF_UP</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(&quot;1000&quot;);  </span><br><span class="line">BigDecimal b2 = new BigDecimal(&quot;100&quot;);  </span><br><span class="line">System.out.println(b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP).toString());</span><br><span class="line">输出：</span><br><span class="line">10.00,结果返回一个BigDecimal</span><br></pre></td></tr></table></figure>


<p>对BigDecimal进行截断和四舍五入可用setScale方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5635&quot;);</span><br><span class="line"></span><br><span class="line">        a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入</span><br><span class="line">        a = a.setScale(3, BigDecimal.ROUND_HALF_UP);    //这个也行</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Double d = a.doubleValue();  //转为double/Double类型</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal都是不主动变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line">        a.add(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);  //输出4.5. 加减乘除方法会返回一个新的BigDecimal对象，原来的a不变</span><br><span class="line">        a = a.add(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/YangJavaer/p/6056394.html">https://www.cnblogs.com/YangJavaer/p/6056394.html</a></p>
<hr>
<h4 id="✅BigDecimal比较"><a href="#✅BigDecimal比较" class="headerlink" title="✅BigDecimal比较"></a>✅BigDecimal比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int flag = bigdemical.compareTo(bigdemical1)。</span><br><span class="line"></span><br><span class="line">flag = -1，表示bigdemical小于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =0，表示bigdemical等于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =1，表示bigdemical大于bigdemical1。</span><br><span class="line"></span><br><span class="line">实际中直接跟0比较就可以了，别跟-1或者1比较。</span><br></pre></td></tr></table></figure>

<p>BigDecimal的equals方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a=BigDecimal.valueOf(1.0);</span><br><span class="line">BigDecimal b=BigDecimal.valueOf(1.000);</span><br><span class="line">System.out.println(a.equals(b));  //true</span><br><span class="line"></span><br><span class="line">BigDecimal c = new BigDecimal(&quot;10.00&quot;);</span><br><span class="line">BigDecimal d = new BigDecimal(&quot;10&quot;);</span><br><span class="line">BigDecimal e = new BigDecimal(10.00);</span><br><span class="line">System.out.println(c.equals(d));  //false</span><br><span class="line">System.out.println(c.equals(e));  //false</span><br><span class="line">// equals是比较内容，“1.0”和“1.000”不一样.</span><br><span class="line"></span><br><span class="line">//toPlainString再equals</span><br><span class="line">System.out.println(c.toPlainString().equals(d.toPlainString())); //false</span><br><span class="line">System.out.println(c.toPlainString().equals(e.toPlainString())); //false</span><br><span class="line"></span><br><span class="line">//longValue方式</span><br><span class="line">System.out.println(c.longValue() == d.longValue()); //true</span><br><span class="line">System.out.println(c.longValue() == e.longValue()); //true</span><br><span class="line"></span><br><span class="line">//compareTo</span><br><span class="line">System.out.println(c.compareTo(d) == 0); //true</span><br><span class="line">System.out.println(c.compareTo(e) == 0); //true</span><br><span class="line"></span><br><span class="line">BigDecimal f = new BigDecimal(&quot;10.100001&quot;);</span><br><span class="line">BigDecimal g = new BigDecimal(10.100001);</span><br><span class="line">System.out.println(f.compareTo(g) == 0); //false</span><br><span class="line">// 这是因为本身Double传参的构造就不准，看上面</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/bijian1013-2366549">https://www.iteye.com/blog/bijian1013-2366549</a></p>
<hr>
<h4 id="✅mysql的decimal"><a href="#✅mysql的decimal" class="headerlink" title="✅mysql的decimal"></a>✅mysql的decimal</h4><p>decimal:数字型，不存在精度损失，常用于银行帐目计算</p>
<p><code>distance decimal(10,1) not null default 0.0 comment &#39;距离&#39;</code></p>
<p>decimal(P,m)<br>P的取值范围是1–65，表示整数位数<br>M的取值是0–30.表示小数位<br>精度M最大为30，表示有30位小数。<br>decimal整数和小数位均不写 默认为decimal(10,0)<br>若小数位不写默认的小数位为0。</p>
<p>decimal(22,6）表示整数位16个小数位6个。</p>
<p>decimal 还可以存储超过bigint的整数位，最大存储65位的整数类型。<br>还可以存储对应位数的负数</p>
<p>例：decimal(2,1)，此时，插入数据“12.3”、“12”等会出现“数据溢出错误”的异常；插入“1.23”或“1.2345…”会自动四舍五入成“1.2”；插入“2”会自动补成“2.0”，以确保2位的有效长度，其中包含1位小数。<br>当用 int类型会有溢出时，可以用 decimal 类型进行处理，把结果可以用 convert 或是 cast 进行转换。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenpp666/article/details/124372731">https://blog.csdn.net/chenpp666/article/details/124372731</a></p>
<h3 id="java位运算"><a href="#java位运算" class="headerlink" title="java位运算"></a>java位运算</h3><p>1、左移( &lt;&lt; )  向左移动，低位补0<br>2、右移( &gt;&gt; )  向右移动，高位补0<br>3、无符号右移( &gt;&gt;&gt; )   正数右移，高位补0，负数右移，高位补1，当负数使用无符号右移时，用0进行补位(自然而然的，就由负数变成了正数了)<br>4、与( &amp; )  都为1，结果为1，否则为0<br>5、或( | )  一个是1，结果为1，否则为0<br>6、异或( ^ )  两个相反，结果为1，否则为0<br>7、非( ~ ) 一元操作符   取相反。</p>
<h3 id="Autowired接口还是现实类？"><a href="#Autowired接口还是现实类？" class="headerlink" title="Autowired接口还是现实类？"></a>Autowired接口还是现实类？</h3><p>答案：接口好</p>
<p>当实现类唯一时，表面上注入接口，其实注入实现类<br>当实现类多个时，通过@Service(“menuService1”)指定实现类</p>
<p>解析：<br>这个其实是创建了实现类的对象但引用了接口类型，<br>即 “InjectionDao injectionDao = new InjectionDaoImpl ()”, 是 Java 多态性（向上转型）的一种应用。<br>在实现类处加 @Repository 注解，意思就是 new InjectionDaoImpl (),</p>
<p>而在 InjectionServiceImpl 中定义属性 InjectionDAO injectionDAO 就是将 new 出来的这个 InjectionDaoImpl 对象向上转型为 InjectionDao 类型。</p>
<p>注意：<br>若一个接口被多个实现类，实现的时候，@Autowired，Spring 会按 byType 的方式寻找接口的实现类，将其注入。存在多个实现类，应该指定名字，可以通过 byName 注入的方式。可以使用 @Resource 或 @Qualifier 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//实现类1</span><br><span class="line">@Service(&quot;menuService1&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line">//实现类2</span><br><span class="line">@Service(&quot;menuService2&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService1实现类</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService1&quot;)</span><br><span class="line">private IMenuService menuService;</span><br><span class="line"></span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService2实现类  </span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService2&quot;)</span><br><span class="line">private IMenuService menuService;</span><br></pre></td></tr></table></figure>

<p>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/huangkechen/article/details/122475824">https://blog.csdn.net/huangkechen/article/details/122475824</a></p>
<p>总结：就是Java 多态性（向上转型）的一种应用，但是这样做的好处并没有说。<br>规矩：注入实现类时用@Resource（@Autowired应该也可以），接口单个实现类用@Autowired（@Resource应该也可以），接口多个实现类用@Autowired + @Qualifier(value=””) 或 @Resource(name=””)。</p>
<h3 id="Collection、Collections、CollectionUtils"><a href="#Collection、Collections、CollectionUtils" class="headerlink" title="Collection、Collections、CollectionUtils"></a>Collection、Collections、CollectionUtils</h3><p>Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Collection（单例集合  ） </span><br><span class="line">├-List（有序，可重复 ）  </span><br><span class="line">│  ├-LinkedList（查询速度慢，增删快）   </span><br><span class="line">│  ├-ArrayList（查询速度快，增删慢）  </span><br><span class="line">│  └-Vector（线程安全的，操作效率低 ）  </span><br><span class="line">│　    └-Stack   </span><br><span class="line">└-Set（无序，不可重复） </span><br><span class="line">      ├-HashSet（使用了哈希表存取）</span><br><span class="line">      │    └-LinkedHashSet</span><br><span class="line">      └-SortedSet</span><br><span class="line">               └-TreeSet（有序）</span><br><span class="line">Map（键值对）  </span><br><span class="line">├-Hashtable   </span><br><span class="line">├-HashMap   </span><br><span class="line">└-WeakHashMap</span><br></pre></td></tr></table></figure>
<p>set是在HashMap的基础上实现的，HashSet的存储方式是把HashMap中的Key作为Set的对应存储项。HashMap是非同步的，线程不安全的，Hashtable虽然是同步线程安全的，但是已经过期了。 现在使用ConcurrentHashMap，这个是线程安全同步的。</p>
<p>Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>例如：排序(Sort)、倒序(reverse)、最大(max)、最小(min)、替换(fill)</p>
<p>使用sort方法可以根据元素的自然顺序对指定列表按升序进行排列。列表中所有元素都必须实现Comparable接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);//排序</span><br><span class="line">System.out.println(list);</span><br><span class="line">Collections.reverse(list);//倒序</span><br><span class="line">System.out.println(list);</span><br><span class="line">int max = Collections.max(list);//最大</span><br><span class="line">System.out.println(max);</span><br><span class="line">int min = Collections.min(list);//最小</span><br><span class="line"></span><br><span class="line">Collections.emptyList()  //空list</span><br></pre></td></tr></table></figure>

<p>CollectionUtils是对Collection集合操作的类方法，这个类不是java自带的类方法，需要另外导入一个commons-collections.jar包才可以使用这个类中方法。</p>
<p>例如：CollectionUtils.isEmpty(list)<br>它可以处理null，但是list.isEmpty里面为null，会NPE。</p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chaoge321/article/details/83788667">https://blog.csdn.net/chaoge321/article/details/83788667</a></p>
<h3 id="list的一些操作"><a href="#list的一些操作" class="headerlink" title="list的一些操作"></a>list的一些操作</h3><h4 id="一、Lists-newArrayList-和-new-ArrayList-："><a href="#一、Lists-newArrayList-和-new-ArrayList-：" class="headerlink" title="一、Lists.newArrayList() 和 new ArrayList() ："></a>一、Lists.newArrayList() 和 new ArrayList() ：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">Lists和Maps是谷歌的两个工具类,</span><br><span class="line"></span><br><span class="line">Lists.newArrayList()其实和new ArrayList()几乎一模一样,</span><br><span class="line"></span><br><span class="line">唯一它帮你做的(其实是javac帮你做的),就是自动推导尖括号里的数据类型.</span><br><span class="line"></span><br><span class="line">在 Java 7 之后，都允许类型推断 - 在运行时没有区别。</span><br><span class="line"></span><br><span class="line">java8 的new ArrayList&lt;&gt;()的&lt;&gt;里面可以不写类型，java回帮你自动推导类型</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>同样，还有Sets：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; sets = Sets.newHashSet(&quot;ww&quot;); //可直接定义</span><br><span class="line">Set&lt;String&gt; sets = new HashSet&lt;&gt;(Lists.newArrayList(&quot;11&quot;,&quot;22&quot;));</span><br><span class="line">//还得用list转换</span><br><span class="line"></span><br><span class="line">set没有get(i)方法，遍历得用迭代器。要么先转换成list。</span><br><span class="line">set转换为list：</span><br><span class="line">ArrayList&lt;Long&gt; list = new ArrayList(set);</span><br></pre></td></tr></table></figure>

<p>新建List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(&quot;1&quot;, &quot;2&quot;); 不行</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list2.add(&quot;3&quot;);  //咩问题</span><br><span class="line">System.out.println(list2);</span><br><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list3.set(1, &quot;3&quot;); //设置除了0、1会报错</span><br><span class="line">System.out.println(list3);</span><br><span class="line">list3.add(&quot;3&quot;);  //报错：java.lang.UnsupportedOperationException</span><br><span class="line">System.out.println(list3);</span><br><span class="line">List&lt;String&gt; list4 = Collections.singletonList(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;); //报错：java.lang.UnsupportedOperationException</span><br><span class="line"></span><br><span class="line">String a[] = new String[] &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot; &#125;;</span><br><span class="line">List&lt;String&gt; list5 = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<p>✅Array.asList创建方式：<br>java.util.Arrays 类的 asList() 方法用于返回一个由指定数组支持的固定大小的列表。<br>Arrays.asList 最大特点是整个集合允许有多个元素存入数组，一旦初始化后，这个数组的长度就是固定的，但数组的元素可以修改，所以也就是为什么 add 和 remove 方法报错的原因。如果在开发中碰到长度可以确定的集合，并且在初始化时已经确定了储存元素的情况下，推荐使用。<br>Arrays.asList 中传入的数组参数中允许存在 null，但不允许只有一个 null</p>
<p>✅Collections.singletonList()创建方式：<br>Collection.singletonList 长度为 1，初始完后不可修改。根据这个特性，在开发的时候遇到只要储存一个元素的集合，并且整个过程存储或者传递为主，不会进行修改或调整的情况下，推荐使用。<br>Collections.singletonList 中保存元素的是一个对象</p>
<p>✅Arrays.asList() 和 Collections.singletonList()区别 ：<br>1、Arrays.asList()得到的List中元素是可变的，大小不可变。<br>而Collections.singletonList是不可变的，一旦修改就会导致UnsupportedOperationException异常抛出<br>2、Collections.singletonList()得到的List元素只能有1个<br>3、Arrays.asList(strArray)不具有add方法，可以通过set方法进行改变值。Collections.singletonList()返回的是不可变的集合，但是这个长度的集合只有1。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41606477/article/details/108449415">https://blog.csdn.net/weixin_41606477/article/details/108449415</a></p>
<p>新建Set，除了上面的，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; list4 = Collections.singleton(&quot;1&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="二、对list排序：Comparator-java工具类"><a href="#二、对list排序：Comparator-java工具类" class="headerlink" title="二、对list排序：Comparator-java工具类"></a>二、对list排序：Comparator-java工具类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(A::getB));</span><br><span class="line"></span><br><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序排序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序排序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序 属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序 属性二升序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));//先以属性一降序,再进行属性二升序</span><br><span class="line"></span><br><span class="line">//含Null数据排序,nullsLast空的放后面，距离Date类型属性</span><br><span class="line">list.stream().sorted(Comparator.comparing(item -&gt; item.属性, Comparator.nullsLast(Date::compareTo))).collect(Collectors.toList());</span><br><span class="line">// nullLast或nullFirst里面带类型，可以用Comparator.nullsLast(Comparator.naturalOrder()))</span><br><span class="line"></span><br><span class="line">//空/Null数据分组</span><br><span class="line">Map&lt;String, List&lt;类&gt;&gt; map = list.stream().collect(Collectors.groupingBy(item -&gt; &#123;</span><br><span class="line">  if (item.属性一 == null || item.属性一.equals(&quot;&quot;)) &#123;</span><br><span class="line">  　　return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return DateFormat.getDateInstance().format(item.属性一);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>list可以直接使用sort。<br>用sorted就需要先.stream()，再.collect(Collectors.toList())<br>::都得是get属性</p>
<p>自定义排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;list中元素&gt;()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(元素 o1, 元素 o2) &#123;</span><br><span class="line">    if(..)  return 1;  //表示o1在前</span><br><span class="line">    if(..)  return 0;  //表示一样</span><br><span class="line">    return -1；  //表示o2在前</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="三、list移除：-removeIf"><a href="#三、list移除：-removeIf" class="headerlink" title="三、list移除： removeIf"></a>三、list移除： removeIf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeIf() 方法用于删除所有满足特定条件的数组元素。</span><br><span class="line">ArrayList&lt;String&gt; sites = new ArrayList&lt;&gt;();</span><br><span class="line">sites.add(&quot;Taobao&quot;);</span><br><span class="line">sites.removeIf(e -&gt; e.contains(&quot;Tao&quot;));</span><br><span class="line">用了String的contains方法</span><br></pre></td></tr></table></figure>
<p>list元素可以先设置，再更改。</p>
<p>不能在循环中用正序索引进行移除，因为移除的过程中索引会变。<br>可以用倒序索引。<br>如果非得用循环移除，用迭代器。</p>
<p>for的下标倒序遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (&quot;b&quot;.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用list.stream().filter().collect()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; newList = list.stream()</span><br><span class="line">        .filter(e -&gt; !&quot;b&quot;.equals(e))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>用迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    if (&quot;b&quot;.equals(s)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🤔总结一下list移除方法：<br>1、removeIf<br>2、倒叙for循环<br>3、stream filter<br>4、迭代器</p>
<p>⚠️迭代器中，又移除，又对list增加元素是不行的，会引发并发错误。<br>map也是一样，用Entry遍历时，不能又remove又put，而且再循环里不能put新的，只能put已有的，不然会并发错误。也不能remove。用迭代器移除元素。</p>
<p>所以，替换List中的元素，用set方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">list.set(1, 4L);  //[1, 4, 3]</span><br></pre></td></tr></table></figure>

<p>【JAVA】List常用移除、过滤、去重、flatMap、peek等操作：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38397501/article/details/116494227">https://blog.csdn.net/qq_38397501/article/details/116494227</a></p>
<h4 id="四、判断list为空"><a href="#四、判断list为空" class="headerlink" title="四、判断list为空"></a>四、判断list为空</h4><p>if(CollectionUtils.isEmpty(list)){}</p>
<h4 id="五、indexOf方法"><a href="#五、indexOf方法" class="headerlink" title="五、indexOf方法"></a>五、indexOf方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indexOf() 方法返回动态数组中元素的索引值。</span><br><span class="line">int i = arraylist.indexOf(Object obj)</span><br></pre></td></tr></table></figure>

<h4 id="六、list、set、String转换"><a href="#六、list、set、String转换" class="headerlink" title="六、list、set、String转换"></a>六、list、set、String转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//list直接变set：</span><br><span class="line">Set&lt;Long&gt; set2 = new HashSet&lt;&gt;(list);</span><br><span class="line">Set&lt;Long&gt; set1 = Sets.newHashSet(list);</span><br><span class="line">//set变list：</span><br><span class="line">List&lt;Long&gt; list2 = new ArrayList&lt;&gt;(set1);</span><br><span class="line">List&lt;Long&gt; list3 = Lists.newArrayList(set1);</span><br></pre></td></tr></table></figure>

<p>,分割的String转换为List，看下面Splitter。</p>
<p>List转换为,分割字符串，看下面Joiner连接字符串。</p>
<h4 id="七、foreach"><a href="#七、foreach" class="headerlink" title="七、foreach"></a>七、foreach</h4><p>forEach() 方法用于遍历动态数组中每一个元素并执行特定操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testArray()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 往数组中添加元素</span><br><span class="line">    numbers.add(1);</span><br><span class="line">    numbers.add(2);</span><br><span class="line">    numbers.add(3);</span><br><span class="line">    numbers.add(4);</span><br><span class="line">    System.out.println(&quot;ArrayList: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">    // 将 lambda 表达式传递给 forEach</span><br><span class="line">    numbers.forEach((e) -&gt; &#123;</span><br><span class="line">        System.out.print(e + &quot; &quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach 增强for循环，用于遍历动态数组中每一个元素并执行特定操作。</p>
<p>List的forEach是在Iterable类中，<code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code>，stream的forEach在Stream中。</p>
<p>Iterable中的方法原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️使用中出现：提示Variable used in lambda expression should be final or effectively final</p>
<p>这句话的意思是：lambda表达式中使用的变量应该是final或者有效的final。</p>
<p>其实在 Java 8 之前：<br>匿名类中如果要访问局部变量的话，那个局部变量必须显式的声明为final。<br>lambda表达式是由匿名内部类演变过来的，他们的作用都是实现接口方法，于是类比匿名内部类，lambda表达式中使用的变量也需要是final类型。</p>
<p>所以：需要赋值到另一个变量中使用。并且为final类型，不是final类型也可以，变量名中加final。<br>因为：Java 8 之后，在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。</p>
<p>为什么 lambda 表达式或者匿名内部类不能访问非 final 的局部变量，为什么呢？</p>
<p>其实这就要说到Jvm内存模型和线程了，因为实例变量存在堆中，而局部变量是在栈上分配，<strong>lambda 表达(匿名内部类) 会在另一个线程中执行</strong>。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.liangzl.com/get-article-detail-213550.html">https://www.liangzl.com/get-article-detail-213550.html</a></p>
<p>所以这个问题的原因不在forEach，而是在lambda表达式。<br>java的lambda表达式里不能出现变量，必须是final修饰的，但是可以让变量在定义时候就写入，这样就不算变量了。可以使用lambda表达式，不再报错。（只定义一次不再改，如果是需要多步才能定义出变量，那就写个方法出结果也可以）</p>
<p>不行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean ebola = false;</span><br><span class="line">ebola = list.size()&gt;10;//赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boolean ebola = checkEbola(list);//相当于定义时直接赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean checkEbola(ArrayList&lt;Object&gt; list)&#123;</span><br><span class="line">  return list.size()&gt;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="八、List截取"><a href="#八、List截取" class="headerlink" title="八、List截取"></a>八、List截取</h4><p>List自己的suubList方法，传参数起始索引和终点索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">    System.out.println(list.subList(1, list.size()));</span><br><span class="line">    // 2,3</span><br><span class="line"></span><br><span class="line">    // 新建固定大小的List</span><br><span class="line">    List&lt;Long&gt; list1 = Lists.newArrayListWithExpectedSize(3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、数组转换为List"><a href="#九、数组转换为List" class="headerlink" title="九、数组转换为List"></a>九、数组转换为List</h4><p>原文：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/221887.htm">https://www.jb51.net/article/221887.htm</a></p>
<p>1、使用ArrayList.asList(strArray)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">List&lt;String&gt; ints = Arrays.asList(str);</span><br><span class="line">//这里会报错</span><br><span class="line">ints.add(&quot;laopo&quot;);</span><br></pre></td></tr></table></figure>
<p>使用Arrays工具类Arrays.asList(strArray)方式,转换完成后,只能对List数组进行查改,不能增删,增删就会抛出UnsupportedOperationException 异常。<br>报错原因:Arrays.asList(str)返回值是java.util.Arrays类中一个私有静态内部类 java.utiil.Arrays.Arraylist,并不是我们平时用的java.util.ArrayList();</p>
<p>⚠️：使用的asList()方法会返回一个final的,固定长度的ArrayList类，并不是java.util.ArrayList，直接这样利用它进行add()或remove()是无效的。</p>
<p>2、使用new ArrayList(Arrays.asList(strArray))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">java.util.ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">strings.add(&quot;aop&quot;);</span><br><span class="line">strings.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>通过ArrayList的构造器,将Arrays.asList(strArray)的返回值由java.utilArrays.ArrayList转为java.util.ArrayList.</p>
<p>3、集合工具类Collections.addAll()方法（用这个）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">java.util.ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(str.length);</span><br><span class="line">Collections.addAll(stringList,str);</span><br></pre></td></tr></table></figure>
<p>通过Collections.addAll(arrayList, strArray)方式转换，根据数组的长度创建一个长度相同的List，然后通过Collections.addAll()方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。</p>
<p>4、JDK8的Stream流将3总基本类型数组转为List</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long[] longs = &#123;1, 2, 3&#125;;</span><br><span class="line">double[] doubles = &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(longs).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(doubles).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如果JDK版本在1.8以上,使用流stream来将下列3种数组快速转为List,分别是int[],long[],double[],不支持short[ ],byte[ ],char[]在JDK1.8中暂不支持.</p>
<p>⚠️ 不能把基本数据类型转化为列表<br>asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int [] intarray = &#123; 1 ,  2 ,  3 ,  4 ,  5 &#125;;</span><br><span class="line">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span><br><span class="line">List&lt; int []&gt; list = Arrays.asList(intarray);  //输出一个int[]元素的list</span><br></pre></td></tr></table></figure>

<p>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] intArray = &#123; 1 ,  2 ,  3 ,  4 &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Ints.asList(intArray);</span><br></pre></td></tr></table></figure>

<p>为什么int[]不能直接转为List,而Integer[]可以转为List,而Integer[]就可以转为List了,因为List中的泛型必须是引用类型。？？？</p>
<p>⚠️asList方法返回的是数组的一个视图</p>
<p>视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。</p>
<h4 id="十、List转为数组"><a href="#十、List转为数组" class="headerlink" title="十、List转为数组"></a>十、List转为数组</h4><p>一般数组是不能添加元素的，因为他们在初始化时就已定好长度了，不能改变长度。</p>
<p>1、 list.toArray();</p>
<p>直接将 list 转换成 Object[] 类型的 数组；<br>Object ： 对象类，是所有类的父类</p>
<p><code>Object[]  ans1 = list.toArray();</code></p>
<p>2、list.toArray(T[] a);</p>
<p>输出指定类型的数组，输出的数组类型与括号中参数类型一致；<br>必须是包装类（String、Integer、Character等），不能是基本数据类型了（string、int、char）；<br>// 创建数组时： int [ ] arr = new int [ ] {}; 使用的是基本数据类型</p>
<p><code>Integer[] ans2 = list.toArray(new Integer[list.size()]);</code><br>注意：idea提示用空的：<br><code>Integer[] ans2 = list.toArray(new Integer[0]);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个list，并且对list赋值        </span><br><span class="line">List&lt;Integer&gt;  list = new ArrayList&lt;&gt;();       </span><br><span class="line">for (int i = 1; i &lt; 11; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//方法一：</span><br><span class="line">Object[]  ans1 = list.toArray();</span><br><span class="line">System.out.println(&quot;1:&quot; + Arrays.toString(ans1));</span><br><span class="line"> </span><br><span class="line">// 方法二：</span><br><span class="line">Integer[] ans2 = list.toArray(new Integer[list.size()]);</span><br><span class="line">System.out.println(&quot;2:&quot; + Arrays.toString(ans2));</span><br><span class="line"> </span><br><span class="line">1:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">2:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>


<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Gc_680/article/details/122568085">https://blog.csdn.net/Gc_680/article/details/122568085</a></p>
<h4 id="十、分割list"><a href="#十、分割list" class="headerlink" title="十、分割list"></a>十、分割list</h4><p>Lists的方法，com.google.guava中。</p>
<p>使用场景：list集合中数据量过大，可根据需要进行拆分，进而通过循环或者多线程来处理数据。<br>或者是list拆分后，分批插入数据库。<br>Lists.partition方法，根据传入的size，对list进行拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将集合list按照 2 个元素一份进行划分</span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 2);</span><br></pre></td></tr></table></figure>

<h4 id="十一、list根据对象中某一元素去重"><a href="#十一、list根据对象中某一元素去重" class="headerlink" title="十一、list根据对象中某一元素去重"></a>十一、list根据对象中某一元素去重</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-11 22:25</span><br><span class="line"> **/</span><br><span class="line">public class TestRemoveDup &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *     TreeSet的本质是一个&quot;有序的，并且没有重复元素&quot;的集合，它是通过TreeMap实现的。</span><br><span class="line">     *     TreeSet注意事项：</span><br><span class="line">     *     如果向TreeSet集合中添加元素的时候，元素本身没有具备自然顺序的特性，并且元素所属的类也没有</span><br><span class="line">     *     实现Comparable接口，那么必须在创建TreeSet对象的时候传入一个比较器；</span><br><span class="line">     */</span><br><span class="line">    //根据名字进行比较，相等时TreeSet会将该元素视为重复元素，不允许添加；</span><br><span class="line">    private List&lt;Person&gt; removeDupByName(List&lt;Person&gt; people) &#123;</span><br><span class="line">        Set&lt;Person&gt; personSet = new TreeSet&lt;&gt;(Comparator.comparing(Person::getName));</span><br><span class="line">        personSet.addAll(people);</span><br><span class="line">        return new ArrayList&lt;&gt;(personSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;Person&gt; removeDupByName2(List&lt;Person&gt; people) &#123;</span><br><span class="line">        List&lt;Person&gt; unique = people.stream().collect(</span><br><span class="line">                Collectors.collectingAndThen(</span><br><span class="line">                        Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Person::getName))), ArrayList::new)</span><br><span class="line">        );</span><br><span class="line">        return unique;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //filter的使用方式为： filter(item -&gt; item的逻辑判断 ) ，其中filter会保留判断条件为true的记录</span><br><span class="line">    private List&lt;Person&gt; removeDupByName3(List&lt;Person&gt; people) &#123;</span><br><span class="line">        //用一个name的list去重，没用TreeSet</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();//用来临时存储person的id</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = people.stream().filter(// 过滤去重</span><br><span class="line">                v -&gt; &#123;</span><br><span class="line">                    boolean flag = !names.contains(v.getName());</span><br><span class="line">                    names.add(v.getName());</span><br><span class="line">                    return flag;</span><br><span class="line">                &#125;</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        return personList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; people = new ArrayList&lt;&gt;();</span><br><span class="line">        Person p1 = new Person(&quot;Liu&quot;,30);</span><br><span class="line">        people.add(p1);</span><br><span class="line">        Person p2 = new Person(&quot;Mi&quot;,36);</span><br><span class="line">        people.add(p2);</span><br><span class="line">        Person p3 = new Person(&quot;Liu&quot;,31);</span><br><span class="line">        people.add(p3);</span><br><span class="line">        TestRemoveDup testRemoveDup = new TestRemoveDup();</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people1 = testRemoveDup.removeDupByName(people);</span><br><span class="line">        List&lt;Person&gt; people2 = testRemoveDup.removeDupByName2(people);</span><br><span class="line">        List&lt;Person&gt; people3 = testRemoveDup.removeDupByName3(people);</span><br><span class="line">        System.out.println(people1);</span><br><span class="line">        System.out.println(people2);</span><br><span class="line">        System.out.println(people3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    @ToString</span><br><span class="line">    @RequiredArgsConstructor</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private final String name;</span><br><span class="line">        private final Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的第三种，用filter方法，自定义一个方法，优雅一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unique = books.stream().filter(distinctByKey(o -&gt; o.getId())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter根据Predicate返回的布尔值来判断是否要过滤掉，</span><br><span class="line">会过滤掉返回值为false的数据。</span><br><span class="line">而我们自己定义的distinctByKey返回值就是Predicate，所以可以作为参数传入filter。</span><br><span class="line"></span><br><span class="line">distinctByKey也需要一个Function的参数。</span><br><span class="line">distinctByKey先是定义了一个线程安全的Map(相比于Hashtable以及Collections.synchronizedMap()，</span><br><span class="line">ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，</span><br><span class="line">但同时降低了对读一致性的要求)，因为在流计算中是多线程处理的，需要线程安全。</span><br><span class="line"></span><br><span class="line">然后将值作为key,TRUE作为value put到map中。</span><br><span class="line">这里的put方法使用的是putIfAbsent()。</span><br><span class="line">putIfAbsent()方法是如果key不存在则put如map中，并返回null。若key存在，则直接返回key所对应的value值。</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/zwh0910/p/15877284.html</span><br></pre></td></tr></table></figure>


<h4 id="十二、list-add和addAll的一个NPE问题"><a href="#十二、list-add和addAll的一个NPE问题" class="headerlink" title="十二、list.add和addAll的一个NPE问题"></a>十二、list.add和addAll的一个NPE问题</h4><p>背景：addAll遇到的一个空指针问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test7() &#123;</span><br><span class="line">    Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1L, 1L);</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">    System.out.println(map.get(2L)); //null</span><br><span class="line">    list.add(null); //没问题</span><br><span class="line">    //list.addAll(null); //会报空指针</span><br><span class="line">    //list.addAll(1L);  //addAll只能传Collection</span><br><span class="line"></span><br><span class="line">    list.add(1L);</span><br><span class="line">    list.add(3L);</span><br><span class="line">    list.add(1, 2L);</span><br><span class="line">    System.out.println(list);  //[null, 2, 1, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法是将元素可以插在指定的位置，如果参数只有一个的话就默认插在队列的尾部，而对于addAll方法，可以看其实作用差不多，但是参数必须为Collection 集合。</p>
<p>add方法参数为泛型E，所以他是支持任意类型的，但是这里要注意的一点是，如果你使用add方法并且传的参数为集合，那么其实 list集合会把这个参数中的集合当做一个整体，添加到原本的集合中。<br>而addAll方法，则会把参数里面的集合给分别放进原本的集合中。<br>(通过一个forEach 循环遍历后得到参数集合中的每个元素，在循环里面再分别调用add方法来实现这个功能)</p>
<p>⚠️addAll之后修改之前的list的元素：<br>修改是对新的list有效的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">a.setName(&quot;lll&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">list2.addAll(list1);</span><br><span class="line">System.out.println(list2); //[A(name=lll)]</span><br><span class="line">a.setName(&quot;www&quot;);</span><br><span class="line">System.out.println(list1); //[A(name=www)]</span><br><span class="line">System.out.println(list2); //[A(name=www)]</span><br></pre></td></tr></table></figure>

<h4 id="十三、list反转"><a href="#十三、list反转" class="headerlink" title="十三、list反转"></a>十三、list反转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.使用stream的sorted (这种方法只能用于普通类型)</span><br><span class="line">List&lt;Long&gt; li = Lists.newArrayList(1L, 2L);</span><br><span class="line">li = li.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line">System.out.println(li);</span><br><span class="line"></span><br><span class="line">2.使用Collections.reverse方法</span><br><span class="line">A a1 = new A(&quot;lll&quot;);</span><br><span class="line">A a2 = new A(&quot;hhh&quot;);</span><br><span class="line">List&lt;A&gt; list = Lists.newArrayList(a1, a2);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">3.保留原List进行反转</span><br><span class="line">List&lt;Integer&gt; listData = new ArrayList&lt;&gt;();</span><br><span class="line">listData.add(1);</span><br><span class="line">listData.add(2);</span><br><span class="line">List&lt;Integer&gt; tempData = Arrays.asList(new Integer[listData.size()]);</span><br><span class="line">Collections.copy(tempData, listData);</span><br><span class="line">Collections.reverse(listData);</span><br><span class="line">System.out.println(&quot;反转后原来:&quot; + tempData);</span><br><span class="line">System.out.println(&quot;反转后现在:&quot; + listData);</span><br></pre></td></tr></table></figure>

<h4 id="十四、list复制"><a href="#十四、list复制" class="headerlink" title="十四、list复制"></a>十四、list复制</h4><p>首先看一下初始化指定长度List的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(new Integer[10]);</span><br><span class="line">System.out.println(list.size());  //10</span><br><span class="line">System.out.println(list);  //都是null</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(10);</span><br><span class="line">System.out.println(list1.size());  //0</span><br><span class="line">System.out.println(list1);  //空[]</span><br></pre></td></tr></table></figure>

<p>list复制的几个方法：</p>
<p>1、copy一个List最简单方式就是使用构造器，这个构造器能接收一个集合参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(list);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.add(4);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.set(0, 5);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br></pre></td></tr></table></figure>
<p>对原来的list进行add，或者set修改某元素，不会影响到复制的。</p>
<p>但是由于使用这种方式的内部机制是：复制对象的引用而不是clone对象，所以对对象的每一个修改都将同时影响两个list。</p>
<p>正式由于上述的原因，使用构造器这种方法比较适用于那些不可改变对象在list间的复制。比如Integer、String…</p>
<p>2、addAll方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;();</span><br><span class="line">copy.addAll(list);</span><br></pre></td></tr></table></figure>
<p>和使用构造器一样，在使用这个方法时，两个list中的内容都将引用的是相同对象。</p>
<p>3、Collections.copy</p>
<p>Collections类提供了一些专门用于操作集合的静态方法。其中一个就是copy。Collections.copy(dest,source),这个方法接收两个参数，一个是source list 和一个dest list（dest list的长度应大于source list，不然会报错：IndexOutOfBoundsException）。</p>
<p>这个方法的特点是： 它将保持每一个被copy元素在目标集合中的下标和它们在源集合中的下标一样。  即： 源集合中下标为1的元素会被复制到目标集合的下标为1的位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; source = Arrays.asList(1,2,3);</span><br><span class="line">List&lt;Integer&gt; dest = Arrays.asList(4,5,6);</span><br><span class="line">Collections.copy(dest, source);</span><br><span class="line">System.out.println(dest);  //1 2 3</span><br><span class="line"></span><br><span class="line">A a1 = new A(&quot;111&quot;);</span><br><span class="line">A a2 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList(a1, a2);</span><br><span class="line">// List&lt;A&gt; list3 = new ArrayList&lt;&gt;(2); //这种初始化大小不行</span><br><span class="line">List&lt;A&gt; list3 = Lists.newArrayList(new A[2]);</span><br><span class="line">System.out.println(list3);  //[null, null]</span><br><span class="line">Collections.copy(list3, list2);</span><br><span class="line">System.out.println(list3);  //[ListTest.A(name=111), ListTest.A(name=222)]</span><br><span class="line">list2.get(0).setName(&quot;333&quot;);</span><br><span class="line">System.out.println(list3);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>注意：这种复制方法也是直接复制引用，而不是深拷贝对象，改变原来List的对象会影响复制的List。</p>
<p>4、使用Java8 stream</p>
<p>在Java8中，我们可以使用stream来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;A&gt; list4 = list2.stream().collect(Collectors.toList());</span><br><span class="line">list2.get(0).setName(&quot;444&quot;);</span><br><span class="line">System.out.println(list4);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>好处是可以用stream进行其他操作，但是还是浅拷贝。</p>
<p>5、对象深拷贝</p>
<p>首先，看下对象怎么深拷贝，重写Object的clone方法，并且需要实现Cloneable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">static</span><br><span class="line">class A implements Cloneable &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected A clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (A)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想要异常，就在clone方法里自己写set方法，新建对象返回。</p>
<p>对象的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a1 = new A(&quot;11&quot;);</span><br><span class="line">A a2 = a1;  //浅拷贝</span><br><span class="line">System.out.println(a2);</span><br><span class="line">System.out.println(a1 == a2);  //true</span><br><span class="line">A a3 = a1.clone();</span><br><span class="line">System.out.println(a1 == a3);  //false</span><br></pre></td></tr></table></figure>

<hr>
<p>Apache Commons Lang序列化 实现对象深拷贝</p>
<p>第一步、导入commons-lang3包</p>
<p>第二步、实体类实现Serializable接口</p>
<p>第三步、调用SerializationUtils工具类，实现深拷贝（注意：SerializationUtils不能直接拷贝List类型）<br><code>User user2 = SerializationUtils.clone(user1);</code></p>
<p>如果想拷贝List，需要新建一个实体类implements Serializable，然后将list变为其中属性，再用上面的操作深拷贝新建对象，再取其中的list。</p>
<p>或者用循环add深拷贝后的对象的方式实现list的深拷贝。</p>
<p>Java对象深拷贝详解（List深拷贝）:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42675423/article/details/128260074">https://blog.csdn.net/weixin_42675423/article/details/128260074</a></p>
<hr>
<p>6、json序列化实现list深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a4 = new A(&quot;111&quot;);</span><br><span class="line">A a5 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a4, a5);</span><br><span class="line">List&lt;A&gt; list2 = JSONObject.parseArray(JSONObject.toJSONString(list1), A.class); //深拷贝</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<h4 id="十五、list交集并集"><a href="#十五、list交集并集" class="headerlink" title="十五、list交集并集"></a>十五、list交集并集</h4><p>求两个list的交集</p>
<p>需要导入apache的包：commons-collections</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Lists.newArrayList(&quot;11&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;44&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">Collection&lt;String&gt; list3 = CollectionUtils.intersection(list1, list2);</span><br></pre></td></tr></table></figure>

<hr>
<p>从list1中移除存在list2中的元素（差集）：<code>list1.removeAll(list2)</code></p>
<p>调用流程：removeAll-&gt;contains-&gt;equals方法，对于引用类型，要使用removeAll，需要重写equals方法。<br>contains方法中，当对象o不为空时，迭代判断用到了Object的equals方法，而Object的equals方法指的是两个对象的引用是否相等，如果我们要判断两个对象的内容相等，这里就需要重写equals方法。</p>
<p>两个list的并集：<code>a.addAll(b);</code></p>
<p>两个list的交集：<code>a.retainAll(b);</code></p>
<p>要去重的：<code>List newList = b.stream().distinct().collect(Collectors.toList());</code></p>
<hr>
<p>lambda表达式取交集、并集、差集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list1.add(&quot;1&quot;);</span><br><span class="line">    list1.add(&quot;2&quot;);</span><br><span class="line">    list1.add(&quot;3&quot;);</span><br><span class="line">    list1.add(&quot;5&quot;);</span><br><span class="line">    list1.add(&quot;6&quot;);</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list2.add(&quot;2&quot;);</span><br><span class="line">    list2.add(&quot;3&quot;);</span><br><span class="line">    list2.add(&quot;7&quot;);</span><br><span class="line">    list2.add(&quot;8&quot;);</span><br><span class="line"> </span><br><span class="line">    // 交集</span><br><span class="line">    List&lt;String&gt; intersection = list1.stream().filter(item -&gt; list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---交集 intersection---&quot;);</span><br><span class="line">    intersection.parallelStream().forEach(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 差集 (list1 - list2)</span><br><span class="line">    List&lt;String&gt; reduce1 = list1.stream().filter(item -&gt; !list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---差集 reduce1 (list1 - list2)---&quot;);</span><br><span class="line">    reduce1.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">    // 并集</span><br><span class="line">    List&lt;String&gt; listAll = list1.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = list2.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(&quot;---并集 listAll---&quot;);</span><br><span class="line">    listAll.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 去重并集</span><br><span class="line">    List&lt;String&gt; listAllDistinct = listAll.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(&quot;---得到去重并集 listAllDistinct---&quot;);</span><br><span class="line">    listAllDistinct.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;---原来的List1---&quot;);</span><br><span class="line">    list1.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line">    System.out.println(&quot;---原来的List2---&quot;);</span><br><span class="line">    list2.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十六、获取List-lt-DO-gt-中最小的begin"><a href="#十六、获取List-lt-DO-gt-中最小的begin" class="headerlink" title="十六、获取List&lt;DO&gt;中最小的begin"></a>十六、获取<code>List&lt;DO&gt;</code>中最小的begin</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DO do = list.stream().min(Comparator.comparing(DO::getBegin)).orElse(null);</span><br><span class="line">if (do != null) &#123;</span><br><span class="line">    Date min = do.getBegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用下面Stream里的min，结合Optional。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Long&gt; minBegin = list.stream()</span><br><span class="line">    .map(DO::getBegin)</span><br><span class="line">    .min(Long::compareTo);</span><br><span class="line">if(minBegin.isPresent())&#123;</span><br><span class="line">    minBegin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的，是线程不安全的，允许元素为null的双向链表。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/162980143">https://zhuanlan.zhihu.com/p/162980143</a></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="✅移除"><a href="#✅移除" class="headerlink" title="✅移除"></a>✅移除</h4><p>移除Set集合中的指定对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">set.add(&quot;111&quot;);</span><br><span class="line">set.add(&quot;222&quot;);</span><br><span class="line">set.remove(&quot;111&quot;);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<h4 id="获取上一个下一个元素"><a href="#获取上一个下一个元素" class="headerlink" title="获取上一个下一个元素"></a>获取上一个下一个元素</h4><p>用迭代器的<code>previous()</code>方法和<code>next()</code>方法</p>
<h3 id="Comparable、Comparator"><a href="#Comparable、Comparator" class="headerlink" title="Comparable、Comparator"></a>Comparable、Comparator</h3><p>要讲这个，就要讲list的排序，看上面，有几种办法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.list.sort(Comparator.comparing(A::getB))</span><br><span class="line">2.list.stream.sorted(Comparator.comparing(A::getB)).collect(Collectors.toList())</span><br><span class="line">3.list.stream.sorted((a1,a2)-&gt;a1.compareTo(a2))</span><br><span class="line">4.直接Collections.sort(list)  </span><br><span class="line">//这个需要list的元素实现Comparable接口，重写compareTo方法，比如String就实现了</span><br><span class="line">5.Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>他们都是java的接口, 并且是用来对自定义的实体类比较大小的.</p>
<p>Comparable接口需要进行比较的实体类在定义时实现它，重写compareTo方法。<br>Comparator接口是在集合外部实现的排序，重写compare方法。Comparator接口比Comparable接口要灵活。</p>
<p>✅ compareTo()方法<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则表示两个对象相等，如果该方法返回一个正整数，则表明obj1大于obj2；如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>一些已经实现了Comparable接口的常用类：<br>Character：按照字符的UNICODE值进行比较<br>String：按照字符的UNICODE值进行比较<br>Date\Time：外面比里面新，返回1<br>Long：a.compareTo(b)，a比b大返回1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以特定格式返回日期格式化程序</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date oldTime = dateFormat.parse(&quot;2019-04-07 19:50:11&quot;);</span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 日期变为字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="stream流-parallelStream流"><a href="#stream流-parallelStream流" class="headerlink" title="stream流 parallelStream流"></a>stream流 parallelStream流</h3><p>stream(): 是串行执行，按照顺序执行</p>
<p>parallelStream()：是并行执行，异步执行，多线程，并且使用的线程池是ForkJoinPool.common，可能存在共享资源、线程安全等问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">过滤：</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; 3);   //filter里面的条件是留下来的条件</span><br><span class="line">integerList = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">排序：</span><br><span class="line">.stream().sorted((e1,e2)-&gt;e1.compareTo(e2)).</span><br><span class="line"></span><br><span class="line">去重：</span><br><span class="line">.stream().distinct().</span><br><span class="line"></span><br><span class="line">按照对象中某一元素去重：[tolook]</span><br><span class="line">.stream().filter(...)</span><br><span class="line"></span><br><span class="line">返回指定流个数：</span><br><span class="line">.limit(5)</span><br><span class="line"></span><br><span class="line">跳过流中元素：</span><br><span class="line">.skip(2)</span><br><span class="line"></span><br><span class="line">map流映射：将接收的元素映射成另外一个元素：</span><br><span class="line">.map(类::get属性).collect...</span><br><span class="line">.map(对象-&gt;&#123;</span><br><span class="line">  构造另一种对象;</span><br><span class="line">  return 另一对象;</span><br><span class="line">&#125;).</span><br><span class="line">.map(string-&gt;Long.valueOf(string)).  //String变为Long</span><br><span class="line"></span><br><span class="line">对象list根据某一个元素变为map：(变成 元素-对象list的map)</span><br><span class="line">list.stream().collect(Collectors.groupingBy(类::get属性))</span><br><span class="line"></span><br><span class="line">//流的过程中对元素进行操作</span><br><span class="line">List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">list2.stream().forEach(s -&gt; list.add(Long.valueOf(s)));</span><br><span class="line"></span><br><span class="line">anyMatch判断</span><br><span class="line">想比较list1中是否存在list2中的任何对象</span><br><span class="line">可以遍历两个列表并使用.contains()比较所有元素</span><br><span class="line">但是更高效的方法是anyMatch：</span><br><span class="line">List&lt;Item&gt; list1;</span><br><span class="line">List&lt;Item&gt; list2;</span><br><span class="line">boolean anyMatch = list1.stream().anyMatch(x -&gt; x.equals(list2.stream()));</span><br><span class="line">System.out.println(anyMatch);</span><br><span class="line">很容易理解，即是有一个或一个以上的元素满足函数参数计算结果为true那整个方法返回值为true。</span><br></pre></td></tr></table></figure>

<h4 id="✅list-stream-mapToDouble"><a href="#✅list-stream-mapToDouble" class="headerlink" title="✅list.stream().mapToDouble"></a>✅list.stream().mapToDouble</h4><p>求最大最小，求和求平均</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.stream().mapToDouble(User::getAge).sum()//和</span><br><span class="line">list.stream().mapToDouble(User::getAge).max()//最大</span><br><span class="line">list.stream().mapToDouble(User::getAge).min()//最小</span><br><span class="line">list.stream().mapToDouble(User::getAge).average()//平均值</span><br><span class="line"></span><br><span class="line">double sum = list.stream().mapToDouble(Integer::doubleValue).sum();</span><br></pre></td></tr></table></figure>

<h4 id="✅list变map"><a href="#✅list变map" class="headerlink" title="✅list变map"></a>✅list变map</h4><p>第一种：会出现键重复异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//以id为主键转为map</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId,Function.identity()));</span><br></pre></td></tr></table></figure>

<p>第二种：不会出现重复键异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//给出key重复时，使用哪个key作为主键，以下代码中的(key1, key2) -&gt; key2)代表key1和key2键重复时返回key2做主键</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId, Function.identity(), (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第三种：对象变为属性-属性map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 不想返回对象，只返回对象里某个属性时 采用这种方式</span><br><span class="line">Map&lt;Long, String&gt; map = list.stream().collect(Collectors.toMap(User::getId, User::getAge, (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第四种：以某一属性分组，变为属性-对象list map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&gt; map = list.stream().collect(Collectors.groupingBy(User::getId));</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lizaiismy/article/details/121352640">https://blog.csdn.net/lizaiismy/article/details/121352640</a></p>
<p>ps：<code>Function.identity()</code><br>Function是一个接口，Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。<br><code>Function.identity()</code>返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static  Function identity() &#123;</span><br><span class="line">    return t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>Function.identity()</code>是一个用来返回自己的lambda表达式</p>
<h4 id="✅stream流的max-min方法"><a href="#✅stream流的max-min方法" class="headerlink" title="✅stream流的max,min方法"></a>✅stream流的max,min方法</h4><p>max : 获取最大值<br>min : 获取最小值</p>
<p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></p>
<p>max、min 方法参数类型为 Comparator 接口,利用比较器自定义排序。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; personList = Arrays.asList(</span><br><span class="line">                new Person(1, &quot;大毛&quot;, 30, 175),</span><br><span class="line">                new Person(2, &quot;二毛&quot;, 35, 170),</span><br><span class="line">                new Person(3, &quot;三毛&quot;, 26, 173),</span><br><span class="line">                new Person(4, &quot;小毛&quot;, 30, 175));</span><br><span class="line"> </span><br><span class="line">        // 获取 person 类型流</span><br><span class="line">        Stream&lt;Person&gt; personStream = personList.stream();</span><br><span class="line">        // 按照年龄升序排序,然后获取排序后的最大值 o1-o2 代表升序排序;o2-o1 代表降序排序</span><br><span class="line">        Optional&lt;Person&gt; max = personStream.max(((o1, o2) -&gt; o1.getAge() - o2.getAge()));</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅有一个List-lt-Map-gt-想根据字段统计数量"><a href="#✅有一个List-lt-Map-gt-想根据字段统计数量" class="headerlink" title="✅有一个List&lt;Map&gt;想根据字段统计数量"></a>✅有一个<code>List&lt;Map&gt;</code>想根据字段统计数量</h4><p>使用Collectors.groupingBy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt;list = </span><br><span class="line">Map&lt;String, Long&gt; res = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(map -&gt; (String)map.get(&quot;city&quot;), Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>如果想统计去重后的数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt;list = </span><br><span class="line">Map&lt;String, Long&gt; res = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(map -&gt; (String)map.get(&quot;city&quot;), </span><br><span class="line">    Collectors.maping(map -&gt; map.get(&quot;task_id&quot;), Collectors.toSet())))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry :: getKey, e -&gt; (long)e.getValue().size())));</span><br></pre></td></tr></table></figure>


<h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h4 id="✅now-after"><a href="#✅now-after" class="headerlink" title="✅now.after()"></a>✅now.after()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(oldTime))&#123;</span><br><span class="line">    System.out.println(&quot;now比after新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateFormat类"><a href="#✅DateFormat类" class="headerlink" title="✅DateFormat类"></a>✅DateFormat类</h4><p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p>
<p>在创建 DateFormat 对象时不能使用 new 关键字，而应该使用 DateFormat 类中的静态方法 getDateInstance()：<br><code>DateFormat df = DateFormat.getDatelnstance();</code><br>在创建了一个 DateFormat 对象后，可以调用该对象中的方法来对日期/时间进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//定义对象，日期、时间，也有getDateTimeInstance</span><br><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br><span class="line"></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"></span><br><span class="line">//字符串到Date</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line"></span><br><span class="line">//Date到字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br><span class="line"></span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(old))&#123;</span><br><span class="line">    System.out.println(&quot;now比old新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅SimpleDateFormat"><a href="#✅SimpleDateFormat" class="headerlink" title="✅SimpleDateFormat"></a>✅SimpleDateFormat</h4><p>DateFormat可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat</p>
<p>SimpleDateFormat 使得可以选择任何用户定义的日期/时间格式的模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date(); // 创建一个Date对象，获取当前时间</span><br><span class="line">// 指定格式化格式</span><br><span class="line">SimpleDateFormat f = new SimpleDateFormat(&quot;今天是 &quot; + &quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;);</span><br><span class="line">// Date转为String</span><br><span class="line">System.out.println(f.format(now)); // 将当前时间袼式化为指定的格式</span><br><span class="line">// String转为Date</span><br><span class="line">String str=&quot;2008-08-08 12:12:12&quot;;</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date dd=sdf2.parse(str);</span><br><span class="line">System.out.println(dd);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/878.html">http://c.biancheng.net/view/878.html</a></p>
<h4 id="✅FastDataFormat"><a href="#✅FastDataFormat" class="headerlink" title="✅FastDataFormat"></a>✅FastDataFormat</h4><p>Apache commons-lang中的FastDateFormat。也可以做时间的格式化。<br>FastDateFormat是线程安全的，可以直接使用，不必考虑多线程的情况<br>JDK里自带的SimpleDateFormat存在线程不安全问题。<br>SimpleDateFormat在对时间进行格式化的方法format中，会先对calendar对象进行setTime的赋值，若是有多个线程同时操作一个SimpleDateFormat实例的话，就会对calendar的赋值进行覆盖，进而产生问题。</p>
<p>FastDateFormat用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FastDateFormat f = FastDateFormat.getInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">String s = f.format(new Date());</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">Date dd=f.parse(s);</span><br></pre></td></tr></table></figure>


<h4 id="✅当前时间的后几秒："><a href="#✅当前时间的后几秒：" class="headerlink" title="✅当前时间的后几秒："></a>✅当前时间的后几秒：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前时间的后几秒</span><br><span class="line">Date data = new Date(System.currentTimeMillis() + 10 * 1000);</span><br><span class="line">System.out.println(data);</span><br><span class="line">加的是毫秒</span><br></pre></td></tr></table></figure>

<p>获取当前时间的月份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mon = LocalDate.now().getMonthValue();</span><br></pre></td></tr></table></figure>

<h4 id="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"><a href="#✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】" class="headerlink" title="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"></a>✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】</h4><p>为什么需要LocalDate、LocalTime、LocalDateTime</p>
<p>1.Date如果不格式化，打印出的日期可读性差<br>Tue Sep 10 09:34:04 CST 2019<br>Date对时间处理比较麻烦。<br>getYear、getMonth这些方法吗，获取年月日很Easy，但都被弃用了。</p>
<p>2.使用SimpleDateFormat对时间进行格式化，但SimpleDateFormat是线程不安全的。SimpleDateFormat的format方法中的calendar是共享变量，并且这个共享变量没有做线程安全控制。当多个线程同时使用相同的SimpleDateFormat对象【如用static修饰的SimpleDateFormat】调用format方法时，多个线程会同时调用calendar.setTime方法，可能一个线程刚设置好time值。另外的一个线程马上把设置的time值给修改了导致返回的格式化时间可能是错误的。在多并发情况下使用SimpleDateFormat需格外注意 SimpleDateFormat除了format是线程不安全以外，parse方法也是线程不安全的。</p>
<p>多线程并发如何保证线程安全 - 避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次SimpleDateFormat对象 =&gt; 创建和销毁对象的开销大 - 对使用format和parse方法的地方进行加锁 =&gt; 线程阻塞性能差 - 使用ThreadLocal保证每个线程最多只创建一次SimpleDateFormat对象 =&gt; 较好的方法。</p>
<p>LocalDate用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">只会获取年月日</span><br><span class="line">//获取当前年月日</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">//构造指定的年月日</span><br><span class="line">LocalDate localDate1 = LocalDate.of(2019, 9, 10);</span><br><span class="line"></span><br><span class="line">获取年、月、日、星期几</span><br><span class="line">int year = localDate.getYear();  //2022</span><br><span class="line">int year1 = localDate.get(ChronoField.YEAR); //2022</span><br><span class="line">Month month = localDate.getMonth();  //JUNE</span><br><span class="line">int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);  //6</span><br><span class="line"></span><br><span class="line">//获取当前日期是所在年的第几天、月的第几天、当前星期</span><br><span class="line">int day = localDate.getDayOfMonth();  //26</span><br><span class="line">int day1 = localDate.get(ChronoField.DAY_OF_MONTH);  //26</span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek(); //SUNDAY</span><br><span class="line">int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK); //7</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">int year = now.getDayOfYear();  //一年的第几天</span><br><span class="line">int month = now.getDayOfMonth();  //月的第几天</span><br><span class="line"></span><br><span class="line">System.out.println(LocalDate.MAX);  //+999999999-12-31</span><br><span class="line">System.out.println(LocalDate.MIN);  //-999999999-01-01</span><br><span class="line"></span><br><span class="line">//获取当前月，当前月天数</span><br><span class="line">Month month = now.getMonth();  //JANUARY</span><br><span class="line">int monthValue = now.getMonthValue();</span><br><span class="line">int i = now.lengthOfMonth();</span><br><span class="line"></span><br><span class="line">//with指定年月日</span><br><span class="line">LocalDate localDate = now.withDayOfMonth(1);  //当月的指定日</span><br><span class="line">LocalDate localDate1 = now.withDayOfYear(21);  //获取今年第第几天</span><br><span class="line">LocalDate localDate2 = now.withMonth(3);  //今年指定月份，日为当天的日期</span><br><span class="line">LocalDate localDate3 = now.withYear(2004);  //指定年份的今天</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LocalTime用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">只会获取几点几分几秒</span><br><span class="line">创建LocalTime</span><br><span class="line">LocalTime localTime = LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">获取时分秒</span><br><span class="line">//获取小时</span><br><span class="line">int hour = localTime.getHour();</span><br><span class="line">int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">//获取分</span><br><span class="line">int minute = localTime.getMinute();</span><br><span class="line">int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">//获取秒</span><br><span class="line">int second = localTime.getSecond();</span><br><span class="line">int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">获取年月日时分秒，等于LocalDate+LocalTime</span><br><span class="line">创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, 6, 26, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 = localTime.atDate(localDate);</span><br><span class="line">获取LocalDate</span><br><span class="line">LocalDate localDate2 = localDateTime.toLocalDate();</span><br><span class="line">获取LocalTime</span><br><span class="line">LocalTime localTime2 = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<p>Instant: 可以精确到纳秒的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">获取秒数</span><br><span class="line">创建Instant对象</span><br><span class="line">Instant instant = Instant.now();  //提前北京时间8小时</span><br><span class="line"></span><br><span class="line">//根据时期添加偏移量</span><br><span class="line">OffsetDateTime offsetDateTime1 = instance.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(&quot;处理后时间为：&quot;+offsetDateTime1);</span><br><span class="line"></span><br><span class="line">获取秒数</span><br><span class="line">long currentSecond = instant.getEpochSecond();</span><br><span class="line">获取毫秒数</span><br><span class="line">long currentMilli = instant.toEpochMilli();</span><br><span class="line">如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便</span><br></pre></td></tr></table></figure>

<p>时间变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本</span><br><span class="line">增加、减少年数、月数、天数等 以LocalDateTime为例</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">14, 46, 56);</span><br><span class="line">//增加一年</span><br><span class="line">localDateTime = localDateTime.plusYears(1);</span><br><span class="line">localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">//减少一个月</span><br><span class="line">localDateTime = localDateTime.minusMonths(1);</span><br><span class="line">localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS);</span><br><span class="line">通过with修改某些值</span><br><span class="line">//修改年为2019</span><br><span class="line">localDateTime = localDateTime.withYear(2020);</span><br><span class="line">//修改为2022</span><br><span class="line">localDateTime = localDateTime.with(ChronoField.YEAR, 2022);</span><br><span class="line">还可以修改月、日</span><br></pre></td></tr></table></figure>

<p>时间计算:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">//得到今年第一天</span><br><span class="line">LocalDate localDate1 = localDate.with(firstDayOfYear());</span><br><span class="line">比如通过firstDayOfYear()返回了当前日期的第一天日期，还有很多方法这里不在举例说明</span><br></pre></td></tr></table></figure>

<p>格式化时间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">//自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);</span><br><span class="line">String s3 = localDate.format(dateTimeFormatter);</span><br><span class="line">DateTimeFormatter默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过DateTimeFormatter的ofPattern方法创建自定义格式化方式</span><br><span class="line"></span><br><span class="line">//变为字符串：</span><br><span class="line">String currentTime = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(LocalDateTime.now());</span><br><span class="line">System.out.println(currentTime);</span><br><span class="line">String currentTime1 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">System.out.println(currentTime1</span><br></pre></td></tr></table></figure>

<p>解析时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 = LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">和SimpleDateFormat相比，DateTimeFormatter是线程安全的</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc</a></p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158786867">https://zhuanlan.zhihu.com/p/158786867</a></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtilsTest &#123;</span><br><span class="line">    public static final String DATE_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        // 获取指定格式时间字符串</span><br><span class="line">        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN));</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        // 获取当前月份</span><br><span class="line">        Integer month = LocalDateTime.now().getMonth().getValue();</span><br><span class="line">        System.out.println(month);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        // 时间戳</span><br><span class="line">        long timeStamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间戳：&quot; + timeStamp);</span><br><span class="line">        // 时间戳字符串到时间戳到LocalDateTime</span><br><span class="line">        LocalDateTime time = new Timestamp(timeStamp).toLocalDateTime();</span><br><span class="line">        System.out.println(&quot;LocatDateTime：&quot; + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：获取指定天后的日期字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.now().plusDays(1).format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="✅Calendar、Date、LocalDate-LocalTime关系"><a href="#✅Calendar、Date、LocalDate-LocalTime关系" class="headerlink" title="✅Calendar、Date、LocalDate/LocalTime关系"></a>✅Calendar、Date、LocalDate/LocalTime关系</h4><p>1、Date 类如今很多方法已经没有什么用处了，如今时间的处理并不直接在Date 类中进行，而是通过Calendar，或者LocalDate 来进行，我们在日常使用中，更多的是要来做一个记录日期的实例。</p>
<p>2、Date用于记录某一个含日期的、精确到毫秒的时间。重点在代表一刹那的时间本身。Calendar用于将某一日期放到历法中的互动——时间和年、月、日、星期、上午、下午、夏令时等这些历法规定互相作用关系和互动。Calendar本身代表公历的一个简化缩水版，姑且叫“计算机历”。</p>
<p>3、Java 8新增了LocalDate和LocalTime接口，为什么要搞一套全新的处理日期和时间的API？因为旧的java.util.Date实在是太难用了。<br>java.util.Date月份从0开始，一月是0，十二月是11，变态吧！java.time.LocalDate月份和星期都改成了enum，就不可能再用错了。<br>java.util.Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jaycekon/p/6179700.html">https://www.cnblogs.com/jaycekon/p/6179700.html</a></p>
<h4 id="✅Calender"><a href="#✅Calender" class="headerlink" title="✅Calender"></a>✅Calender</h4><p>Calendar 是一个抽象类, 无法通过直接实例化得到对象. 因此, Calendar 提供了一个方法 getInstance（工厂方法）,来获得一个Calendar的子类对象, 得到的 Calendar 由当前时间初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CalenderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set (2013, 5, 4, 13, 44, 51);//年月日时分秒 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.YEAR, 2014); //年</span><br><span class="line">        cal.set (Calendar.MONTH, 7); //月 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.DATE, 11); //日</span><br><span class="line">        cal.set (Calendar.HOUR_OF_DAY, 15); //时</span><br><span class="line">        cal.set (Calendar.MINUTE, 33); //分</span><br><span class="line">        cal.set (Calendar.SECOND, 32); //秒</span><br><span class="line"></span><br><span class="line">        //同时还有get、add方法，使用类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calendar是父类，GregorianCalendar是子类。<br>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。可以使用new关键字创建实例。</p>
<p>例子：返回当前时间加10分钟后的日期时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = new GregorianCalendar();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(GregorianCalendar.MINUTE, 10);</span><br><span class="line">Date after = calendar.getTime();</span><br><span class="line">System.out.println(after);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//1.创建Calendar对象</span><br><span class="line">Calendar calendar =Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getTime());//Calender变Date</span><br><span class="line">System.out.println(calendar.getTimeInMillis());//Calender变时间戳</span><br><span class="line">Calendar calendar1 = new GregorianCalendar();</span><br><span class="line">System.out.println(calendar1.getTime()); //输出一样</span><br><span class="line"></span><br><span class="line">//2.获取时间信息</span><br><span class="line">//获取年</span><br><span class="line">int year = calendar.get(Calendar.YEAR);</span><br><span class="line">//月</span><br><span class="line">int month = calendar.get(Calendar.MONTH);</span><br><span class="line">//日</span><br><span class="line">int day = calendar.get(Calendar.DAY_OF_MONTH);//DATE</span><br><span class="line">//小时</span><br><span class="line">int hour = calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">//分钟</span><br><span class="line">int minute = calendar.get(Calendar.MINUTE);</span><br><span class="line">//秒</span><br><span class="line">int second = calendar.get(Calendar.SECOND);</span><br><span class="line">System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+&quot;  &quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;);</span><br><span class="line"></span><br><span class="line">//修改时间</span><br><span class="line">Calendar calendar2 =Calendar.getInstance();</span><br><span class="line">calendar2.set(Calendar.DAY_OF_MONTH,5);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//add方法修改时间</span><br><span class="line">calendar2.add(Calendar.HOUR,-1);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//获取当月多少天</span><br><span class="line">int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH); //30</span><br><span class="line">int min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH); //1</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1439775520/article/details/98442556">https://blog.csdn.net/a1439775520/article/details/98442556</a> </p>
<p>🍎用Calender计算量日期相差天数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private static int differentDays(Date date1,Date date2) &#123;</span><br><span class="line">    Calendar cal1 = Calendar.getInstance();</span><br><span class="line">    cal1.setTime(date1);</span><br><span class="line"></span><br><span class="line">    Calendar cal2 = Calendar.getInstance();</span><br><span class="line">    cal2.setTime(date2);</span><br><span class="line">    int day1= cal1.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    int day2 = cal2.get(Calendar.DAY_OF_YEAR);</span><br><span class="line"></span><br><span class="line">    int year1 = cal1.get(Calendar.YEAR);</span><br><span class="line">    int year2 = cal2.get(Calendar.YEAR);</span><br><span class="line">    if(year1 != year2) &#123;//不同年</span><br><span class="line">        int timeDistance = 0 ;</span><br><span class="line">        for(int i = year1 ; i &lt; year2 ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%4==0 &amp;&amp; i%100!=0 || i%400==0)    //闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 366;</span><br><span class="line">            &#125;</span><br><span class="line">            else    //不是闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 365;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return timeDistance + (day2-day1) ;</span><br><span class="line">    &#125; else &#123;// 同年</span><br><span class="line">        System.out.println(&quot;判断day2 - day1 : &quot; + (day2-day1));</span><br><span class="line">        return day2-day1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int differentDaysByMillisecond(Date date1,Date date2)&#123;</span><br><span class="line">    int days = (int) ((date2.getTime() - date1.getTime()) / (1000*3600*24));</span><br><span class="line">    return days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅时间戳"><a href="#✅时间戳" class="headerlink" title="✅时间戳"></a>✅时间戳</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void timeStampTest() &#123;</span><br><span class="line">  // 当前时间时间戳</span><br><span class="line">  long nowStamp = System.currentTimeMillis();</span><br><span class="line">  System.out.println(&quot;毫秒时间戳：&quot; + nowStamp);</span><br><span class="line">  long nowhaomiao = System.currentTimeMillis() * 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳&quot; + nowhaomiao);</span><br><span class="line">  long nowhaomiao1 = System.nanoTime() / 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳1&quot; + nowhaomiao1); //不行</span><br><span class="line"></span><br><span class="line">  // 昨天这个时间时间戳</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.add(Calendar.DAY_OF_YEAR, -1);</span><br><span class="line">  //calender.getTime变Date，再getTime变时间戳（long型的）</span><br><span class="line">  System.out.println(&quot;昨天此时：&quot; + calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 昨天某时间的时间戳</span><br><span class="line">  Calendar calendar1 = Calendar.getInstance();</span><br><span class="line">  calendar.set(calendar1.get(Calendar.YEAR), calendar1.get(Calendar.MONTH), calendar1.get(Calendar.DAY_OF_MONTH) - 1, 23, 59, 59);</span><br><span class="line">  System.out.println(calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 时间戳转换为Date</span><br><span class="line">  Date now = new Date(nowStamp);  //long型</span><br><span class="line">  //如果是时间戳字符串，用下面</span><br><span class="line">  //Date now1 = new Date(Long.parseLong(nowStamp));</span><br><span class="line">  System.out.println(&quot;now: &quot; + now);</span><br><span class="line">  // 再转换为字符串</span><br><span class="line">  String format = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line">  SimpleDateFormat sdf = new SimpleDateFormat(format);</span><br><span class="line">  System.out.println(&quot;now: &quot; + sdf.format(now));</span><br><span class="line"></span><br><span class="line">  // 日期格式字符串转换为时间戳</span><br><span class="line">  String s = &quot;2022-06-25 12:12:12&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">      // String-Date-long型时间戳</span><br><span class="line">      System.out.println(&quot;时间戳：&quot; + String.valueOf(sdf.parse(s).getTime()));</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateUtils工具类"><a href="#✅DateUtils工具类" class="headerlink" title="✅DateUtils工具类"></a>✅DateUtils工具类</h4><p>apache.commons.lang3包下的工具类</p>
<p>1、获取指定日期的开始时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDateUtils() throws ParseException &#123;</span><br><span class="line">    // 获取指定日期的开始时间</span><br><span class="line">    DateFormat df = DateFormat.getDateInstance();</span><br><span class="line">    Date date = df.parse(&quot;2022-06-24 14:01:01&quot;);</span><br><span class="line">    Date begin = org.apache.commons.lang3.time.DateUtils.truncate(date, Calendar.DATE);</span><br><span class="line">    System.out.println(&quot;初始时间：&quot; + begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅计算两个时间段之间的所有天"><a href="#✅计算两个时间段之间的所有天" class="headerlink" title="✅计算两个时间段之间的所有天"></a>✅计算两个时间段之间的所有天</h4><p>输入：begin:‘2022-08-01’ end:‘2022-08-05’<br>输出：”2021-08-01”,”2021-08-02”,”2021-08-03”,”2021-08-04”,”2021-08-05”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; findDates(String beginTime, String endTime)</span><br><span class="line">        throws ParseException &#123;</span><br><span class="line">    List&lt;String&gt; allDate = new ArrayList();</span><br><span class="line">    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    Date dBegin = sdf.parse(beginTime);</span><br><span class="line">    Date dEnd = sdf.parse(endTime);</span><br><span class="line">    allDate.add(sdf.format(dBegin));</span><br><span class="line">    Calendar calBegin = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calBegin.setTime(dBegin);</span><br><span class="line">    Calendar calEnd = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calEnd.setTime(dEnd);</span><br><span class="line">    // 测试此日期是否在指定日期之后</span><br><span class="line">    while (dEnd.after(calBegin.getTime())) &#123;</span><br><span class="line">        // 根据日历的规则，为给定的日历字段添加或减去指定的时间量</span><br><span class="line">        calBegin.add(Calendar.DAY_OF_MONTH, 1);</span><br><span class="line">        allDate.add(sdf.format(calBegin.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;时间==&quot; + allDate);</span><br><span class="line">    return allDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅判断是否同一天"><a href="#✅判断是否同一天" class="headerlink" title="✅判断是否同一天"></a>✅判断是否同一天</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    LocalDate localDate1 = date1.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    LocalDate localDate2 = date2.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    return localDate1.isEqual(localDate2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    SimpleDateFormat fmt = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">    return fmt.format(date1).equals(fmt.format(date2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nandao158/article/details/121905050">https://blog.csdn.net/nandao158/article/details/121905050</a></p>
<h4 id="✅获取今天星期几"><a href="#✅获取今天星期几" class="headerlink" title="✅获取今天星期几"></a>✅获取今天星期几</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>

<p>获取到的数字，星期一到星期七对应数字{2，3，4，5，6, 7，0}，所以需要减一，减一之后判断是不是等于0，等于0就变成7.</p>
<h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="int变String-String变int"><a href="#int变String-String变int" class="headerlink" title="int变String,String变int"></a>int变String,String变int</h4><p>第一种方式：使用int的封装类Integer，在Integer里面用他的toString方法。（性能最好）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=3；</span><br><span class="line">String s=Integer.toString(i);</span><br></pre></td></tr></table></figure>

<p>第二种方式：String的valueOf方法，传参是Object（性能第二）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">String s=String.valueOf(i);</span><br></pre></td></tr></table></figure>

<p>第三种方式，直接在int后面加一个空的字符串，因为在java里面，默认任务int类型和字符串类型相加，为字符串类型。（性能最差）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=2；</span><br><span class="line">String s=i+&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>string变int/Long：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = Integer.parseInt(s);</span><br><span class="line">Integer i = Integer.valueOf(s);</span><br><span class="line">Long l = Long.valueOf(s);</span><br><span class="line">Long l1 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>

<p><code>Integer.parseInt</code> 方法：<br>parseInt(String s, int radix)： s表示字符串  radix表示字符串数值的进制，例如：parseInt(“100”, 16) = 256<br>parseInt(String s)：相当于默认是10进制</p>
<h4 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h4><p>String.format(String format, Object… args)<br>字符串格式化方法，sout也这么用。</p>
<p><code>String str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);  </code></p>
<p>%s    字符串类型    “hello”<br>%c    字符类型    ‘m’<br>%b    布尔类型    true<br>%d    整数类型（十进制）    88<br>%x    整数类型（十六进制）    FF<br>%o    整数类型（八进制）    77<br>%f    浮点类型    8.888<br>%a    十六进制浮点类型    FF.35AE<br>%e    指数类型    9.38e+5<br>%g    通用浮点类型（f和e类型中较短的）    不举例(基本用不到)<br>%h    散列码    不举例(基本用不到)<br>%%    百分比类型    ％(%特殊字符%%才能显示%)<br>%n    换行符    不举例(基本用不到)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    String str=null;  </span><br><span class="line">    str=String.format(&quot;Hi,%s&quot;, &quot;小超&quot;);  </span><br><span class="line">    System.out.println(str);  </span><br><span class="line">    str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);            </span><br><span class="line">    System.out.println(str);                           </span><br><span class="line">    System.out.printf(&quot;字母c的大写是：%c %n&quot;, &#x27;C&#x27;);  </span><br><span class="line">    System.out.printf(&quot;布尔结果是：%b %n&quot;, &quot;小超&quot;.equal(&quot;帅哥&quot;));  </span><br><span class="line">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class="line">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class="line">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class="line"></span><br><span class="line">日期格式：%tx x代表日期转换符</span><br><span class="line">c	包括全部日期和时间信息	星期六 十月 27 14:21:20 CST 2007</span><br><span class="line">F	“年-月-日”格式	2007-10-27</span><br><span class="line">D	“月/日/年”格式	10/27/07</span><br><span class="line">r	“HH:MM:SS PM”格式（12时制）	02:25:51 下午</span><br><span class="line">T	“HH:MM:SS”格式（24时制）	14:28:16</span><br><span class="line">R	“HH:MM”格式（24时制）	14:28</span><br><span class="line"></span><br><span class="line">Date date=new Date();                                  </span><br><span class="line">//c的使用  </span><br><span class="line">System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class="line">//f的使用  </span><br><span class="line">System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class="line">//d的使用  </span><br><span class="line">System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class="line">//r的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class="line">//t的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class="line">//R的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;%f&quot;, d);// &quot;f&quot;表示格式化输出浮点数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%9.2f&quot;, d);// &quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+9.2f&quot;, d);// &quot;+&quot;表示输出的数带正负号。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%-9.4f&quot;, d);// &quot;-&quot;表示输出的数左对齐（默认为右对齐）。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+-9.3f&quot;, d);// &quot;+-&quot;表示输出的数带正负号且左对齐。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%d&quot;, i);// &quot;d&quot;表示输出十进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%o&quot;, i);// &quot;o&quot;表示输出八进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%x&quot;, i);// &quot;d&quot;表示输出十六进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%#x&quot;, i);// &quot;d&quot;表示输出带有十六进制标志的整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%s&quot;, s);// &quot;d&quot;表示输出字符串。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;, d, i, s);  </span><br><span class="line">// 可以输出多个变量，注意顺序。  </span><br><span class="line">System.out.println();  </span><br></pre></td></tr></table></figure>

<h4 id="Strings-nullToEmpty"><a href="#Strings-nullToEmpty" class="headerlink" title="Strings.nullToEmpty"></a>Strings.nullToEmpty</h4><p>Strings、Lists、Maps 都是google提供的工具类。<br>使用之前导入包guava。</p>
<p>vo.setS(String.nullToEmpty(s));  一般用于给对象属性赋值，如果为null，就设空。</p>
<p>其他guava工具类使用：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/article/17770773.html">https://www.w3cschool.cn/article/17770773.html</a></p>
<h4 id="StringUtils工具类"><a href="#StringUtils工具类" class="headerlink" title="StringUtils工具类"></a>StringUtils工具类</h4><p>StringUtils工具类是org.apache.commons.lang3包下的工具类，对String类型的操作作了封装，是对Java自带的API的有效补充，可以帮助我们更高效快速地处理字符串。</p>
<p>导入commons-lang3包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String substringAfter(String str,String separator)：</span><br><span class="line">在第一次出现分隔符后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringAfterLast(String str,String separator)：</span><br><span class="line">在最后一次出现分隔符之后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringBefore(String str,String separator)：</span><br><span class="line">也是第一次出现之前的</span><br><span class="line">StringUtils.substringBefore(&quot;www.baidu.com&quot;, &quot;.)  www</span><br></pre></td></tr></table></figure>

<p>工具类：一般是直接用它的静态方法，直接用类来调用，例如：Collections、Arrays等jaa自带的工具类；Lists、Maps等google工具类；CollectionUtils、StringUtils等apache工具类。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1662921">https://cloud.tencent.com/developer/article/1662921</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.EMPTY = &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 只替换一次--&gt;结果是：phhhss</span><br><span class="line">StringUtils.replaceOnce(&quot;sshhhss&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 全部替换</span><br><span class="line">StringUtils.replace(&quot;sshhhs&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 定义替换次数</span><br><span class="line">StringUtils.replace(&quot;sshhhsshss&quot;, &quot;ss&quot;, &quot;7777&quot;,2);</span><br><span class="line">// 检验字符串是否不为null且不为“”</span><br><span class="line">if(!StringUtils.isEmpty(s))</span><br><span class="line"></span><br><span class="line">//忽略大小写的比较：</span><br><span class="line">System.out.println(StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;aBC&quot;));</span><br></pre></td></tr></table></figure>

<p><code>ObjectUtils.allNotNull(o1, o2)</code> 是commons-lang3包下的，返回boolean，表示是否所有的对象都不为null，false表示有null。</p>
<h4 id="string自己的方法"><a href="#string自己的方法" class="headerlink" title="string自己的方法"></a>string自己的方法</h4><p>✅str.trim()  用于删除字符串的头尾空白符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;   hello   &quot;);</span><br><span class="line">System.out.println( str.trim() );</span><br></pre></td></tr></table></figure>

<p>✅str.replaceAll(正则表达式, 替换字符串)<br>使用给定的参数 replacement 替换字符串所有匹配给定的正则表达式的子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Str = new String(&quot;www.hello.com&quot;);</span><br><span class="line">System.out.println(Str.replaceAll(&quot;(.*)hello(.*)&quot;, &quot;hi&quot; ));</span><br></pre></td></tr></table></figure>

<p>✅str.replace(原字符/字符串, 替换成的新字符/字符串)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String replace(char oldChar, char newChar)</span><br><span class="line">用新字符newChar 替换所有的 旧字符oldChar 。</span><br><span class="line"></span><br><span class="line">String replace(CharSequence target, CharSequence replacement)</span><br><span class="line">用新字符串replacement替换所有的 旧字符串target。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换所有的 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line"></span><br><span class="line">String replaceFirst(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换第一个 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line">————————————————</span><br><span class="line">另外，StringBuilder中也有该方法：</span><br><span class="line">replace(int start，int end，String str)</span><br><span class="line">用str 替换 start–end的子串。//不包括end</span><br></pre></td></tr></table></figure>

<p>✅str.indexof() 用于返回字符串中某部分的索引<br>1、 indexOf(String str): 返回指定字符str在字符串中（方法调用者）第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。<br>2、indexOf(String str, int index): 返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;01234567890123456789&quot;;</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;));  //return 1</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;,5));  //return 11</span><br></pre></td></tr></table></figure>

<p>str.lastIndexOf(“//“)  返回最后一次出现字符/字符串的位置。</p>
<p>✅String.join()静态方法<br>用于将list/set变为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 2L);</span><br><span class="line">// 元素中类型变换</span><br><span class="line">List&lt;String&gt; ls = list.stream().distinct().map(String::valueOf).collect(Collectors.toList());</span><br><span class="line">// 里面的ls不能为空，必须是String元素类型</span><br><span class="line">String s = String.join(&quot;,&quot;, ls);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">//用set也可以</span><br><span class="line">Set&lt;Long&gt; set = Sets.newHashSet(1L, 2L);</span><br><span class="line">Set&lt;String&gt; ss = set.stream().map(i-&gt;String.valueOf(i)).collect(Collectors.toSet());</span><br><span class="line">s = String.join(&quot;,&quot;, ss);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>✅获取某个位置的字符<br><code>char c = s.charAt(index);</code></p>
<h4 id="Splitter工具类（String拆分成list）"><a href="#Splitter工具类（String拆分成list）" class="headerlink" title="Splitter工具类（String拆分成list）"></a>Splitter工具类（String拆分成list）</h4><p>是google出品的，guava包下的工具类，用于对字符串分割处理。</p>
<p>首先，已有的对字符串进行分割的方法：</p>
<p>1.String自带的split()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;1,2,3&quot;;</span><br><span class="line">String[] split = s.split(&quot;,&quot;);</span><br></pre></td></tr></table></figure>
<p>不足之处：如果,后有空格的话，还需要做进一步处理，<br>并且分割后以数组接收，如果数据过多，还需要再转为集合。</p>
<p>2.使用Patter类的split静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br></pre></td></tr></table></figure>

<p>3.Splitter来分割字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SplitterTest &#123;</span><br><span class="line"></span><br><span class="line">    //定义一个拆分器，“,”分隔，去空格</span><br><span class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;).trimResults().omitEmptyStrings();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String s = &quot;1,2, 3&quot;;</span><br><span class="line">        List&lt;String&gt; list = splitter.splitToList(s);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        List&lt;Long&gt; list1 = list.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Joiner连接字符串"><a href="#Joiner连接字符串" class="headerlink" title="Joiner连接字符串"></a>Joiner连接字符串</h4><p>google guava提供的用来连接字符串的类。需要导包：guava。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 连接字符串list</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB:CC</span><br><span class="line"></span><br><span class="line">//过滤其中的null</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, null);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).skipNulls().join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB</span><br><span class="line"></span><br><span class="line">// 可以先定义一个Join对象</span><br><span class="line">private static Joiner MY_JOINER = Joiner.on(&quot;/&quot;).skipNulls();</span><br><span class="line">String s = MY_JOINER.join(..);  里面的参数是Object类型，可以多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44143796/article/details/122998799">https://blog.csdn.net/qq_44143796/article/details/122998799</a></p>
<h4 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h4><p>✅截取字符串</p>
<p>1、string自己的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">System.out.println(s.substring(2)); //llo</span><br><span class="line">System.out.println(s.substring(2, 4)); //ll 左闭右开</span><br></pre></td></tr></table></figure>

<p>2、StringUtils提供的方法（apache）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.substring(&quot;hello world&quot;, 4);   // 返回值，从第4位截取到字符串末尾 : o wrold</span><br><span class="line">StringUtils.substring(&quot;hello world&quot;, 4, 10); // 返回值，从第4位截取到第9位 :   o wrol</span><br><span class="line"></span><br><span class="line">//截取某个字符串之前的字符</span><br><span class="line">StringUtils.substringBefore(&quot;hello world&quot;, &quot;l&quot;); </span><br><span class="line">//结果是：he          这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringBeforeLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：hello wor   这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取某个字符串之后的字符</span><br><span class="line">StringUtils.substringAfter(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果是：lo world   这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringAfterLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：d          这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取两个字符串之间隔的字符</span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;o&quot;);    </span><br><span class="line">//结果是： w   两个o之间的字符串。   </span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;); </span><br><span class="line">//结果是： lo wo   第一个字符“l”与第一个字符“r”之间的字符串   </span><br><span class="line">StringUtils.substringsBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;);</span><br><span class="line">//结果是：数组 [lo wo]   第一个字符“l”与第一个字符“r”之间的字符串，以数组形式返回。   </span><br></pre></td></tr></table></figure>

<p>3、string自己的split方法<br>将字符串按照分割符截取，以数组形式返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hello, world, ni,  hao&quot;;</span><br><span class="line">String[]  strs=str.split(&quot;,&quot;);</span><br><span class="line">for(int i=0,len=strs.length;i&lt;len;i++)&#123;</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//空格也算了</span><br><span class="line">hello</span><br><span class="line"> world</span><br><span class="line"> ni</span><br><span class="line">  hao</span><br></pre></td></tr></table></figure>

<p><code>split(String regex)</code> 参数regex称为分割符,可以使用正则表达式来表示。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str= &quot;a33b444c555d&quot;;</span><br><span class="line">//正则表达式中\d+表示一个或多个数字,java中\\表示一个普通\</span><br><span class="line">//String[] split = str.split(Pattern.compile(&quot;\\d+&quot;).toString());</span><br><span class="line">//两种写法都是一样的,下面写法简洁</span><br><span class="line">String[] split = str.split(&quot;\\d+&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa|bbb|ccc&quot;;</span><br><span class="line">//使用|作为分隔符,其余特殊字符同理</span><br><span class="line">//两个\表示一个\,加了\后表示仅匹配字符本身</span><br><span class="line">String[] split = str.split(&quot;\\|&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa,bbb#ccc&quot;;</span><br><span class="line">//使用,或#分割字符串</span><br><span class="line">String[] split = str.split(&quot;,|#&quot;);</span><br></pre></td></tr></table></figure>

<p><code>split(String regex,int limit)</code> limit控制分割的次数，只填一个正则表达式的话,limit默认是0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）limit &gt; 0,(从左到右)最多分割 n - 1 次,数组的长度将不会大于 n,结尾的空字符串不会丢弃</span><br><span class="line">//limit=3,切割2次,末尾会分割出一个&quot;&quot;空字符串</span><br><span class="line">String[] split = &quot;abcb&quot;.split(&quot;b&quot;,3);</span><br><span class="line">//split:&#123;&quot;a&quot;,&quot;c&quot;,&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">（2）limit &lt; 0,匹配到多少次就分割多少次,而且数组可以是任何长度。结尾的空字符串不会丢弃</span><br><span class="line"></span><br><span class="line">（3）limit=0不限制分割次数，要注意结尾的空字符串将会丢弃</span><br></pre></td></tr></table></figure>

<p>split方法完整用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41740883/article/details/111696866">https://blog.csdn.net/qq_41740883/article/details/111696866</a></p>
<p>✅字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接用+，内部会替换成StringBuilder的append方法</span><br><span class="line">    // 不建议在 for 循环中使用 “+” 进行字符串拼接，会创建多个StringBuilder 对象</span><br><span class="line">    String s1 = &quot;hel&quot;;</span><br><span class="line">    String s2 = null;</span><br><span class="line">    System.out.println(s1 + s2); //helnull  如果是null，当作字符串null来处理</span><br><span class="line">    </span><br><span class="line">    // 2.StringBuilder的append方法 （非线程安全）</span><br><span class="line">    StringBuilder s3 = new StringBuilder(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s3.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 3.StringBuffer的append方法 （线程安全）</span><br><span class="line">    StringBuffer s4 = new StringBuffer(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s4.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 4.String类的concat方法</span><br><span class="line">    System.out.println(s1.concat(&quot;lo&quot;));</span><br><span class="line">    //System.out.println(s1.concat(null)); //NPE</span><br><span class="line">    </span><br><span class="line">    // 5.String类的静态join方法 JDK 1.8 提供，可以分隔符，也可以多个字符串(看上面，也可以是list/set)</span><br><span class="line">    System.out.println(String.join(&quot;&quot;, &quot;hel&quot;, &quot;lo&quot;)); //第一个参数为字符串连接符，后面可以是很多个字符串连接</span><br><span class="line">    </span><br><span class="line">    // 6.org.apache.commons.lang3.StringUtil的join方法（为什么使用这个会慢？？？）</span><br><span class="line">    // 不用担心 NullPointerException,内部使用的仍然是 StringBuilder</span><br><span class="line">    System.out.println(StringUtils.join(&quot;hel&quot;, &quot;lo&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ChineseSoftware/article/details/122956817">https://blog.csdn.net/ChineseSoftware/article/details/122956817</a></p>
<p>concat与+的区别：<br>①如果拼接的字符串是 null，concat 时候就会抛出 NullPointerException，“+” 操作符会当做是 “null” 字符串来处理。<br>②如果拼接的字符串是一个空字符串(“”)，那么 concat 的效率要更高一点。毕竟不需要 new StringBuilder 对象。<br>③如果拼接的字符串非常多，concat 的效率就会下降，因为用到字符数组，开销就大。</p>
<p>✅字符串翻转</p>
<p>1、用stringBuffer或者stringBuilder自带的reverse方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String newS = new StringBuilder(old).reverse().toString();</span><br></pre></td></tr></table></figure>

<p>2、将字符串拆分为char数组，然后交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">char[] charArray = s.toCharArray();</span><br><span class="line">int start = 0, end = charArray.length - 1;</span><br><span class="line">for (; start &lt; end; start++, end--) &#123;</span><br><span class="line">    charArray[start] ^= charArray[end];//采用异或</span><br><span class="line">    charArray[end] ^= charArray[start];</span><br><span class="line">    charArray[start] ^= charArray[end];</span><br><span class="line">&#125;</span><br><span class="line">String newS = new String(charArray);</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">while (start &lt; end) &#123;</span><br><span class="line">    //交换首尾char值</span><br><span class="line">    char c = charArray[end];</span><br><span class="line">    charArray[end] = charArray[start];</span><br><span class="line">    charArray[start] = c;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、stringBuffer倒序拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">for (int i = s.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    sb.append(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>4、利用栈的先进后出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">Stack stack = new Stack();</span><br><span class="line">for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    stack.push(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">    //stack会返回栈顶值，并且会把该值删除</span><br><span class="line">    sb.append(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>5、切割递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    if (s.length() &lt;= 1) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //每次把第一个放在后面</span><br><span class="line">    return reverse(s.substring(1)) + s.substring(0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、二分递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    int length = s.length();</span><br><span class="line">    if (length &lt;= 1) return s;</span><br><span class="line">    String left = s.substring(0, length / 2);</span><br><span class="line">    String right = s.substring(length / 2, length);</span><br><span class="line">    return reverse(right) + reverse(left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/237801.htm">https://www.jb51.net/article/237801.htm</a></p>
<p>✅删除字符串最后一个字符</p>
<p>1、String的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">System.out.println(s.substring(0, s.length() - 1));</span><br></pre></td></tr></table></figure>

<p>2、replaceFirst方法 正则表达式匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abcd&quot;;</span><br><span class="line">str = str.replaceFirst(&quot;.$&quot;, &quot;&quot;);</span><br><span class="line">//匹配除“\n”和&quot;\r&quot;之外的任何单个字符</span><br><span class="line">//匹配输入行尾。</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35764295/article/details/126106534">https://blog.csdn.net/qq_35764295/article/details/126106534</a></p>
<h4 id="StringBuilder操作"><a href="#StringBuilder操作" class="headerlink" title="StringBuilder操作"></a>StringBuilder操作</h4><p>✅删除最后一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&#x27;a&#x27;).append(&#x27;b&#x27;).append(&#x27;c&#x27;);</span><br><span class="line">sb.deleteCharAt(sb.length()-1);</span><br><span class="line">System.out.println(sb); //ab</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">sb.delete(sb.length()-1, sb.length());</span><br></pre></td></tr></table></figure>

<h3 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a>map相关</h3><h4 id="map几种遍历方式"><a href="#map几种遍历方式" class="headerlink" title="map几种遍历方式"></a>map几种遍历方式</h4><p>一、Map.Entry遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">  System.out.println(&quot;key= &quot; + entry.getKey());</span><br><span class="line">  System.out.println(&quot;value= &quot; + entry.getValue());</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>二、通过Iterator迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**通过entrySet()方法将key和value存放到Set集合中，Set集合中有迭代器**/</span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,String&gt;&gt; iterators = entry.iterator();</span><br><span class="line">while(iterators.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,String&gt; entrys  = iterators.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+entrys.getKey()+&quot;&amp;&amp;value=&quot;+entrys.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、通过keySet()遍历<br>keySet()：将Map中所有的key存放到Set集合中。因为Set集合有迭代器，可以通过迭代器循环key，再通过get()方法，得到每个key所对应的value；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**通过keySet()方法将所有的key值存放到Set集合中,Set集合中有迭代器**/</span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+key+&quot;  &quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以不用迭代器，直接for循环</span><br><span class="line">for (String key: map.keySet()) &#123;</span><br><span class="line">  System.out.println(&quot;key:&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、values()遍历<br>values()获取集合中的所有的value值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = map.values();</span><br><span class="line">再for遍历得到value，同样也可以用迭代器</span><br><span class="line">Iterator var3 = values.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">  String value = (String)var3.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、直接foreach map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;第五种:&quot; + key + &quot; ：&quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="MapUtils工具类"><a href="#MapUtils工具类" class="headerlink" title="MapUtils工具类"></a>MapUtils工具类</h4><p>MapUtils是 org.apache.commons.collections 工具包中常用的工具类<br>需要导入包：commons-collections4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int value = MapUtils.getInteger(map, key, 0)</span><br><span class="line">//将结果转换为Integer，如果转换失败则使用默认值</span><br></pre></td></tr></table></figure>

<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012894692/article/details/82557843">https://blog.csdn.net/u012894692/article/details/82557843</a></p>
<h4 id="map的一些操作"><a href="#map的一些操作" class="headerlink" title="map的一些操作"></a>map的一些操作</h4><p>✅map的size</p>
<p>map.size() 返回 hashMap 中键/值对的数量。</p>
<p>✅map的put和putIfAbsent<br>1.使用 put 方法添加键值对，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null；如果已经存在对应的值，则会<strong>覆盖旧值</strong>，value 为新的值，返回值为旧的value。<br><code>map.put(key, value)</code></p>
<p>2.使用 putIfAbsent 方法添加键值对，不存在才加入，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null，如果已经存在对应的值，则依旧为原来的值，返回值为 value（旧的值）。<br><code>map.putIfAbsent(key, value)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;11&quot;, &quot;11&quot;);</span><br><span class="line">    System.out.println(map.put(&quot;11&quot;, &quot;22&quot;));  //输出11</span><br><span class="line">    System.out.println(map.put(&quot;22&quot;, &quot;22&quot;));  //输出null</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;11&quot;, &quot;33&quot;));  //输出22</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;33&quot;, &quot;44&quot;));  //输出33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>✅map.getOrDefault(key, defaultvalue)<br>用于map获取value，与.get(key)不同的是，如果得到的value是null的话，可以给一个默认值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;StudentGrade&gt; gradeList = Lists.newArrayList();</span><br><span class="line">//把学生成绩list变为map：学生-成绩list</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeMap = Maps.newHashMap();</span><br><span class="line">for(StudentGrade studentGrade : gradeList) &#123;</span><br><span class="line">  List&lt;String&gt; grades = gradeMap.getOrDefault(studentGrade.getName(), Lists.newArrayList());</span><br><span class="line">  grades.add(studentGrade.getGrade());</span><br><span class="line">  gradeMap.put(studentGrade.getName(), grades); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅对map的某个value加一</p>
<p>用<code>map.get(i)++;</code> 不行。得先：<code>int v = map.get(i) + 1;</code> 然后：<code>map.put(i, v);</code></p>
<p>✅某key是否存在<br><code>map.containsKey(key)</code></p>
<p>✅json字符串转换为map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, String&gt; map = JSON.parseObject(jsonString, Map.class);</span><br></pre></td></tr></table></figure>

<p>✅ceilingEntry()</p>
<p>java.util.TreeMap.ceilingEntry() 返回具有最小键值（大于或等于指定键）的键值对，如果没有这样的键，则返回null。(取比输入值大的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;1&quot;);</span><br><span class="line">map.put(3, &quot;3&quot;);</span><br><span class="line">Map.Entry&lt;Integer, String&gt; entry = map.ceilingEntry(2);</span><br><span class="line">System.out.println(entry.getValue()); //3</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>定义枚举类，定义在一个包中，和impl、service、vo包平级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum SexEnum:int &#123;</span><br><span class="line">    male,female;</span><br><span class="line">&#125;</span><br><span class="line">多个枚举成员之间使用逗号分隔，</span><br><span class="line">如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum DemoEnum &#123;</span><br><span class="line">  LIU(&quot;liu&quot;, 1),</span><br><span class="line">  WANG(&quot;wang&quot;, 2);</span><br><span class="line">  UN_KNOW(&quot;unknow&quot;, 99)</span><br><span class="line"></span><br><span class="line">  private final String name;</span><br><span class="line">  private final int age;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  private DemoEnum(String name, int age)&#123; </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //可以存一个map供外部使用，里面是直接的enum类</span><br><span class="line">  static Map&lt;String, DemoEnum&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    for (DemoEnum enum : DemoEnum.values()) &#123;</span><br><span class="line">      map.put(enum.getName(), enum)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DemoEnum getEnumByName(String name) &#123;</span><br><span class="line">    return map.get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //根据属性获得enum，再获得另一属性</span><br><span class="line">  //可以使用上面构造个map，再从map获取的方法</span><br><span class="line">  //也可以加个方法，遍历获取，根据属性获取enum</span><br><span class="line">  public static DemoEnum nameOf(String name) &#123;</span><br><span class="line">    for (DemoEnum e : DemoEnum.values()) &#123;</span><br><span class="line">      if (e.name = name) &#123;</span><br><span class="line">        return e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UN_KNOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的values()方法，获取定义的成员数组：<br><code>DemoEnum[] values = DemoEnum.values();</code></p>
<p>Enum valueOf方法：<br>通过字符串来获取枚举enum：<br><code>DemoEnum e = DemoEnum.valueOf(&quot;LIU&quot;)</code></p>
<h3 id="File相关"><a href="#File相关" class="headerlink" title="File相关"></a>File相关</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。<br>File对象代表磁盘中实际存在的文件和目录。<br>自我理解：File对象就是文件路径在java里的一个抽象，并不代表真实文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">新建文件：</span><br><span class="line">String dirname = &quot;/java&quot;;</span><br><span class="line">File f1 = new File(dirname);</span><br><span class="line"></span><br><span class="line">// 判断该文件是否是一个目录</span><br><span class="line">if (f1.isDirectory()) &#123; &#125;</span><br><span class="line">f1.isFile() 是否是文件</span><br><span class="line"></span><br><span class="line">// 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</span><br><span class="line">String s[] = f1.list();</span><br><span class="line">for (int i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  File f = new File(dirname + &quot;/&quot; + s[i]);</span><br><span class="line">  if (f.isDirectory()) &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a directory&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a file&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName()  返回此抽象路径名表示的文件或目录的名称。（文件名）</span><br><span class="line"></span><br><span class="line">public String getPath()  将此抽象路径名转换为一个路径名字符串。（路径名）</span><br><span class="line"></span><br><span class="line">public String getParent()  返回此抽象路径名的父路径名的路径名字符串（路径名）</span><br><span class="line"></span><br><span class="line">public File getParentFile()  返回父文件</span><br><span class="line"></span><br><span class="line">public boolean exists()  测试此抽象路径名表示的文件或目录是否存在。</span><br><span class="line"></span><br><span class="line">// 创建文件所在目录：</span><br><span class="line">File file = new File(&quot;/Users/liuxuan/MyProject/hi.md&quot;);</span><br><span class="line">File dirFile = file.getParentFile();</span><br><span class="line">if(dirFile != null &amp;&amp; !dirFile.exists())&#123;</span><br><span class="line">  dirFile.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多方法：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-file.html">https://www.runoob.com/java/java-file.html</a></p>
<p>✅文件读写的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IOException &#123;</span><br><span class="line">    // 1. 新建文件夹</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    File file1 = new File(filePath);</span><br><span class="line">    boolean isSame = file.equals(file1);  //true 重写了，变值比较</span><br><span class="line">    boolean isSame1 = file == file1;  //false 地址比较</span><br><span class="line">    System.out.println(isSame);  //true</span><br><span class="line">    if(!file.getParentFile().exists()) &#123;</span><br><span class="line">        File dirFile = file.getParentFile();</span><br><span class="line">        dirFile.mkdirs();  //建立父文件夹</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.字节数组直接写文件，下面有加一步输出流的方式</span><br><span class="line">    String filePath1 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi.java&quot;;</span><br><span class="line">    File file2 = new File(filePath1);</span><br><span class="line">    if(file2.exists()) &#123;</span><br><span class="line">        boolean res = file2.delete();</span><br><span class="line">        System.out.println(&quot;delete:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] data = &quot;hi&quot;.getBytes();</span><br><span class="line">    byte[] data1 = &quot;System.out.println(\&quot;hi\&quot;)&quot;.getBytes();  //String变字节数组</span><br><span class="line">    try &#123;</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data);</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data1);  //覆写的方式</span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组</span><br><span class="line">    FileInputStream in = new FileInputStream(file2);  //也有传入路径字符串的构造函数</span><br><span class="line">    // 输入流变字节数组</span><br><span class="line">    byte[] data2 = IOUtils.toByteArray(in);</span><br><span class="line">    //String content = data2.toString();  //字节数组变String，用这个不对</span><br><span class="line">    String content = new String(data2);  //得用它</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content);</span><br><span class="line">    String content4 = Arrays.toString(data2);</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content4); //这样输出的是数字</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组，另种方法</span><br><span class="line">    FileInputStream in1 = new FileInputStream(file2);</span><br><span class="line">    byte[] data3 = new byte[20];</span><br><span class="line">    String content3 = CharStreams.toString(new InputStreamReader(in1, Charsets.UTF_8)); //这里也消耗输入流</span><br><span class="line">    System.out.println(&quot;前面获取输入流内容：&quot; + content3);</span><br><span class="line">    int num = in1.read(data3);  //输入流消耗20个字节</span><br><span class="line">    System.out.println(&quot;几个字节：&quot; + num);</span><br><span class="line">    String content1 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content1);   //这里只剩几个可以展示</span><br><span class="line">    String content2 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容2：&quot; + content2);  //这里已经没有了</span><br><span class="line"></span><br><span class="line">    // 4.写文件：用输出流 字节数组-&gt;输出流-&gt;文件</span><br><span class="line">    String filePath2 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi2.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file3 = new File(filePath2);</span><br><span class="line">    FileOutputStream out = new FileOutputStream(filePath2);</span><br><span class="line">    byte[] data4 = &quot;System.out.println(\&quot;hi2\&quot;)&quot;.getBytes();</span><br><span class="line">    out.write(data4);  //如果文件存在内容，则是覆盖的方式</span><br><span class="line">    if(file3.exists()) System.out.println(&quot;写入成功&quot;);</span><br><span class="line">    //关闭流</span><br><span class="line">    IOUtils.closeQuietly(in);</span><br><span class="line">    IOUtils.closeQuietly(out);</span><br><span class="line"></span><br><span class="line">    // 5.copy文件：文件-输入流-字节数组-输出流-文件，用IOUtils.copy()一步到位</span><br><span class="line">    String filePath3 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi3.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file4 = new File(filePath3);</span><br><span class="line">    FileInputStream in3 = new FileInputStream(file3);</span><br><span class="line">    FileOutputStream out2 = new FileOutputStream(file4);</span><br><span class="line">    IOUtils.copy(in3, out2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅获取文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.方法一：使用java io</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    long size = file.length();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.方法二：使用java nio</span><br><span class="line">    Path filePath1 = Paths.get(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;);  //绝对路径</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(filePath1);</span><br><span class="line">    long size1 = fileChannel.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size1 + &quot;B&quot;);</span><br><span class="line">    Path filePath2 = Paths.get(&quot;src/test/resources/hi.md&quot;);  //项目下路径</span><br><span class="line">    FileChannel fileChannel2 = FileChannel.open(filePath2);</span><br><span class="line">    long size2 = fileChannel2.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size2 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 3.方法三：使用  apache commons io (只能读文件夹的大小)</span><br><span class="line">    String dir = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile&quot;;</span><br><span class="line">    File file1 = new File(dir);</span><br><span class="line">    long size3 = FileUtils.sizeOfDirectory(file1);</span><br><span class="line">    System.out.println(&quot;文件夹大小：&quot; + size3 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 用户可读视角？</span><br><span class="line">    String display = FileUtils.byteCountToDisplaySize(size);</span><br><span class="line">    System.out.println(display);  //117 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File流"><a href="#File流" class="headerlink" title="File流"></a>File流</h4><p>JAVA中针对文件的读写操作设置了一系列的流，其中主要有FileInputStream,FileOutputStream,FileReader,FileWriter四种最为常用的流</p>
<p>一、FileInputStream流</p>
<p>被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等</p>
<p>若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  File file=new File(&quot;xxxxxxxx&quot;); </span><br><span class="line">  //根据路径创建File类对象--这里路径即使错误也不会报错，因为只是产生File对象，还并未与计算机文件读写有关联</span><br><span class="line">        </span><br><span class="line">  try&#123;</span><br><span class="line">    FileInputStream fileInputStream=new FileInputStream(file);</span><br><span class="line">    //与根据File类对象的所代表的实际文件建立链接创建fileInputStream对象</span><br><span class="line">      &#125;catch (FileNotFoundException e)&#123;</span><br><span class="line">          System.out.println(&quot;文件不存在或者文件不可读或者文件是目录&quot;);</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 也可以根据文件路径名字符串进行建立</span><br><span class="line">FileInputStream fileInputStream=new FileInputStream(filepath);</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ai_bao_zi/article/details/81097898">https://blog.csdn.net/ai_bao_zi/article/details/81097898</a></p>
<p>IO流的关系：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lianshan/p/11911773.html">https://www.cnblogs.com/lianshan/p/11911773.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/q306507291/article/details/118825930">https://blog.csdn.net/q306507291/article/details/118825930</a></p>
<h4 id="FileUtils-工具类"><a href="#FileUtils-工具类" class="headerlink" title="FileUtils 工具类"></a>FileUtils 工具类</h4><p>apache 的commons-io包下的FileUtils，导包：commons-io</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;E:\\java\\file04\\abc雪.jpg&quot;);</span><br><span class="line">//删除指定文件，从不引发异常。</span><br><span class="line">FileUtils.deleteQuietly(file);</span><br><span class="line"></span><br><span class="line">//将byte数组写为File</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">FileUtils.writeByteArrayToFile(new File(path), bytes)</span><br><span class="line"></span><br><span class="line">//删除掉指定目录的文件</span><br><span class="line">FileUtils.deleteExistFile(new File(localpath));</span><br></pre></td></tr></table></figure>
<p>更多方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42402854/article/details/83374559">https://blog.csdn.net/qq_42402854/article/details/83374559</a></p>
<h4 id="IOUtils工具类"><a href="#IOUtils工具类" class="headerlink" title="IOUtils工具类"></a>IOUtils工具类</h4><p>它是 Apache Commons IO 的一部分 。该类的所有成员函数都被用来处理输入 - 输出流。这些方法基于 InputStream,  OutputStream,  Reader 和 Writer工作。</p>
<p>所有成员字段和方法都是静态的，不需要创建对象，直接用类名调用。</p>
<p>✅输入流转为字节数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将输入流转换成字符数组:</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br></pre></td></tr></table></figure>

<p>✅关闭流<br>之前关闭流，往往在finally中，因为会抛出IOException，所以finally中需要try catch，并且close之前需要判断是否为null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">  if (in != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      in.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          LOGGER.warn(&quot;Fail to close stream : &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以使用 IOUtils.closeQuietly 来精简代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = new byte[1024];</span><br><span class="line">InputStream in = null;</span><br><span class="line">OutputStream out = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">      in = new FileInputStream(&quot;foo.txt&quot;);</span><br><span class="line">      in.read(data);</span><br><span class="line"></span><br><span class="line">      out = new FileOutputStream(&quot;foo.txt&quot;);</span><br><span class="line">      data = &quot;Hello, World&quot;.getBytes();</span><br><span class="line">      out.write(data);</span><br><span class="line"></span><br><span class="line">      IOUtils.copy(in, out);</span><br><span class="line"></span><br><span class="line">      in.close(); //close errors are handled</span><br><span class="line">      out.close();</span><br><span class="line">&#125; catch (IOException e) &#123; </span><br><span class="line">      // error handling</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">      IOUtils.closeQuietly(in);</span><br><span class="line">      IOUtils.closeQuietly(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sulia1234567890/article/details/120569718">https://blog.csdn.net/sulia1234567890/article/details/120569718</a></p>
<p>✅写文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws IOException &#123;</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    OutputStream out = new FileOutputStream(file, true);</span><br><span class="line">    IOUtils.write(&quot;hello&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;\n&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;hi&quot;, out);</span><br><span class="line">    //也可以传字节数组、字符数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️new FileOutputStream(“b.txt”,true);</p>
<p>默认第二个参数是false，表示不追加，每次new对象都会清空之前的内容创建新的内容，ture表示在之前的基础上追加内容</p>
<p>✅字节数组转换为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = &quot;hello world&quot;.getBytes();</span><br><span class="line">//apache里io的IOUtils需要commons-io包</span><br><span class="line">String s1 = IOUtils.toString(data, &quot;utf-8&quot;);</span><br><span class="line">String s2 = new String(data);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>

<h4 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h4><p>需要依赖：spring-web</p>
<p>首先，“流”是一个抽象的概念，它是对输入输出设备的一种抽象理解，在java中，对数据的输入输出操作都是以“流”的方式进行的。“流”具有方向性，输入流、输出流是相对的。当程序需要从数据源中读入数据的时候就会开启一个输入流，相反，写出数据到某个数据源目的地的时候也会开启一个输出流。</p>
<p>MultipartFile是SpringMVC提供简化上传操作的工具类。实现文件的快速上传，不需要先将File转换成output流 再传输过去 接收端接收流再生成文件。</p>
<p>在不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据，文件是以二进制流传递到后端的，然后需要我们自己转换为File类。使用了MultipartFile工具类之后，我们对文件上传的操作就简便许多了。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45393094/article/details/112056436">https://blog.csdn.net/weixin_45393094/article/details/112056436</a></p>
<p>✅内部方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface MultipartFile extends InputStreamSource &#123;</span><br><span class="line">    //getName() 返回参数的名称</span><br><span class="line">    String getName();</span><br><span class="line">    //获取源文件的昵称</span><br><span class="line">    @Nullable</span><br><span class="line">    String getOriginalFilename();</span><br><span class="line">    //getContentType() 返回文件的内容类型</span><br><span class="line">    @Nullable</span><br><span class="line">    String getContentType();</span><br><span class="line">    //isEmpty() 判断是否为空，或者上传的文件是否有内容</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    //getSize() 返回文件大小 以字节为单位</span><br><span class="line">    long getSize();</span><br><span class="line">    //getBytes() 将文件内容转化成一个byte[] 返回</span><br><span class="line">    byte[] getBytes() throws IOException;</span><br><span class="line">    //getInputStream() 返回InputStream读取文件的内容</span><br><span class="line">    InputStream getInputStream() throws IOException;</span><br><span class="line"></span><br><span class="line">    default Resource getResource() &#123;</span><br><span class="line">        return new MultipartFileResource(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //transferTo(File dest) 用来把 MultipartFile 转换换成 File</span><br><span class="line">    void transferTo(File var1) throws IOException, IllegalStateException;</span><br><span class="line"></span><br><span class="line">    default void transferTo(Path dest) throws IOException, IllegalStateException &#123;</span><br><span class="line">        FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅MockMultipartFile</p>
<p>可以用MockMultipartFile创建MultipartFile。需要导入spring-test.jar</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MockMultipartFile(String name, @Nullable String originalFilename, @Nullable String contentType, InputStream contentStream)</span><br><span class="line">第一个参数：传输后的文件名 </span><br><span class="line">第二个：旧文件名字（可为空） </span><br><span class="line">第三：类型</span><br><span class="line">第四：输入流</span><br></pre></td></tr></table></figure>

<p>✅MultipartFile与File的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws IOException &#123;</span><br><span class="line">    // 1.File转为MultipartFile：file-InputStream-MultipartFile</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    System.out.println(file.getName());  //hello.java</span><br><span class="line">    System.out.println(FilenameUtils.getExtension(file.getName()));  //后缀java</span><br><span class="line">    FileInputStream in = new FileInputStream(file);</span><br><span class="line">    MultipartFile mf = new MockMultipartFile(file.getName(), file.getName(), &quot;text/plain&quot;, in);</span><br><span class="line">    System.out.println(mf.getName()); //hello.java</span><br><span class="line">    System.out.println(mf.getOriginalFilename());  //hello.java</span><br><span class="line"></span><br><span class="line">    // 2.MultipartFile转为File</span><br><span class="line">    try &#123;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        //得到文件后缀</span><br><span class="line">        String originalName = mf.getOriginalFilename();</span><br><span class="line">        String ext = &quot;.&quot; + FilenameUtils.getExtension(originalName);</span><br><span class="line">        String fileName = uuid + ext;</span><br><span class="line">        File targetFile = new File(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/&quot;, fileName);</span><br><span class="line">        //第一个参数：文件夹  第二个参数：文件名</span><br><span class="line">        // 方法一：MultipartFile - 字节数组 - File本地</span><br><span class="line">        FileUtils.writeByteArrayToFile(targetFile, mf.getBytes());</span><br><span class="line">        // 方法二：MultipartFile - 字节数组 - 输出流 - File本地</span><br><span class="line">        byte[] data = mf.getBytes();</span><br><span class="line">        FileOutputStream out = new FileOutputStream(targetFile);</span><br><span class="line">        out.write(data);</span><br><span class="line">        IOUtils.closeQuietly(out);</span><br><span class="line">        // 方法三：直接用MultipartFile内部方法</span><br><span class="line">        mf.transferTo(targetFile);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        System.out.println(&quot;失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅使用MultipartFile实现文件上传的一个case</p>
<p>背景：文件上传备份希望它是和主业务线程处于异步情况下的，这样可以更快的响应给用户反馈，减少等待时间。<br>MultipartFile异步保存文件transferto 报错java.io.FileNotFoundException: XXX.tmp (No such file or directory)</p>
<p>原因：由于SpringBoot上传文件后会形成MultiPartFile的实例，在临时文件夹中生成临时文件，并且此实例执行此临时文件。当主线程执行结束后，<br>SpringMVC会清除掉此临时文件，导致子线程在处理此实例的时候找不到此实例指向的临时文件，MultipartFile对象就变成了null,从而报FileNotFoundException！</p>
<p>解决：先获取传InputStrem，传传InputStrem。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42408648/article/details/126272849">https://blog.csdn.net/weixin_42408648/article/details/126272849</a></p>
<p>✅MultipartFile 对上传的文件大小进行限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MultipartFileUtil &#123;</span><br><span class="line"></span><br><span class="line">private final static Integer FILE_SIZE = 5;//文件上传限制大小</span><br><span class="line">private final static String FILE_UNIT = &quot;M&quot;;//文件上传限制单位（B,K,M,G）</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param len  文件长度</span><br><span class="line">     * @param size 限制大小</span><br><span class="line">     * @param unit 限制单位（B,K,M,G）</span><br><span class="line">     * @描述 判断文件大小</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkFileSize(Long len, int size, String unit) &#123;</span><br><span class="line">        double fileSize = 0;</span><br><span class="line">        if (&quot;B&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len;</span><br><span class="line">        &#125; else if (&quot;K&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1024;</span><br><span class="line">        &#125; else if (&quot;M&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1048576;</span><br><span class="line">        &#125; else if (&quot;G&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1073741824;</span><br><span class="line">        &#125;</span><br><span class="line">        return !(fileSize &gt; size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //文件上传调用</span><br><span class="line">    public static String upload(MultipartFile file) &#123;</span><br><span class="line">        boolean flag = checkFileSize(file.getSize(), FILE_SIZE, FILE_UNIT);</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;上传文件大小超出限制&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/w_shimmer/article/details/124341265">https://blog.csdn.net/w_shimmer/article/details/124341265</a></p>
<h4 id="java-nio-file-文件操作"><a href="#java-nio-file-文件操作" class="headerlink" title="java.nio.file 文件操作"></a>java.nio.file 文件操作</h4><p>自 Java7 开始，Java 终于简化了文件读写的基本操作，新增了 java.nio.file 库，通过与 Java8 新增的 stream 结合可以使得文件操作变得更加优雅。</p>
<p>1️⃣文件和目录路径Path</p>
<p>java.nio.file.Paths 类包含一个静态方法 <code>static.get()</code>，可以接受一系列 String 字符串或一个统一资源标识符 URI 作为参数，并且转换返回一个 <code>Path</code> 对象。</p>
<p>一个 Path 对象表示一个文件或者目录的路径，是一个跨操作系统和文件系统的抽象，目的是在构造路径时可以不必关注底层操作系统。如果 Path 仅由一个空的名称元素组成，则认为是空的路径。使用空路径访问文件等同于访问文件系统的默认目录。Path 接口的实现是不可变且安全的，可供多个并行线程使用.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;);</span><br><span class="line">System.out.println(path1); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path2 = Paths.get(&quot;C:/path/to/nowhere/NoFile.txt&quot;);</span><br><span class="line">System.out.println(path2); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">URI uri = path2.toUri();  //转换为URI对象，可以用于构建web资源的绝对uri</span><br><span class="line">System.out.println(uri); //file:///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path3 = Paths.get(uri);</span><br><span class="line">System.out.println(path3);</span><br><span class="line"></span><br><span class="line">// 返回表示此路径的绝对路径的Path对象</span><br><span class="line">Path p = Paths.get(&quot;FileTest.java&quot;).toAbsolutePath();  //相对于当前项目目录</span><br><span class="line">System.out.println(p); ///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">// 返回表示此路径的真实路径的Path对象，也即是带上盘符（根路径）</span><br><span class="line">Path p2 = Paths.get(&quot;/Users/liuxuan/Downloads/test&quot;).toRealPath();</span><br><span class="line">// getNameCount() 返回路径中的名称元素的数量</span><br><span class="line">for(int i = 0; i &lt; p.getNameCount(); i++) &#123;</span><br><span class="line">    // 返回此路径的名称元素作为 Path对象</span><br><span class="line">    System.out.println(p.getName(i));</span><br><span class="line">&#125;</span><br><span class="line">// 测试路径是否以给定的路径结束，这里会输出 end with &#x27;.java&#x27;:false</span><br><span class="line">System.out.println(&quot;ends with &#x27;.java&#x27;: &quot; + p.endsWith(&quot;.java&quot;));</span><br><span class="line">// Path 也实现了 iterable 接口，会对路径中的名称元素进行遍历</span><br><span class="line">for(Path pp : p) &#123;</span><br><span class="line">    System.out.println(pp);</span><br><span class="line">&#125;</span><br><span class="line">// getRoot() 返回此路径的根路径作为Path对象，为null则该路径不具有根</span><br><span class="line">// startsWith() 效果和 endsWith() 相似</span><br><span class="line">// 这里会输出 Starts with C:\ true</span><br><span class="line">System.out.println(&quot;Starts with &quot; + p.getRoot() + &quot; &quot; + p.startsWith(p.getRoot()));</span><br></pre></td></tr></table></figure>

<p>有时我们还需要通过对 Path 对象增加或修改一部分来构造一个新的 path 对象，可以使用 relativize() 移除 Path 的根路径，或者使用 resolve() 添加 Path 的尾路径，注意添加的路径可以不是真实存在的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用..可以跳转到上一级路径，但必须使用normalize()方法</span><br><span class="line">// 假设当前路径为/Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">Path base = Paths.get(&quot;..&quot;, &quot;..&quot;, &quot;..&quot;).toAbsolutePath().normalize();</span><br><span class="line">System.out.println(base); ///Users/liuxuan/MyProject</span><br><span class="line">// 构造此路径和给定路径之间的相对路径</span><br><span class="line">Path p4 = base.relativize(p);</span><br><span class="line">System.out.println(p4);</span><br><span class="line">// 使用resolve构造路径</span><br><span class="line">// 此时路径为C:\Users\Bruce\Documents\GitHub\string</span><br><span class="line">Path convoluted = p.getParent().resolve(&quot;string&quot;);</span><br><span class="line">System.out.println(convoluted);</span><br></pre></td></tr></table></figure>

<p>2️⃣Files工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取文件的字节数组：</span><br><span class="line">byte[] fileBytes = Files.readAllBytes(Paths.get(&quot;/Users/liuxuan/Downloads/test/cal.sh&quot;));</span><br><span class="line">System.out.println(new String(fileBytes));</span><br></pre></td></tr></table></figure>

<p>获取文件夹中的文件夹数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String path = &quot;/Users/liuxuan/Downloads/&quot;;</span><br><span class="line">File fileDir = new File(path);</span><br><span class="line">if (!fileDir.exists() || !fileDir.isDirectory()) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String[] fileList = fileDir.list();</span><br><span class="line">int count = 0;</span><br><span class="line">for (String file : fileList) &#123;</span><br><span class="line">    if (new File(path + file).isDirectory()) &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">File[] files = fileDir.listFiles();</span><br><span class="line">for (File file : files) &#123;</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Files实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;/Users/liuxuan/Downloads/&quot;);</span><br><span class="line">if (!Files.exists(path1) || !Files.isDirectory(path1)) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long dirCount = Files.list(path1).filter(Files :: isDirectory).count();</span><br><span class="line">System.out.println(dirCount);</span><br></pre></td></tr></table></figure>

<p>使用<code>Files.list(path)</code>需要注意，它返回的是<code>Stream&lt;Path&gt;</code>，如果没有关闭，并且代码频繁使用，将导致打开的文件过多而报错（每个进程可以打开的文件数量是有限制的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps -mlVv | grep javaTest</span><br><span class="line">lsof -p 进程id | wc -l</span><br></pre></td></tr></table></figure>

<p>所以要关闭流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.手动关闭</span><br><span class="line">Stream&lt;Path&gt; paths = Files.list(path);</span><br><span class="line">paths.close();</span><br><span class="line"></span><br><span class="line">2.try resource自动关闭流</span><br><span class="line">try(Stream&lt;Path&gt; paths = Files.list(path)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多该包下的用法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_handsome/article/details/109743637">https://blog.csdn.net/CSDN_handsome/article/details/109743637</a></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>看《java基础》<br>针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set.stream().map(i-&gt;String.valueOf(i)).</span><br><span class="line">括号内的i，表示流处理中的元素，也是lambda表达式的输入</span><br><span class="line">只有一句语句，省去了&#123;&#125;，省去了return</span><br><span class="line"></span><br><span class="line">使用现有的方法，比如上面的，可以变成lambda表达式的引用形式::</span><br><span class="line">.map(String::valueOf).</span><br><span class="line"></span><br><span class="line">上面的方法例如map()，内部的传参是只有一个函数式接口，</span><br><span class="line">有的方法穿参，除了一个函数式接口还有其他，所以会有其他参数。</span><br><span class="line">例如：</span><br><span class="line">方法：showSum(int x, int y, Calculate cu)</span><br><span class="line">使用：showSum(10, 20, (x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>



<h3 id="spring-expression-Spel表达式-java语言解析"><a href="#spring-expression-Spel表达式-java语言解析" class="headerlink" title="spring-expression Spel表达式 java语言解析"></a>spring-expression Spel表达式 java语言解析</h3><p>ExpressionParse接口是springframework包下的。<br>对表达式进行解析，通过字符串传入解析器，进行解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //将一整个语句直接定义了字符串 ,其中对字符串的开始索引与结束索引使用替代变量</span><br><span class="line">    //变量前需要加#</span><br><span class="line">    String str = &quot;#var + 2&quot;;</span><br><span class="line">    //1定义一个专属的表达式解析工具</span><br><span class="line">    ExpressionParser parser = new SpelExpressionParser() ;</span><br><span class="line">    //2定义一个表达式处理类</span><br><span class="line">    Expression exp = parser.parseExpression(str);</span><br><span class="line">    //3进行最终的表达式计算，这个上下文用来传参</span><br><span class="line">    EvaluationContext context = new StandardEvaluationContext() ;</span><br><span class="line">    context.setVariable(&quot;var&quot;, 5);</span><br><span class="line">    //4通过表达式进行结果计算</span><br><span class="line">    System.out.println(exp.getValue(context, Integer.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger类是系统底层保护的int类型，通过提供执行方法的控制进行值的原子操作。AtomicInteger它不能当作Integer来使用。</p>
<p>从JAVA 1.5开始，AtomicInteger 属于java.util.concurrent.atomic 包下的一个类。</p>
<p>AtomicInteger通过调用构造函数可以直接创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//初始值是 0</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(); </span><br><span class="line"> </span><br><span class="line">//初始值是 100</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line"> </span><br><span class="line">int currentValue = atomicInteger.get();         //100</span><br><span class="line"> </span><br><span class="line">atomicInteger.set(1234);                        //当前值1234</span><br></pre></td></tr></table></figure>

<p>什么时候用？<br>1、作为多个线程同时使用的原子计数器。<br>2、在比较和交换操作中实现非阻塞算法。</p>
<p>原子计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一些以原子方式执行加法和减法操作的方法:</span><br><span class="line">addAndGet()- 以原子方式将给定值添加到当前值，并在添加后返回新值。</span><br><span class="line">getAndAdd() - 以原子方式将给定值添加到当前值并返回旧值。</span><br><span class="line">incrementAndGet()- 以原子方式将当前值递增1并在递增后返回新值。它相当于i ++操作。</span><br><span class="line">getAndIncrement() - 以原子方式递增当前值并返回旧值。它相当于++ i操作。</span><br><span class="line">decrementAndGet()- 原子地将当前值减1并在减量后返回新值。它等同于i-操作。</span><br><span class="line">getAndDecrement() - 以原子方式递减当前值并返回旧值。它相当于-i操作。</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.addAndGet(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //102</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndAdd(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.incrementAndGet());    //105  </span><br><span class="line">        System.out.println(atomicInteger);                      //105  </span><br><span class="line">                 </span><br><span class="line">        System.out.println(atomicInteger.getAndIncrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //106</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.decrementAndGet());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //105</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndDecrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较和交换：<br>1、比较和交换操作将内存位置的内容与给定值进行比较，并且只有它们相同时，才将该内存位置的内容修改为给定的新值。这是作为单个原子操作完成的。<br>2、原子性保证了新值是根据最新信息计算出来的; 如果在此期间该值已被另一个线程更新，则写入将失败。<br><code>boolean compareAndSet(int expect, int update)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        //1、默认初始值</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">        //2、默认初始值和给定值，都是100，所以会更改成功</span><br><span class="line">        boolean isSuccess = atomicInteger.compareAndSet(100,110);   //current value 100</span><br><span class="line">        //3、返回true</span><br><span class="line">        System.out.println(isSuccess);      //true</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">        //4、默认初始值是110,给定值是100，所以会更改失败</span><br><span class="line">        isSuccess = atomicInteger.compareAndSet(100,120);       //current value 110</span><br><span class="line">        //5、返回false</span><br><span class="line">        System.out.println(isSuccess);      //false</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/073096a729f6">https://www.jianshu.com/p/073096a729f6</a></p>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>返回Class类型的对象。只是getClass()，返回当前运行时类。object.getClass()前面带对象.getClass()返回对象的类。</p>
<p>Class常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IllegalAccessException, InstantiationException, IOException &#123;</span><br><span class="line">  Class cl = getClass();</span><br><span class="line">  System.out.println(cl); //class org.example.javaer.ClassTest</span><br><span class="line">  String name = cl.getName(); // org.example.javaer.ClassTest</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  Object classTest = cl.newInstance(); //创建实例</span><br><span class="line">  String packName = cl.getPackage().getName();</span><br><span class="line">  System.out.println(packName); //org.example.javaer</span><br><span class="line">  ClassLoader classLoader = cl.getClassLoader(); //获取类加载器</span><br><span class="line">  System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">  //getResourceAsStream从项目下文件中获取输入流</span><br><span class="line">  //读取文件内容为String</span><br><span class="line">  InputStream in = cl.getResourceAsStream(&quot;/hi.md&quot;); //加&quot;/&quot;，/表示src/test/resources下（ClassPath根目录）</span><br><span class="line">  System.out.println(IOUtils.toString(in, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">  //读取为字节数组</span><br><span class="line">  byte[] bytes = IOUtils.toByteArray(in);</span><br><span class="line">  System.out.println(bytes);</span><br><span class="line"></span><br><span class="line">  InputStream in1 = cl.getResourceAsStream(&quot;src/test/resources/hi.md&quot;); //不行，NPE</span><br><span class="line">  System.out.println(IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅获取各种路径"><a href="#✅获取各种路径" class="headerlink" title="✅获取各种路径"></a>✅获取各种路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.获取ClassPath根路径（类加载根路径），到src/test/resources，两种方法</span><br><span class="line">    String path1 = getClass().getResource(&quot;/&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path1);</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + getClass().getClassLoader().getResource(&quot;&quot;)); //和上面一样</span><br><span class="line"></span><br><span class="line">    // 2.获取绝对路径</span><br><span class="line">    String path2 = getClass().getResource(&quot;&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/classes/org/example/javaer/</span><br><span class="line">    System.out.println(&quot;绝对路径：&quot; + path2);</span><br><span class="line"></span><br><span class="line">    // 3.获取项目路径 两种方法</span><br><span class="line">    File dir = new File(&quot;&quot;); //参数为空</span><br><span class="line">    String path3 = dir.getCanonicalPath(); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path3);</span><br><span class="line">    String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">    String allPath = System.getProperty(&quot;java.class.path&quot;); //所有jar包的路径</span><br><span class="line">    System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">    // 再看看</span><br><span class="line">    String path5 = getClass().getResource(&quot;/&quot;).getPath(); //这样获得的前面没有file</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path5);</span><br><span class="line">    URL url = getClass().getClassLoader().getResource(&quot;&quot;); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15057811/4080631">https://blog.51cto.com/u_15057811/4080631</a></p>
<h4 id="✅System-getProperty-方法"><a href="#✅System-getProperty-方法" class="headerlink" title="✅System.getProperty()方法"></a>✅System.getProperty()方法</h4><p>获取当前系统的版本等一些信息。<br>内部key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">String allPath = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">Java.version</span><br><span class="line">Java 运行时环境版本</span><br><span class="line">java.vendor</span><br><span class="line">Java 运行时环境供应商</span><br><span class="line">java.vendor.url</span><br><span class="line">Java 供应商的 URL</span><br><span class="line">java.home</span><br><span class="line">Java 安装目录</span><br><span class="line">java.vm.specification.version</span><br><span class="line">Java 虚拟机规范版本</span><br><span class="line">java.vm.specification.vendor</span><br><span class="line">Java 虚拟机规范供应商</span><br><span class="line">java.vm.specification.name</span><br><span class="line">Java 虚拟机规范名称</span><br><span class="line">java.vm.version</span><br><span class="line">Java 虚拟机实现版本</span><br><span class="line">java.vm.vendor</span><br><span class="line">Java 虚拟机实现供应商</span><br><span class="line">java.vm.name</span><br><span class="line">Java 虚拟机实现名称</span><br><span class="line">java.specification.version</span><br><span class="line">Java 运行时环境规范版本</span><br><span class="line">java.specification.vendor</span><br><span class="line">Java 运行时环境规范供应商</span><br><span class="line">java.specification.name</span><br><span class="line">Java 运行时环境规范名称</span><br><span class="line">java.class.version</span><br><span class="line">Java 类格式版本号</span><br><span class="line">java.class.path</span><br><span class="line">Java 类路径</span><br><span class="line">java.library.path</span><br><span class="line">加载库时搜索的路径列表</span><br><span class="line">java.io.tmpdir</span><br><span class="line">默认的临时文件路径</span><br><span class="line">java.compiler</span><br><span class="line">要使用的 JIT 编译器的名称</span><br><span class="line">java.ext.dirs</span><br><span class="line">一个或多个扩展目录的路径</span><br><span class="line">os.name</span><br><span class="line">操作系统的名称</span><br><span class="line">os.arch</span><br><span class="line">操作系统的架构</span><br><span class="line">os.version</span><br><span class="line">操作系统的版本</span><br><span class="line">file.separator</span><br><span class="line">文件分隔符（在 UNIX 系统中是“/”）</span><br><span class="line">path.separator</span><br><span class="line">路径分隔符（在 UNIX 系统中是“:”）</span><br><span class="line">line.separator</span><br><span class="line">行分隔符（在 UNIX 系统中是“/n”）</span><br><span class="line">user.name</span><br><span class="line">用户的账户名称</span><br><span class="line">user.home</span><br><span class="line">用户的主目录</span><br><span class="line">user.dir</span><br><span class="line">用户的当前工作目录</span><br></pre></td></tr></table></figure>

<h4 id="✅类加载器"><a href="#✅类加载器" class="headerlink" title="✅类加载器"></a>✅类加载器</h4><p>用来把类装载进内存的。</p>
<p>非常不错的详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_68064743/article/details/123957150">https://blog.csdn.net/m0_68064743/article/details/123957150</a></p>
<h4 id="✅getSimpleName"><a href="#✅getSimpleName" class="headerlink" title="✅getSimpleName"></a>✅getSimpleName</h4><p>Class.getSimpleName()方法返回此Class对象表示的类或接口的简单名称，作为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String className1 = SomeTest.class.getName();</span><br><span class="line">System.out.println(className1); //com.liuxuan.study.SomeTest</span><br><span class="line">String className2 = SomeTest.class.getSimpleName();</span><br><span class="line">System.out.println(className2); //SomeTest</span><br></pre></td></tr></table></figure>

<h3 id="Class-forName方法"><a href="#Class-forName方法" class="headerlink" title="Class.forName方法"></a>Class.forName方法</h3><p>Class类的静态方法forName()<br>和上面的一样，都是返回Class类型的对象，区别在于object.getClass()用于根据对象获取Class对象；Class.forName(className)用于根据类名获取Class对象。</p>
<h4 id="✅-首先讲述Class是个什么样的对象"><a href="#✅-首先讲述Class是个什么样的对象" class="headerlink" title="✅ 首先讲述Class是个什么样的对象"></a>✅ 首先讲述Class是个什么样的对象</h4><p>1、 Class类封装了类或接口的运行时状态</p>
<p>Java程序在运行时，系统一直对所有的对象进行所谓的运行时类型标识，这些标示纪录了每个对象所属的类。<br>虚拟机通常使用运行时类型信息选择正确方法去执行，用来保存这些类型信息的类是Class类。</p>
<p>2、Class类型的对象，是加载类时自动创建的</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时，由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。</p>
<p>3、虚拟机为每种类型管理一个独一无二的Class对象</p>
<p>每个类（型）都有一个Class对象。<br>运行程序时，Java虚拟机(JVM)首先检查所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<p>4、基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。</p>
<p>5、每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p>
<p>6、一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</p>
<h4 id="✅-结合反射使用举例"><a href="#✅-结合反射使用举例" class="headerlink" title="✅ 结合反射使用举例"></a>✅ 结合反射使用举例</h4><p>对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<p>getMethod()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。</p>
<p>getDeclaredMethod()对象表示的类或接口声明的所有方法,包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p>
<p>一个实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line">    private static final String defName = &quot;《程序猿植发》&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;我是静态代码块，输出: &quot; + defName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印生产日期：</span><br><span class="line">    public static String printProduceDate(String name) &#123;</span><br><span class="line">        return &quot;我是静态方法printProduceDate，输出: &quot; + name + &quot;, produce is:&quot; + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line">        System.out.println(&quot;我是Book声明的构造方法！&quot;);</span><br><span class="line">        name = defName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString(String msg) &#123;</span><br><span class="line">        return name + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">    //1-将指定类加载到JVM中（ClassNotFoundException）</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Book&quot;); //加载过程会执行static静态代码块 out：我是静态代码块，输出: 《程序猿植发》</span><br><span class="line">    System.out.println(aClass);  //out:class com.junit.demo.Book</span><br><span class="line"></span><br><span class="line">    //2.1-访问静态方法：NoSuchMethodException，InvocationTargetException</span><br><span class="line">    Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">    String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);  </span><br><span class="line">    //反射静态方法 第一个参数是Class对象(也可以传入null？) 第二个参数是输入</span><br><span class="line">    System.out.println(result); //out：我是静态方法printProduceDate，输出: 《程序猿的颈椎自传》, produce is:1626682894095</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.2-初始化对象：</span><br><span class="line">    Book obj = (Book) aClass.newInstance();  //out:我是Book声明的构造方法！</span><br><span class="line">    System.out.println(&quot;得到对象后访问get方法：&quot; + obj.toString(&quot;&quot;));  //out:得到对象后访问get方法：《程序猿植发》</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.3-初始化对象后访问方法：</span><br><span class="line">    Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">    String result3 = (String) method3.invoke(aClass.newInstance()/*obj*/, &quot;这本书是我的伙伴！&quot;); </span><br><span class="line">    //反射非静态方法，第一个参数是对象，第二个是输入。</span><br><span class="line">    System.out.println(result3); //out：《程序猿植发》这本书是我的伙伴！</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Book.class.getName()); //com.junit.demo.Book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>☝️通过反射方式访问静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 由Class获取方法：第一个参数为方法名，第二个参数为方法的参数类型。</span><br><span class="line">Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">// 引用方法：(引用实例/调用静态方法可为null，参数值/有多个用逗号隔开)，参数值要和参数类型的数量匹配！</span><br><span class="line">String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;printProduceDate&quot;, String.class).invoke(null, &quot;《程序猿的颈椎自传》&quot;);</span><br></pre></td></tr></table></figure>

<p>✌️通过反射方式访问实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//方法一：直接转化实例化后的对象，直接调用方法</span><br><span class="line">Book book= (Book) aClass.newInstance();</span><br><span class="line">// book.setName(&#x27;xxx&#x27;); or book.getName(); or more...</span><br><span class="line"></span><br><span class="line">//方法二：使用invoke调用指定实例a的指定方法b</span><br><span class="line">Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">//这里的book可以是已实例化的对象，或者使用 aClass.newInstance() 传入，详见简写：</span><br><span class="line">String result3 = (String) method3.invoke(book, &quot;这本书是我的伙伴！&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;toString&quot;, String.class).invoke(aClass.newInstance(), &quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果是类似于工具类可用于全部类访问的，可以使用一个实例化对象，而不需要每次都newInstance。</p>
<p>另外，方法一适用于需要映射的类是已知或少数时，反之需要统一按指定字符串反射调用方法的话，需使用方法二。</p>
<p>☝️通过反射方式访问私有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Netbar &#123;</span><br><span class="line">    private Double random = Math.random();</span><br><span class="line"></span><br><span class="line">    public Double getRandom() &#123;</span><br><span class="line">        return random;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Netbar createNew() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Netbar getInstance() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Netbar netbar = new Netbar();</span><br><span class="line">        System.out.println(&quot;Random:: &quot; + netbar.getRandom());</span><br><span class="line">        Netbar netbar2 = netbar.createNew();</span><br><span class="line">        System.out.println(&quot;Random2:: &quot; + netbar2.getRandom());</span><br><span class="line">        Netbar netbar3 = Netbar.getInstance();</span><br><span class="line">        System.out.println(&quot;Random3:: &quot; + netbar3.getRandom());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有非静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;createNew&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(aClass.newInstance()); //传入对象</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;getInstance&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(null);  //静态方法可以传入null</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：Java之Class.forName方法详解：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26599807/article/details/118900090">https://blog.csdn.net/qq_26599807/article/details/118900090</a></p>
<h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><p>首先，浅拷贝和深拷贝都是针对一个已有对象的操作。</p>
<p>在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象（引用数据类型）。而一般使用 『 = 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(12345);</span><br><span class="line">    Student stu2 = stu1;</span><br><span class="line">    stu2.setNumber(54321);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2.getNumber());  //改2，1跟着也改了</span><br><span class="line">    //原因出在(stu2 = stu1) 这一句。</span><br><span class="line">    //该语句的作用是将stu1的引用赋值给stu2。其实，stu1和stu2在堆内存中指向的是同一个对象</span><br><span class="line"></span><br><span class="line">    // 2.新建一个，再set</span><br><span class="line">    Student stu3 = new Student();</span><br><span class="line">    stu3.setNumber(stu1.getNumber());</span><br><span class="line">    stu3.setNumber(111);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生3:&quot; + stu3.getNumber());  //改2，1不会跟着也改了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。</p>
<p>所谓的浅拷贝和深拷贝，只是在拷贝对象的时候，对 类的实例对象 这种引用数据类型的不同操作而已。</p>
<p>总结来说：</p>
<p>1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p>Object 上的 clone() 方法<br>在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。<br>而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。</p>
<p>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常) 该接口为标记接口(不含任何方法)<br>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象（native为本地方法)</p>
<hr>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hongshi/p/16189920.html">https://www.cnblogs.com/hongshi/p/16189920.html</a></p>
<h4 id="✅浅拷贝"><a href="#✅浅拷贝" class="headerlink" title="✅浅拷贝"></a>✅浅拷贝</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    //ClassTest.Student(number=1, name=ll, teacher=ClassTest.Teacher(age=24)) hashCode:1407343478</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    //ClassTest.Student(number=2, name=oo, teacher=ClassTest.Teacher(age=24)) hashCode:1940447180</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">    //teacher的hashCode：83 83</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">    //浅拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面的Teacher对象，实际上还是指向了同一个对象，只对对它的引用进行了传递。</p>
<p>注意⚠️：String作为不可更改的类（immutable class），在new赋值的时候，就已经创建了一个新的对象；表现出来的是深拷贝（和基本数据类型一样）。</p>
<h4 id="✅深拷贝"><a href="#✅深拷贝" class="headerlink" title="✅深拷贝"></a>✅深拷贝</h4><p>两种方法：<br>1、序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。<br>2、继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。也就是让Teacher类也实现Cloneable接口，重写clone方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">//        //浅拷贝</span><br><span class="line">//        @Override</span><br><span class="line">//        public Object clone() &#123;</span><br><span class="line">//            try&#123;</span><br><span class="line">//                return super.clone();</span><br><span class="line">//            &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            return null;</span><br><span class="line">//        &#125;</span><br><span class="line">    //深拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Student stu = (Student)super.clone();</span><br><span class="line">            stu.setTeacher((Teacher)this.teacher.clone());</span><br><span class="line">            return stu;</span><br><span class="line"></span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher implements Cloneable&#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanUtils-copyProperties"><a href="#BeanUtils-copyProperties" class="headerlink" title="BeanUtils.copyProperties"></a>BeanUtils.copyProperties</h4><p><code>BeanUtils.copyProperties（source,target）</code>有两个参数，用于将事件源的数据拷贝到目标源中。BeanUtils有两个，一个是spring的，一个是apache的commons下的。用法一样，但是两者的区别在于：一个是将前者拷贝给后者，另一个是将后者拷贝给前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student studentOne  = new StudentOne(&quot;张三&quot;);</span><br><span class="line">Student studentTwo  = new StudentOne();  //先新建一个要拷贝出来的对象</span><br><span class="line">//BeanUtils.copyProperties是将studentOne的数据拷贝给studentTwo</span><br><span class="line">BeanUtils.copyProperties(studentOne, studentTwo);</span><br><span class="line">//spring的第一个是输入，第二个谁输出</span><br></pre></td></tr></table></figure>

<p>如果两个类不一样时，只会拷贝属性一样的内容。<br>使用场景：开发中经常遇到，把父类的属性拷贝到子类中。<br>BeanUtils是浅拷贝。浅拷贝：引用的一个内存地址)。</p>
<p>通常用于转换器Convertor，用来转换一个类的对象为另一个类的对象，重写里面的convert方法来用。</p>
<h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><h4 id="hashcode-1"><a href="#hashcode-1" class="headerlink" title="hashcode"></a>hashcode</h4><p>1、hash和hash表是什么？</p>
<blockquote>
<p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值。</p>
</blockquote>
<p>2、hashcode　</p>
<blockquote>
<p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。<br>每个对象都有hashcode，对象的hashcode怎么得来的呢？<br>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？<br>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。所以，hashcode是什么呢？就是在hash表中对应的位置。</p>
</blockquote>
<blockquote>
<p>这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p>
</blockquote>
<p>3、hashcode有什么作用</p>
<blockquote>
<p>为什么hashcode不直接写物理地址呢，还要另外用一张hash表来代表对象的地址？<br>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)<br>为什么hashcode就查找的更快，比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。<br>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果没一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，所以比较的次数会让你觉得也挺多的，实际上，如果hash表很大，那么比较的次数就很少很少了。<br>通过对原始方法和使用hashcode方法进行对比，我们就知道了hashcode的作用，并且为什么要使用hashcode了</p>
</blockquote>
<p>4、equals方法和hashcode的关系</p>
<blockquote>
<p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p>
</blockquote>
<blockquote>
<p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p>
</blockquote>
<blockquote>
<p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同<br>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
</blockquote>
<p>5、为什么equals方法重写的话，建议也一起重写hashcode方法</p>
<blockquote>
<p>比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。</p>
</blockquote>
<p>Integer的重写方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;  // 变成比较Integer内部的final int常量的值是否相等</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hashCode方法也是用的值</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Integer.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int hashCode(int value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode是用于查找使用的，而 equals是用于比较两个对象的是否相等的。hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的.</p>
<p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致.</p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44364444/article/details/120054230">https://blog.csdn.net/weixin_44364444/article/details/120054230</a></p>
<h4 id="java变量地址"><a href="#java变量地址" class="headerlink" title="java变量地址"></a>java变量地址</h4><p>java的变量不能直接获取真实的地址，只能使用<code>System.out.println(obj.hashcode())</code>输出的时对象的哈希码，而非内存地址。</p>
<p>在Java中是不可能得到对象真正的内存地址的，因为Java中堆是由JVM管理的不能直接操作。只能说此时打印出的Hash码表示了该对象在JAVA虚拟机中的内存位置，Java虚拟机会根据该hash码最终在真正的的堆空间中给该对象分配一个地址.</p>
<p>要想得到变量在物理内存中的真实地存，那只有用JNI技术调用c/c++去实现，否则无能为力，因为java超不出JVM，而JVM对物理内存地址是“不可见”的，否则java中不就有了指针，而去直接操作内存了，当然这是与java语言相违背的。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feng3702592/article/details/126722686">https://blog.csdn.net/feng3702592/article/details/126722686</a></p>
<h4 id="、equals、hashCode"><a href="#、equals、hashCode" class="headerlink" title="==、equals、hashCode"></a>==、equals、hashCode</h4><p>1、==对于普通变量是值比较，对于包装类型变量，是内存地址比较，也就是比较是不是同一个对象。</p>
<p>2、包装类型重写了equals方法，变成了值比较。</p>
<p>3、hashCode表示在hash表中的位置。equals一样，那么hashCode一定一样。（只要值是一样的，hashCode就会是相同的。）<br>原因：尽管不同的数值类型的包装类，计算hashCode的算法不一样，但是底层都是拿对应的原始数据类型的值去进行hashCode计算。<br>反过来：</p>
<p>4、同一个对象的，hashCode值一定相同，但是 hashCode相同，不一定是同一个对象，也不一定equals为true。</p>
<p>关系：同一个对象（==）最小的圈，equals为true中间圈，hashCode一样最大圈。<code>（equals要看重写了没有，不重写就是==）</code></p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-24 00:45</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> *hashCode相同，不一定是同一个对象</span><br><span class="line"> *同一个对象的，hashCode值一定相同</span><br><span class="line"> *</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *普通对象的HashCode值源码解释：</span><br><span class="line"> * equals相同则hashCode一定一样</span><br><span class="line"> *If two objects are equal according to the equals(Object) method, then calling</span><br><span class="line"> *the hashCode method on each of the two objects must produce the same integer result.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *equals不一样，hashCode不一定不一样</span><br><span class="line"> * It is not required that if two objects are unequal according to the</span><br><span class="line"> *java.lang.Object.equals(java.lang.Object) method, then calling the hashCode</span><br><span class="line"> *method on each of the two objects must produce distinct integer results.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *However, the programmer should be aware that producing distinct integer results</span><br><span class="line"> *for unequal objects may improve the performance of hash tables.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;--------------------普通对象-----------------------&quot;);</span><br><span class="line">        HashCodeTest test3=new HashCodeTest();</span><br><span class="line">        HashCodeTest test4=new HashCodeTest();</span><br><span class="line">        System.out.println(test3.equals(test4));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test3.hashCode() == test4.hashCode());//false</span><br><span class="line"></span><br><span class="line">        HashCodeTest test1=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        HashCodeTest test2=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        System.out.println(test1.equals(test2));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test1.hashCode() == test2.hashCode());//false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------String-----------------------&quot;);</span><br><span class="line">        String s1=&quot;abc&quot;;</span><br><span class="line">        String s2=&quot;abc&quot;;</span><br><span class="line">        System.out.println(s1.equals(s2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s1.hashCode() == s2.hashCode());//true</span><br><span class="line">        System.out.println(s1==s2); //true(是一个对象)</span><br><span class="line"></span><br><span class="line">        String s5=new String(&quot;abc&quot;);</span><br><span class="line">        String s6=new String(&quot;abc&quot;);</span><br><span class="line">        System.out.println(s5.equals(s6));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s5.hashCode() == s6.hashCode());//true</span><br><span class="line">        System.out.println(s5==s6); //false(不是一个对象)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String s3=new String();</span><br><span class="line">        String s4=new String();</span><br><span class="line">        System.out.println(s3.hashCode());//0</span><br><span class="line">        System.out.println(s4.hashCode());//0</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 数值型原始类型对应的包装类(Byte,Short,Integer,Float,Double)，hashCode算法都是基于</span><br><span class="line">         * 对应的原始数据类型，所以只要包装类的数值相同，那么hashCode必然相同</span><br><span class="line">         *</span><br><span class="line">         * Double类关于hashCode源码说明：</span><br><span class="line">         * Double类的hashCode是根据对应的double值计算获得的。</span><br><span class="line">         *</span><br><span class="line">         * Returns a hash code for a &#123;@code double&#125; value; compatible with</span><br><span class="line">         * &#123;@code Double.hashCode()&#125;.</span><br><span class="line">         *</span><br><span class="line">         * @param value the value to hash</span><br><span class="line">         * @return a hash code value for a &#123;@code double&#125; value.</span><br><span class="line">         * @since 1.8</span><br><span class="line">         */</span><br><span class="line">        /*Double类关于hashCode源码：</span><br><span class="line">         * public static int hashCode(double value) &#123;</span><br><span class="line">            long bits = doubleToLongBits(value);</span><br><span class="line">            return (int)(bits ^ (bits &gt;&gt;&gt; 32));</span><br><span class="line">        &#125;*/</span><br><span class="line">        System.out.println(&quot;--------------------原始类型对应的包装类-----------------------&quot;);</span><br><span class="line">        Double d1=5.0;</span><br><span class="line">        Double d2=5.0;</span><br><span class="line">        System.out.println(d1.equals(d2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d1.hashCode() == d2.hashCode());//true</span><br><span class="line">        System.out.println(d1==d2);//false (？？？为啥是false，和String不一样)</span><br><span class="line"></span><br><span class="line">        Double d3=new Double(5.0);</span><br><span class="line">        Double d4=new Double(5.0);</span><br><span class="line">        System.out.println(d3.equals(d4));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d3.hashCode() == d4.hashCode());//true</span><br><span class="line">        System.out.println(d3==d4);//false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未解：<code>Double d1=5.0; Double d2=5.0</code> 不是共用一个对象。但是<code>String s1=&quot;1&quot;; String s2=&quot;1&quot;</code>是共用。</p>
<h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><p>背景：代码中需要捕获到专门的异常进行特殊处理，主要是为了不影响主流程，该用try…catch，是在调用的时候catch，还是在调用方法里catch？<br>🤔如果是只想在这次调用时补货异常就在调用处使用，如果是想把方法包装好随意调用不发生异常就在方法里捕获。作用是：发生异常了不中断流程，只是打个error log之类的。如果不加，就是自动抛出throws异常了。</p>
<p>背景：里面方法的异常，外面方法能不能catch到？里面方法也catch了，外面方法还能不能catch到？<br>🤔里面方法没有catch异常的话，外面方法是能捕获到的，并且运行时异常不用在里面的方法上加throws，外面方法就能捕获到。编译时异常必须做：catch住处理或者throw + throws，或者直接throws出去，这样才能在外面方法捕获到。如果里面方法捕获了异常，但是没throw出去（运行时异常throw了不需要throws，编译时异常throw了还需要throws），外面方法就捕获不到这个异常。</p>
<p>背景：什么时候需要在方法上throws异常，一定要throws吗？<br>🤔运行时异常，可以不在方法上throws，虚拟机会自动捕获抛出去。编译时异常通常在编译时就要求throws出去异常，或者用try…catch进行异常处理（打log之类）。</p>
<p>背景：什么时候需要try..catch..throw..throws<br>🤔首先运行时异常可以不throws，如果没有try..catch，会自动throws出去，所以如果不是try..catch..对特殊异常捕获，没必要try..catch..throws。编译型异常如果是try..catch..打log了，就不用throws了。如果想抛出去，就直接throws就行。所以不需要try..catch..throw..throws。如果即想用try..catch..finally..还想throws出去，就用。</p>
<h4 id="✅java的异常体系"><a href="#✅java的异常体系" class="headerlink" title="✅java的异常体系"></a>✅java的异常体系</h4><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p><img src="https://img-blog.csdnimg.cn/2019101117003396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MjI5NTY3,size_16,color_FFFFFF,t_70"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1/0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常，编译时异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<hr>
<p>Error是java程序运行中不可预料的异常情况（正常情况下不大可能出现的情况），这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。【表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误 ，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形.应用程序不应该抛出这种类型的对象(一般是由虚拟机抛出).假如出现这种错误,除了尽力使程序安全退出外,在其他方面是无能为力的。】</p>
<p>Exception：<br>1．可以是可被控制(checked) 或不可控制的(unchecked)。<br>2．表示一个由程序员导致的错误。<br>3．应该在应用程序级被处理。<br>Error：<br>1．总是不可控制的(unchecked)。<br>2．经常用来用于表示系统错误或低层资源的错误。<br>3．如何可能的话，应该在系统级被捕捉。</p>
<hr>
<h4 id="✅常见的-Error-和-Exception："><a href="#✅常见的-Error-和-Exception：" class="headerlink" title="✅常见的 Error 和 Exception："></a>✅常见的 Error 和 Exception：</h4><p>1）运行时异常（RuntimeException）也称 【非检查型异常 UncheckedException】：</p>
<p>Nullpointer Exception：空指针异常；<br>ClassCastException：类型强制转换异常<br>IllegalArgumentException：传递非法参数异常<br>IndexOutOfBoundsException：下标越界异常<br>NumberFormatException：数字格式异常<br>ArrayIndexOutOfBoundsException: 数组越界异常<br>ArrayStoreException: 数据存储异常，操作数组时类型不一致<br>ArithmeticException： (算术异常)<br>BufferOverflowException： (缓冲区溢出异常)</p>
<p>2）非运行时异常（CheckedException）也称 【检查型异常】：</p>
<p>ClassNotFoundException：找不到指定 class 的异常<br>IOException：IO 操作异常<br>FileNotFoundException：文件不存在异常<br>SQLException：SQL语句异常<br>InterruptedException： (中断异常-调用线程睡眠时候)</p>
<p>3）错误（Error）：</p>
<p>NoClassDefFoundError：找不到 class 定义异常<br>StackOverflowError：深递归导致栈被耗尽而抛出的异常<br>OutOfMemoryError：内存溢出异常</p>
<h4 id="✅遇到的异常记录"><a href="#✅遇到的异常记录" class="headerlink" title="✅遇到的异常记录"></a>✅遇到的异常记录</h4><h4 id="ExecutionException"><a href="#ExecutionException" class="headerlink" title="ExecutionException"></a>ExecutionException</h4><p>future.get()抛出的，ExecutionException包装正在执行的线程抛出的任何异常。没明白，应该是个检查型异常。是必须要程序员处理的。</p>
<p><a target="_blank" rel="noopener" href="https://www.orcode.com/question/618888_kb0916.html">https://www.orcode.com/question/618888_kb0916.html</a><br><a target="_blank" rel="noopener" href="https://www.mianshigee.com/question/91669mas/">https://www.mianshigee.com/question/91669mas/</a></p>
<h4 id="InterruptException"><a href="#InterruptException" class="headerlink" title="InterruptException"></a>InterruptException</h4><p>future.get()会抛出，Thread.sleep也会抛出。<br>当线程正在等待、休眠或以其他方式被占用，并且线程在活动之前或活动期间被中断时抛出。 有时，方法可能希望测试当前线程是否被中断，如果是，则立即抛出此异常。<br>活动线程的执行中断行为，可以抛出这样的异常。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/kevinmeanscool/article/details/123566970">https://blog.csdn.net/kevinmeanscool/article/details/123566970</a></p>
<h4 id="java-lang-NoClassDefFoundError"><a href="#java-lang-NoClassDefFoundError" class="headerlink" title="java.lang.NoClassDefFoundError"></a>java.lang.NoClassDefFoundError</h4><p>NoClassDefFoundError可能出现的情况<br>目前有发现几种情况<br>1.一种情况就是因为静态变量加载不到原因<br>2.工程里没有将jar添加到classpath，maven项目的，需要根据项目情况排查</p>
<p>实际原因：在报错的test类所在的包里，没有引某个包，导致找不到某类。<br>首先用：<code>mvn dependency:tree</code>，查看依赖jar的关系，看一下这个类的包是哪个，引用了没。<br>发现在父pom里有这个包，但是在报错的包里没有用父pom，也没引那个包。<br>所以，在报错的包的pom里，引用那个包就解决。</p>
<h4 id="NoUniqueBeanDefinitionException"><a href="#NoUniqueBeanDefinitionException" class="headerlink" title="NoUniqueBeanDefinitionException"></a>NoUniqueBeanDefinitionException</h4><p>不唯一的bean定义异常<br>没有一个合适的bean类型（cn.cy.bean.Tool）可用，预期有一个单独的匹配的bean，但是找到了多个。</p>
<p>看看是不是一个接口有多个实现类，然后在某类中注入该接口中没有指定注入哪个。</p>
<blockquote>
<p>通常如果一个接口多个实现类，会根据条件Enum选择哪个类执行的话，加一个ServiceFacade类来根据条件选择，这个类实现Service接口和InitializingBean接口，里面定义一个map&lt;Enum, 接口Service&gt;，在使用到实现类的方法中，注入ServiceFacade就行。</p>
</blockquote>
<p>解决方法：<br>1、注入接口的地方 <code>@Autowired + @Qualifer(&quot;whichImpl&quot;)</code><br>2、注入接口的地方 <code>@Resource(name=&quot;whichImpl&quot;)</code></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46030002/article/details/125661107">https://blog.csdn.net/weixin_46030002/article/details/125661107</a></p>
<h4 id="BeanCreationException"><a href="#BeanCreationException" class="headerlink" title="BeanCreationException"></a>BeanCreationException</h4><p>Bean创建过程中抛出异常。具体有以下几种常见异常，包括上面的NoUniqueBeanDefinitionException 也是一种。</p>
<p>1.org.springframework.beans.factory.NoSuchBeanDefinitionException</p>
<p>上下文中不存在此Bean，一般原因在没有声明Bean，BeanA尝试注入BeanB，但是spring上下文中不存在BeanB。检查是否用@Component @Service @Controller @Repository 注入了bean。</p>
<p>2.org.springframework.beans.factory.NoUniqueBeanDefinitionException</p>
<p>当一个Bean有多个实现，例如BeanB1 和BeanB2都实现了同一个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BeanB1 implements IBeanB &#123; ... &#125;</span><br><span class="line">@Component</span><br><span class="line">public class BeanB2 implements IBeanB &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">@Component</span><br><span class="line">public class BeanA &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private IBeanB dependency;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.org.springframework.beans.BeanInstantiationException</p>
<p>Bean 实例化过程中出现异常，具体原因需要查看nested exception后面报错</p>
<p>3.1 Custom Exception<br>业务自定义抛出异常，如下抛出空指针异常</p>
<p>3.2 java.lang.InstantiationException<br>在xml配置中使用抽象类定义bean</p>
<p>3.3 java.lang.NoSuchMethodException<br>如果一个bean类没有默认的构造方法，spring在创建bean实例时.</p>
<p>4.org.springframework.beans.factory.CannotLoadBeanClassException</p>
<p>当spring加载不到bean对应的类文件时，这种异常将会被抛出。这种情况很有可能发生在当配置文件中的类路径全称找不到对应文件时。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37578675/article/details/117075030">https://blog.csdn.net/m0_37578675/article/details/117075030</a></p>
<hr>
<h4 id="✅NoClassDefFoundError-和-ClassNotFoundException-的区别："><a href="#✅NoClassDefFoundError-和-ClassNotFoundException-的区别：" class="headerlink" title="✅NoClassDefFoundError 和 ClassNotFoundException 的区别："></a>✅NoClassDefFoundError 和 ClassNotFoundException 的区别：</h4><p>区别一：<br>NoClassDefFoundError它是Error，<br>ClassNotFoundException是Exception。</p>
<p>区别二：<br>NoClassDefFoundError是JVM运行时通过classpath加载类时，找不到对应的类而抛出的错误。<br>ClassNotFoundException是编译时异常，在编译过程中必须将ClassNotFoundException异常抛出！</p>
<p>NoClassDefFoundError发生场景如下：<br>1、类依赖的class或者jar不存在 （简单说就是maven生成运行包后被篡改）<br>2、类文件存在，但是存在不同的域中 （简单说就是引入的类不在对应的包下)<br>3、大小写问题，javac编译的时候是无视大小的，很有可能你编译出来的class文件就与想要的不一样！这个没有做验证？？？</p>
<p>ClassNotFoundException发生场景如下：<br>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>举例说明如下:<br>Class.forName(“abc”); 比如abc这个类不存项目中，代码编写时，就会提示此异常是检查性异常，比如将此异常抛出。</p>
<hr>
<h4 id="✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别："><a href="#✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别：" class="headerlink" title="✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别："></a>✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别：</h4><p>1:checked （检查型异常）也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。编译器要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，<br>另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try …catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法名的后边，eg:  方法名（） throws  IOExecption。</p>
<p>理解：检查型异常，要么：try… catch.. 打log，要么：try..catch..throw..throws（多此一举，没必要），要么只是throws。</p>
<p>2:runtime exception（运行时异常），编译器不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try …catch）,会直接throws出去，如果不想throws出去，就try catch 打log。<br>如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。  当出现这样的异常时，总是由虚拟机接管。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangbaolong/p/12884224.html">https://www.cnblogs.com/liangbaolong/p/12884224.html</a></p>
<hr>
<h4 id="✅多异常捕获："><a href="#✅多异常捕获：" class="headerlink" title="✅多异常捕获："></a>✅多异常捕获：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; catch(NullPointerException | IOException e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| 符合 可以 写多个，符合其中之一。<br>注意要把异常范围小的放在前面，范围大的放在后面。<br>⚠️注意在try内return或者break了，finally也会执行的。</p>
<h4 id="catch-Exeception-e-和catch-Throwable-e"><a href="#catch-Exeception-e-和catch-Throwable-e" class="headerlink" title="catch(Exeception e)和catch(Throwable e)"></a>catch(Exeception e)和catch(Throwable e)</h4><p>Throwable可以捕获Error和Exception两大类的异常，其中Error是比较严重不可控的异常。而Exception是可以被编程处理的异常。<br>Exception只能捕获RuntimeException和IOException。</p>
<p>回顾一下java的异常体系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Throwable: Java中所有异常和错误类的父类。只有这个类的实例（或者子类的实例）可以被虚拟机抛出或者被java的throw关键字抛出。同样，只有其或其子类可以出现在catch子句里面。</span><br><span class="line">Error: Throwable的子类，表示严重的问题发生了，而且这种错误是不可恢复的。</span><br><span class="line">Exception: Throwable的子类，应用程序应该要捕获其或其子类（RuntimeException例外），称为checked exception。比如：IOException, NoSuchMethodException...</span><br><span class="line">RuntimeException: Exception的子类，运行时异常，程序可以不捕获，称为unchecked exception。比如：NullPointException.</span><br></pre></td></tr></table></figure>

<p>❓应该catch (Throwable th) 还是 catch (Exception)?</p>
<p>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。第一种catch相当于比第二种catch多捕捉了把Error和其子类。</p>
<p>❓Error是否需要捕捉?</p>
<p>JDK中Error类的的注释里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)”来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。</p>
<p>❓Error可以catch吗？ 可以catch了后做些其他处理吗？</p>
<p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p>
<p>假设进行网络连接操作的时候，IOException 发生了，可能是网络中断，我可以再尝试几次。</p>
<p>假设OutOfMemoryError发生了，就算被捕捉了，可以有什么手段让程序正常运行下去吗？ 假设ExceptionInInitializerError发生了，类无法被正常初始化，这个是可以通过捕捉来恢复的吗？</p>
<p>👌结论：Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用</p>
<p>转自：如何处理异常? catch Exception OR catch Throwable<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/smile361/p/5521278.html">https://www.cnblogs.com/smile361/p/5521278.html</a></p>
<p>举一个用<code>catch (Throwable e)</code>的例子：<br>目的是确保异常被打印，一个无线递归，导致的StackOverflowError</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Throwable_demo &#123;</span><br><span class="line">    static void generate_throwable() &#123;</span><br><span class="line">        generate_throwable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //此种情形下我们要catch Throwable, 以确保异常被打印...</span><br><span class="line">        try &#123;</span><br><span class="line">            final int[] times = &#123; 0 &#125;;</span><br><span class="line">            Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        ++times[0];</span><br><span class="line">                        System.out.println(times[0]);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(10);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread1.start();</span><br><span class="line">            generate_throwable();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            //若catch的是Exception：</span><br><span class="line">            //因finally中的exit指令，在打印异常前程序就会终止。</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;end.&quot;);</span><br><span class="line">            //如果不exit: 因 thread1 未停止，程序不会终止。</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅项目中的自定义异常"><a href="#✅项目中的自定义异常" class="headerlink" title="✅项目中的自定义异常"></a>✅项目中的自定义异常</h4><p>继承RuntimeException扩展一个新的异常作为整个类库的异常基类。<br>里面定义异常编码啥的。</p>
<p>如果需要根据异常进行不同的处理，建议给自定义异常增加一个ERROR_CODE字段，这样无论在服务器还是客户端都可以根据不同的ERROR_CODE进行对应的处理。但是出现这种情况的时候，应该需要考虑一下设计思路了，一般来讲根据异常来决定业务流程不是一个好的设计方案。</p>
<h4 id="✅e-getMeasage-和e-toString"><a href="#✅e-getMeasage-和e-toString" class="headerlink" title="✅e.getMeasage()和e.toString()"></a>✅e.getMeasage()和e.toString()</h4><p>e.getMeasage()返回异常的简短描述信息，是一个字符串。<br>e.toString()返回异常的详细信息，包括异常类型和异常消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">空指针：</span><br><span class="line">message:null</span><br><span class="line">toString:java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList线程安全问题"><a href="#ArrayList线程安全问题" class="headerlink" title="ArrayList线程安全问题"></a>ArrayList线程安全问题</h3><p>ArrayList 是线程不安全的集合类，当多线程环境下，并发对同一个ArrayList执行add，可能会丢数据。如果多线程又是add，又是输出list，会发生并发错误。</p>
<p>⚠️为什么说可能呢，因为有时候add得太快，就没出问题。</p>
<blockquote>
<p>ConcurrentModificationException: 并发修改异常<br>    使用迭代器循环，在循环中用ArrayList的add/remove方法会出现该异常。原因及解决方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013168615/article/details/116570591">https://blog.csdn.net/u013168615/article/details/116570591</a></p>
</blockquote>
<hr>
<p>多线程对List进行add又遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 1; i &lt;= 30; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(0, 8));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread.sleep(60 * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常：Exception in thread “Thread-0” java.util.ConcurrentModificationException</p>
<h4 id="✅ArrayList为什么线程不安全"><a href="#✅ArrayList为什么线程不安全" class="headerlink" title="✅ArrayList为什么线程不安全"></a>✅ArrayList为什么线程不安全</h4><p>多线程对ArrayList进行add有可能会造成数据丢失。也有可能会造成数组越界。</p>
<blockquote>
<p>线程安全：指当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染等意外情况。</p>
<p>线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染等意外情况。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line"> implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 列表元素集合数组如果新建ArrayList对象时没有指定大小，那么会将 </span><br><span class="line">    * EMPTY_ELEMENTDATA赋值给elementData，</span><br><span class="line">    * 并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY </span><br><span class="line">    */</span><br><span class="line">    transient Object[] elementData; </span><br><span class="line">    // 列表大小，elementData中存储的元素个数</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的实现主要就是：<br>1️⃣用了一个 Object 的数组，用来保存所有的元素；<br>2️⃣一个 size 变量用来保存当前数组中已经添加了多少元素。</p>
<p>ensureCapacityInternal() 的作用就是如果将当前的新元素加到列表后面，判断列表的 elementData 数组的大小是否满足。如果 size + 1 的这个需求长度大于 elementData 这个数组的长度，那么就要对这个数组进行扩容。由此看到 add 元素时，实际有两个大的步骤：<br>1️⃣判断 elementData 数组 capacity 容量是否满足需求，是否需要扩容。<br>2️⃣在 elementData 对应位置上设置值。<br><code>这样就出现了第一个导致线程不安全的隐患，在多个线程进行 add 操作时可能会导致 elementData 数组越界。</code></p>
<hr>
<p>为什么会数组越界ArrayIndexOutOfBoundsException？</p>
<p>ArrayList 默认数组大小为 10。假设现在已经添加进去 9 个元素了，size = 9。</p>
<p>1、线程 A 执行完 add 方法中的 ensureCapacityInternal(size+1) 挂起了。<br>2、线程 B 开始执行，校验数组容量发现不需要扩容。于是把 “b” 放在了下标为 9 的位置，且 size 自增 1。此时 size = 10。<br>3、线程 A 接着执行，尝试把 “a” 放在下标为 10 的位置，因为 size = 10。但因为数组还没有扩容，最大的下标才为 9，所以会抛出数组越界异常ArrayIndexOutOfBoundsException。</p>
<hr>
<p>为什么会数据丢失？</p>
<p>ArrayList线程不安全，当一条线程执行list.add()的时候会出现被另一条线程的值覆盖，比如线程A对list进行add，携带的size是n，同时线程B也进行add操作，携带的size也是n，所以ArrayList没有达到扩容的条件，A的值应该放在ArrayList的第n位，但是B的值也将放在第n位，覆盖了A的值，导致数据丢失。</p>
<p>源码：<br>第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这里可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：<br>elementData[size] = e;<br>size = size + 1;</p>
<p>ArrayList 为什么线程不安全：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChineseSoftware/article/details/117047757">https://blog.csdn.net/ChineseSoftware/article/details/117047757</a></p>
<hr>
<p>ArrayList的所有方法都没有加Lock，也没有加synchronized，因此在并发操作下，扩容函数grow()会存在问题。</p>
<p>举个简单的例子：<br>elementData数组刚刚添加了最后一个元素，也就是刚好满员了<br>这时2个线程同时又调用了add，那么就必须要执行grow进行扩容<br>第1个线程调用完grow()，然后也调用了elementData[size++] = e，把新元素添加上去<br>第2个线程又调用一次grow()，整个elementData数组就乱掉了。</p>
<h4 id="✅多线程情况下该用什么："><a href="#✅多线程情况下该用什么：" class="headerlink" title="✅多线程情况下该用什么："></a>✅多线程情况下该用什么：</h4><p>1、使用 Vector 初始化 list 对象，效率低<br><code>List&lt;String&gt; list = new Vector&lt;&gt;();</code><br>Vector.add使用了synchronized加锁<br>转换成ArrayList：<br><code>List&lt;String&gt; newList = new ArrayList&lt;String&gt;(vector);</code></p>
<p>2、使用 Collections.synchronizedList<br><code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code><br><code>List&lt;String&gt; list = Collections.synchronizedList(Lists.newArrayList());</code><br>add方法同样加了 synchronized 锁。</p>
<p>3、使用 CopyOnWriteArrayList<br><code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></p>
<p>写时复制，即向一个容器添加元素的时候，不直接向当前容器添加，而是将当前容器进行复制，然后向新容器进行添加操作，最后将原容器的引用指向新的容器。</p>
<p>这样的好处是允许并发的读而不需要加锁（因为容器内元素未发生变化），提升效率，仅写时上锁，读和写再不同的容器中，体现了读写分离的思想 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fhblikesky/p/13692641.html">https://www.cnblogs.com/fhblikesky/p/13692641.html</a></p>
<h4 id="✅list的ConcurrentModificationException问题"><a href="#✅list的ConcurrentModificationException问题" class="headerlink" title="✅list的ConcurrentModificationException问题"></a>✅list的ConcurrentModificationException问题</h4><p>除了多线程修改ArrayList的操作会造成该问题之外，在迭代器中用list.add或list.remove去添加删除list元素，也会造成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = myList.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Iterator it = myList.iterator(); it.hasNext();) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (String value : myList) &#123;</span><br><span class="line">    System. out.println( &quot;List Value:&quot; + value);</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>原因看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出</li>
<li>lastRet：表示上一个访问的元素的索引</li>
<li>expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。</li>
<li>modCount: 是在 ArrayList 中赋值的，并且初始值为 0，在 add 和 remove 的时候（修改元素的时候）会增加 1.</li>
</ul>
<p>hasNext方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasNext 方法，在方法中的 size 是 ArrayList 中的变量，这个 ConcurrentModificationException 异常存在的原因之一就在这个方法体现出来了，在多线程的情况下，如果使用迭代器遍历时，ArrayList数组元素变少导致 cursor &gt; size，然后数组越界。在正常情况下当 cursor == size代表已经到数组尽头了.</p>
<p>next 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    int i = cursor;</span><br><span class="line">    if (i &gt;= size)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">    if (i &gt;= elementData.length)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    cursor = i + 1;</span><br><span class="line">    return (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next 方法中先是判断了 modCount 是否等于 expectedModCount，不相等则抛出 并发修改异常，否则取到游标，然后判断游标是否大于数组长度或者元素个数。最后游标加一，然后返回数的同时使 lastRet 等于 i。</p>
<p>remove方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList.this.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 remove 掉元素的时候更新下自己的 expectedModCount。注意的是remove后 lastRet 会变成 -1，也就是不能连续 remove 两次，因为在 next 中检查了 lastRet 的值不能小于 0。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">if (modCount != expectedModCount)</span><br><span class="line">throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当modCount != expectedModCount时，执行next()就会抛出ConcurrentModificationException<br>而什么时候会造成modCount != expectedModCount呢？<br>ArrayList.add()和remove()方法，每执行一次都会modCount++，但不改变expectedModCount的值。expectedModCount的值是在构建迭代的时候初始为expectedModCount=modCount的。<br>在构建迭代器之后，再使用ArrayList.add()方法就造成了modCount != expectedModCount<br>构建迭代器后，用迭代器来add和remove就没有问题。因为它会在改变modCount的值之后，又把值赋给了expectedModCount，从而保证modCount=expectedModCount</p>
<hr>
<p>解决方法：用迭代器的remove方法<br>多线程情况下，iterator是线程私有，也即是说expectedModCount是每个线程私有。使用Vector也不行。<br>所以：<br>在使用iterator迭代的时候使用synchronized或者Lock进行同步。不推荐，因为增删造成的同步锁可能会阻塞遍历操作。<br>使用并发容器CopyOnWriteArrayList或者ConcurrentHashMap代替ArrayList和Vector。CopyOnWriteArrayList不能使用Iterator.remove()进行删</p>
<p>ConcurrentModificationException异常原因和解决方法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44613591/article/details/114108920">https://blog.csdn.net/qq_44613591/article/details/114108920</a></p>
<p>Java 遍历List ConcurrentModificationException 异常解析：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30051139/article/details/54019515">https://blog.csdn.net/qq_30051139/article/details/54019515</a></p>
<h4 id="总结多线程下ArrayList的几个问题"><a href="#总结多线程下ArrayList的几个问题" class="headerlink" title="总结多线程下ArrayList的几个问题"></a>总结多线程下ArrayList的几个问题</h4><p>1.多线程add可能会丢数据，也可能数组越界，但不会并发错误<br>2.多线程add又打印ArrayList，会并发错误，应为System.out方法里用了迭代器。<br>3.用迭代器遍历中又用ArrayList的add和remove方法，会并发错误。</p>
<p>实验：对partition后的某个subList进行add的话，会牵一发而动全身，因为每个subList是多大已经规定好，对前面的subList进行add，add的元素会跑到下一个subList，以此类推。原来的list也会改变。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList进行add，会并发错误。<br>🤔为什么单纯ArrayList多线程add不会并发错误，这里就会。<br>这里使用的是AbstractList的add方法，其中用到ArrayList的size方法会检查modCount。但是ArrayList的add方法用的是ArrayList的add方法。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList只是打印，在主线程里再add，会并发错误。原因：打印List也会用到迭代器。<br>如果是在线程里循环遍历打印单个元素，不会有错误。并且会实时反映增加的元素。</p>
<h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h3><p>1、泛型与Object的区别</p>
<p>方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object doSomething(Object obj) &#123;....&#125;</span><br><span class="line">​</span><br><span class="line">public &lt;T&gt; T doSomething(T t) &#123;....&#125;</span><br></pre></td></tr></table></figure>

<p>无论是T还是 obj，你都只能调用Object类型的参数和返回值。</p>
<p>但是，如果是使用了泛型的类，和普通的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;Foo&gt; my = new MyClass&lt;Foo&gt;();</span><br><span class="line">Foo foo = new Foo();</span><br><span class="line"></span><br><span class="line">泛型：</span><br><span class="line">Foo newFoo = my.doSomething(foo);</span><br><span class="line"></span><br><span class="line">Object:</span><br><span class="line">Foo newFoo = (Foo) my.doSomething(foo);</span><br></pre></td></tr></table></figure>

<p>因此，使用泛型的好处：</p>
<p>1.不需要做强制类型转换</p>
<p>2.编译时更安全。如果使用Object类的话，你没法保证返回的类型一定是Foo，也许是其它类型。这时你就会在运行时得到一个类型转换异常（ClassCastException）</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SDDDDDSA/article/details/120733398">https://blog.csdn.net/SDDDDDSA/article/details/120733398</a></p>
<p>2、泛型<code>&lt;T&gt; T</code> 与 T 的区别</p>
<p>方法返回前的<code>&lt;T&gt; </code>是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.jt.test;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @Description</span><br><span class="line"> * 有的方法返回值为 &lt;T&gt; T ，有的方法返回值为 T ,区别在那里 ？</span><br><span class="line"> **/</span><br><span class="line">public class Request&lt;E&gt; &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public &lt;T&gt; T getObject(Class&lt;T&gt; tClass) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        T t = tClass.newInstance();</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 方法返回前的 &lt;T&gt; 是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，</span><br><span class="line">     * 也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同</span><br><span class="line">     *</span><br><span class="line">     * 参数 T</span><br><span class="line">     *  第一个 表示是泛型</span><br><span class="line">     *  第二个 表示是返回是T类型的数据</span><br><span class="line">     *  第三个 表示限制参数类型为T</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private &lt;T&gt; T getListFirst(List&lt;T&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 这个只能传T类型的数据</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private E getListFirst2(List&lt;E&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; data2 = new ArrayList&lt;&gt;();</span><br><span class="line">        // 入参由List&lt;T&gt;的T 决定，因为返回值为&lt;T&gt; T ,所以入参不受 Request&lt;T&gt; 影响</span><br><span class="line">        Integer a = new Request&lt;String&gt;().getListFirst(data);</span><br><span class="line"> </span><br><span class="line">        // 编译出错，入参由Request&lt;T&gt; T的决定，受Request&lt;T&gt;影响</span><br><span class="line">        //new Request&lt;String&gt;().getListFirst2(data);</span><br><span class="line"> </span><br><span class="line">        // 没什么区别</span><br><span class="line">        String aa = new Request&lt;String&gt;().getListFirst(data2);</span><br><span class="line">        String bb = new Request&lt;String&gt;().getListFirst2(data2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianzhitu/article/details/107962657">https://blog.csdn.net/qianzhitu/article/details/107962657</a></p>
<p>3、泛型通配符</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>常用的 T，E，K，V，？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<p>？表示不确定的 java 类型<br>T (type) 表示具体的一个java类型<br>K V (key value) 分别代表java键值中的Key Value<br>E (element) 代表Element</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/minkeyto/article/details/116205607">https://blog.csdn.net/minkeyto/article/details/116205607</a></p>
<p>学长教学妹java泛型：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67401499/article/details/125401501">https://blog.csdn.net/m0_67401499/article/details/125401501</a></p>
<h3 id="java可变参数"><a href="#java可变参数" class="headerlink" title="java可变参数"></a>java可变参数</h3><p>java可变参数是指在调用方法时传入不定长度的参数，本质上是基于数组实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">//在定义方法时，在最后一个形参上加&quot;…&quot;就表示该形参可以接受多个参数值，多个参数值被当做数组传入。</span><br><span class="line">public static void element(Integer... args)&#123; &#125;</span><br><span class="line">//参数为数组</span><br><span class="line">public static void element(Integer[] args)&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">public static void element(Integer... args) &#123;</span><br><span class="line">    for (int arg : args) &#123;</span><br><span class="line">        System.out.print(arg + &quot;  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //都可以</span><br><span class="line">    element(1,2,3);</span><br><span class="line">    int[] array=&#123;1,2,3&#125;;</span><br><span class="line">    element(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️可变参数只能做为函数的最后一个参数，前面有没有其他参数都可以，一个函数最多只能有一个可变参数。</p>
<p>可变参数在编译为字节码后，在方法签名中是以数组形态出现的，如果两个方法签名编译后的是一致的话，是不能编译通过的，不可以作为方法的重载。</p>
<p>可变参数作为参数的方法可以传入数组类型的数据或者直接传入多个数据，但是数组作为参数的方法只能传入数组类型的数据。</p>
<p>反射时，可变参数的注意事项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void element(Integer... args)&#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arrry=&#123;1,2,3&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //反射是运行时获取的，在运行时看来，可变参数和数组上是一致的。因而方法的签名为([java/lang/Integer;)V</span><br><span class="line">            //Method对象的方法声明为Object invoke (Object obj,Object.. args)</span><br><span class="line">            //args虽然是一个可变长度的参数，但是args的长度受限于该方法对象代表的真实方法的参数列表长度,</span><br><span class="line">            //从运行时签名来看，([java/lang/Integer;)V实际上是一个形参，即Integer[] args,因此invoke (Object obj,Object.. args)中可变参数args的实际参数长度只能为1。</span><br><span class="line">            Method method = Demo5.class.getMethod(&quot;element&quot;, Integer[].class);</span><br><span class="line">            //array的长度为3，不符合</span><br><span class="line">            method.invoke(null,arrry);</span><br><span class="line">            //将Integer[]转为Object[]，长度还是为3，不符合</span><br><span class="line">            method.invoke(null,(Object[])arrry);</span><br><span class="line">            //将整个Integer[]转为一个Object，长度为1，符合</span><br><span class="line">            method.invoke(null,(Object)arrry);</span><br><span class="line">            //Object[]的长度为1，符合，和上面相同</span><br><span class="line">            method.invoke(null,new Object[]&#123;arrry&#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43413307/article/details/125485292">https://blog.csdn.net/weixin_43413307/article/details/125485292</a></p>
<h3 id="类中的布尔类型get方法注意"><a href="#类中的布尔类型get方法注意" class="headerlink" title="类中的布尔类型get方法注意"></a>类中的布尔类型get方法注意</h3><p>@Getter自动生成getter方法，但是：<br>1.Boolean类型,生成的get方法是get开头的(建议使用这个).<br>2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).</p>
<p>用到布尔值的属性时,最好统一使用大写的包装类Boolean.<br>如果用小写的booean基本类型,最好重写get方法,保证是getXxxx的格式即可.<br>*如果这个对象涉及到反射,反射一般会默认调取对象的get方法,对于这个is的情况,是走不通的.</p>
<h3 id="java的native方法"><a href="#java的native方法" class="headerlink" title="java的native方法"></a>java的native方法</h3><p>什么是native方法？<br>一个Native Method是一个java调用非java代码的接口。Native Method的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<p>使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p>
<p>例如：<br>Thread.sleep(1000); 还有 Thread.start0() 都是native方法。<br>在JDK 源码 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法</p>
<p>native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。<br>java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.native方法是java与其他语言协作的时候使用的，底层实现不是java(c,c++)</span><br><span class="line">2.native并不是java实现的，所以直接调用就好，不需要管他底层实现</span><br><span class="line">3.native方法实际上是java用于调用底层操作系统的方法,java只能调用，不能查看和修改</span><br><span class="line">4.java是跨平台语言，自然而然会失去对底层的控制，于是想要调用底层方法，就必须使用native方法间接调用底层操作系统的方法(c,c++实现)</span><br><span class="line">5.随着java的不断发展，native方法越来越少</span><br><span class="line">6.native是一个关键字，其修饰的方法只说明不实现</span><br><span class="line">7.native方法加载到 本地栈中</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/TheWayForDream/article/details/122202601</span><br></pre></td></tr></table></figure>

<p>JNI：Java Native Interface：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28001771/answer/2049534464">https://www.zhihu.com/question/28001771/answer/2049534464</a><br>native用法：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/195760.html">https://www.jb51.net/article/195760.html</a></p>
<h3 id="printStackTrace-方法"><a href="#printStackTrace-方法" class="headerlink" title="printStackTrace()方法"></a>printStackTrace()方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">… &#125; catch(Exception e) &#123;</span><br><span class="line">e.printStackTrace() ; &#125;</span><br></pre></td></tr></table></figure>

<p>try语句中出现异常时，系统会自动将catch括号中的Exception e 初始化。</p>
<p>printStackTrace()：在命令行打印异常信息在程序中出错的位置及原因。<br>System.out.println(e)：打印异常</p>
<p>不建议使用printStackTrace()的原因：<br>e.printStackTrace() 语句要产生的字符串记录的是堆栈信息，太长太多，内存会被填满。</p>
<p>短时间内大量请求访问此接口 -&gt; 代码本身有问题，很多情况下抛异常  -&gt; e.printStackTrace() 来打印异常到控制台 -&gt; 产生错误堆栈字符串到字符串池内存空间 -&gt; 此内存空间一下子被占满了 -&gt; 开始在此内存空间产出字符串的线程未完成，就没空间了 -&gt;  大量线程产出字符串产出到一半，等在这儿（等有内存了继续搞）-&gt; 相互等待，等内存，锁死了，整个应用挂掉了。</p>
<p>为什么不建议printStackTrace：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kzadmxz/article/details/89914896">https://blog.csdn.net/kzadmxz/article/details/89914896</a></p>
<p>建议：logger.error(“***”,  e);</p>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><p>✅1.使用Math方法</p>
<p>java本身的，不需要导入包，Math.random()随机生成一个double类型[0，1)，如果想生成1~100的随机数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = (int)(Math.random()*100)+1;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println((int)0.01); //0</span><br></pre></td></tr></table></figure>

<p>✅2.使用Random方法生成随机数</p>
<p>Random类是java.until下的一个根据随机算法的起源数字进行一些变化，从而得到随机数字的方法。</p>
<p>随机算法的起源数字被成为种子数（seed）。</p>
<p>虽然Random类产生的数字是随机的，但在相同种子数（seed）下的相同次数产生的随机数是相同的（伪随机）。</p>
<p>Random中共有两种构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、public Random（）</span><br><span class="line">此构造方法是以系统自身的时间为种子数来构造Random对象。</span><br><span class="line"></span><br><span class="line">2、public Random（long seed）</span><br><span class="line">此构造方法可以自己来选定具体的种子来构造Random对象。</span><br></pre></td></tr></table></figure>

<p>常用方法：都可以加参数表示范围，范围是左闭右开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">random.nextInt()	返回值为整数,范围是int类型范围</span><br><span class="line">random.nextLong()	返回值为长整型，范围是long类型的范围</span><br><span class="line">random.nextFloat()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextDouble()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextBoolean（）	返回值为boolean值，true和false概率相同</span><br><span class="line">radom.nextGaussian()	返回值为呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random r = new Random();//以系统自身时间为种子数</span><br><span class="line">int i = r.nextInt();</span><br><span class="line">System.out.println(&quot;i&quot;+i);</span><br><span class="line">Scanner sc  =new Scanner(System.in);</span><br><span class="line">int j = sc.nextInt();</span><br><span class="line">Random r2 = new Random(j);//自定义种子数</span><br><span class="line">Random r3 = new Random(j);//这里是为了验证上方的注意事项：Random类是伪随机，相同种子数相同次数产生的随机数相同</span><br><span class="line">int num  = r2.nextInt(1000);</span><br><span class="line">int num2 = r3.nextInt(1000);</span><br><span class="line">System.out.println(&quot;num&quot;+num);</span><br><span class="line">System.out.println(&quot;num2&quot;+num2);</span><br></pre></td></tr></table></figure>

<p>✅3.使用SecureRandom生成随机数</p>
<p>java.util.Random的实例不是加密安全的，要是知道setSeed值(即时间戳)，很明显能把随机数给猜出来。所以不建议使用Random。SecureRandom来获取加密安全的伪随机数生成器，以供对安全敏感的应用程序使用。</p>
<p>在安全应用场景，随机数应该使用安全的随机数。密码学意义上的安全随机数，要求必须保证其不可预测性。</p>
<p>密码学安全的伪随机数产生器：JDK的java.security.SecureRandom</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom random = new SecureRandom();</span><br><span class="line">String returnValue = &quot;&quot;;</span><br><span class="line">int randomInt = 0;</span><br><span class="line">int range = 9;</span><br><span class="line">for(int i=0; i&lt;5; i++ )&#123;</span><br><span class="line">    randomInt = random.nextInt(range+1);</span><br><span class="line">    returnValue = returnValue + randomInt;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">secureRandom.setSeed(System.currentTimeMillis()); //使用系统时间作为种子</span><br><span class="line">如果同一毫秒连续调用，则得到的随机数则是相同的。</span><br><span class="line">不要自己指定种子。应当使用系统随机源。采用无参构造方法实例化</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSecureRandom() throws NoSuchAlgorithmException &#123;</span><br><span class="line">    //指定算法名称</span><br><span class="line">    SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0 ; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-------------------&quot;);</span><br><span class="line">    secureRandom = new SecureRandom();</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getInstance方法"><a href="#getInstance方法" class="headerlink" title="getInstance方法"></a>getInstance方法</h3><p>两个使用场景：</p>
<p>✅1.抽象类</p>
<p>抽象类是无法直接new出来的，所以想要通过实例化的话只能通过getInstance()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class GetInstanceTest &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Person p = Person.getInstance(&quot;Limbo&quot;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public Person(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public void eat();</span><br><span class="line">    public static  PersonImpl getInstance(String title) &#123;</span><br><span class="line">        return new PersonImpl(title);</span><br><span class="line">    &#125;</span><br><span class="line">    //必须static：</span><br><span class="line">    static class PersonImpl extends Person</span><br><span class="line">    &#123;</span><br><span class="line">        public PersonImpl(String title) &#123;</span><br><span class="line">            super(title);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void eat()</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Eat!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅2.单例设计模式</p>
<p>一般在单例模式下使用.getInstance()创建对象.<br>单例模式：一个类有且只有一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Singleton s = Singleton.getInstance();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    private String content;</span><br><span class="line">    //在自己内部定义自己的一个实例</span><br><span class="line">    private static Singleton SINGLETON = null;</span><br><span class="line">    //private 只能在自己内部供自己去访问</span><br><span class="line">    private Singleton(String title, String content) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    //此静态方法供外部直接访问</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (SINGLETON == null)</span><br><span class="line">            SINGLETON = new Singleton(&quot;Kobe&quot;, &quot;MVP&quot;);</span><br><span class="line">        return SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.title + &quot; - &quot; + this.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getInsance()t:在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。</p>
<p>(1)对象使用之前通过getinstance得到，而不需要自己定义，用完之后不需要delete；</p>
<p>(2)new 一定要生成一个新对象，分配内存；getInstance() 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于new；</p>
<p>(3) new创建后只能当次使用，而getInstance()可以跨栈区域使用，或者远程跨区域使用。所以getInstance()通常是static静态实例方法。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/baxianhua/p/9341953.html">https://www.cnblogs.com/baxianhua/p/9341953.html</a></p>
<h3 id="lang3下的Pair"><a href="#lang3下的Pair" class="headerlink" title="lang3下的Pair"></a>lang3下的Pair</h3><p>org.apache.commons.lang3.tuple.Pair</p>
<p>Pair 用于存储左右元素对，Pair&lt;Left, Right&gt;。主要有两个子类，ImmutablePair 和 MutablePair。</p>
<p>Pair 实现了 java.util.Map.Entry，因此 left 和 right 也可以视作 key-value。不同于Map，Pair只能存一组键值对。</p>
<p>of 方法 以 static 调用的形式创建一个 Pair 实例. 默认创建的是 ImmutablePair。left, right值final 修饰， 值第一次被设置后不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; pair = Pair.of(1, &quot;1&quot;);</span><br><span class="line">System.out.println(pair.getLeft());</span><br><span class="line">System.out.println(pair.getKey());</span><br><span class="line">System.out.println(pair.getRight());</span><br><span class="line">System.out.println(pair.getValue());</span><br><span class="line">pair.setValue(&quot;2&quot;); //java.lang.UnsupportedOperationException</span><br></pre></td></tr></table></figure>

<p>org.apache.commons.lang3.tuple.MutablePair<br>继承了 Pair，left 和 right 值可变。</p>
<p>Pair与Map：<br>1.共通点: Pair 和 Map 都是以 key, value 进行存储。<br>2.不同点:<br>Pair 通过 getKey(), getValue() 获取 key 和 value，没有增加键值对的操作。<br>Map 是通过 get(key) 获取 key 对应的 value，通过 values() 获取所有的value，而且还可以通过 put 增加键值对。<br>Pair 保存的是一对 key-value，而 Map 可以保存多对 key-value。</p>
<p>⚠️Pair的一个使用场景：VO中用到的小数据结构，不想再构造一个pojo了，有两组键值对的数据，比如Point，只有x和y。就可以用<code>List&lt;Pair&lt;String, Double&gt;&gt;</code> 表示。<br>⚠️但是Pair不能被json解析。</p>
<h3 id="几种排序算法"><a href="#几种排序算法" class="headerlink" title="几种排序算法"></a>几种排序算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-交换排序</span><br><span class="line"> -冒泡排序</span><br><span class="line"> -快速排序</span><br><span class="line">-插入排序</span><br><span class="line"> -直接插入排序</span><br><span class="line"> -希尔排序</span><br><span class="line">-选择排序</span><br><span class="line"> -简单选择排序</span><br><span class="line"> -堆排序</span><br><span class="line">-归并排序</span><br><span class="line">-基数排序</span><br></pre></td></tr></table></figure>

<h4 id="✅冒泡排序"><a href="#✅冒泡排序" class="headerlink" title="✅冒泡排序"></a>✅冒泡排序</h4><p>1.从第一个元素开始，比较相邻的两个元素。如果第一个比第二个大，则进行交换,此时最后的元素应是最大的数。<br>2.对剩余元素重复以上步骤，直到没有任何一对元素需要比较为止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSortOpt(int[] arr) &#123;</span><br><span class="line">    if(arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序优化：<br>假如待排序数组是 2、1、3、4、5 这样的情况，按照上述代码实现，第一次循环即可得出正确结果。但循环并不会停止，而是继续执行，直到结束为止。显然，之后的循环遍历是没有必要的。</p>
<p>为了解决这个问题，我们可以设置一个标志位，用来表示当前次循环是否有交换，如果没有，则说明当前数组已经完全排序，直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static int bubbleSortOpt2(int[] arr) &#123;</span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序再优化：<br>比如 3、4、2、1、6、7、8 这个数组，第一次循环后，变为 3、2、1、4、6、7、8 的顺序，我们发现，1 之后的 4 、6、7、8 已经有序了，第二次循环就没必要对后面这段再遍历比较。<br>记录最后发生交换的地点，就是我们要找的分界点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static int bubbleSortOpt3(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int len = arr.length - 1;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 记录最后一次交换位置</span><br><span class="line">        int lastChange = 0;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                // 每交换一次更新一次</span><br><span class="line">                lastChange = j;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (lastChange == 0) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        len = lastChange;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅快速排序"><a href="#✅快速排序" class="headerlink" title="✅快速排序"></a>✅快速排序</h4><p>快速排序的思想很简单，先找一个基准数，先把待排序的数组根据基准数拆成左右两个区间，左边都比中间的基准数小，右边都比基准数大。接着左右两边各自再做同样的操作，完成后再拆分再继续，一直到各区间只有一个数为止。<br>算法的实现需要用到递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line"></span><br><span class="line">    if(start &lt; end) &#123;</span><br><span class="line">        // 把数组中的首位数字作为基准数</span><br><span class="line">        int pivot = arr[start];</span><br><span class="line">        // 记录需要排序的下标</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end;</span><br><span class="line">        // 循环找到比基准数大的数和比基准数小的数</span><br><span class="line">        while(low &lt; high) &#123;</span><br><span class="line">            // 右边的数字比基准数大</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用右边的数替换左边的数</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            // 左边的数字比基准数小</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用左边的数替换右边的数</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把标准值赋给下标重合的位置</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        // 处理所有小的数字</span><br><span class="line">        quickSort(arr, start, low);</span><br><span class="line">        // 处理所有大的数字</span><br><span class="line">        quickSort(arr, low + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Java 实现的八种常用排序算法:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_handsome/article/details/109055036">https://blog.csdn.net/CSDN_handsome/article/details/109055036</a></p>
<p>想实现一个根据对象某属性首尾相接的排序，用Comparator自定义排序没行得通，所以：先弄一个end的Set，然后便利start，找到第一个对象，然后造一个start-对象的Map，然后用end找对象，一个一个找到。</p>
<h3 id="java链式编程"><a href="#java链式编程" class="headerlink" title="java链式编程"></a>java链式编程</h3><p>链式编程的原理是返回一个this对象，也就是返回对象本身，从而达到链式效果。</p>
<p>链式编程，中间操作的返回值都是自己，每个操作的输出是体现在自己对象的改变中的，类似于<code>Stream&lt;T&gt;</code></p>
<p>链式编程的案例：</p>
<p>1、StringBuilder 和 StringBuffer中的append()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder buffer = new StringBuilder();</span><br><span class="line">buffer.append(&quot;你&quot;).append(&quot;好&quot;).append(&quot;!&quot;);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、String 进行字符串操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String string = String.valueOf(&quot;123&quot;).concat(&quot;,4567890&quot;).replace(&#x27;,&#x27;, &#x27;!&#x27;).substring(2, 8);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">返回的是对象本身，所以可以使用链式编程</span><br><span class="line">public static String valueOf(Object obj) &#123;</span><br><span class="line">    return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">     // 省略...</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、 Stream 流式计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    // 相同元素去重</span><br><span class="line">    .distinct()</span><br><span class="line">    // 升序排序</span><br><span class="line">    .sorted((c1, c2) -&gt; c1.compareTo(c2))</span><br><span class="line">    // 遍历</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">方法返回的是对象本身，所以可以使用链式编程</span><br><span class="line">Stream&lt;T&gt; distinct();</span><br><span class="line">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span><br></pre></td></tr></table></figure>

<p>自己做一个链式编程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.setAge(10).setName(&quot;11&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Integer age;</span><br><span class="line"></span><br><span class="line">        public Person setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Person setAge(Integer age) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="java数组、字符串、list的最大长度"><a href="#java数组、字符串、list的最大长度" class="headerlink" title="java数组、字符串、list的最大长度"></a>java数组、字符串、list的最大长度</h3><p>✅数组的最大长度：<br>数组的length属性是int类型，占4个字节，最大值为Integer.MAX_VALUE= 2^31-1【21亿多】<br>注意：这是理论上的最大长度，堆内存不一定能开辟那么大的存储空间来存储该数组。</p>
<p>✅字符串的最大长度：<br>运行时：<br>String、StringBuilder、StringBuffer底层都是基于字符数组char[ ]的，该数组的最大长度也为Integer.MAX_VALUE，所以一个字符串最大21亿多个字符【每个字符在java8中占1个字节】，即占2^32-2个字节，即差2个字节达到4GB。<br>2^10字节=1KB，2^20=1MB，2^30=1GB</p>
<p>编译时：<br>java源码通过javac编译后生成的字节码文件中，静态常量池中字符串常量的长度最多为65535，因为JVM为了解决历史上的一个BUG，所以强制要求编译时字符串的最大长度为65534。</p>
<p>✅ArrayList和LinkedList的最大长度<br>ArrayList底层是数组，最大值为Integer.MAX_VALUE= 231-1【21亿多】<br>LinkedList底层是链表，理论是无上限长度。</p>
<h3 id="Java元组Tuple"><a href="#Java元组Tuple" class="headerlink" title="Java元组Tuple"></a>Java元组Tuple</h3><p>Java中的Tuple是一种数据结构，可存放多个元素，每个元素的数据类型可不同。Tuple与List集合类似，但是不同的是，List集合只能存储一种数据类型，而Tuple可存储多种数据类型。<br>可能你会说，Object类型的List实际也是可以存储多种类型的啊？但是在创建List的时候，需要指定元素数据类型，也就是只能指定为Object类型，获取的元素类型就是Object，如有需要则要进行强转。而Tuple在创建的时候，则可以直接指定多个元素数据类型。</p>
<p>元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。关系数据库中的 一条记录就是一个元组， 一个表就是一个关系， 纪录组成表， 元组生成关系， 这就是关系数据库的核心理念。</p>
<p>元组的使用就是通过泛型定义一个类，然后去保存多个类型属性。所以可以认为元组完全是基于泛型的。返回的所有类型属性外包一层对象然后返回这个对象，其实就是作为元组的实现定义。</p>
<p>元组不同于List，List存储相同的数据类型，虽然也可以存储不同的数据类型，那就不符合泛型了。</p>
<p>元组不同于数组，数组种存储的相同的数据类型。</p>
<p>元组不同于map，map类型是键值对存在的，而元组中的值，值之间没有关系。</p>
<p>元组的值可以是不同数据类型，值与值之间没有关系。</p>
<p>理解：元祖相当于定义一个VO，里面有不同的属性类型，可以包装不同类型。和list区别是，十元祖就可以放10个不同类型的数据。元祖的优点其实还是可以防止代码的冗余，不用写更多的方法，可以通过一个返回多个我想要的类型属性。上面的Pair就是实现这么一个功能，也是元祖。</p>
<hr>
<p>依赖Jar包：javatuples</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javatuples&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javatuples&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>jar包中的结构很简单，其中的类主要是tuple基础类、扩展的一元组、二元组…十元组，以及键值对元组；接口的作用是提供【获取创建各元组时传入参数值】的方法。</p>
<p>其中三元祖的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package org.javatuples;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">import org.javatuples.valueintf.IValue0;</span><br><span class="line">import org.javatuples.valueintf.IValue1;</span><br><span class="line">import org.javatuples.valueintf.IValue2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A tuple of three elements.</span><br><span class="line"> * &lt;/p&gt; </span><br><span class="line"> * </span><br><span class="line"> * @since 1.0</span><br><span class="line"> * </span><br><span class="line"> * @author Daniel Fern&amp;aacute;ndez</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public final class Triplet&lt;A,B,C&gt; </span><br><span class="line">        extends Tuple</span><br><span class="line">        implements IValue0&lt;A&gt;,</span><br><span class="line">                    IValue1&lt;B&gt;,</span><br><span class="line">                    IValue2&lt;C&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -1877265551599483740L;</span><br><span class="line"></span><br><span class="line">    private static final int SIZE = 3;</span><br><span class="line"></span><br><span class="line">    private final A val0;</span><br><span class="line">    private final B val1;</span><br><span class="line">    private final C val2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;A,B,C&gt; Triplet&lt;A,B,C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return new Triplet&lt;A,B,C&gt;(value0,value1,value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般调用静态方法with，传入元组数据，创建一个元组。可以自定义一个工具类，提供公共方法，根据传入的参数个数，返回不同的元组对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.study;</span><br><span class="line"></span><br><span class="line">import com.liuxuan.repository.domain.Student;</span><br><span class="line">import org.javatuples.Pair;</span><br><span class="line">import org.javatuples.Triplet;</span><br><span class="line">import org.javatuples.Unit;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-02-06 22:32</span><br><span class="line"> **/</span><br><span class="line">public class TupleUtils&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 单元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A&gt; Unit&lt;A&gt; with(final A value0) &#123;</span><br><span class="line">        return Unit.with(value0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 双元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B&gt; Pair&lt;A, B&gt; with(final A value0, final B value1) &#123;</span><br><span class="line">        return Pair.with(value0, value1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 三元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B, C&gt; Triplet&lt;A, B, C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return Triplet.with(value0, value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Triplet&lt;Integer, String, String&gt;&gt; roleList = new ArrayList&lt;Triplet&lt;Integer, String, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        Triplet&lt;Integer, String, String&gt; studentTriplet = TupleUtils.with(11, &quot;sid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; teacherTriplet = TupleUtils.with(22, &quot;tid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; programmerTriplet = TupleUtils.with(33, &quot;id&quot;, &quot;graduate&quot;);</span><br><span class="line"></span><br><span class="line">        roleList.add(studentTriplet);</span><br><span class="line">        roleList.add(teacherTriplet);</span><br><span class="line">        roleList.add(programmerTriplet);</span><br><span class="line"></span><br><span class="line">        for (Triplet&lt;Integer, String, String&gt; triplet : roleList) &#123;</span><br><span class="line">            System.out.println(triplet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TupleUtils中提供了with的重载方法，调用时根据传入的参数值个数，返回对应的元组对象。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35006663/article/details/100301416">https://blog.csdn.net/qq_35006663/article/details/100301416</a></p>
<hr>
<p>org.apache.commons.lang3.tuple 中的元祖</p>
<p>用于处理一对键值的对象pair类似于Map.entry，commons lang3增加了可以处理3个值的Triple基类，此包下定义了<code>Pair&lt;L,R&gt;</code>抽象基类，及MutablePair,MutableTriple,ImmutablePair,ImmutableTriple子类。一个线程非安全，另一个线程安全。</p>
<p>接口：<br>1.<code>Pair</code>：封装一对键值对。<br>实现类：可变：<code>MutablePair&lt;L,R&gt;</code>，不可变：<code>ImmutablePair</code><br>2.<code>Triple</code>：封装3个值的类<br>实现类：<code>ImmutableTriple</code>; <code>MuttableTriple&lt;L,M,R&gt;</code></p>
<h3 id="Preconditions-checkArgument校验字段"><a href="#Preconditions-checkArgument校验字段" class="headerlink" title="Preconditions.checkArgument校验字段"></a>Preconditions.checkArgument校验字段</h3><p>guava中的静态方法，用来确认参数是不是符合要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;31.0.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String param = &quot;&quot;;</span><br><span class="line">//旧式写法</span><br><span class="line">if (StringUtils.isEmpty(param)) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;param字段不能为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//新式写法：期望这个字段不能为空</span><br><span class="line">Preconditions.checkArgument(StringUtils.isNotEmpty(param), &quot;param字段不能为空&quot;);</span><br></pre></td></tr></table></figure>

<p>新式的校验是：要求我们对某个字段的要求是什么，当逻辑未命中要求时，则抛出异常。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>drainTo()方法：<br>ArrayBlockingQueue是有界的阻塞队列，该队列内部使用数组支持的元素存储。<br>drainTo()方法用于将所有元素传输到集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 10;</span><br><span class="line">ArrayBlockingQueue queue = new ArrayBlockingQueue(capacity);</span><br><span class="line">queue.add(11);</span><br><span class="line">queue.add(22);</span><br><span class="line">queue.add(33);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[11, 22, 33]</span><br><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">queue.drainTo(list);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[]</span><br><span class="line">System.out.println(&quot;collection = &quot; + list); //[11, 22, 33]</span><br></pre></td></tr></table></figure>

<h3 id="java获取本地ip"><a href="#java获取本地ip" class="headerlink" title="java获取本地ip"></a>java获取本地ip</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String localIP = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">System.out.println(localIP);</span><br></pre></td></tr></table></figure>

<h3 id="guava中的ImmutableList"><a href="#guava中的ImmutableList" class="headerlink" title="guava中的ImmutableList"></a>guava中的ImmutableList</h3><p>ImmutableList是一个不可变、线程安全的列表集合，它只会获取传入对象的一个副本，而不会影响到原来的变量或者对象。</p>
<p>ImmutableList创建不可变对象有两种方法，一种是使用静态of方法，另外一种是使用静态内部类Builder。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">静态内部类构建方法 :</span><br><span class="line">ImmutableList&lt;Integer&gt; list = ImmutableList .&lt;Integer&gt;builder()</span><br><span class="line">                        .add(12)</span><br><span class="line">                        .add(23)</span><br><span class="line">                        .add(34)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">静态方法提供了多个参数的of静态方法:</span><br><span class="line">ImmutableList&lt;String&gt; list3 = ImmutableList .&lt;String&gt;of(&quot;12&quot;,&quot;23&quot;);</span><br><span class="line"></span><br><span class="line">复制数组中的元素到ImmutableList中:</span><br><span class="line"> List&lt;String&gt; list4 = new ArrayList&lt;String&gt;();</span><br><span class="line">list4.add(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;);</span><br><span class="line">list4.add(&quot;3&quot;);</span><br><span class="line">//copy数组list4的一个副本</span><br><span class="line">List&lt;String&gt; list5 = ImmutableList .&lt;String&gt;copyOf(list4);</span><br></pre></td></tr></table></figure>

<h3 id="System-getProperty"><a href="#System-getProperty" class="headerlink" title="System.getProperty()"></a>System.getProperty()</h3><p>获取系统属性，即在java虚拟机启动时定义的环境变量的值，第一个参数是属性名称，第二个参数是属性的默认值。</p>
<p><code>String s = System.getProperty(&quot;line.separator&quot;)</code> 获取系统空格。</p>
<p>System.getProperty() 是获取系统的相关属性，包括文件编码、操作系统名称、区域、用户名等，此属性一般是由 JVM 自动获取，不能设置。这个必须接收一个 String 类型的参数，并且返回一个 String 类型的值。如果想要获取所有的系统的相关属性值可以使用 System.getProperties() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">java.runtime.name-------Java(TM) SE Runtime Environment</span><br><span class="line">sun.boot.library.path-------C:\Program Files\Java\jdk1.8.0_60\jre\bin</span><br><span class="line">java.vm.version-------25.60-b23</span><br><span class="line">java.vm.vendor-------Oracle Corporation</span><br><span class="line">java.vendor.url-------http://java.oracle.com/</span><br><span class="line">path.separator-------;</span><br><span class="line">java.vm.name-------Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">file.encoding.pkg-------sun.io</span><br><span class="line">user.country-------CN</span><br><span class="line">user.script-------</span><br><span class="line">sun.java.launcher-------SUN_STANDARD</span><br><span class="line">sun.os.patch.level-------</span><br><span class="line">java.vm.specification.name-------Java Virtual Machine Specification</span><br><span class="line">user.dir-------F:\siwei\dayunmotor-tbox\dayunmotor-forward-hbase</span><br><span class="line">java.runtime.version-------1.8.0_60-b27</span><br><span class="line">java.awt.graphicsenv-------sun.awt.Win32GraphicsEnvironment</span><br><span class="line">java.endorsed.dirs-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\endorsed</span><br><span class="line">os.arch-------amd64</span><br><span class="line">java.io.tmpdir-------C:\Users\yesway\AppData\Local\Temp\</span><br><span class="line">line.separator-------</span><br><span class="line"></span><br><span class="line">java.vm.specification.vendor-------Oracle Corporation</span><br><span class="line">user.variant-------</span><br><span class="line">os.name-------Windows 10</span><br><span class="line">sun.jnu.encoding-------GBK</span><br><span class="line">java.library.path-------C:\Program Files\Java\jdk1.8.0_60\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\ProgramData\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;D:\Program Files\Git\cmd;C:\Users\yesway\AppData\Local\Microsoft\WindowsApps;;.</span><br><span class="line">java.specification.name-------Java Platform API Specification</span><br><span class="line">java.class.version-------52.0</span><br><span class="line">sun.management.compiler-------HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version-------10.0</span><br><span class="line">user.home-------C:\Users\yesway</span><br><span class="line">user.timezone-------</span><br><span class="line">java.awt.printerjob-------sun.awt.windows.WPrinterJob</span><br><span class="line">file.encoding-------UTF-8</span><br><span class="line">java.specification.version-------1.8</span><br><span class="line">java.class.path-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\rt.jar;F:\siwei\dayunmotor-tbox\dayunmotor-forward-hbase\target\classes;D:\dayunMaven\org\springframework\boot\spring-boot-starter\2.4.0\spring-boot-starter-2.4.0.jar;D:\dayunMaven\org\springframework\boot\spring-boot\2.4.0\spring-boot-2.4.0.jar;D:\dayunMaven\org\springframework\spring-context\5.3.1\spring-context-5.3.1.jar;D:\dayunMaven\org\springframework\boot\spring-boot-autoconfigure\2.4.0\spring-boot-autoconfigure-2.4.0.jar;D:\dayunMaven\jakarta\annotation\jakarta.annotation-api\1.3.5\jakarta.annotation-api-1.3.5.jar;D:\dayunMaven\org\springframework\spring-core\5.3.1\spring-core-5.3.1.jar;D:\dayunMaven\org\springframework\spring-jcl\5.3.1\spring-jcl-5.3.1.jar;D:\dayunMaven\org\yaml\snakeyaml\1.27\snakeyaml-1.27.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-aop\2.4.0\spring-boot-starter-aop-2.4.0.jar;D:\dayunMaven\org\springframework\spring-aop\5.3.1\spring-aop-5.3.1.jar;D:\dayunMaven\org\springframework\spring-beans\5.3.1\spring-beans-5.3.1.jar;D:\dayunMaven\org\aspectj\aspectjweaver\1.9.6\aspectjweaver-1.9.6.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-amqp\2.4.0\spring-boot-starter-amqp-2.4.0.jar;D:\dayunMaven\org\springframework\spring-messaging\5.3.1\spring-messaging-5.3.1.jar;D:\dayunMaven\org\springframework\amqp\spring-rabbit\2.3.1\spring-rabbit-2.3.1.jar;D:\dayunMaven\org\springframework\amqp\spring-amqp\2.3.1\spring-amqp-2.3.1.jar;D:\dayunMaven\org\springframework\retry\spring-retry\1.3.0\spring-retry-1.3.0.jar;D:\dayunMaven\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;D:\dayunMaven\com\rabbitmq\amqp-client\5.9.0\amqp-client-5.9.0.jar;D:\dayunMaven\org\springframework\spring-tx\5.3.1\spring-tx-5.3.1.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-log4j2\2.4.0\spring-boot-starter-log4j2-2.4.0.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-slf4j-impl\2.13.3\log4j-slf4j-impl-2.13.3.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-jul\2.13.3\log4j-jul-2.13.3.jar;D:\dayunMaven\org\slf4j\jul-to-slf4j\1.7.30\jul-to-slf4j-1.7.30.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-web\2.4.0\spring-boot-starter-web-2.4.0.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-json\2.4.0\spring-boot-starter-json-2.4.0.jar;D:\dayunMaven\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.11.3\jackson-datatype-jdk8-2.11.3.jar;D:\dayunMaven\com\fasterxml\jackson\module\jackson-module-parameter-names\2.11.3\jackson-module-parameter-names-2.11.3.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-tomcat\2.4.0\spring-boot-starter-tomcat-2.4.0.jar;D:\dayunMaven\org\apache\tomcat\embed\tomcat-embed-core\9.0.39\tomcat-embed-core-9.0.39.jar;D:\dayunMaven\org\glassfish\jakarta.el\3.0.3\jakarta.el-3.0.3.jar;D:\dayunMaven\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.39\tomcat-embed-websocket-9.0.39.jar;D:\dayunMaven\org\springframework\spring-web\5.3.1\spring-web-5.3.1.jar;D:\dayunMaven\org\springframework\spring-webmvc\5.3.1\spring-webmvc-5.3.1.jar;D:\dayunMaven\org\springframework\spring-expression\5.3.1\spring-expression-5.3.1.jar;D:\dayunMaven\net\minidev\json-smart\2.3\json-smart-2.3.jar;D:\dayunMaven\net\minidev\accessors-smart\1.2\accessors-smart-1.2.jar;D:\dayunMaven\org\ow2\asm\asm\5.0.4\asm-5.0.4.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-data-redis\2.4.0\spring-boot-starter-data-redis-2.4.0.jar;D:\dayunMaven\org\springframework\data\spring-data-redis\2.4.1\spring-data-redis-2.4.1.jar;D:\dayunMaven\org\springframework\data\spring-data-keyvalue\2.4.1\spring-data-keyvalue-2.4.1.jar;D:\dayunMaven\org\springframework\data\spring-data-commons\2.4.1\spring-data-commons-2.4.1.jar;D:\dayunMaven\org\springframework\spring-oxm\5.3.1\spring-oxm-5.3.1.jar;D:\dayunMaven\org\springframework\spring-context-support\5.3.1\spring-context-support-5.3.1.jar;D:\dayunMaven\io\lettuce\lettuce-core\6.0.1.RELEASE\lettuce-core-6.0.1.RELEASE.jar;D:\dayunMaven\io\netty\netty-common\4.1.53.Final\netty-common-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-handler\4.1.53.Final\netty-handler-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-resolver\4.1.53.Final\netty-resolver-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-buffer\4.1.53.Final\netty-buffer-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-codec\4.1.53.Final\netty-codec-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-transport\4.1.53.Final\netty-transport-4.1.53.Final.jar;D:\dayunMaven\io\projectreactor\reactor-core\3.3.11.RELEASE\reactor-core-3.3.11.RELEASE.jar;D:\dayunMaven\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;D:\dayunMaven\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;D:\dayunMaven\org\apache\commons\commons-pool2\2.8.0\commons-pool2-2.8.0.jar;D:\dayunMaven\org\projectlombok\lombok\1.18.8\lombok-1.18.8.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-core\2.11.2\log4j-core-2.11.2.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-api\2.11.2\log4j-api-2.11.2.jar;D:\dayunMaven\org\slf4j\slf4j-api\1.7.5\slf4j-api-1.7.5.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;D:\dayunMaven\com\alibaba\fastjson\1.2.47\fastjson-1.2.47.jar;D:\dayunMaven\org\apache\hadoop\hadoop-client\3.0.0\hadoop-client-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-hdfs-client\3.0.0\hadoop-hdfs-client-3.0.0.jar;D:\dayunMaven\com\squareup\okhttp\okhttp\2.4.0\okhttp-2.4.0.jar;D:\dayunMaven\com\squareup\okio\okio\1.4.0\okio-1.4.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-api\3.0.0\hadoop-yarn-api-3.0.0.jar;D:\dayunMaven\javax\xml\bind\jaxb-api\2.2.11\jaxb-api-2.2.11.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-client\3.0.0\hadoop-yarn-client-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-core\3.0.0\hadoop-mapreduce-client-core-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-common\3.0.0\hadoop-yarn-common-3.0.0.jar;D:\dayunMaven\org\eclipse\jetty\jetty-util\9.3.19.v20170502\jetty-util-9.3.19.v20170502.jar;D:\dayunMaven\com\sun\jersey\jersey-client\1.19\jersey-client-1.19.jar;D:\dayunMaven\com\fasterxml\jackson\module\jackson-module-jaxb-annotations\2.7.8\jackson-module-jaxb-annotations-2.7.8.jar;D:\dayunMaven\com\fasterxml\jackson\jaxrs\jackson-jaxrs-json-provider\2.7.8\jackson-jaxrs-json-provider-2.7.8.jar;D:\dayunMaven\com\fasterxml\jackson\jaxrs\jackson-jaxrs-base\2.7.8\jackson-jaxrs-base-2.7.8.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-jobclient\3.0.0\hadoop-mapreduce-client-jobclient-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-common\3.0.0\hadoop-mapreduce-client-common-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-annotations\3.0.0\hadoop-annotations-3.0.0.jar;D:\dayunMaven\org\apache\hbase\hbase-shaded-client\2.1.0\hbase-shaded-client-2.1.0.jar;D:\dayunMaven\com\github\stephenc\findbugs\findbugs-annotations\1.3.9-1\findbugs-annotations-1.3.9-1.jar;D:\dayunMaven\org\apache\htrace\htrace-core4\4.2.0-incubating\htrace-core4-4.2.0-incubating.jar;D:\dayunMaven\commons-logging\commons-logging\1.2\commons-logging-1.2.jar;D:\dayunMaven\org\apache\htrace\htrace-core\3.1.0-incubating\htrace-core-3.1.0-incubating.jar;D:\dayunMaven\log4j\log4j\1.2.17\log4j-1.2.17.jar;D:\dayunMaven\org\apache\yetus\audience-annotations\0.5.0\audience-annotations-0.5.0.jar;D:\dayunMaven\junit\junit\4.12\junit-4.12.jar;D:\dayunMaven\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;D:\dayunMaven\org\apache\hadoop\hadoop-common\3.0.0\hadoop-common-3.0.0.jar;D:\dayunMaven\com\google\guava\guava\11.0.2\guava-11.0.2.jar;D:\dayunMaven\commons-cli\commons-cli\1.2\commons-cli-1.2.jar;D:\dayunMaven\org\apache\commons\commons-math3\3.1.1\commons-math3-3.1.1.jar;D:\dayunMaven\org\apache\httpcomponents\httpclient\4.5.2\httpclient-4.5.2.jar;D:\dayunMaven\org\apache\httpcomponents\httpcore\4.4.4\httpcore-4.4.4.jar;D:\dayunMaven\commons-codec\commons-codec\1.4\commons-codec-1.4.jar;D:\dayunMaven\commons-io\commons-io\2.4\commons-io-2.4.jar;D:\dayunMaven\commons-net\commons-net\3.1\commons-net-3.1.jar;D:\dayunMaven\commons-collections\commons-collections\3.2.2\commons-collections-3.2.2.jar;D:\dayunMaven\javax\servlet\javax.servlet-api\3.1.0\javax.servlet-api-3.1.0.jar;D:\dayunMaven\javax\servlet\jsp\jsp-api\2.1\jsp-api-2.1.jar;D:\dayunMaven\com\sun\jersey\jersey-core\1.19\jersey-core-1.19.jar;D:\dayunMaven\javax\ws\rs\jsr311-api\1.1.1\jsr311-api-1.1.1.jar;D:\dayunMaven\com\sun\jersey\jersey-servlet\1.19\jersey-servlet-1.19.jar;D:\dayunMaven\com\sun\jersey\jersey-json\1.19\jersey-json-1.19.jar;D:\dayunMaven\org\codehaus\jettison\jettison\1.1\jettison-1.1.jar;D:\dayunMaven\com\sun\xml\bind\jaxb-impl\2.2.3-1\jaxb-impl-2.2.3-1.jar;D:\dayunMaven\org\codehaus\jackson\jackson-core-asl\1.9.2\jackson-core-asl-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-mapper-asl\1.9.2\jackson-mapper-asl-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-jaxrs\1.9.2\jackson-jaxrs-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-xc\1.9.2\jackson-xc-1.9.2.jar;D:\dayunMaven\com\sun\jersey\jersey-server\1.19\jersey-server-1.19.jar;D:\dayunMaven\commons-beanutils\commons-beanutils\1.9.3\commons-beanutils-1.9.3.jar;D:\dayunMaven\org\apache\commons\commons-configuration2\2.1.1\commons-configuration2-2.1.1.jar;D:\dayunMaven\org\apache\commons\commons-lang3\3.4\commons-lang3-3.4.jar;D:\dayunMaven\org\slf4j\slf4j-log4j12\1.7.25\slf4j-log4j12-1.7.25.jar;D:\dayunMaven\org\apache\avro\avro\1.7.7\avro-1.7.7.jar;D:\dayunMaven\com\thoughtworks\paranamer\paranamer\2.3\paranamer-2.3.jar;D:\dayunMaven\org\xerial\snappy\snappy-java\1.0.5\snappy-java-1.0.5.jar;D:\dayunMaven\com\google\re2j\re2j\1.1\re2j-1.1.jar;D:\dayunMaven\com\google\protobuf\protobuf-java\2.5.0\protobuf-java-2.5.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-auth\3.0.0\hadoop-auth-3.0.0.jar;D:\dayunMaven\com\nimbusds\nimbus-jose-jwt\4.41.1\nimbus-jose-jwt-4.41.1.jar;D:\dayunMaven\com\github\stephenc\jcip\jcip-annotations\1.0-1\jcip-annotations-1.0-1.jar;D:\dayunMaven\org\apache\curator\curator-framework\2.12.0\curator-framework-2.12.0.jar;D:\dayunMaven\com\jcraft\jsch\0.1.54\jsch-0.1.54.jar;D:\dayunMaven\org\apache\curator\curator-client\2.12.0\curator-client-2.12.0.jar;D:\dayunMaven\org\apache\curator\curator-recipes\2.12.0\curator-recipes-2.12.0.jar;D:\dayunMaven\com\google\code\findbugs\jsr305\3.0.0\jsr305-3.0.0.jar;D:\dayunMaven\org\apache\zookeeper\zookeeper\3.4.9\zookeeper-3.4.9.jar;D:\dayunMaven\jline\jline\0.9.94\jline-0.9.94.jar;D:\dayunMaven\io\netty\netty\3.10.5.Final\netty-3.10.5.Final.jar;D:\dayunMaven\org\apache\commons\commons-compress\1.4.1\commons-compress-1.4.1.jar;D:\dayunMaven\org\tukaani\xz\1.0\xz-1.0.jar;D:\dayunMaven\org\apache\kerby\kerb-simplekdc\1.0.1\kerb-simplekdc-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-client\1.0.1\kerb-client-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-config\1.0.1\kerby-config-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-core\1.0.1\kerb-core-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-pkix\1.0.1\kerby-pkix-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-asn1\1.0.1\kerby-asn1-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-util\1.0.1\kerby-util-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-common\1.0.1\kerb-common-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-crypto\1.0.1\kerb-crypto-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-util\1.0.1\kerb-util-1.0.1.jar;D:\dayunMaven\org\apache\kerby\token-provider\1.0.1\token-provider-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-admin\1.0.1\kerb-admin-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-server\1.0.1\kerb-server-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-identity\1.0.1\kerb-identity-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-xdr\1.0.1\kerby-xdr-1.0.1.jar;D:\dayunMaven\org\codehaus\woodstox\stax2-api\3.1.4\stax2-api-3.1.4.jar;D:\dayunMaven\com\fasterxml\woodstox\woodstox-core\5.0.3\woodstox-core-5.0.3.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-databind\2.9.6\jackson-databind-2.9.6.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-core\2.9.6\jackson-core-2.9.6.jar;D:\dayunMaven\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.6\jackson-datatype-jsr310-2.9.6.jar;D:\dayunMaven\com\google\code\gson\gson\2.6.2\gson-2.6.2.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.4\lib\idea_rt.jar</span><br><span class="line">user.name-------yesway</span><br><span class="line">java.vm.specification.version-------1.8</span><br><span class="line">sun.java.command-------com.dayunmotor.forward.hbase.ForwardHbaseApplication</span><br><span class="line">java.home-------C:\Program Files\Java\jdk1.8.0_60\jre</span><br><span class="line">sun.arch.data.model-------64</span><br><span class="line">user.language-------zh</span><br><span class="line">java.specification.vendor-------Oracle Corporation</span><br><span class="line">awt.toolkit-------sun.awt.windows.WToolkit</span><br><span class="line">java.vm.info-------mixed mode</span><br><span class="line">java.version-------1.8.0_60</span><br><span class="line">java.ext.dirs-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">sun.boot.class.path-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_60\jre\classes</span><br><span class="line">java.vendor-------Oracle Corporation</span><br><span class="line">file.separator-------\</span><br><span class="line">java.vendor.url.bug-------http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding-------UnicodeLittle</span><br><span class="line">sun.cpu.endian-------little</span><br><span class="line">sun.desktop-------windows</span><br><span class="line">sun.cpu.isalist-------amd64</span><br></pre></td></tr></table></figure>


<h3 id="用反射获取Java对象中所有的属性名称和属性值"><a href="#用反射获取Java对象中所有的属性名称和属性值" class="headerlink" title="用反射获取Java对象中所有的属性名称和属性值"></a>用反射获取Java对象中所有的属性名称和属性值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person(&quot;zhangsan&quot;, 30, &quot;男&quot;);</span><br><span class="line">        StringBuilder sbName = new StringBuilder();</span><br><span class="line">        StringBuilder sbValue = new StringBuilder();</span><br><span class="line">        String[] fieldNames = getFiledName(person);</span><br><span class="line"></span><br><span class="line">        for(int j=0 ; j&lt;fieldNames.length ; j++)&#123; //遍历所有属性</span><br><span class="line">            String name = fieldNames[j]; //获取属性的名字</span><br><span class="line">            Object value = getFieldValueByName(name, person);</span><br><span class="line">            sbName.append(name);</span><br><span class="line">            sbValue.append(value);</span><br><span class="line">            if(j != fieldNames.length - 1) &#123;</span><br><span class="line">                sbName.append(&quot;/&quot;);</span><br><span class="line">                sbValue.append(&quot;/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;attribute name:&quot;+sbName.toString());</span><br><span class="line">        System.out.println(&quot;attribute value:&quot;+sbValue.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取属性名数组</span><br><span class="line">     * */</span><br><span class="line">    private static String[] getFiledName(Object o)&#123;</span><br><span class="line">        Field[] fields=o.getClass().getDeclaredFields();</span><br><span class="line">        String[] fieldNames=new String[fields.length];</span><br><span class="line">        for(int i=0;i&lt;fields.length;i++)&#123;</span><br><span class="line">            // System.out.println(fields[i].getType());</span><br><span class="line">            fieldNames[i]=fields[i].getName();</span><br><span class="line">        &#125;</span><br><span class="line">        return fieldNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 根据属性名获取属性值</span><br><span class="line">     **/</span><br><span class="line">    private static Object getFieldValueByName(String fieldName, Object o) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String firstLetter = fieldName.substring(0, 1).toUpperCase();</span><br><span class="line">            String getter = &quot;get&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">            Method method = o.getClass().getMethod(getter, new Class[] &#123;&#125;);</span><br><span class="line">            Object value = method.invoke(o, new Object[] &#123;&#125;);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">        private String gender;</span><br><span class="line"></span><br><span class="line">        public Person(String n,int a,String g) &#123;</span><br><span class="line">            name = n;</span><br><span class="line">            age = a;</span><br><span class="line">            gender = g;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getGender() &#123;</span><br><span class="line">            return gender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiadongqing/p/16298207.html">https://www.cnblogs.com/xiadongqing/p/16298207.html</a></p>
<p>关于反射的概念：<br>Java中的反射是通过反射API来实现的。Java反射API主要包括以下几个重要的类和接口：<br>1、Class 类：表示一个类或接口，在运行时JVM中每个类都有一个对应的Class对象。<br>2、Constructor类：表示一个类的构造方法。<br>3、Method 类：表示一个类的方法。<br>4、Field 类：表示一个类的成员变量（字段）。</p>
<p>反射实现的核心是 Class 类，一个类在编译后会生成对应的 class文件，这个文件中包含了类的结构信息，包括字段、方法、构造函数等信息。在运行时，JVM会读取这个 文件并将其加载到内存中。当需要使用一个类时，JVM会通过类的全限定名来找到对应的 class 文件，并将其加载到内存中。在加载后，JVM 会为每个类创建一个对应的 Class对象，该对象包含了类的所有结构信息。</p>
<p>通过 Class 对象可以获取类的所有结构信息，包括构造函数、方法、字段等。可以通过 Constructor、Method 和Field 等类来表示类的构造函数、方法和字段，通过这些类可以获取和调用类的构造函数数、方法和字段。</p>
<p>反射的实现主要依靠JVM 中的类加载机制和 Class对象，通过 class 对象可以获取类的所有结构信息，通过这些信息可以实现对类的动态操作。在运行时，通过反射可以动态地创建对象、调用方法、访问字段等，从而实现了比较灵活的编程方式。</p>
<p>反射是指在程序运行时动态获取对象信息的能力。它可以让程序在运行时通过对象的引用来获取对象的类型信息、属性、方法等，而不需要在编译时进行硬编码。具体实现反射的方式是通过反射APl来获取对象的类信息，包括类名、父类、接口、方法、属性等，然后通过反射API提供的方法来操作这些信息。在Java中，反射API主要包括 Class 类、Constructor类、Field类和Method类等。通过这些类，可以实现动态创建对象、调用方法、获取属性等操作。</p>
<p>反射是一种强大的编程技术，但也需要谨慎使用，因为它会增加代码的复杂度和运行时开销。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/java%E6%8E%A5%E5%8F%A3&%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/java%E6%8E%A5%E5%8F%A3&%E7%B1%BB/" class="post-title-link" itemprop="url">java常规接口、类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 09:59:37" itemprop="dateCreated datePublished" datetime="2022-04-30T09:59:37+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-26 12:49:46" itemprop="dateModified" datetime="2023-03-26T12:49:46+08:00">2023-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>位于java.io.Serializable包中，一般在创建实体类的时候会去实现这个接口，目的是为了序列化。</p>
<p>序列化指的是把对象转化成字节序列的过程，就是把内存中的对象转换成一连串的字节bytes描述的过程。<br>反序列化就是将字节bytes数据恢复为对象的过程。</p>
<p>需要将内存中对象状态数据保存到文件或数据库中时，需要进行序列化。这个比较直观的就是通过ObjectOutputStream和FileOutputStream向文件中保存对象时，实现了Serializable接口的对象会以二进制数据的形式保存到文件中，而未实现Serializable接口的对象则会直接报错，无法保存。</p>
<p>serialVersionUID：<br>如果在进行反序列化前，将某个实体类原有的serialVersionUID改变，在进行反序列化时就会报InvalidClassException异常。<br>如果没有指定serialVersionUID，在进行序列化时，JVM会通过计算给该类一个默认的serialVersionUID值。<br>但是不建议不指定serialVersionUID，高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。个人认为应该是指不同编译器编译的不同类可能产生一个相同的默认serialVersionUID。<br>另外尽量用private来修饰serialVersionUID。</p>
<hr>
<p>Serializable其实是个空接口，用来标识当前类可以被序列化。<br>告诉jvm，让jvm帮忙做序列化。</p>
<p>实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。</p>
<p>✅什么是序列化？</p>
<p>序列化（serialize） - 序列化是将对象转换为字节流。<br>反序列化（deserialize） - 反序列化是将字节流转换为对象。</p>
<p>作用：<br>序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。<br>在网络上传送对象的字节序列。<br>RMI(远程方法调用)</p>
<p>什么时候用：<br>1、想把内存中的对象状态保存到一个文件中或者数据库中时<br>2、想把对象通过网络进行传输时</p>
<p>✅如何使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// Gender类，表示性别</span><br><span class="line">// 每个枚举类型都会默认继承类java.lang.Enum，而Enum类实现了Serializable接口，所以枚举类型对象都是默认可以被序列化的。</span><br><span class="line">public enum Gender &#123;  </span><br><span class="line">    MALE, FEMALE  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// Person 类实现了 Serializable 接口，它包含三个字段。另外，它还重写了该类的 toString() 方法，以方便打印 Person 实例中的内容。</span><br><span class="line">public class Person implements Serializable &#123;  </span><br><span class="line">    private String name = null;  </span><br><span class="line">    private Integer age = null;  </span><br><span class="line">    private Gender gender = null;  </span><br><span class="line"></span><br><span class="line">    public Person() &#123;  </span><br><span class="line">        System.out.println(&quot;none-arg constructor&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    public Person(String name, Integer age, Gender gender) &#123;  </span><br><span class="line">        System.out.println(&quot;arg constructor&quot;);  </span><br><span class="line">        this.name = name;  </span><br><span class="line">        this.age = age;  </span><br><span class="line">        this.gender = gender;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 省略 set get 方法</span><br><span class="line">    @Override </span><br><span class="line">    public String toString() &#123;  </span><br><span class="line">        return &quot;[&quot; + name + &quot;, &quot; + age + &quot;, &quot; + gender + &quot;]&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// SimpleSerial类，是一个简单的序列化程序，它先将Person对象保存到文件person.out中，然后再从该文件中读出被存储的Person对象，并打印该对象。</span><br><span class="line">public class SimpleSerial &#123;  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        File file = new File(&quot;person.out&quot;);  </span><br><span class="line">        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file)); // 注意这里使用的是 ObjectOutputStream 对象输出流封装其他的输出流</span><br><span class="line">        Person person = new Person(&quot;John&quot;, 101, Gender.MALE);  </span><br><span class="line">        oout.writeObject(person);  </span><br><span class="line">        oout.close();  </span><br><span class="line"> </span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));  // 使用对象输入流读取序列化的对象</span><br><span class="line">        Object newPerson = oin.readObject(); // 没有强制转换到Person类型  </span><br><span class="line">        oin.close();  </span><br><span class="line">        System.out.println(newPerson);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// 上述程序的输出的结果为：</span><br><span class="line">arg constructor  </span><br><span class="line">[John, 31, MALE]</span><br></pre></td></tr></table></figure>

<p>转自：简书<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e4a9cac727f">https://www.jianshu.com/p/8e4a9cac727f</a></p>
<p>csdn：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011568312/article/details/57611440">https://blog.csdn.net/u011568312/article/details/57611440</a></p>
<h3 id="MultipartFile接口"><a href="#MultipartFile接口" class="headerlink" title="MultipartFile接口"></a>MultipartFile接口</h3><p>用于http中获取前台传来的文件</p>
<p>位于：package org.springframework.web.multipart;包下<br>中文名：多组件文档<br>继承自：InputStreamSource,并封装了getInputStream()方法<br>此方法用法：<code>@RequesParam(&quot;file&quot;)MultipartFile file</code><br><code>InputStream is  = file.getInputStream();</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String getName():得到的是@RequesParam(value = &quot;file&quot;)中的value值，不会为空。</span><br><span class="line">String getOriginalFilename():获取的是文件的完整名称，包括文件名称+文件拓展名。</span><br><span class="line">String getContentType()：返回文件内容类型，不是文件扩展名（例如：jpeg图片：image/jpeg）</span><br><span class="line">boolean isEmpty()：返回上传的文件是否为空，即multipart形式中没有选择任何文件或者选择的文件没有内容</span><br><span class="line">long getSize()：以字节为单位返回文件大小</span><br><span class="line">byte[] getBytes()：以字节数组的形式返回文件内容</span><br><span class="line">InputStream getInputStream()：返回一个字节流</span><br><span class="line">void transferTo()：用来将接收文件传输到给定目标路径，会抛出IOException、IllegalStateException异常。该方法在实际项目开发中使用较少。</span><br></pre></td></tr></table></figure>





<h3 id="Pattern类-amp-Matcher类"><a href="#Pattern类-amp-Matcher类" class="headerlink" title="Pattern类&amp;Matcher类"></a>Pattern类&amp;Matcher类</h3><p>Pattern类是java.util.regex包中的final类。是正则表达式的编译表示形式，此类的实例是不可变的，可供多个并发线程安全使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">public final class Pattern extends Object implements Serializable</span><br><span class="line"></span><br><span class="line">//Pattern调用静态方法compile返回Pattern实例。</span><br><span class="line">// 将给定的正则表达式编译并赋予给Pattern类</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line"></span><br><span class="line">// 增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ </span><br><span class="line">static Pattern compile(String regex, int flags) </span><br><span class="line">//先不明白</span><br><span class="line"></span><br><span class="line">//Pattern.split()（静态方法）和string.split()用途一样，</span><br><span class="line">//是将字符串从正则表达式匹配的地方分开</span><br><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input, 3)));</span><br><span class="line">// 第二种，第二个参数用来限制将输入分割成字符串的数量</span><br></pre></td></tr></table></figure>

<p>正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\\d 表示数字，前面多了第一个\，是转义的意思。</span><br><span class="line">+表示重复前面的</span><br><span class="line">\\d+ 表示多个数字</span><br></pre></td></tr></table></figure>

<p>Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查，此类的实例用于多个并发线程是不安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pattern.matcher 静态方法：</span><br><span class="line">Pattern.matcher(String regex,CharSequence input)</span><br><span class="line">静态方法,用于快速匹配字符串,匹配全部字符串</span><br><span class="line"></span><br><span class="line">pattern.matcher(CharSequence input):</span><br><span class="line">返回一个Matcher对象。</span><br><span class="line">Matcher类的构造方法也是私有的,不能随意创建,</span><br><span class="line">只能通过pattern.matcher(CharSequence input)方法得到该类的实例</span><br><span class="line"></span><br><span class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;); </span><br><span class="line">Matcher m=p.matcher(&quot;22bb23&quot;); </span><br><span class="line">m.pattern();//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</span><br></pre></td></tr></table></figure>

<p>用Pattern以及Matcher匹配例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;aa11bb&quot;;</span><br><span class="line">String paternStr = &quot;\\d+&quot;;</span><br><span class="line">Pattern pattern = Pattern.compile(paternStr);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line">if (matcher.find()) &#123;   //有匹配就行</span><br><span class="line">    System.out.println(matcher.group(0));  //输出11</span><br><span class="line">&#125;</span><br><span class="line">if (matcher.matches()) &#123;  //需要完全匹配</span><br><span class="line">    System.out.println(matcher.group(0));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/woniu317/article/details/52186694">https://blog.csdn.net/woniu317/article/details/52186694</a><br><a target="_blank" rel="noopener" href="http://www.51gjie.com/java/759.html">http://www.51gjie.com/java/759.html</a></p>
<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供。 </p>
<p>java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：起到了转换类型的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(s -&gt; Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(Function&lt;String, Integer&gt; function) &#123;</span><br><span class="line">        int num = function.apply(&quot;10&quot;);</span><br><span class="line">        System.out.println(num + 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法：如andThen方法<br><a target="_blank" rel="noopener" href="http://t.zoukankan.com/liyihua-p-12286100.html">http://t.zoukankan.com/liyihua-p-12286100.html</a></p>
<p>和@FunctionalInterface作用一样？</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只有一个抽象方法的接口。</p>
<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。可以有多个default方法。</p>
<p>为了避免别人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，可以在接口上加上一个注解<code>@FunctionalInterface</code>, 这样别人就无法在里面添加新的接口函数了。</p>
<p><code>@FunctionalInterface public interface Function&lt;T, R&gt; &#123;   &#125;</code></p>
<p>在java.util.function包下：</p>
<h4 id="✅Function接口"><a href="#✅Function接口" class="headerlink" title="✅Function接口"></a>✅Function接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">    R apply(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数型接口：<code>Function&lt;T, R&gt;</code>，有参有返回值，接受一个T类型的参数，并返回一个R类型的返回值。</p>
<p>其中的抽象方法：<code>R apply(T t);</code></p>
<p>T是输入，R是输出，表示一个类型转换，lambda表达式实现apply方法。<br>stream的map方法，传参就是Function，表示映射。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line">    Function&lt;String, String&gt; function = (str) -&gt; &#123;</span><br><span class="line">        return &quot;hello,&quot; + str;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String funDemo(String str2, Function&lt;String, String&gt; function) &#123;</span><br><span class="line">        return function.apply(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFunDemo() &#123;</span><br><span class="line">        System.out.println(funDemo(&quot;小明&quot;, function));</span><br><span class="line">        System.out.println(funDemo(&quot;小美&quot;, str -&gt; &quot;hello&quot;+str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅Predicate接口"><a href="#✅Predicate接口" class="headerlink" title="✅Predicate接口"></a>✅Predicate接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断言型接口：<code>Predicate&lt;T&gt;</code> 有参有返回值，返回值是boolean类型，用来判断某项条件是否满足。经常用来进行筛滤操作。</p>
<p>其中的抽象方法：<code>boolean test(T t);</code></p>
<p>T是输入，输出boolean类型，表示一种条件过滤。<br>stream的filter方法穿参是Predicate。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class PredicateTest &#123;</span><br><span class="line">    Predicate&lt;Integer&gt; predicate = (i) -&gt; &#123;</span><br><span class="line">        return i &gt; 10;</span><br><span class="line">    &#125;;</span><br><span class="line">    boolean preDemo(Integer i, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">        return predicate.test(i);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testPreDemo() &#123;</span><br><span class="line">        System.out.println(preDemo(12, predicate));//打印结果：true</span><br><span class="line">        System.out.println(preDemo(12, i -&gt; i &gt; 13));//打印结果：false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅Consumer接口"><a href="#✅Consumer接口" class="headerlink" title="✅Consumer接口"></a>✅Consumer接口</h4><p>消费型接口：Consumer 有参无返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConsumerTest &#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = (str) -&gt; &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;;</span><br><span class="line">    public void conDemo(String str, Consumer&lt;String&gt; consumer) &#123;</span><br><span class="line">        consumer.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testConDemo() &#123;</span><br><span class="line">        conDemo(&quot;hello&quot;, consumer);//打印结果：hello</span><br><span class="line">        conDemo(&quot;hello&quot;, s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>更多函数式接口：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45580378/article/details/124853396">https://blog.csdn.net/weixin_45580378/article/details/124853396</a></p>
<p>迷惑：<br>1.函数式接口中的default方法是干嘛的<br>2.泛型。<code>Function&lt;T, R&gt;</code>代表两个泛型；<code>Function&lt;? super T, ? extends R&gt; mapper</code>代表限制泛型类型？</p>
<h4 id="✅Supplier接口"><a href="#✅Supplier接口" class="headerlink" title="✅Supplier接口"></a>✅Supplier接口</h4><p>供给型接口：Supplier 无参有返回值，用于提供数据源的。</p>
<p>该接口通常用于延迟计算，只有在需要结果的时候才进行计算，可以被用作一种工厂模式，生产不同的对象，具体实现可以由Lambda表达式传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; supplier = () -&gt; &quot;hello&quot;;</span><br><span class="line">String res = supplier.get();</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure>

<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Java 8 提供的，是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。</p>
<p>Optional，可以避免没有必要的 null 值检查.</p>
<p><code>public final class Optional&lt;T&gt; &#123;&#125;</code></p>
<p>Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。<br>在 Java 8 之前，任何访问对象方法或属性的调用都可能导致NullPointerException.</p>
<p>✅创建Optional对象</p>
<p>1）可以使用静态方法 empty() 创建一个空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty); // 输出：Optional.empty</span><br><span class="line"></span><br><span class="line">@Test(expected = NoSuchElementException.class)</span><br><span class="line">public void whenCreateEmptyOptional_thenNull() &#123;</span><br><span class="line">    Optional&lt;Person&gt; emptyOpt = Optional.empty();</span><br><span class="line">    System.out.println(emptyOpt);</span><br><span class="line">    emptyOpt.get(); //NoSuchElementException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）可以使用静态方法 of() 创建一个非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;11&quot;);</span><br><span class="line">System.out.println(opt); // 输出：Optional[11]</span><br></pre></td></tr></table></figure>

<p>传递给 of() 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p>
<p>3）可以使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">System.out.println(optOrNull); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>

<p>✅ifPresent方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return value != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">    if (value != null)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过方法 isPresent() 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 obj != null 的判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;11&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br></pre></td></tr></table></figure>

<p>ifPresent(Consumer&lt;? super T&gt; consumer) 是如果不为null的话，对对象做什么操作。</p>
<p>java中的Optional：<br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/214824.htm">https://www.jb51.net/article/214824.htm</a><br>一文彻底搞懂 Java 的 Optional：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qing_gee/article/details/104767082">https://blog.csdn.net/qing_gee/article/details/104767082</a></p>
<h3 id="GenericConverter接口"><a href="#GenericConverter接口" class="headerlink" title="GenericConverter接口"></a>GenericConverter接口</h3><p>是spring框架中用于进行类型转换的接口，可以将一种类型的对象转换成另一种类型的对象。</p>
<p>GenericConverter是converter接口的一个比较精致的实现，它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</p>
<p>getConvertibleTypes返回一个source-&gt;target的键值对，然后通过实现convert接口来实现你的转换逻辑。sourceTypeDescrptor能让你获取到存放着即将被转换的值的field，而targetTypeDescriptor能让你获得被转换后的值将被存放的field。</p>
<p>GenericConverter的一个很好的例子就是能将array转collection的ArrayToCollectionConverter。</p>
<p>例子：<br>1、首先需要写一个配置类，它作为converter们的注册中心，然后将自己重写的GenericConverter注册进来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public ConvertService getConvertService() &#123;</span><br><span class="line">    ConversionServiceFactoryBean bean = new ConversionServiceFactoryBean();</span><br><span class="line">    Set&lt;?&gt; sets = Sets.newHashSet(new MyGenericConverter());</span><br><span class="line">    bean.setConverters(sets);</span><br><span class="line">    bean.afterPropertiesSet();</span><br><span class="line">    return bean.getObject();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class MyGenericConverter implements GenericConverter &#123;</span><br><span class="line">    /**</span><br><span class="line">        * 告诉转换器总部，我这个转换器支持什么样的转换，可以支持多个转换</span><br><span class="line">        * 此处支持 string -&gt; list 和 string -&gt; map</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;ConvertiblePair&gt; getConvertibleTypes() &#123;</span><br><span class="line">        Set&lt;ConvertiblePair&gt; convertiblePairs = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        ConvertiblePair stringToArray = new ConvertiblePair(String.class, Array.class);</span><br><span class="line">        ConvertiblePair stringToMap = new ConvertiblePair(String.class, Map.class);</span><br><span class="line">        convertiblePairs.add(stringToArray);</span><br><span class="line">        convertiblePairs.add(stringToMap);</span><br><span class="line">        return convertiblePairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * @param source     被转换的东西</span><br><span class="line">        * @param sourceType 被转换的东西的上下文，可以用于设置条件，具体咋玩看typeDescriptor，比如可以用来判断转换源是否拥有某些注解</span><br><span class="line">        *                   @see TypeDescriptor</span><br><span class="line">        * @param targetType 转换目标类型的上下文</span><br><span class="line">        * @return</span><br><span class="line">        * 案例场景：如果转换源被@Resource标识，并且目标类型为List，则转换list</span><br><span class="line">        *                                         目标类型为map，则转换为map</span><br><span class="line">        */</span><br><span class="line">    @Override</span><br><span class="line">    public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) &#123;</span><br><span class="line">        Resource annotation = sourceType.getAnnotation(Resource.class);</span><br><span class="line">        if (annotation!= null)&#123;</span><br><span class="line">            if (targetType.getType() == List.class)&#123;</span><br><span class="line">                return Arrays.asList(source.toString().split(&quot;:&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            if (targetType.getType() == Map.class)&#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;a&quot;,source.toString().split(&quot;:&quot;)[0]);</span><br><span class="line">                map.put(&quot;b&quot;,source.toString().split(&quot;:&quot;)[1]);</span><br><span class="line">                return map;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        DefaultConversionService defaultConversionService = new DefaultConversionService();</span><br><span class="line">        defaultConversionService.addConverter(new MyGenericConverter());</span><br><span class="line"></span><br><span class="line">        Apple apple = new Apple();</span><br><span class="line">        apple.setName(&quot;1:2&quot;);</span><br><span class="line"></span><br><span class="line">        List convert = (List) defaultConversionService.convert(apple.getName(),</span><br><span class="line">                new TypeDescriptor(Apple.class.getDeclaredField(&quot;name&quot;)),</span><br><span class="line">                new TypeDescriptor(ResolvableType.forRawClass(List.class),null,null));</span><br><span class="line">        System.out.println(convert.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、getConvertibleTypes 用于告诉注册中心，你重写的converter能够支持什么样的转换，比如我的就支持string到list，string到map的转换</p>
<p>参考：GenericConverter的用法随笔<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26950567/article/details/103685810">https://blog.csdn.net/qq_26950567/article/details/103685810</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/fastjson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/fastjson/" class="post-title-link" itemprop="url">fastjson</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 09:44:44" itemprop="dateCreated datePublished" datetime="2022-04-30T09:44:44+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-18 15:50:45" itemprop="dateModified" datetime="2023-02-18T15:50:45+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>fastjson是阿里出品的处理JSON字符串的Java类库，可以对JSON字符串、JSON对象、Java对象进行互相转换。需要导入fastjson包。</p>
<h3 id="String、JSONObject、Object转换"><a href="#String、JSONObject、Object转换" class="headerlink" title="String、JSONObject、Object转换"></a>String、JSONObject、Object转换</h3><p>一、字符串转成JSON对象/数组<br>字符串转成JSON对象<br>JSON.parseObject(String text)<br>JSON.parse(String text)</p>
<p>字符串转成JSON数组<br>JSON.parseArray(String text)<br>JSON.parse(String text)</p>
<p>二、字符串转成Java对象/列表<br>字符串转成Java对象<br>JSON.parseObject(String text, Class<T> clazz)</T></p>
<p>字符串转成Java对象列表<br>JSON.parseArray(String text, Class<T> clazz)</T></p>
<p>三、Java对象/列表转成JSON对象/数组<br>Java对象转成JSON对象<br>JSONObject.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>Java对象列表转成JSON数组<br>JSONArray.toJSON(Object javaObject)<br>JSON.toJSON(Object javaObject)</p>
<p>四、JSON对象/数组转成Java对象/列表<br>JSON对象转成Java对象<br>JSON.toJavaObject(JSON json, Class<T> clazz)<br>jsonObject.toJavaObject(JSON json) (非静态方法)</T></p>
<p>JSON数组转成Java对象列表<br>jsonArray.toJavaList(Class<T> clazz) (非静态方法)</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class FastJSONLearning &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    String jsonObjectStr = &quot;&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;&quot;;</span><br><span class="line">    String jsonArrayStr = &quot;[&#123;\&quot;prop\&quot;:\&quot;code\&quot;,\&quot;label\&quot;:\&quot;代码\&quot;,\&quot;required\&quot;:true,\&quot;key\&quot;:true&#125;,&#123;\&quot;prop\&quot;:\&quot;explain\&quot;,\&quot;label\&quot;:\&quot;中文释义\&quot;,\&quot;required\&quot;:true&#125;]&quot;;</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON对象/数组</span><br><span class="line">    // 字符串转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject1 = JSON.parseObject(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject2 = (JSONObject) JSON.parse(jsonObjectStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON对象: &quot; + jsonObject2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray1 = JSON.parseArray(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray1);</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray2 = (JSONArray) JSON.parse(jsonArrayStr);</span><br><span class="line">    System.out.println(&quot;字符串转成JSON数组: &quot; + jsonArray2);</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象/列表</span><br><span class="line">    // 字符串转成Java对象</span><br><span class="line">    Dict dict = JSON.parseObject(jsonObjectStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象: &quot; + dict.toString());</span><br><span class="line"> </span><br><span class="line">    // 字符串转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList = JSON.parseArray(jsonArrayStr, Dict.class);</span><br><span class="line">    System.out.println(&quot;字符串转成Java对象列表: &quot; + dictList.toString());</span><br><span class="line"> </span><br><span class="line">    // Java对象/列表转成JSON对象/数组</span><br><span class="line">    // Java对象转成JSON对象</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONObject jsonObject3 = (JSONObject) JSONObject.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONObject jsonObject4 = (JSONObject) JSON.toJSON(dict);</span><br><span class="line">    System.out.println(&quot;Java对象转成JSON对象: &quot; + jsonObject4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // Java对象列表转成JSON数组</span><br><span class="line">    // 方法1</span><br><span class="line">    JSONArray jsonArray3 = (JSONArray) JSONArray.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray3.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // 方法2</span><br><span class="line">    JSONArray jsonArray4 = (JSONArray) JSON.toJSON(dictList);</span><br><span class="line">    System.out.println(&quot;Java对象列表转成JSON数组: &quot; + jsonArray4.toJSONString());</span><br><span class="line"> </span><br><span class="line">    // JSON对象/数组转成Java对象/列表</span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法1</span><br><span class="line">    Dict dict1 = JSON.toJavaObject(jsonObject1, Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict1);</span><br><span class="line"> </span><br><span class="line">    // JSON对象转成Java对象</span><br><span class="line">    // 方法2</span><br><span class="line">    Dict dict2 = jsonObject1.toJavaObject(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON对象转成Java对象: &quot; + dict2);</span><br><span class="line"> </span><br><span class="line">    // JSON数组转成Java对象列表</span><br><span class="line">    List&lt;Dict&gt; dictList1 = jsonArray1.toJavaList(Dict.class);</span><br><span class="line">    System.out.println(&quot;JSON数组转成Java对象列表: &quot; + dictList1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lasdaybg/p/15144350.html">https://www.cnblogs.com/lasdaybg/p/15144350.html</a></p>
<h3 id="json文件中获取"><a href="#json文件中获取" class="headerlink" title="json文件中获取"></a>json文件中获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class JsonTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void TestJ()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            File jsonFile = ResourceUtils.getFile(&quot;classpath:hello.json&quot;);</span><br><span class="line">            String s = FileUtils.readFileToString(jsonFile);</span><br><span class="line">            System.out.println(&quot;s:&quot;+s);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;error:&quot;+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileUtils 需要导包：commons-io。<br>classpath表示项目中的resource文件夹。</p>
<h3 id="JSONObject、JSONArray"><a href="#JSONObject、JSONArray" class="headerlink" title="JSONObject、JSONArray"></a>JSONObject、JSONArray</h3><p>也是fastjson下的</p>
<p>JSON是互联网开发过程中应用最广泛的一种数据类型，不管是后端API接口中，还是在前端都能得到广泛应用。JSON 就是一种轻量级的数据交换格式，被广泛应用于 WEB 应用程序开发</p>
<p>在线解析：<a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/53/">https://c.runoob.com/front-end/53/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;area&quot;: &quot;山东菏泽&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;马马马马马百万&quot;,</span><br><span class="line">  &quot;age&quot;: [1,2,3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON、JSON对象、JSON数组区别<br>JSON 呢只是一种宏观上的叫法，可以理解为是一种数据结构，就像 xml 结构一样，是一种规约性内容；而 JSON 对象则是对 JSON 的具体体现；JSON 数组则是将多个 JSON 对象进行存储的一个集合，可以想象成 Java 中的 List 和 Object 的关系</p>
<h4 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h4><p>JSONObject 是根据 JSON 形式在 Java 中存在的对象映射<br>各大 JSON 类库的 JSONObject 内部实现也是不太一样的。<br>例如fastjson：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class JSONObject extends JSON implements Map&lt;String, Object&gt;, Cloneable, Serializable, InvocationHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line">对 HashMap 的一层封装，并提供了一些个性化方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSONObject json = new JSONObject();</span><br><span class="line">json.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">json.put(&quot;key1&quot;,&quot;11&quot;);</span><br><span class="line">System.out.println(json.getInteger(&quot;key1&quot;));</span><br><span class="line">System.out.println(json.getString(&quot;key&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="JSONArray"><a href="#JSONArray" class="headerlink" title="JSONArray"></a>JSONArray</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class JSONArray extends JSON implements List&lt;Object&gt;, Cloneable, RandomAccess, Serializable &#123;</span><br><span class="line">&#125;</span><br><span class="line">一个 List 中 套了个 Map 类结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">JSONObject drug = new JSONObject();</span><br><span class="line">drug.put(&quot;drugName&quot;, &quot;盐酸丁卡因注射液&quot;);</span><br><span class="line">JSONArray array = new JSONArray();</span><br><span class="line">array.add(person);</span><br><span class="line">array.add(drug);</span><br></pre></td></tr></table></figure>

<h4 id="各种转换"><a href="#各种转换" class="headerlink" title="各种转换"></a>各种转换</h4><p>普通对象、json字符串、jsonObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将对象转换为json字符串</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">String jsonStr = JSON.toJSONString(person);</span><br><span class="line">将json字符串转换为JSONObject对象</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonStr);</span><br><span class="line">将JSONObject 转换为对象</span><br><span class="line">JSONObject person = new JSONObject();</span><br><span class="line">person.put(&quot;name&quot;, &quot;马马马马马百万&quot;);</span><br><span class="line">person.put(&quot;age&quot;, 25);</span><br><span class="line">Student stuObj = JSON.toJavaObject(person, Student.class);</span><br></pre></td></tr></table></figure>

<h3 id="一个对象转换为另一个对象"><a href="#一个对象转换为另一个对象" class="headerlink" title="一个对象转换为另一个对象"></a>一个对象转换为另一个对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = JSON.parseObject(JSON.toString(a), b.class)</span><br></pre></td></tr></table></figure>


<h3 id="getJSONObject、getJSONArray"><a href="#getJSONObject、getJSONArray" class="headerlink" title="getJSONObject、getJSONArray"></a>getJSONObject、getJSONArray</h3><p>Fastjson中getJSONObject()与getJSONArray()，用于获取JSONObject里的JSONObject、JSONArray()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;    &quot;package&quot;: &#123;</span><br><span class="line">        &quot;List1&quot;: &#123;</span><br><span class="line">            &quot;errorCode&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;errorMsg&quot;: &quot;Success&quot;,</span><br><span class="line">            &quot;receiverTradeNum&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;List2&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;medicalNum&quot;: &quot;15XXXXXX&quot;,</span><br><span class="line">                &quot;queryDate&quot;: &quot;YYYYMMDD&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;XXX&quot;,</span><br><span class="line">                &quot;authorizationNum&quot;: &quot;xxxxx&quot;,</span><br><span class="line">                &quot;pageNum&quot;: &quot;1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = JSON.parseObject(jsonStr);</span><br><span class="line">JSONObject package = jsonObj.getJSONObject(&quot;package&quot;);     // 定位到package json对象</span><br><span class="line">JSONArray list = package.getJSONArray(&quot;List2&quot;);   //采用getJSONArray方法， 定位到json集合</span><br></pre></td></tr></table></figure>


<h3 id="XStream"><a href="#XStream" class="headerlink" title="XStream"></a>XStream</h3><p>XStream是Java类库，用来将对象序列化成XML（JSON）或反序列化为对象。<br>也就是说，使用XStream，我们可以把Java对象转换成XML，也可以将XML转换为Java对象。</p>
<p>依赖：<br>XStream的必导JAR包：<br>核心JAR包：xstream-1.4.7.jar；<br>必须依赖包：xpp3_min-1.1.4c.jar（XML Pull Parser，一款速度很快的XML解析器）。</p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XStream xStream = new XStream();</span><br><span class="line">xStream.alias(&quot;china&quot;, List.class);   //标签类换成指定字符</span><br><span class="line">xStream.alias(&quot;province&quot;, Province.class);</span><br><span class="line">xStream.alias(&quot;city&quot;, City.class);</span><br><span class="line"></span><br><span class="line">xStream.useAttributeFor(Province.class, &quot;name&quot;); //子元素编程熟悉</span><br><span class="line">xStream.addImplicitCollection(Province.class, &quot;cities&quot;);  //去掉cities标签</span><br><span class="line"></span><br><span class="line">String string = xStream.toXML(proList);</span><br><span class="line">System.out.println(string);</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014565127/article/details/104419528">https://blog.csdn.net/u014565127/article/details/104419528</a></p>
<p><strong>高并发情况下的性能问题</strong></p>
<p>项目中使用了XStream进行XML序列化、反序列化的方案，完成服务之间的接口报文Object与Xmlg格式之间的转化。</p>
<p>当线上业务量并不大的情况下，一切正常；但是发现当业务量突然加大的情况下，突然发现，线上服务器出现CPU居高不下，服务接口调用速度越来越慢，研究JVM日志分析，发现出现很多的RUNNABLE问题。</p>
<p>问题原因：XStream在new的时候会创建CompositeClassLoader（初始类加载器），并且不断new会不断创建，导致ygc需要扫描的内容越来越多，最终导致接口调用性能下降。</p>
<p>XStream是线程安全的，不需要重复初始化xstream对象，每一种类型实例化一个对象即可，而正是由于开发人员错误地在每次处理时都实例化一个新的xstream对象，才导致了该问题。</p>
<p>解决：单列模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">原来：</span><br><span class="line">XStream xstream = XStreamInitializer.getInstance();</span><br><span class="line">xstream.processAnnotations(this.getClass());</span><br><span class="line">xstream.aliasSystemAttribute(null, &quot;class&quot;);</span><br><span class="line">return xstream.toXML(this);</span><br><span class="line"></span><br><span class="line">现在：</span><br><span class="line">实现单列：</span><br><span class="line">public class XmlHandler&#123;</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentHashMap xStream = new ConcurrentHashMap&lt;String, XStream&gt;();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     * @param objName</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static XStream getXStream(Class&lt;?&gt; objName) &#123;</span><br><span class="line">        String key = objName.getName();</span><br><span class="line">        if (xStream.get(key) == null)</span><br><span class="line">            xStream.put(key, new XStream());</span><br><span class="line">        return (XStream) xStream.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">序列化：</span><br><span class="line">XStream xstream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xstream.processAnnotations(Dog.class);</span><br><span class="line">String xml = xstream.toXML(dog);</span><br><span class="line"></span><br><span class="line">反序列化：</span><br><span class="line">XStream xStream = XmlHandler.getXStream(Dog.class);</span><br><span class="line">xStream.processAnnotations(Dog.class);</span><br><span class="line">Dog dog = (Dog) xStream.fromXML(xml);</span><br></pre></td></tr></table></figure>

<p>原文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767602/article/details/114824028">https://blog.csdn.net/weixin_43767602/article/details/114824028</a></p>
<h3 id="JSON与XML转化"><a href="#JSON与XML转化" class="headerlink" title="JSON与XML转化"></a>JSON与XML转化</h3><p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CDWLX/article/details/119038509">https://blog.csdn.net/CDWLX/article/details/119038509</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37366055/article/details/110468129">https://blog.csdn.net/baidu_37366055/article/details/110468129</a></p>
<p>xml转json：用 org.jdom，用 dom 提取节点 转成map<br>json转xml： com.alibaba.fastjson.JSONObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jdom&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdom&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;dom4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.16.graal&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line">import java.io.StringWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">import org.dom4j.io.OutputFormat;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line">import org.dom4j.io.XMLWriter;</span><br><span class="line">import org.jdom.Document;</span><br><span class="line">import org.jdom.Element;</span><br><span class="line">import org.jdom.JDOMException;</span><br><span class="line">import org.jdom.input.SAXBuilder;</span><br><span class="line">import org.xml.sax.InputSource;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONArray;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class JsonXML &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //请注意使用正常的xml</span><br><span class="line">        //xml-&gt;json</span><br><span class="line">//      String jsonStr = xmlToJson(&quot;D:\\NewFile.xml&quot;, null);</span><br><span class="line">//      System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line">        //json-&gt;xml</span><br><span class="line">        String xmlstr = jsonToXml(&quot;&#123;\&quot;b_content\&quot;:&#123;\&quot;sdata\&quot;:\&quot;Ps/DPJnZZPN6QQJQodY3+hK6PWCF3/2oi3DJPnFEXgKDrXX5rHT7q/I0nQPAruuBbQRfErnenQNvPpbf/lXl690qtye0/ZEuDs0ByFdFAGffQalB+Ij3lLUMDPz=\&quot;,\&quot;userobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;ma000\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;法人用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;10\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市天河区天河北路XXX号\&quot;,\&quot;legal_code=440***********033\&quot;,\&quot;ent_type=-1\&quot;,\&quot;link_person_code=350************14\&quot;,\&quot;origin=gdbs\&quot;,\&quot;card_type_two_num=-1\&quot;,\&quot;cert_ca=-1\&quot;,\&quot;accout_type=2\&quot;,\&quot;account_uid=2\&quot;,\&quot;comm_code=-1\&quot;,\&quot;unit_type=-1\&quot;,\&quot;legal_id_type=10\&quot;,\&quot;landline=-1\&quot;,\&quot;tax_code=-1\&quot;,\&quot;cert_notafter=-1\&quot;,\&quot;card_type_one_num=-1\&quot;,\&quot;local_user=-1\&quot;,\&quot;legal_person=郑**\&quot;,\&quot;link_person_type=10\&quot;,\&quot;card_type_three=-1\&quot;,\&quot;card_type_two=-1\&quot;,\&quot;card_type_three_num=-1\&quot;,\&quot;cert_data=-1\&quot;,\&quot;area=guangzhou\&quot;,\&quot;uversion=3.0\&quot;,\&quot;cert_notbefore=-1\&quot;,\&quot;card_type_one=-1\&quot;,\&quot;user_typeext=2\&quot;],\&quot;idcardnumber\&quot;:\&quot;11***************23\&quot;,\&quot;useridcode\&quot;:\&quot;38c97fa1ee2e43d4a664cffc4554cde4\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;pareobj\&quot;:&#123;\&quot;uid\&quot;:\&quot;mayintao\&quot;,\&quot;realtype\&quot;:\&quot;DC\&quot;,\&quot;cn\&quot;:\&quot;单位用户2\&quot;,\&quot;tokenid\&quot;:\&quot;\&quot;,\&quot;usertype\&quot;:\&quot;2\&quot;,\&quot;link_person_name\&quot;:\&quot;联系人2\&quot;,\&quot;isreal\&quot;:\&quot;true\&quot;,\&quot;telephonenumber\&quot;:\&quot;13*******21\&quot;,\&quot;mail\&quot;:\&quot;ceshi@123.com\&quot;,\&quot;idcardtype\&quot;:\&quot;50\&quot;,\&quot;createtime\&quot;:\&quot;20150618191221\&quot;,\&quot;extproperties\&quot;:[\&quot;address=广东省广州市东山区\&quot;,\&quot;legal_id_type=-1\&quot;,\&quot;link_person_type=-1\&quot;,\&quot;legal_code=-1\&quot;,\&quot;origin=gdbs\&quot;,\&quot;tax_code=-1\&quot;,\&quot;legal_person=-1\&quot;,\&quot;area=shenzhen\&quot;,\&quot;link_person_code=-1\&quot;,\&quot;user_typeext=2\&quot;,\&quot;uversion=1.0\&quot;],\&quot;idcardnumber\&quot;:\&quot;456787654\&quot;,\&quot;useridcode\&quot;:\&quot;75c91fagrr2e67d4a169cfmc8735ctrf\&quot;,\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;,\&quot;user_creditable_level\&quot;:&#123;\&quot;creditable_level_of_account_way\&quot;:\&quot;L2@YSS@2088******653||L0@IDV@44088******75||L3@GW@44088******75\&quot;,\&quot;creditable_level_of_account_way_list\&quot;:[&#123;\&quot;auth_time\&quot;:\&quot;2018-02-28 16:45:26\&quot;,\&quot;uniqueid\&quot;:\&quot;***86f93fb61***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;2088******653\&quot;,\&quot;identity_level\&quot;:\&quot;L2\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;YSS\&quot;&#125;,&#123;\&quot;auth_time\&quot;:null,\&quot;uniqueid\&quot;:\&quot;***764486f93fb61212***\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L0\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;IDV\&quot;&#125;,&#123;\&quot;auth_time\&quot;:\&quot;2018-02-13 17:12:31\&quot;,\&quot;uniqueid\&quot;:\&quot;*****764486f93fb612122*****\&quot;,\&quot;user_name\&quot;:\&quot;郭**\&quot;,\&quot;auth_identification\&quot;:\&quot;44088******75\&quot;,\&quot;identity_level\&quot;:\&quot;L3\&quot;,\&quot;credential_no\&quot;:\&quot;44088******75\&quot;,\&quot;way_code\&quot;:\&quot;GW\&quot;&#125;],\&quot;creditable_level_of_account\&quot;:\&quot;L3\&quot;&#125;&#125;,\&quot;time_stamp\&quot;:\&quot;20200821\&quot;,\&quot;version \&quot;:\&quot;v1\&quot;,\&quot;sign\&quot;:\&quot;rxf0MFT7eQqYgYKWtgzNBi6mhS2tbqkPgI \&quot;&#125;&quot;);</span><br><span class="line">        System.out.println(xmlstr);</span><br><span class="line">        createXMLFile(formatXML(xmlstr), &quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * xml转json字符串 注意:路径和字符串二传一另外一个传null&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToJson &lt;br&gt;</span><br><span class="line">     * @param xmlPath xml路径(和字符串二传一,两样都传优先使用路径)</span><br><span class="line">     * @param xmlStr xml字符串(和路径二传一,两样都传优先使用路径)</span><br><span class="line">     * @return String</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws JDOMException</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static String xmlToJson(String xmlPath,String xmlStr)&#123;</span><br><span class="line">        SAXBuilder sbder = new SAXBuilder();</span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        Document document;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(xmlPath!=null)&#123;</span><br><span class="line">                //路径</span><br><span class="line">                document = sbder.build(new File(xmlPath));</span><br><span class="line">            &#125;else if(xmlStr!=null)&#123;</span><br><span class="line">                //xml字符</span><br><span class="line">                StringReader reader = new StringReader(xmlStr);</span><br><span class="line">                InputSource ins = new InputSource(reader);</span><br><span class="line">                document = sbder.build(ins);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return &quot;&#123;&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取根节点</span><br><span class="line">            Element el =  document.getRootElement();</span><br><span class="line">            List&lt;Element&gt; eList =  el.getChildren();</span><br><span class="line">            Map&lt;String, Object&gt; rootMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            //得到递归组装的map</span><br><span class="line">            rootMap = xmlToMap(eList,rootMap);</span><br><span class="line">            map.put(el.getName(), rootMap);</span><br><span class="line">            //将map转换为json 返回</span><br><span class="line">            return JSON.toJSONString(map);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return &quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转xml&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXml &lt;br&gt;</span><br><span class="line">     * @param json</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXml(String json)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            StringBuffer buffer = new StringBuffer();</span><br><span class="line">            buffer.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);</span><br><span class="line">            buffer.append(&quot;&lt;base&gt;&quot;);</span><br><span class="line">            JSONObject jObj = JSON.parseObject(json);</span><br><span class="line">            jsonToXmlstr(jObj,buffer);</span><br><span class="line">            buffer.append(&quot;&lt;/base&gt;&quot;);</span><br><span class="line">            return buffer.toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * json转str&lt;br&gt;</span><br><span class="line">     * 方 法 名：jsonToXmlstr &lt;br&gt;</span><br><span class="line">     * @param jObj</span><br><span class="line">     * @param buffer</span><br><span class="line">     * @return String</span><br><span class="line">     */</span><br><span class="line">    public static String jsonToXmlstr(JSONObject jObj,StringBuffer buffer )&#123;</span><br><span class="line">        Set&lt;Entry&lt;String, Object&gt;&gt;  se = jObj.entrySet();</span><br><span class="line">        for( Iterator&lt;Entry&lt;String, Object&gt;&gt;   it = se.iterator();  it.hasNext(); )</span><br><span class="line">        &#123;</span><br><span class="line">            Entry&lt;String, Object&gt; en = it.next();</span><br><span class="line">            if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONObject&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                JSONObject jo = jObj.getJSONObject(en.getKey());</span><br><span class="line">                jsonToXmlstr(jo,buffer);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;com.alibaba.fastjson.JSONArray&quot;))&#123;</span><br><span class="line">                if (en.getKey().equals(&quot;extproperties&quot;)) &#123;</span><br><span class="line">                    JSONArray ja = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    Iterator&lt;Object&gt; it1 = ja.iterator();</span><br><span class="line">                    List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">                    while (it1.hasNext()) &#123;</span><br><span class="line">                        String ob = (String) it1.next();</span><br><span class="line">                        System.out.println(ob);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    JSONArray jarray = jObj.getJSONArray(en.getKey());</span><br><span class="line">                    for (int i = 0; i &lt; jarray.size(); i++) &#123;</span><br><span class="line">                        buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                        JSONObject jsonobject =  jarray.getJSONObject(i);</span><br><span class="line">                        jsonToXmlstr(jsonobject,buffer);</span><br><span class="line">                        buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else if(en.getValue() != null &amp;&amp; en.getValue().getClass().getName().equals(&quot;java.lang.String&quot;))&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+en.getValue());</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                buffer.append(&quot;&lt;&quot;+en.getKey()+&quot;&gt;&quot;+&quot;&quot;);</span><br><span class="line">                buffer.append(&quot;&lt;/&quot;+en.getKey()+&quot;&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 节点转map&lt;br&gt;</span><br><span class="line">     * 方 法 名：xmlToMap &lt;br&gt;</span><br><span class="line">     * @param eList</span><br><span class="line">     * @param map</span><br><span class="line">     * @return Map&lt;String,Object&gt;</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static Map&lt;String, Object&gt; xmlToMap(List&lt;Element&gt; eList,Map&lt;String, Object&gt; map)&#123;</span><br><span class="line">        for (Element e : eList) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; eMap = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            List&lt;Element&gt; elementList = e.getChildren();</span><br><span class="line">            if(elementList!=null&amp;&amp;elementList.size()&gt;0)&#123;</span><br><span class="line">                eMap = xmlToMap(elementList,eMap);</span><br><span class="line">                Object obj = map.get(e.getName());</span><br><span class="line">                if(obj!=null)&#123;</span><br><span class="line">                    List&lt;Object&gt; olist = new ArrayList&lt;Object&gt;();</span><br><span class="line">                    if(obj.getClass().getName().equals(&quot;java.util.HashMap&quot;))&#123;</span><br><span class="line">                        olist.add(obj);</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line"></span><br><span class="line">                    &#125;else if(obj.getClass().getName().equals(&quot;java.util.ArrayList&quot;))&#123;</span><br><span class="line">                        olist = (List&lt;Object&gt;)obj;</span><br><span class="line">                        olist.add(eMap);</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(e.getName(), olist);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map.put(e.getName(), eMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(e.getName(), e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将已经格式化的xml字符串写入xml文件</span><br><span class="line">     * @param xmlStr</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean createXMLFile(String xmlStr,String xmlName)&#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            XMLWriter output = null;</span><br><span class="line">            //OutputFormat   format   =   OutputFormat.createPrettyPrint();</span><br><span class="line">            //format.setSuppressDeclaration(true);</span><br><span class="line">            // format.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为GBK，则应当用FileWriter来构建xml文件，否则会出现中文连码问题</span><br><span class="line">                /*outpt = new XMLWriter(</span><br><span class="line">                        new FileWriter(</span><br><span class="line">                                new File(&quot;D:/myeclipse/Workspaces/fusionChartsDemoTest/WebRoot/xml/&quot;+xmlName+&quot;.xml&quot;)) ,</span><br><span class="line">                                    format);</span><br><span class="line">                  */</span><br><span class="line"></span><br><span class="line">            //如果上面设置的xml编码类型为utf-8，则应当用FileOutputStream来构建xml文件，否则还是会出现问题</span><br><span class="line">            output = new XMLWriter(</span><br><span class="line">                    new FileOutputStream(</span><br><span class="line">                            new File(&quot;D:/&quot;+xmlName+&quot;.xml&quot;)));</span><br><span class="line">            output.setEscapeText(false);</span><br><span class="line">            output.write( xmlStr );</span><br><span class="line">            output.close();</span><br><span class="line">            return flag = true;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  String formatXML(String str) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        SAXReader reader=new SAXReader();</span><br><span class="line"></span><br><span class="line">        //创建一个串的字符输入流</span><br><span class="line">        StringReader in=new StringReader(str);</span><br><span class="line">        org.dom4j.Document doc=reader.read(in);</span><br><span class="line">        // 创建输出格式</span><br><span class="line">        OutputFormat formater=OutputFormat.createPrettyPrint();</span><br><span class="line">        //去掉xml文件的版本信息</span><br><span class="line">        //formater.setSuppressDeclaration(true);</span><br><span class="line">        //设置xml的输出编码</span><br><span class="line">        formater.setEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        //创建输出(目标)</span><br><span class="line">        StringWriter out=new StringWriter();</span><br><span class="line">        //创建输出流</span><br><span class="line">        XMLWriter writer=new XMLWriter(out,formater);</span><br><span class="line">        //输出格式化的串到目标中，执行后。格式化后的串保存在out中。</span><br><span class="line">        writer.write(doc);</span><br><span class="line"></span><br><span class="line">        writer.close();</span><br><span class="line"></span><br><span class="line">        // System.out.println(out.toString());</span><br><span class="line"></span><br><span class="line">        //返回我们格式化后的结果</span><br><span class="line">        return out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/myblog/JAVA/java%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/29/myblog/JAVA/java%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">java常规注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-29 22:56:27" itemprop="dateCreated datePublished" datetime="2022-04-29T22:56:27+08:00">2022-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-18 14:12:26" itemprop="dateModified" datetime="2023-02-18T14:12:26+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从JDK5开始,Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。</p>
<p>所有的注解本质上都是继承自 Annotation 接口。但是，手动定义一个接口继承 Annotation 接口无效的，需要通过 @interface 声明注解，Annotation 接口本身也不定义注解类型，只是一个普通的接口。</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="@Pattern"></a>@Pattern</h3><p>用来限定string格式，用正则表达式来限定。<br>需要导入validation-api包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class StudentVO&#123;</span><br><span class="line">        @Pattern(regexp = &quot;^[A-Za-z]+$&quot;, message = &quot;只能字母&quot;)</span><br><span class="line">        private String name;</span><br><span class="line">        private Long age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>常用的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1 匹配首尾空格的正则表达式：(^\s*)|(\s*$)</span><br><span class="line">  2 整数或者小数：^[0-9]+\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line">  3 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line">  4 只能输入n位的数字：&quot;^\d&#123;n&#125;$&quot;。</span><br><span class="line">  5 只能输入至少n位的数字：&quot;^\d&#123;n,&#125;$&quot;。</span><br><span class="line">  6 只能输入m~n位的数字：。&quot;^\d&#123;m,n&#125;$&quot;</span><br><span class="line">  7 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line">  8 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line">  9 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 10 只能输入非零的正整数：&quot;^\+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 11 只能输入非零的负整数：&quot;^\-[1-9][]0-9&quot;*$。</span><br><span class="line"> 12 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 13 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 14 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 15 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 16 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 17 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\w+$&quot;。</span><br><span class="line"> 18 验证用户密码：&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。</span><br><span class="line"> 19 验证是否含有^%&amp;&#x27;,;=?$\&quot;等字符：&quot;[^%&amp;&#x27;,;=?$\x22]+&quot;。</span><br><span class="line"> 20 只能输入汉字：&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 21 验证Email地址：&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;。</span><br><span class="line"> 22 验证InternetURL：&quot;^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 23 验证电话号码：&quot;^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 24 验证身份证号（15位或18位数字）：&quot;^\d&#123;15&#125;|\d&#123;18&#125;$&quot;。</span><br><span class="line"> 25 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 26 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 27 匹配中文字符的正则表达式： [\u4e00-\u9fa5]</span><br><span class="line"> 28 匹配双字节字符(包括汉字在内)：[^\x00-\xff]</span><br><span class="line"> 29 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> 30 String.prototype.len=function()&#123;return this.replace(/[^\x00-\xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 31 匹配空行的正则表达式：\n[\s| ]*\r</span><br><span class="line"> 32 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\/(.*)&gt;|&lt;(.*)\/&gt;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36927265/article/details/87864026</span><br></pre></td></tr></table></figure>

<p>在control层，前端调用来进行数据校验。</p>
<p>一、VO对象内用@Pattern限定，control方法中用@Valid检查。<br><a target="_blank" rel="noopener" href="http://www.wpf123.com/post/97.html">http://www.wpf123.com/post/97.html</a></p>
<p>二、control类用@Validated注解，方法内String参数用@Pattern</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Validated</span><br><span class="line">class Controller &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">public ResponseEntity&lt;List&lt;Permission&gt;&gt; query(</span><br><span class="line">    @RequestHeader(&quot;iv-user&quot;) String userId,</span><br><span class="line">        @Pattern(regexp = &quot;^accessor$&quot;, message = &quot;请求参数不合法&quot;)</span><br><span class="line">        @RequestParam(&quot;findBy&quot;) String accessor,</span><br><span class="line">        @RequestParam(&quot;accessorId&quot;) long accessorId)&#123;</span><br><span class="line">        //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JSONField"><a href="#JSONField" class="headerlink" title="@JSONField"></a>@JSONField</h3><p>来自fastjson，fastjson是阿里巴巴出品的快速解析json的一个工具,</p>
<p>一、name属性：用来指定JSON串中key的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(name = &quot;AGE&quot;)</span><br><span class="line">private String age;</span><br></pre></td></tr></table></figure>
<p>也可以作用在setter、getter方法上。</p>
<p>二、format规定日期格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(format=&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">private Date date;</span><br></pre></td></tr></table></figure>

<p>三、ordinal：规定字段的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(ordinal = 3)</span><br><span class="line">private int f0;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 2)</span><br><span class="line">private int f1;</span><br><span class="line"></span><br><span class="line">@JSONField(ordinal = 1)</span><br><span class="line">private int f2;</span><br></pre></td></tr></table></figure>

<p>四、serialize/deserialize指定字段不序列化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(serialize=false)</span><br><span class="line">public Date date;</span><br></pre></td></tr></table></figure>

<p>五、<code>@JSONField(serializeUsing=xxx.class, deserializeUsing=xxx.class)</code><br>指定序列化和反序列化字段使用的序列化器和反序列化器。<br>需要实现<code>ObjectSerializer</code>接口。</p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>LomBok中的注解，用来简化代码。</p>
<p>1.默认情况下，将打印所有非静态字段。<br>2.如果要跳过某些字段，可以用注释这些字段@ToString.Exclude。<br>3.可以使用精确指定要被toString方法包含的字段，先设置@ToString(onlyExplicitlyIncluded = true)，然后使用@ToString.Include标记每个要包含的字段。<br>4.可以更改用于标识成员的名称@ToString.Include(name = “some other name”)，name相当于给字段起别名。<br>5.可以通过更改成员的打印顺序@ToString.Include(rank = 1)。rank 表示该字段的优先级，值越大排在越前面，默认为 0，等级相同的成员以它们在源文件中出现的顺序打印。</p>
<h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>出于安全原因，浏览器禁止Ajax调用驻留在当前原点之外的资源。</p>
<p>跨源资源共享（CORS）是由大多数浏览器实现的W3C规范，允许您灵活地指定什么样的跨域请求被授权，而不是使用一些不太安全和不太强大的策略，如IFRAME或JSONP。</p>
<p>参数：<br>origins： 允许可访问的域列表<br>maxAge:准备响应前的缓存持续的最大时间（以秒为单位）。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins = &#123;&quot;http://domain2.com&quot;,&quot;。。。&quot;&#125;, maxAge = 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/188106">https://cloud.tencent.com/developer/article/188106</a></p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>开发restful API时，会用到，@RestController 是@controller和@ResponseBody 的结合。</p>
<p>@Controller 将当前修饰的类注入Spring IOC容器，使得从该类所在的项目跑起来的过程中，这个类就被实例化。</p>
<p>@ResponseBody 它的作用是指该类中所有的API接口返回的数据，甭管你对应的方法返回Map或是其他Object，它会以Json字符串的形式返回给客户端。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController  </span><br><span class="line">@RequestMapping(&quot;/home&quot;)  </span><br><span class="line">public class IndexController &#123;  </span><br><span class="line">    @RequestMapping(&quot;/&quot;)  </span><br><span class="line">    String get() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/  </span><br><span class="line">        return &quot;go to home&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @RequestMapping(&quot;/index&quot;)  </span><br><span class="line">    String index() &#123;  </span><br><span class="line">        //mapped to hostname:port/home/index/  </span><br><span class="line">        return &quot;go to index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6f5aec232c97">https://www.jianshu.com/p/6f5aec232c97</a></p>
<p>✅RequestMapping参数</p>
<p>1，value，method<br>value：指定请求的实际地址，指定的地址可以是URI Template模式。<br>method：指定请求的method类型，GET、POST、PUT、DELETE等。</p>
<p>2，consumes，produces<br>consumes：指定处理请求的提交内容类型（content-type），例如application/json，text/html。<br>produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型才返回。不但可以设置返回值类型还可以设定返回值的字符编码。</p>
<p>3，params，headers<br>params：指定request中必须包含某些参数值时，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p>前后端数据json数据类型</p>
<p>1，json对象类型，即前端定义的Content type为application/x-www-form-urlencoded等，后端应使用@RequestParam注解接收此类型的json参数。</p>
<p>2，json字符串类型，即前端定义的Content type为application/json，后端应使用@RequestBody注解接收json参数。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/FlyGoldfish/articles/15649305.html">https://www.cnblogs.com/FlyGoldfish/articles/15649305.html</a></p>
<p>在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/web&quot;)</span><br><span class="line">piblic class TestController &#123;</span><br><span class="line">    // 方法仅处理请求方式是GET和request Content-Type为“application/json”类型的请求</span><br><span class="line">    //普通参数用@RequestParam</span><br><span class="line">    @RequestMapping(value = &quot;/test1&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = &quot;application/json&quot;)</span><br><span class="line">    public String test2(@RequestParam(&quot;id&quot;) String id)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对象类型用@RequestBody</span><br><span class="line">    @RequestMapping(value = &quot;/test2&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;, consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    public String test2(@RequestBody VO vo)&#123;</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指定返回值类型为json</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json&quot;)</span><br><span class="line">public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">   JSONObject object = new JSONObject();</span><br><span class="line">   object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">   return object;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    //@responseBody就是返回值是json数据，使用@responseBody，就可以省略produces属性</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回值是json数据，字符编码为utf-8</span><br><span class="line">    @RequestMapping(value = &quot;/list&quot; , method = RequestMethod.POST,produces=&quot;application/json;charset=utf-8&quot;)</span><br><span class="line">    public JSONObject list(@PathVariable String communityId) &#123;</span><br><span class="line">    JSONObject object = new JSONObject();</span><br><span class="line">    object.put(&quot;communityId&quot;,communityId);</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46058921/article/details/122141863">https://blog.csdn.net/weixin_46058921/article/details/122141863</a></p>
<p>✅MediaType<br>consumes参数中可以用的。</p>
<p>MediaType媒体类型：决定浏览器将以什么形式、什么编码对资源进行解析Content-Type：也属于MediaType媒体类型，主要用于在请求头中指定资源的MediaType</p>
<p><a target="_blank" rel="noopener" href="https://javajgs.com/archives/75280">https://javajgs.com/archives/75280</a></p>
<p>✅RequestMapping、GetMapping、PostMapping的区别</p>
<p>@RequestMapping是一个无方法的注解。@GetMapping和@PostMapping是组合注解，分别是@RequestMapping(method = RequestMethod.GET)和@RequestMapping(method = RequestMethod.POST)的缩写。<br>GET、POST是方法的映射，表示为<br>@RequestMapping(method = RequestMethod.${方法})</p>
<p>在一开始的映射是使用@RequestMapping(method = RequestMethod.${方法})来表示。后来Spring4.3中引进了@GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping注解来帮助简化常用的HTTP方法的映射。</p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：f(@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””) String s</span><br><span class="line">       , 其他入参）</span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"> </span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</span><br></pre></td></tr></table></figure>

<p>✅@RequestParam如何接收List参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;hello&quot;, method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public boolean hello(@RequestParam(value = &quot;userIds&quot;) List&lt;Long&gt; userIds) &#123;</span><br><span class="line">   </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接在Params中加：1,2,3</p>
<p>⚠️：@RequestBody传的vo，并且指明传入json格式（contentType），放在body-row中。<br>用的是@RequestParam传参，放在Params中，放在body-row中用json格式不行。放在Params中，相当于是加在url后面。</p>
<p>✅@RequestParam如何接收Date参数</p>
<p>首先引入joda-time包。maven的dependency：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Controller代码里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String testMethod(@RequestParam @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date testdate)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman传参：直接2022-09-24 00:00:00</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)，因此@RequestBody只能用于接收POST请求的参数<br>@RequestParam接收的是key-value里面的参数(URL中的参数)，通常用于接收GET请求的参数（POST也能接收只接收URL里的，请求体的接收不到）</p>
<p>即：<br>如果参数是放在请求体VO中，传入后台的话，那么后台要用@RequestBody才能接收到；<br>如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收。</p>
<p>总结：<br>@RequestParam和@RequestBody都能接收Post方式请求传来的数据，但是@RequestParam不能接收json字符串，而@RequestBody能，@RequestBody不能接收form-data类型的内容，@RequestParam能。<br>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。<br>@ReuestBody接受单个参数的时候只能先使用Map&lt;String,Object&gt; params接收,然后再使用params.get(“name”)获取参数的值。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">https://blog.csdn.net/justry_deng/article/details/80972817</a></p>
<h3 id="postman上如何请求"><a href="#postman上如何请求" class="headerlink" title="postman上如何请求"></a>postman上如何请求</h3><p>✅post请求，传参是list的话，用@RequestParam的话只能放在url后面，长度是有限制的。用@RequestBody是放在body里。</p>
<p>✅关于@RequestParam传参和@RequestBody传参，在postman中如何加：<br>1、@RequestParam的参数可以放在postman的param中（跟在url后面），也可以放在body里的form-data里（放在body里的），但是不能放在body的raw里。能放在哪里需要看consume参数的MedisType，想放在form-data里需要设置MedisType为multipart/form-data，或者不要限定为json。<br>2、@RequestBody的参数放在body里的raw里格式为json。一般传对象vo。</p>
<p>✅RequestBody传map型参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@PostMapping(&quot;/test&quot;)</span><br><span class="line">public String testMethod(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    System.out.println(testDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman如何请求：<br>1.设置请求方式为Post<br>2.在Headers中添加Content-Type，值为application/json<br>3.在body中选择row，选择json数据格式，最后在下面以json的数据格式填写参数</p>
<p>✅@RequestParam传参什么时候放在form-data里，什么时候放在params里</p>
<p>长的话放在form-data里，不是跟在url后的。如果放在params里就是跟在url后面的。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody 注解的作用是将Controller的方法返回的对象，通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</p>
<p>@ResponseBody的作用其实是将java对象转为json格式的数据，然后直接写入HTTP response 的body中；一般在异步获取数据时使用</p>
<p>@ResponseBody 是作用在方法上的</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47609799/article/details/124843709">https://blog.csdn.net/weixin_47609799/article/details/124843709</a></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>lombok中的注解。<br>Builder 使用创建者模式又叫建造者模式。简单来说，就是一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程。</p>
<p>@Builder注解的作用主要是用来生成对象，并且可以为对象链式赋值。放在实体类上。<br>​@Builder​​注释为你的类生成相对略微复杂的构建器API。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.builder()</span><br><span class="line">        .name( &quot;admin&quot; )</span><br><span class="line">        .age( 18 )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>与@Singular结合使用<br>使用@Singular注释注释一个集合字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Singular</span><br><span class="line">private List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">.hobbies( &quot;110&quot; ).hobbies( &quot;112&quot; )</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/g56467467464/article/details/105407741">https://blog.csdn.net/g56467467464/article/details/105407741</a></p>
<h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>baomidou.mybatisplus的注解<br>@TableName是mybatis-plus中的注解，主要是实现实体类型和数据库中的表实现映射。<br>放在实体类DO上。</p>
<p>虽然功能相同，但是，@TableName是mybatis-plus中的注解，@Table是Hibernate中的注解。</p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>1 、@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。<br>2、一般写在mappe接口（DAO接口）的入参，对应xml中#{}中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用方法：</span><br><span class="line">Mapper接口方法：</span><br><span class="line">public int findById(@Param(&quot;userId&quot;) int userId);</span><br><span class="line">对应的xml文件：</span><br><span class="line"> &lt;select id=&quot;findById&quot; resultMap=&quot;baseMap&quot;&gt;</span><br><span class="line">    select &lt;include redif=&quot;all_column_list&quot;&gt; from table_name</span><br><span class="line">    where user_id = #&#123;userId&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>不使用@Param注解时，参数只能有一个，并且是Javabean。</p>
<p>使用了@Param后，可以不用parameterType？ 存疑</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h3><p>在使用Mybatis持久层框架来操作数据库时，我们可以使用@Mapper注解和@MapperScan注解来将Mapper接口类交给Sprinig进行管理。</p>
<p>目的就是为了不再写mapper映射文件（xml文件）。</p>
<p>Spring Boot的核心理念是：不建议使用xml文件配置。但是，这对MyBatis来说进退两难，因为MyBatis离不开xml，需要xml来配置sql语句。为了迎合Spring Boot的发展理念，MyBatis官方开发了mybatis-spring-boot-starter，我们要想更少的依赖xml，需要深入的研究mybatis-spring-boot-starter中的用法，尤其是@MapperScan和@Mapper的用法。</p>
<p>一、注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解<br>在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类</p>
<p>二、@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。指定要变成实现类的接口所在的包<br>添加位置：是在Springboot启动类上面添加，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication  </span><br><span class="line">@MapperScan(&#123;&quot;cn.mybatis.mappers.class&quot;,&quot;cn.mybatis.mappers.student&quot;&#125;)  </span><br><span class="line">public class SpringbootMybatisDemoApplication&#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">       SpringApplication.run(SpringbootMybatisDemoApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终实现：直接在Mapper类中采用注解的形式操作数据库，通过@MapperScan扫描制定的映射器存放路径，最终不需要加任何注解，也不需要对应的xml文件来配置sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不需要加任何注解，也不需要对应的xml文件</span><br><span class="line">public interface UserMapper&#123;</span><br><span class="line">     @Select(&quot;select * from user&quot;)</span><br><span class="line">     List&lt;User&gt; getUserList(String userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://www.mybatis.cn/archives/862.html">http://www.mybatis.cn/archives/862.html</a></p>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>@PostContruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。可作为一些数据的常规化加载，比如数据字典之类的。</p>
<p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void someMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public @PostConstruct void someMethod()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行时机：在依赖注入完成后被自动调用。在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct &gt;&gt; init &gt;&gt; service &gt;&gt; destroy &gt;&gt; PreDestroy</p>
<p>该注解与BeanPostProcessor接口有关，它有个实现类CommonAnnotationBeanPostProcessor，就是专门处理@PostConstruct  @PreDestroy注解。</p>
<hr>
<p>InitialzingBean接口的afterPropertiesSet和配置bean时的init-method，也有类似功能。</p>
<p>initMethod和InitializingBean是spring提供的两种对类的属性进行装配的方式。initMethod和InitializingBean指定方法的执行顺序在普通属性装配之后，initMethod指定的方法又在InitializingBean指定的方法之后执行。</p>
<p>三者执行顺序：Construction &gt; 对象属性set() 方法-&gt; @PostConstruct -&gt; InitializingBean -&gt; initMethod</p>
<p>总结：可不可以理解为@PostConstruct在初始化自己bean时，依赖注入其他属性bean后执行，而InitialzingBean接口又是在它后面。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chinawangfei/article/details/122825129">https://blog.csdn.net/chinawangfei/article/details/122825129</a></p>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>@Deprecated是java内置注解，此注解可以用在方法，属性，类上，表示已废弃，不维护，可能会删除。<br>表示不推荐程序员使用，但是还可以使用。</p>
<h3 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h3><p>用于对象属性字段的规则检测，为了避免使用冗余的代码进行if判断，使用@Valid注解实现。</p>
<p>是Spring中的注解，需要引入依赖，如果是 springboot 项目，那么可以不用引入了，已经引入了，就存在于最核心的 web 开发包 spring-boot-starter-web 里面。</p>
<p>如果不是，需要引入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法：在被检验的实体类中，使用注解加一些限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@NotBlank(message = &quot;请输入名称&quot;)</span><br><span class="line">@Length(message = &quot;名称不能超过个 &#123;max&#125; 字符&quot;, max = 10)</span><br><span class="line">public String name;</span><br><span class="line"> </span><br><span class="line">@NotNull(message = &quot;请输入年龄&quot;)</span><br><span class="line">@Range(message = &quot;年龄范围为 &#123;min&#125; 到 &#123;max&#125; 之间&quot;, min = 1, max = 100)</span><br><span class="line">public Integer age;</span><br><span class="line"></span><br><span class="line">@Email(message = &quot;邮箱不正确&quot;)</span><br><span class="line">@Min(value = 1000000)</span><br><span class="line"></span><br><span class="line">@NotEmpty(message=&quot;不能为空&quot;)</span><br><span class="line">@Size(message=&quot;最多5个&quot;, max=5)</span><br><span class="line">private List&lt;Intefer&gt; list;</span><br></pre></td></tr></table></figure>

<p>在Controller的对应方法中，对传入参数加@Valid注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/action/register&quot;)</span><br><span class="line">public Result registerByForm(@Valid @RequestBody RegisterUser registerUser)&#123;</span><br><span class="line">    return userService.register(registerUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43587472/article/details/110388778">https://blog.csdn.net/weixin_43587472/article/details/110388778</a></p>
<h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><p>springframework中的注解。<br>声明式事务管理，是建立在AOP之上，本质上是对方法前后进行拦截，然后再目标方法开始之前创建或加入一个一个事务，在执行完目标方法之后，根据执行情况提交或者回滚事务。</p>
<p>简而言之：@Transactional注解在代码执行出错时进行事务的回滚。</p>
<p>java异常模型：<br>Throwable是最顶层的父类，有Error和Exception两个子类。<br>Error表示严重的错误（如OOM等）；<br>Exception可以分为运行时异常（RuntimeException及其子类）和非运行时异常（Exception的子类中，除了RuntimeException及其子类之外的类）。</p>
<p>非运行时异常是检查异常（checked exceptions），一定要try catch，因为这类异常是可预料的，编译阶段就检查的出来；<br>Error和运行时异常是非检查异常（unchecked exceptions），不需要try catch，因为这类异常是不可预料的，编辑阶段不会检查，没必要检查，也检查不出来。</p>
<p>spring的@Transactional注解可以很方便的开启事务，但是默认只在遇到运行时异常和Error时才会回滚，非运行时异常不回滚，即Exception的子类中，除了RuntimeException及其子类，其他的类默认不回滚。</p>
<p>而rollbackFor属性可以解决这个问题，rollbackFor = Exception.class表示Exception及其子类的异常都会触发回滚，同时不影响Error的回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 运行时异常，正常回滚</span><br><span class="line">@Transactional</span><br><span class="line">public void save()&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new RuntimeException(&quot;我是异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 非运行时异常，加rollbackFor属性，抛出异常，并回滚</span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void save() throws IOException&#123;</span><br><span class="line">    StudentDO studentDO = new StudentDO();</span><br><span class="line">    studentDO.setName(&quot;ltm&quot;);</span><br><span class="line">    studentDO.setAge(22);</span><br><span class="line">    studentMapper.insert(studentDO);</span><br><span class="line">    throw new IOException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5988db897fc">https://www.jianshu.com/p/c5988db897fc</a></p>
<p>使用方法：<br>1.需要在启动类上添加@EnableTransactionManagement注解。<br>2.当作用在类上，该类所以public方法都具有该类型的事务属性。也可以加在public方法上。</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_9177933/2978291">https://blog.51cto.com/u_9177933/2978291</a></p>
<h3 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h3><p>✅java的异常体系</p>
<p><img src="https://img-blog.csdnimg.cn/2019101117003396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MjI5NTY3,size_16,color_FFFFFF,t_70"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1/0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<p>✅@SneakyThrows的作用：<br>普通Exception类,也就是我们常说的受检异常或者Checked Exception会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成IOException。</p>
<p>但是现实大部分情况下的异常，我们都是一路往外抛了事。所以渐渐的java程序员处理Exception的常见手段就是外面包一层RuntimeException，接着往上丢.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Lombok的@SneakyThrows就是为了消除这样的模板代码。<br>使用注解后不需要担心Exception的处理.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">public class SneakyThrowsExample implements Runnable &#123;</span><br><span class="line">  @SneakyThrows(UnsupportedEncodingException.class)</span><br><span class="line">  public String utf8ToString(byte[] bytes) &#123;</span><br><span class="line">    return new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @SneakyThrows</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    throw new Throwable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：最重要的是throw (T)t, 使用泛型,将传入的Throwable强转为RuntimeException异常.<br>虽然, 我们抛出的异常不是RuntimeException,但是可以骗过javac编译器,泛型最后存储为字节码文件时并没有泛型信息.</p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22162093/article/details/115486647">https://blog.csdn.net/qq_22162093/article/details/115486647</a></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>@Data注解是lombok.jar包下的注解，该注解通常用在实体bean上，不需要写出set和get方法，但是具备实体bean所具备的方法，简化编程提高变成速度。</p>
<p>@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。</p>
<p>@Data ：注在类上，提供类的get、set、equals、hashCode、toString等方法<br>@AllArgsConstructor ：注在类上，提供类的全参构造<br>@NoArgsConstructor ：注在类上，提供类的无参构造<br>@Setter ：注在属性上，提供 set 方法<br>@Getter ：注在属性上，提供 get 方法<br>@EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法<br>@Log4j/@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log</p>
<h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>lombok中的注解。可用于生成有参构造函数，也可以方便在写controller或者Service层的时候，需要注入很多的mapper接口或者另外的service接口的时候就避免会写很多的@Autowired注解。</p>
<p>实体类有参构造函数：<br>必须声明的变量为final</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">static class Person &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequiredArgsConstructor(onConstructor =@_(@Autowired))<br>写在类上可以代替@Autowired注解，需要注意的是在注入时需要用final定义，或者使用@notnull注解.<br>当我们需要注入Bean的时候可以直接在类名称上使用。代替了Autowrited注解.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/v1/demo&quot;)</span><br><span class="line">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span><br><span class="line">public class DemoController &#123;</span><br><span class="line">    private final DemoService demoService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>作用：抑制编译器警告，有时候可以看到idea中有警告的颜色标注，当我们不希望看到这些警告的时候，可以使用 SuppressWarnings注解来抑制警告信息。<br>在<code>&#123;&quot; &quot;&#125; </code>中，可以写入你希望抑制(不显示)警告信息。</p>
<p>例如：<br><code>@SuppressWarnings&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">all，抑制所有警告</span><br><span class="line">boxing，抑制与封装/拆装作业相关的警告</span><br><span class="line">cast，抑制与强制转型作业相关的警告</span><br><span class="line">dep-ann，抑制与淘汰注释相关的警告</span><br><span class="line">deprecation，抑制与淘汰的相关警告</span><br><span class="line">fallthrough，抑制与switch陈述式中遗漏break相关的警告</span><br><span class="line">finally，抑制与未传回finally区块相关的警告</span><br><span class="line">hiding，抑制与隐藏变数的区域变数相关的警告</span><br><span class="line">incomplete-switch，抑制与switch陈述式(enum case)中遗漏项目相关的警告</span><br><span class="line">javadoc，抑制与javadoc相关的警告</span><br><span class="line">nls，抑制与非nls字串文字相关的警告</span><br><span class="line">null，抑制与空值分析相关的警告</span><br><span class="line">rawtypes，抑制与使用raw类型相关的警告</span><br><span class="line">resource，抑制与使用Closeable类型的资源相关的警告</span><br><span class="line">restriction，抑制与使用不建议或禁止参照相关的警告</span><br><span class="line">serial，抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告</span><br><span class="line">static-access，抑制与静态存取不正确相关的警告</span><br><span class="line">static-method，抑制与可能宣告为static的方法相关的警告</span><br><span class="line">super，抑制与置换方法相关但不含super呼叫的警告</span><br><span class="line">synthetic-access，抑制与内部类别的存取未最佳化相关的警告</span><br><span class="line">sync-override，抑制因为置换同步方法而遗漏同步化的警告</span><br><span class="line">unchecked，抑制与未检查的作业相关的警告</span><br><span class="line">unqualified-field-access，抑制与栏位存取不合格相关的警告</span><br><span class="line">unused，抑制与未用的程式码及停用的程式码相关的警告</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41684621/article/details/123807986">https://blog.csdn.net/qq_41684621/article/details/123807986</a></p>
<p>✅<code>Raw use of parameterized class</code> 参数化类型的原始使用</p>
<p>指出省略了类型的参数化类的使用。这种对参数化类型的原始使用在Java中是有效的，但是会破坏使用类型参数的目的，并可能掩盖错误。此检查反映了编译阶段对原始类型的警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList(); //不指定范型，默认为Object类型</span><br><span class="line">list.add(&quot;123&quot;);</span><br><span class="line">list.add(1L);</span><br><span class="line">list.add(0.11d);</span><br><span class="line">// 可以这样构造list，但是下面转类型会出错，不能吧String类型转为double。</span><br><span class="line">//java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double</span><br><span class="line">for (Object o : list) &#123;</span><br><span class="line">    double a = (double) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是直接使用原生态类型的实现，在编译时期不会有任何问题，但是一旦运行就会报错：Exception in thread “main” java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Double，代码设计应该使错误尽早被发现，而这就是不安全的表现了，而且可读性而言，缺少了形式类型参数，我们很难明白List存储的类型是什么，表述性变差。</p>
<p>如果确定使用是安全的，不会在运行时候导致错误，则可通过 <code>@SuppressWarnings(&quot;rawtypes&quot;)</code>消除使用原生态类型警告。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1677759">https://cloud.tencent.com/developer/article/1677759</a></p>
<p>✅<code>Unchecked call to ... </code> 调用未经检查</p>
<p>比如上面add的时候就会提示，表示未检查add的参数的类型，因为定义list的时候没指定类型，如果指定类型就不报了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/myblog/spring/BeanFactory%E5%92%8CApplicationContext/" class="post-title-link" itemprop="url">BeanFactory、ApplicationContext</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-26 22:12:06" itemprop="dateCreated datePublished" datetime="2022-04-26T22:12:06+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-18 18:31:45" itemprop="dateModified" datetime="2023-02-18T18:31:45+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring%E7%90%86%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">spring理解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h3><p>BeanFactory使管理不同类型的java对象成为可能，应用上下文ApplacationContext建立在BeanFactor基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。我们一般称BeanFactory为IOC容器，而称ApplicationContext为应用上下文。但有时为了行文方便，我们也称ApplicationContext为Spring容器。</p>
<p>对于二者的用途，可以进行简单的划分：BeanFactor是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory。</p>
<p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<br>①继承MessageSource，因此支持国际化。<br>②统一的资源文件访问方式。<br>③提供在监听器中注册bean的事件。<br>④同时加载多个配置文件。<br>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>（2）BeanFactory通常是使用编程方式被创建的，而ApplicationContext可以用声明（就是用配置的方式）的方式创建，当然也可以使用ApplicationContext的实现类之一用编码方式来创建ApplicationContext的实例.</p>
<p>（3）BeanFactory采用的是延迟加载形式来注入bean的，只有在使用到getBean() 时，才对该bean进行加载实例化，这样我们就不能发现一些bean的配置问题。而ApplicationContext则相反，它是在容器启动的时候，一次性创建所有的bean，这样在容器启动时就能发现spring 中存在的配置错误。这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>（4）BeanFactory和ApplicationContext都支持BeanPostProcesser、BeanFactoryPostProcessor的使用，但两者的区别是：BeanFactory是手动注册的，ApplicationContext是自动注册的.</p>
<h3 id="ApplicationContext的创建方式"><a href="#ApplicationContext的创建方式" class="headerlink" title="ApplicationContext的创建方式"></a>ApplicationContext的创建方式</h3><h4 id="使用代码方式"><a href="#使用代码方式" class="headerlink" title="使用代码方式"></a>使用代码方式</h4><p>ApplicationContext接口常用实现类：</p>
<p>1.ClassPathXmlApplicationContext</p>
<p>a.加载单个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>b.加载多个配置文件方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] configs = &#123;&quot;bean1.xml&quot;,&quot;bean2.xml&quot;,&quot;bean3.xml&quot;&#125;;</span><br><span class="line">ApplicationContext cxt = new ClassPathXmlApplicationContext(configs);</span><br></pre></td></tr></table></figure>

<p>2.ConfigurableApplicationContext接口</p>
<p>StartApplication中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动springboot应用，获取spring的ioc容器</span><br><span class="line">ConfigurableApplicationContext context = SpringApplication.run(StartApplication.class, args);</span><br></pre></td></tr></table></figure>

<h4 id="使用配置-声明"><a href="#使用配置-声明" class="headerlink" title="使用配置(声明)"></a>使用配置(声明)</h4><p>在javaee应用中向Servlet容器中注入Spring容器的方法</p>
<p>ContextLoader 接口，它有两个实现 :ContextLoaderListener 和 ContextLoaderServlet. 其中常用的是 ContextLoaderListener. 从 spring 文档上可以查到，他们二者实现的功能基本一样，只是 ContextLoaderListener 不能在与 Servlet2.2 兼容的 web 容器中使用。另外，因为 ContextLoaderLitener 是一个 servlet Listener ，因此，它是在 servlet context 建立后立即执行，也就以为这 servlet 已建立， spring 的 ApplicationContext 就得到了初始化，并且能够相应第一个请求，所以首选 ContextLoaderListener.</p>
<p>在web.xml中添加如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; </span><br><span class="line"> &lt;! DOCTYPE web-app</span><br><span class="line">      PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line">      &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; </span><br><span class="line"> </span><br><span class="line"> &lt; web-app &gt; </span><br><span class="line">     &lt; display-name &gt; Baselib Application &lt;/ display-name &gt; </span><br><span class="line">    </span><br><span class="line">     &lt; context-param &gt; </span><br><span class="line">        &lt; param-name &gt; contextConfigLocation &lt;/ param-name &gt; </span><br><span class="line">        &lt; param-value &gt; </span><br><span class="line">        /WEB-INF/classes/spring-sup-middelbeans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-action.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-beans.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-cm.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-hibernate.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-resource.xml</span><br><span class="line">        /WEB-INF/classes/spring-ueaac-sso.xml</span><br><span class="line">        /WEB-INF/classes/com/javaeye/jert/application_context.xml</span><br><span class="line">        &lt;/ param-value &gt; </span><br><span class="line">    &lt;/ context-param &gt; </span><br><span class="line"></span><br><span class="line">    &lt; listener &gt; </span><br><span class="line">        &lt; listener-class &gt; org.springframework.web.context.ContextLoaderListener &lt;/ listener-class &gt; </span><br><span class="line">    &lt;/ listener &gt; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; param-value &gt; /WEB-INF/classes/spring-*.xml &lt;/ context-param &gt; </span><br></pre></td></tr></table></figure>

<p>这里主要是配置了 spring 的监听器 ContextLoaderListener ，它检查 contextConfigLocation 这个参数。如果它不存在的话，它将用 /WEB-INF/applicationContext.xml 作为默认的配置文件。如果 contextConfigLocation 存在的话，它将根据该参数的值查找配置文件的位置，来一一读取 spring 参数。</p>
<p>contextConfigLocation 是被 spring 固定的，专门用来查  找配置文件位置的.</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sole_ghost/article/details/1389664">https://blog.csdn.net/sole_ghost/article/details/1389664</a></p>
<h3 id="ApplicationContext-getBean"><a href="#ApplicationContext-getBean" class="headerlink" title="ApplicationContext.getBean"></a>ApplicationContext.getBean</h3><p>目的：获取Spring容器中已初始化的bean</p>
<p>第一种：getBean(String name)<br>参数name表示IOC容器中已经实例化的bean的id或者name,<br>在IOC容器中是唯一的不能重名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种：getBean(Class<T> type)<br>type表示要加载的Bean的类型。<br>如果该类型没有继承任何父类(Object类除外)和实现接口的话，那么要求该类型的bean在IOC容器中也必须是唯一的.(比如定义同一类的两个bean，但是property注入的属性不一样)<br>不需要类型转换。</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Person p = ctx.getBean(Person.class);</span><br></pre></td></tr></table></figure>

<p>第三种：getBean(String name,Class<T> type)<br>这种方式比较适合接口/抽象类，有不同实现类或子类时，type写接口或父类，name写bean name。</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = ctx.getBean(&quot;person&quot;,BasePerson.class);</span><br></pre></td></tr></table></figure>

<p>第四种： getBean(String name,Object[] args)<br>第二个参数Object[] args可以给bean的属性赋值，赋值的方式有两种：构造方法和工厂方法。但是通过这种方式获取的bean必须把scope属性设置为prototype，也就是非单例模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.构造方法方式：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.bean.Person&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br><span class="line"></span><br><span class="line">2.工厂注入方式：</span><br><span class="line">工厂类：</span><br><span class="line">public class PersonFactory &#123;</span><br><span class="line">//静态工厂注入</span><br><span class="line">public static Person getPersonInstance(String name,int age)throws Exception</span><br><span class="line">&#123;</span><br><span class="line">  Person p = (Person)Class.forName(&quot;com.bean.Person&quot;).newInstance();</span><br><span class="line">   Method m = p.getClass().getMethod(&quot;setName&quot;, java.lang.String.class);</span><br><span class="line">   m.invoke(p, name);</span><br><span class="line">   m = p.getClass().getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">   m.invoke(p, age);</span><br><span class="line">   return p;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置bean：</span><br><span class="line">&lt;bean name=&quot;p3&quot; class=&quot;com.factory.PersonFactory&quot; factory-method=&quot;getPersonInstance&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;</span><br><span class="line">&lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;age&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">Person p = (Person) ctx.getBean(&quot;p3&quot;,new Object[]&#123;&quot;王五&quot;,35&#125;);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23927391/article/details/80625578">https://blog.csdn.net/qq_23927391/article/details/80625578</a></p>
<h3 id="ApplicationContext-getBeanWithAnnotation"><a href="#ApplicationContext-getBeanWithAnnotation" class="headerlink" title="ApplicationContext.getBeanWithAnnotation"></a>ApplicationContext.getBeanWithAnnotation</h3><p>spring中可以通过getBeansWithAnnotation来获取ioc容器中使用了某个注解的所有bean,这个方法底层原理：我们知道可以通过反射来获取一个类中所有的注解，然后通过遍历spring容器中所有bean就能获取需要的结果。返回Map&lt;String, Object&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//自定义@Auditable注解</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">public @interface Auditable &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在person类中我们引入@Auditable，并通过@Component将其注入spring容器</span><br><span class="line">package com.yk.annotation;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Auditable(&quot;person.sleep&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    void sleep()&#123;</span><br><span class="line">        System.out.println(&quot;睡觉了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class TestApplicationContext implements ApplicationContextAware &#123;</span><br><span class="line"> </span><br><span class="line">    protected ApplicationContext applicationContext;</span><br><span class="line">	</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        Class aClass = Class.forName(&quot;com.yk.annotation.Auditable&quot;);</span><br><span class="line">        //boolean b = aClass.isAnnotation();</span><br><span class="line">        //System.out.println(b);</span><br><span class="line">        //Person person = applicationContext.getBean(Person.class);</span><br><span class="line">        Map beansWithAnnotation = applicationContext.getBeansWithAnnotation(aClass);</span><br><span class="line"></span><br><span class="line">        Iterator entries = beansWithAnnotation.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while (entries.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Map.Entry entry = (Map.Entry) entries.next();</span><br><span class="line">            System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42374693/article/details/115374179">https://blog.csdn.net/weixin_42374693/article/details/115374179</a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>一个使用工厂模式管理多个类实现同一个接口的例子：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33898233/article/details/91414228">https://blog.csdn.net/weixin_33898233/article/details/91414228</a></p>
<p><code>applicationContext.getBeansOfType(Sort.class);</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/yarn%E5%92%8Cmapreduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/yarn%E5%92%8Cmapreduce/" class="post-title-link" itemprop="url">yarn和mapreduce模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-23 12:45:14 / Modified: 18:55:54" itemprop="dateCreated datePublished" datetime="2022-04-23T12:45:14+08:00">2022-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="mapreduce"><a href="#mapreduce" class="headerlink" title="mapreduce"></a>mapreduce</h3><p>谷歌三剑客：GFS（高富帅）、bigtable、mapreduce（名人）</p>
<p>层次：GFS最底层文件系统、在往上是BigTable文件模型、再往上是算法MapReduce</p>
<p>map：拆解<br>reduce：组合</p>
<p>mapreduce类似于赛百味：得到数据（input）、切分（split）、把数据归类（map）、组装（shuffle）、交付（reduce）</p>
<p>例子：mapreduce做单词出现数的统计，每个步骤都是并行的过程。</p>
<p><img src="https://img-blog.csdnimg.cn/f7410910fe5e4976b6496ee312260cf4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="tu"></p>
<p>例子：mapreduce实现倒排索引，记录每个单词出现的位置<br><img src="https://img-blog.csdnimg.cn/55a12ac4d4a949d18ebc39338fdb0a39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>mapreduce架构：<br>首先是用户进程（user program）协调和定义程序怎么运行，负责拆解worker，其中一个master worker（作为用户的代理来协调整个过程）。</p>
<p><img src="https://img-blog.csdnimg.cn/6e02cd00a6b543d9bed5d582a23af7f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>mapreduce本质就是分支法。</p>
<h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><p>另一种资源协调者，hadoop1.x中负责资源管理的是一JobTracker。</p>
<p>yarn负责大数据计算中的：资源管理、程序调度。</p>
<p>主要由两个核心部分构成：ResourceManager（统揽全局）、NodeManager（管理每个计算机节点上的资源调度）<br>ResourceManager中有两个部分：ApplicationManager、ResourceScheduler</p>
<p>1.作业提交阶段：client向整个集群提交job，申请job_id，ResourceManager返回job资源提交路径和job_id，client收到后发送jar包到指定路径HDFS。client提交后向ResourceManager提交执行请求，ResourceManager创建一个ApplicationManager来管理这个job。</p>
<p>2.作业初始化阶段：ApplicationManager将job提交到ResourceScheduler中，ResourceScheduler维护一个job队列，等待执行。可以执行时，ResourceScheduler通知ApplicationManager有一个NodeManager可以执行job。ApplicationManager在NodeManager中开辟容器Container，Container中启动ApplicationMaster，ApplicationMaster获取HDFS上的文件，生成Task（可以是mapTask，也可以是reduceTask）。</p>
<p>3.任务分配阶段：ApplicationMaster向ResourceManager申请运行Task的任务资源，ResourceManager将Task任务分配给空闲的NodeManager，NodeManager创建用于执行Task的容器Container。</p>
<p>4.任务运行阶段：ApplicationMaster通知所有接收到Task计算任务的NodeManager启动计算，NodeManager进行计算。执行完成后，向ResourceManager申请Container运行新的Task。所有的Task执行完毕后，ApplicationMaster向ResourceManager申请注销自己。</p>
<p>5.作业完成阶段：框架更新任务的进度和状态。</p>
<p><img src="https://img-blog.csdnimg.cn/9d376a8d36394947951162090fcd08a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAamFkZWxsbGx4eHg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Pa4y1t7nf?spm_id_from=333.1007.top_right_bar_window_history.content.click">https://www.bilibili.com/video/BV1Pa4y1t7nf?spm_id_from=333.1007.top_right_bar_window_history.content.click</a></p>
<h3 id="mapreduce与yarn"><a href="#mapreduce与yarn" class="headerlink" title="mapreduce与yarn"></a>mapreduce与yarn</h3><p>mapreduce的流程：</p>
<p>1.首先用户程序 (JobClient) 提交了一个 job，job 的信息会发送到 Job Tracker 中，Job Tracker 是 Map-reduce 框架的中心，他需要与集群中的机器定时通信 (heartbeat), 需要管理哪些程序应该跑在哪些机器上，需要管理所有 job 失败、重启等操作，需要分配在每个 TaskTracker 上运行的 map 和 reduce 任务。</p>
<p>2.TaskTracker 是 Map-reduce 集群中每台机器都有的一个部分，他做的事情主要是监视自己所在机器的资源情况。 </p>
<p>3.TaskTracker 同时监视当前机器的 tasks 运行状况。TaskTracker 需要把这些信息通过 heartbeat 发送给 JobTracker，JobTracker 会搜集这些信息以给新提交的 job 分配运行在哪些机器上。上图虚线箭头就是表示消息的发送 - 接收的过程。</p>
<hr>
<p>MapReduce存在的问题：</p>
<p>1.JobTracker 是 Map-reduce 的集中处理点，存在单点故障。</p>
<p>2.JobTracker 完成了太多的任务，造成了过多的资源消耗，当 map-reduce job 非常多的时候，会造成很大的内存开销，潜在来说，也增加了 JobTracker fail 的风险，这也是业界普遍总结出老 Hadoop 的 Map-Reduce 只能支持 4000 节点主机的上限。</p>
<p>3.在 TaskTracker 端，以 map/reduce task 的数目作为资源的表示过于简单，没有考虑到 cpu/ 内存的占用情况，如果两个大内存消耗的 task 被调度到了一块，很容易出现 OOM (内存溢出：需要的内存空间大于系统分配的内存空间)。</p>
<p>4.在 TaskTracker 端，把资源强制划分为 map task slot 和 reduce task slot, 如果当系统中只有 map task 或者只有 reduce task 的时候，会造成资源的浪费，也就是前面提过的集群资源利用的问题。</p>
<p>5.源代码层面分析的时候，会发现代码非常的难读，常常因为一个 class 做了太多的事情，代码量达 3000 多行，，造成 class 的任务不清晰，增加 bug 修复和版本维护的难度。</p>
<p>6.从操作的角度来看，现在的 Hadoop MapReduce 框架在有任何重要的或者不重要的变化 ( 例如 bug 修复，性能提升和特性化 ) 时，都会强制进行系统级别的升级更新。更糟的是，它不管用户的喜好，强制让分布式集群系统的每一个用户端同时更新。这些更新会让用户为了验证他们之前的应用程序是不是适用新的 Hadoop 版本而浪费大量时间。</p>
<p>总结：从业界使用分布式系统的变化趋势和 hadoop 框架的长远发展来看，MapReduce 的 JobTracker/TaskTracker 机制需要大规模的调整来修复它在可扩展性，内存消耗，线程模型，可靠性和性能上的缺陷。</p>
<hr>
<p>yarn：</p>
<p>从 0.23.0 版本开始，Hadoop 的 MapReduce 框架完全重构，发生了根本的变化。新的 Hadoop MapReduce 框架命名为 MapReduceV2 或者叫 Yarn。</p>
<p>重构根本的思想是将 JobTracker 两个主要的功能分离成单独的组件，这两个功能是资源管理和任务调度 / 监控。新的ResourceManager 资源管理器全局管理所有应用程序计算资源的分配，每一个应用的 ApplicationMaster 负责相应的调度和协调。一个应用程序无非是一个单独的传统的 MapReduce 任务或者是一个 DAG( 有向无环图 ) 任务。ResourceManager 和每一台机器的节点管理服务器能够管理用户在那台机器上的进程并能对计算进行组织。</p>
<p>老的MapReduce主要包括Job Tracker和Task Tracker，YARN中主要是三个组件：Resource Manager、Node Manager和Application Master。Resource Manager负责全局资源分配，Application Master每个节点（job？）一个，负责当前节点的调度和协调。Node Manager是每台机器的代理，监控应用程序的资源使用情况，并汇报给Resource Manager。因此与老的MapReduce相比，YARN把资源管理与任务调度的工作分离开来，减少了MapReduce中Job Tracker的压力。</p>
<p>ResourceManager：是一个中心的服务，它做的事情是调度、启动每一个 Job 所属的 ApplicationMaster、另外监控 ApplicationMaster 的存在情况。ResourceManager 负责作业与资源的调度。接收 JobSubmitter 提交的作业，按照作业的上下文 (Context) 信息，以及从 NodeManager 收集来的状态信息，启动调度过程，分配一个 Container 作为 App Mstr.</p>
<p>NodeManager：功能比较专一，就是负责 Container 状态的维护，并向 RM 保持心跳。</p>
<p>ApplicationMaster：负责一个 Job 生命周期内的所有工作，类似老的框架中 JobTracker。但注意每一个 Job（不是每一种）都有一个 ApplicationMaster，它可以运行在 ResourceManager 以外的机器上。</p>
<hr>
<p>yarn的优势：</p>
<p>1 YARN大大减少了Job Tracker的资源消耗，并且让监测每个Job子任务状态的程序分布式化了。<br>2 YARN中Application Master是一个可变更部分，用户可以对不同编程模型编写自己的AppMst，让更多类型的编程模型能跑在Hadoop集群中。<br>3 老的框架中，Job Tracker一个很大的负担就是监控Job下任务的运行状况，现在由Application Master去做，而Resource Manager是监测Application Master的运行状况，如果出问题，会将其在其他机器上重启。</p>
<p>出处：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9523999e13cf">https://www.jianshu.com/p/9523999e13cf</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hahachenchen789/article/details/80527706">https://blog.csdn.net/hahachenchen789/article/details/80527706</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
