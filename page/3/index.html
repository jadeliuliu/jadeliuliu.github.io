<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jadeliu&#39;s blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Jadeliu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jade liu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jadeliu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jadeliu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/25/myblog/%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/" class="post-title-link" itemprop="url">《java并发编程的艺术》笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-25 23:05:34" itemprop="dateCreated datePublished" datetime="2022-08-25T23:05:34+08:00">2022-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:43:39" itemprop="dateModified" datetime="2023-08-20T15:43:39+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h2><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程，时间片一般几十毫秒。</p>
<p>上下文切换是指切换前需要保存上一个任务的状态。</p>
<p>由于线程有创建和上下文切换的开销，并发执行的速度不一定比串行快。</p>
<p>上下文每1s切换1000多次。</p>
<p>如何减少上下文切换？<br>1、无锁并发编程，多线程竞争锁时会引起上下文切换，可以将数据id根据hash算法取模分段，不同线程处理不同段的数据。<br>2、CAS算法，Atomic包下，不需要加锁。<br>3、避免创建不需要的线程。每次从waiting到runnable都需要进行一次上下文切换。<br>4、协程：在单线程中实现多任务调度，维持多个任务间的切换。</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2.死锁"></a>2.死锁</h3><p>线程a和线程b互相等待对方释放锁。</p>
<p>一旦出现死锁，业务可感知，使用jstack命令dump线程。</p>
<p>避免死锁的几个方法：<br>1、避免一个线程同时获取多个锁。<br>2、避免一个线程在锁内同时占用多个资源。<br>3、尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制<br>4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败。</p>
<h3 id="3-资源限制"><a href="#3-资源限制" class="headerlink" title="3.资源限制"></a>3.资源限制</h3><p>并发编程时的资源限制：<br>硬件限制：带宽的上传/下载速度（2Mb/s）、硬盘读写速度、CPU处理速度<br>软件限制：数据库连接数、socket连接数<br>例如：线程数比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p>
<p>使用等待超时模式模拟数据库连接池：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52043808/article/details/125759727">https://blog.csdn.net/m0_52043808/article/details/125759727</a></p>
<p>受到资源限制时，并发执行可能会编程串行执行，但是增加了上下文切换和资源调度的时间，比串行还慢。</p>
<p>如何解决？<br>1、对于硬件约束，考虑使用集群并行执行程序，不同机器处理不同数据。<br>2、对于软件限制，考虑使用资源池将资源复用。</p>
<h3 id="4-jstack命令dump线程"><a href="#4-jstack命令dump线程" class="headerlink" title="4.jstack命令dump线程"></a>4.jstack命令dump线程</h3><h4 id="✅什么是jstack？"><a href="#✅什么是jstack？" class="headerlink" title="✅什么是jstack？"></a>✅什么是jstack？</h4><p>如果有一天，你的Java程序长时间停顿，也许是它病了，需要用jstack拍个片子分析分析，才能诊断具体什么病症，是死锁综合征，还是死循环等其他病症。</p>
<p>jstack是JVM自带的Java堆栈跟踪工具，它用于打印出给定的java进程ID、core file、远程调试服务的Java堆栈信息.</p>
<pre><code>1、jstack命令用于生成虚拟机当前时刻的线程快照。
2、线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。
3、线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
4、如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
5、另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
</code></pre>
<h4 id="✅怎么用："><a href="#✅怎么用：" class="headerlink" title="✅怎么用："></a>✅怎么用：</h4><p>首先使用 jps命令查看需要打印线程栈的java进程号pid。<br>然后 jstack pid。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F	当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">-m	如果调用到本地方法的话，可以显示C/C++的堆栈</span><br><span class="line">-l	除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br></pre></td></tr></table></figure>

<p>输出解读：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;jstack 9348</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000018da5881000 nid=0x34c8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">[通过 jstack查看线程栈信息时通常看到的最多的是RUNNABLE,BLOCKED,WAITING和TIMED_WAITING这几种状态，</span><br><span class="line">我们一般看不到线程的NEW和TERMINATED状态，是因为在代码的运行过程中这两种状态只占很小一部分，</span><br><span class="line">我们捕捉到这两种状态前这两种状态已经一闪而过了。</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002e7e800 nid=0x2a1c in Object.wait() [0x0000000002f7f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"></span><br><span class="line">其中开头是线程名称，后面的为线程信息：</span><br><span class="line"> #1 表示当前线程ID，从 main线程开始，JVM 根据线程创建的顺序为线程编号.</span><br><span class="line">prio 是priority优先级的缩写，表名了当前线程的优先级，取值范围为[1-10]，默认为 5。在虚拟机进行线程调度的时候会参考该优先级为线程分配计算资源，这个数值越低越有优先获取到计算资源，一般不设置直接使用默认的优先级。</span><br><span class="line">os_prio为线程对应系统的优先级。</span><br><span class="line">nid 本地线程编号NativeID的缩写,对应JVM 虚拟机中线程映射在操作系统中的线程编号。我们可以使用 top 查看进程对应的线程情况进行相关映射。</span><br></pre></td></tr></table></figure>

<p>nid表示的是线程对应的系统本地的线程编号.</p>
<h4 id="✅案例：jstack-分析死锁问题"><a href="#✅案例：jstack-分析死锁问题" class="headerlink" title="✅案例：jstack 分析死锁问题"></a>✅案例：jstack 分析死锁问题</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法进行下去</p>
<p>死锁demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Java 死锁demo</span><br><span class="line"> */</span><br><span class="line">public class DeathLockTest &#123;</span><br><span class="line">    private static Lock lock1 = new ReentrantLock();</span><br><span class="line">    private static Lock lock2 = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public static void deathLock() &#123;</span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock2&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get the lock1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //设置线程名字，方便分析堆栈信息</span><br><span class="line">        t1.setName(&quot;mythread-jay&quot;);</span><br><span class="line">        t2.setName(&quot;mythread-tianluo&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、在终端中输入jsp查看当前运行的java程序<br>2、使用 jstack -l pid 查看线程堆栈信息<br>3、分析堆栈信息</p>
<p>会出现：Found one Java-level deadlock: 信息。</p>
<p>当一个线程占有一个锁的时候，线程堆栈会打印一个－locked&lt;0x22bffb60&gt;<br>当一个线程正在等在其他线程释放该锁，线程堆栈会打印一个－waiting to lock&lt;0x22bffb60&gt;<br>当一个线程占有一个锁，但又执行在该锁的wait上，线程堆栈中首先打印blocked,然后打印－waiting on &lt;0x22c03c60&gt;</p>
<h4 id="✅案例：分析CPU过高"><a href="#✅案例：分析CPU过高" class="headerlink" title="✅案例：分析CPU过高"></a>✅案例：分析CPU过高</h4><p>导致CPU过高的demo程序，一个死循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 有个导致CPU过高程序的demo，死循环</span><br><span class="line"> */</span><br><span class="line">public class JstackCase &#123;</span><br><span class="line"> </span><br><span class="line">     private static ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Task task1 = new Task();</span><br><span class="line">        Task task2 = new Task();</span><br><span class="line">        executorService.execute(task1);</span><br><span class="line">        executorService.execute(task2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Object lock = new Object();</span><br><span class="line"> </span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                long sum = 0L;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    sum += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排查步骤：<br>1、jps 命令获取目标 java 进程号<br>2、在服务器上，我们可以通过top命令查看各个进程的cpu使用情况，它默认是按cpu使用率由高到低排序的，拿到pid<br>top -Hp pid 【奇怪，不能用，只能top -p pid】<br>通过top -Hp pid可以查看该进程下，各个线程的cpu使用情况<br>3、把线程pid换成nid<br>将该线程好打印成 16进制的<br><code>printf &quot;%x\n&quot; 19343</code><br>4、jstack -l [PID] &gt;/tmp/log.txt<br>一般在生成环境，我们可以把这些堆栈信息打到一个文件里，再回头仔细分析<br>jstack 进程pid | grep -10 线程<br>nid<br>可以看到目标线程的线程堆栈信息了</p>
<p>转自：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44588186/article/details/124680586">https://blog.csdn.net/weixin_44588186/article/details/124680586</a><br>【jstack案例】<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19922839/article/details/115379649">https://blog.csdn.net/qq_19922839/article/details/115379649</a><br>【里面还有pstree 查看进程树，jvm 监控工具Liberica Mission Control】</p>
<h4 id="✅dump线程"><a href="#✅dump线程" class="headerlink" title="✅dump线程"></a>✅dump线程</h4><p>线程dump的目的是转存线程快照。快照中是当前JVM所有线程正在执行方法的堆栈信息。</p>
<p>通过线程dump来分析定位线程出现长时间停顿的原因，如线程死锁、线程死循环、线程请求外部资源长时间等待等。</p>
<p>可以用arthas获取dump文件，dump文件很大，几个G，可以用IDEA打开，或者用其他分析工具。arthas也可以输出所有线程。</p>
<p>线程dump：<a target="_blank" rel="noopener" href="https://blog.csdn.net/HaierFiller/article/details/117367228">https://blog.csdn.net/HaierFiller/article/details/117367228</a></p>
<h2 id="第二章-java并发机制的底层实现原理"><a href="#第二章-java并发机制的底层实现原理" class="headerlink" title="第二章 java并发机制的底层实现原理"></a>第二章 java并发机制的底层实现原理</h2><p>.java代码 -编译为- .class字节码文件 -加载到- jvm -执行字节码- 转化为汇编语言在cpu执行。</p>
<p>java的并发机制依赖于jvm的实现和cpu的执行。</p>
<h3 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1.volatile"></a>1.volatile</h3><h4 id="✅volatile底层"><a href="#✅volatile底层" class="headerlink" title="✅volatile底层"></a>✅volatile底层</h4><p>volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的可见性（所有线程看到的这个变量的值是一致的）。比synchronized执行成本低，不会引起线程上下文的切换和调度。</p>
<p>首先，了解一下cpu处理逻辑：<br>为了提高处理速度，cpu不直接与内存进行通信，而是先将内存的数据读到自己的内存缓存（以缓存行为单位）中。</p>
<p>处理器 - 高速缓存 - 缓存   \<br>处理器 - 高速缓存 - 一致性  - 总线 - 主内存<br>处理器 - 高速缓存 - 协议   /</p>
<p>存储大体上分两种, 主存是堆内存, 工作内存是栈内存, 属于线程私有。<br>对字段操作都需要先从主存读取数据加载进工作内存, 工作内存对这个副本数据进行操作<br>volatile修饰的变量, 等于在堆中这个变量的内存区域上打了个标, 所有操作都必须从主存中读取, 由MESI&lt;缓存一致性协议&gt;实现</p>
<p>对volatile声明的变量进行写操作会发生什么：<br>1、jvm向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回系统内存。lock指令执行期间会锁住总线/缓存，保证不会同时多个cpu修改共享变量。<br>2、多处理下，实现缓存一致性协议，每个处理器使用嗅探技术，保证它的内部缓存和系统内存的数据在总线上保持一致（发现自己缓存行对应的内存地址被修改，首先将缓存行置为无效，重新从系统内存中将数据读到缓存）。</p>
<p>volitale的使用优化：<br>jdk7中的LinkedTransferQueue，使用volitale时，采用追加字节的方式优化出队入队效率。</p>
<p>为什么？<br>因为处理器的高速缓存行是64个字节宽，不支持部分填充缓存行。这样头节点和尾节点在一个高速缓存行中，多处理器下，一个处理器修改头节点，会将整个缓存行锁定，在缓存一致性的作用下，导致其他处理器不能访问自己高速缓存行中的尾节点。<br>节点追加到64字节，可以避免头尾节点加载到同一个缓存行中，修改时不会相互锁定。</p>
<p>注意：缓存行非64字节的别这么做，共享变量不会被频繁写的话别这么做。</p>
<h4 id="✅volatile使用"><a href="#✅volatile使用" class="headerlink" title="✅volatile使用"></a>✅volatile使用</h4><p>⚠️注意：volatile能保证可见性，但不能保证原子性。<br>在 volatile 字段上进行了非原子类操作，会idea提示：<code>Non-atomic operations on volatile fields</code><br>比如：count++ 就是非原子操作，分三步：<br>1、从主存读取 i<br>2、在寄存器中进行加一运算, 自增操作, 此时已经修改工作内存中的值<br>3、将计算后的值赋给 i, 也就是刷回主存</p>
<p><strong>可见性</strong></p>
<p>volatile和static的可见性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>volatile的可见性：是多个线程间的共享变量，当一个线程修改时，其他的线程能够知道这个修改。<br>static不能知道变化，它的可见性：可访问。</p>
<p>volatile修饰的共享变量对其他线程具有可见性，可以保证线程安全。<br>static修饰的变量为全局变量, 对所有线程可访问, 可用于线程间的通信，但是不能保证线程安全。</p>
<p>static线程安全测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int count = 0;</span><br><span class="line"></span><br><span class="line">    private static void count() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            es.execute(VolatileDemo::count);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (es.isTerminated()) &#123;</span><br><span class="line">                System.out.println(&quot;end...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">        System.out.println(&quot;cost:&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个缓存线程池进行对static字段进行自增，结果不是100.<br>t1线程与 t2线程读取 count 值, 然后同步修改为 1, 再写回内存, 写了两遍 1。</p>
<p>因此，static修饰的变量确实可以在线程间通信, 对各个线程都是可见的。但是不能保证线程安全。</p>
<p>那么用volatile，相当于每次修改volatile变量都需要重新读取数据。<br>但是结果依然不是100.</p>
<p>volatile的可见性测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//private boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">//private static boolean tag = false;  //不会运行tag is true,exit</span><br><span class="line">private volatile  boolean tag = false; //会运行tag is true,exit</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void visibleTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //当tag标志变为true时结束循环并打印退出信息</span><br><span class="line">            while(!tag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;tag is true,exit......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            tag = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非原子性</strong></p>
<p>t1线程与t2线程同时从主存中读取了count = 1,自增, 这时候两个线程的寄存器中存的计算后的值都是 2, 然后要写回count的主存, 假设这时 t1成功了, 那么主存中的count就是2, 然后根据MESI协议, t2需要重新从主存读取count值, 得到的是2, 再将寄存器中的计算结果2 赋值给count, 刷回主存, 此时主存中的count值还是2, 而不是期望中的3。</p>
<p>怎么解决？<br>synchronized关键字，或者 atomic原子类 + volatile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private volatile static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">private static void count() &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-12 20:14</span><br><span class="line"> **/</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testVolatile() throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for(int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                    System.out.println(Thread.currentThread() + &quot; count:&quot; + count);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(&quot;count:&quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、static修饰的变量是静态变量, 表示不管对象有多少实例, 只有这一个变量, 强调变量的唯一性<br>2、volatile是基于JMM与MESI提出的一种内存一致性解决方案, 强调的是对共享变量的修改是可见的, 变量值是唯一的<br>3、volatile 可以保证对其所修饰的共享变量的原子性操作是线程安全的</p>
<p>转自：<br>volatile的可见性和非原子性：<a target="_blank" rel="noopener" href="https://www.codenong.com/js5a773b9fb9cb/">https://www.codenong.com/js5a773b9fb9cb/</a></p>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2.synchronized"></a>2.synchronized</h3><p>synchronized之前被称为重量级锁，但是java se 1.6 对synchronized进行优化：减少获取锁和释放锁带来的性能消耗而引入偏向锁、轻量级锁。</p>
<h4 id="✅synchronized锁三种形式"><a href="#✅synchronized锁三种形式" class="headerlink" title="✅synchronized锁三种形式"></a>✅synchronized锁三种形式</h4><p>1.对于普通同步⽅法：锁的是当前实例对象，通常指this，所有的普通同步⽅法⽤的都是同⼀把锁，即实例对象本身。</p>
<p>2.对于静态同步⽅法：锁的是当前类的Class对象。</p>
<p>3.对于同步⽅法块：锁的是synchronized 括号内的对象。</p>
<p>⚠️几个锁的区别：<br>1.静态方法同步和静态代码块同步：所有的静态同步⽅法⽤的也是同⼀把锁——类对象本身，⼀旦⼀个静态同步⽅法获取锁后，其他的静态同步⽅法都必须等待该⽅法释放锁后才能获取锁。（和实例没关系）</p>
<p>2.静态同步和普通同步：具体实例对象this和唯⼀模板Class，这两把锁是两个不同的对象，所以静态同步⽅法与普通同步⽅法之间是不会有竞态条件的</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-17 14:11</span><br><span class="line"> **/</span><br><span class="line">//资源类</span><br><span class="line">class Phone&#123;</span><br><span class="line">    //1.静态方法（加锁）</span><br><span class="line">    public static synchronized void sendEmail() &#123;</span><br><span class="line">        //暂停几秒钟线程</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendEmail&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.普通方法（加锁）</span><br><span class="line">    public synchronized void sendSMS() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------sendSMS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 普通方法不加锁</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread() + &quot;-------hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主方法</span><br><span class="line">public class SynchronizedDemo&#123;</span><br><span class="line">    //一切程序的入口，主线程</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone = new Phone();//资源类1</span><br><span class="line">        Phone phone2 = new Phone();//资源类2</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //phone.sendSMS(); //1、2</span><br><span class="line">                //phone.hello();</span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123; TimeUnit.MILLISECONDS.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅synchronized锁的实现原理"><a href="#✅synchronized锁的实现原理" class="headerlink" title="✅synchronized锁的实现原理"></a>✅synchronized锁的实现原理</h4><p>反编译命令：<code>javap -v -p *.class &gt; 类.txt </code>（将进⾏输出到txt中）</p>
<p>synchronized在jvm中的实现原理：jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，monitor是一个对象的监视器。</p>
<p><strong>同步代码块：</strong></p>
<p>同步代码块是通过monitorenter和monitorexit指令实现的。</p>
<p>monitorenter：在编译后插入到同步代码块的开始位置，会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。</p>
<p>monitorexit：代表执行完synchronized代码块之后，要从对象监视器中退出，也就是释放锁。</p>
<p><strong>同步普通⽅法：</strong></p>
<p>1.同步普通⽅法反编译后的结构：可以看到在synchronized修饰实例方法中，不会再有monitorenter和monitorexit指令，而是在这个方法上多了一个ACC_SYNCHRONIZED的flag。</p>
<p>2.调用普通方法的流程：当程序在运行时，调用method()方法时，会检查该方法是否有ACC_SYNCHRONIZED访问标识，如果有，则表明该方法是同步方法，这时候该线程会先尝试去获取该方法对应的监视器（monitor）对象，如果获取成功，则继续执行该method()方法。</p>
<p>3.在执行期间，任何其他线程都不能再获取该方法监视器的使用权，直到该方法正常退出或者抛出异常，才会释放，其他线程可以重新获得该监视器。</p>
<p><strong>同步静态方法：</strong></p>
<p>synchronized修饰静态方法和实例方法没有区别，都是增加一个ACC_SYNCHRONIZED的flag，静态方法只是比实例方法多一个ACC_STATIC标识代表这个方法是静态的。</p>
<p><strong>阿里开发手册说明：</strong></p>
<p>⾼并发时，同步调⽤应该去考量锁的性能损耗。<br>1.能⽤⽆锁数据结构，就不要⽤有锁；<br>2.能锁区块，就不要锁整个⽅法体；<br>3.能⽤对象锁，就不要⽤类锁；</p>
<p>参考：<br>synchronized三种加锁方式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38963649/article/details/126139304">https://blog.csdn.net/weixin_38963649/article/details/126139304</a></p>
<h4 id="✅java对象头"><a href="#✅java对象头" class="headerlink" title="✅java对象头"></a>✅java对象头</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>HotSpot虚拟机的对象头包括三部分信息：<br>1、mark word 2、元类指针 3、数组长度<br>普通对象头有两个区域（1，2）、数组对象头有三个区域（1,2,3）</p>
<p><strong>Mark Word</strong></p>
<p>这部分主要存储对象自身的运行数据，如Hashcode、gc分代年龄、对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位。</p>
<p>Java对象头一般占有2个机器码（64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
<p><strong>指向类的指针</strong></p>
<p>该指针在32位JVM的长度是32Bit，64是64bit<br>它主要指向类的数据，也就是指向方法区中的位置。</p>
<p><strong>数组长度</strong></p>
<p>只有数组对象保存了这部分数据<br>该数据在32位和64位JVM都是32bit</p>
<p>参考：<br>java对象头以及打印对象头：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sumengnan/article/details/125035218">https://blog.csdn.net/sumengnan/article/details/125035218</a><br>java对象头以及锁升级过程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Alei777/p/16308553.html">https://www.cnblogs.com/Alei777/p/16308553.html</a></p>
<h4 id="✅锁的升级与对比"><a href="#✅锁的升级与对比" class="headerlink" title="✅锁的升级与对比"></a>✅锁的升级与对比</h4><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。<br>在 Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。<br>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>偏向锁</strong></p>
<p>背景：<br>大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁原理：<br>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p>偏向锁释放和升级：<br>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正 在执行的字节码）。<br>1、首先暂停拥有偏向锁的线程<br>2、然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；<br>3、如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁（升级为轻量级锁），最后唤醒暂停的线程。</p>
<p>关闭偏向锁<br>偏向锁在Java 6和Java 7里是默认启用，如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：<br><code>-XX:-UseBiasedLocking=false</code></p>
<p><strong>轻量级锁</strong></p>
<p>升级为轻量级锁后，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>轻量级锁 -&gt; 重量级锁 的方式有两种：</p>
<p>1 若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p>
<p>2 另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p>
<p>自旋会消耗CPU，一旦重量级锁，就不会恢复为轻量级锁。当锁处于这个状态下，其他线程试图获取锁时， 都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p><strong>几种锁的对比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">锁	优点	缺点	使用场景</span><br><span class="line">偏向锁	加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳秒级的差距	如果线程间存在锁竞争，会带来额外的撤销消耗	适用于只有一个线程访问同步块场景</span><br><span class="line">轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	如果始终得不到锁竞争的线程，会自旋消耗CPU	追求响应时间、同步块执行非常快</span><br><span class="line">重量级锁	线程不使用自旋，不会消耗CPU	线程阻塞，响应时间缓慢	追求吞吐量、同步块执行速度较快</span><br></pre></td></tr></table></figure>

<p>参考：<br>《书中内容》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hello_mengkebao/article/details/119874999">https://blog.csdn.net/Hello_mengkebao/article/details/119874999</a></p>
<p><strong>总结：锁的升级过程</strong></p>
<p>JVM一般是这样使用锁和Mark Word的：</p>
<p>1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p>
<p>2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。</p>
<p>3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</p>
<p>4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p>
<p>5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</p>
<p>6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p>
<p>7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p>
<h3 id="3-Atomic原子操作"><a href="#3-Atomic原子操作" class="headerlink" title="3.Atomic原子操作"></a>3.Atomic原子操作</h3><p>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</p>
<h4 id="✅处理器如何实现原子操作"><a href="#✅处理器如何实现原子操作" class="headerlink" title="✅处理器如何实现原子操作"></a>✅处理器如何实现原子操作</h4><p>首先处理器会自动保证<strong>基本的内存操作的原子性</strong>。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的。</p>
<p>但是<strong>复杂的内存操作处理器是不能自动保证其原子性的</strong>，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p>
<p>首先我们要明确一点：a++是三步操作（取数，加一，赋值），而计算机和Java都只保证一步操作的原子性，多步操作是不保证原子性的。所以a++不是原子性的。想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>⚠️volitale保证可见性为什么不能实现i++的线程安全？</p>
<blockquote>
<p>可见性是指瞬时可见性，是指那一时刻的可见性。放在这个例子里，就是指当线程1把（a=0，a++）的结果a=1刷回到主存中时，所有目前有a这个变量的缓存此时都应该变为a=1，而不是使用原来的值。所以，线程2也执行加一后，还没有写回到缓存中，保存在寄存器中，线程2缓存里面的a=0被置为无效，所以线程2又从主存中取得a=1替换掉了自己缓存中的a=0，然后线程2将a=1写入自己的缓存中，随后a=1又一次被立刻刷回到主存中。最后主存中的值还是a=1。</p>
</blockquote>
<p><strong>总线锁</strong></p>
<p>总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p><strong>缓存锁</strong></p>
<p>总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>不能使用缓存锁的情况：<br>1、第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行。<br>2、有些处理器不支持缓存锁定</p>
<h4 id="✅java如何实现原子操作"><a href="#✅java如何实现原子操作" class="headerlink" title="✅java如何实现原子操作"></a>✅java如何实现原子操作</h4><p><strong>循环CAS</strong></p>
<p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数 – 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值相比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。（像改密码需要先验证旧密码一样）</p>
<p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<p>从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<p>CAS仍然存在<strong>三大问题</strong>。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。</p>
<p>1、ABA问题<br>CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>2、循环时间长开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p>3、只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证<strong>引用对象之间的原子性</strong>，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">count.incrementAndGet(); //原子自增</span><br><span class="line">int i = count.get();</span><br><span class="line">boolean suc = count.compareAndSet(i, ++i); //cas</span><br></pre></td></tr></table></figure>

<p><strong>使用锁实现原子操作</strong></p>
<p>使用锁机制实现原子操作锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
<p>参考：<br>书的笔记：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/412363896">https://zhuanlan.zhihu.com/p/412363896</a><br>jdk中的原子操作类：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a47285790467">https://www.jianshu.com/p/a47285790467</a><br>cas原理、synchronized悲观锁和cas乐观锁：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/15746624.html">https://www.cnblogs.com/huansky/p/15746624.html</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>几个java实现多线程安全的操作：<br>1、synchronized加锁<br>2、Volatile关键字<br>3、CAS</p>
<h2 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h2><h3 id="1-java内存模型的基础"><a href="#1-java内存模型的基础" class="headerlink" title="1.java内存模型的基础"></a>1.java内存模型的基础</h3><h4 id="✅并发编程的两个关键问题"><a href="#✅并发编程的两个关键问题" class="headerlink" title="✅并发编程的两个关键问题"></a>✅并发编程的两个关键问题</h4><p>1、线程之间如何通信：<br>通信是指线程之间以何种机制来交换信息<br>通信机制有两种：共享内存和消息传递</p>
<p>2、线程之间如何同步：<br>同步：指程序中用于控制不同线程间操作发生相对顺序的机制</p>
<p>java的并发采用的是共享内存模型，java线程之间的通信总是隐式进行，整个过程对程序员完全透明。</p>
<h4 id="✅java内存模型"><a href="#✅java内存模型" class="headerlink" title="✅java内存模型"></a>✅java内存模型</h4><p>堆内存：实例域、静态域、数组元素；在线程之间共享。<br>栈内存：局部变量、方法定义参数、异常处理器参数；不在线程之间共享，没有内存可见性问题。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见</p>
<p>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(抽象概念)，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证<br>两个线程要通信，要经历下面2个步骤：<br>线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br>线程B到主内存中去读取线程A之前已更新过的共享变量</p>
<h4 id="✅从源代码到指令序列的重排序"><a href="#✅从源代码到指令序列的重排序" class="headerlink" title="✅从源代码到指令序列的重排序"></a>✅从源代码到指令序列的重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序</p>
<p>重排序分3种类型，第一种属于编译器重排，后两种属于处理器重排：<br>编译器优化的重排序<br>指令级并行的重排序<br>内存系统的重排序</p>
<p>JMM通过禁止特定类型的编译器重排序和处理器重排序（插入特定类型的内存屏障），提供内存可见性保证。</p>
<p>处理器利用写缓冲区来临时保存向内存写入的数据。但是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。例如a=1，先写在缓冲区，然后下一个语句用了a，然后缓冲区才将a=1写入主内存。这就算重排序了。</p>
<h4 id="✅happens-before"><a href="#✅happens-before" class="headerlink" title="✅happens-before"></a>✅happens-before</h4><p>JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系（一种阐述内存可见性的概念）。就是要求前一个操作的执行结果对后一个操作可见。并不意味着操作A就一定在操作B之前执行。</p>
<p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</p>
<h3 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2.重排序"></a>2.重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
<h4 id="✅数据依赖性"><a href="#✅数据依赖性" class="headerlink" title="✅数据依赖性"></a>✅数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<br>数据依赖可分为：读后写、写后读、写后写。</p>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</p>
<h4 id="✅as-if-serial语义"><a href="#✅as-if-serial语义" class="headerlink" title="✅as-if-serial语义"></a>✅as-if-serial语义</h4><p>一个概念，意思是：不管怎么重排序，单线程的程序的执行结果不能被改变</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<p>意思就是，编译器和处理器为了提高单线程的并行度，会对没有依赖关系的操作重排序，但是不影响结果和可见性。</p>
<h4 id="✅重排序对多线程的影响"><a href="#✅重排序对多线程的影响" class="headerlink" title="✅重排序对多线程的影响"></a>✅重排序对多线程的影响</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ReorderExample &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a = 1; // 1</span><br><span class="line">        flag = true; // 2</span><br><span class="line">    &#125;</span><br><span class="line">    Public void reader() &#123;</span><br><span class="line">        if (flag) &#123; // 3</span><br><span class="line">        int i = a * a; // 4</span><br><span class="line">    ……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法.</p>
<p>操作1和操作2没有数据依赖关系，且操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两对操作重排序.</p>
<p>对线程A的两个操作进行重排序：<br>1、线程A首先写标记变量flag<br>2、随后线程B读这个变量。由于条件判断为真，线程B将读取变量a<br>3、此时，变量a还没有被线程A写入，多线程程序的语义被重排序破坏</p>
<p>对线程B的两个操作进行重排序：<br>1、由于操作3和操作4存在控制依赖关系，执行线程B的处理器可提前读取并计算a*a<br>2、然后把计算结果临时保存到一个名为重排序缓冲(Reorder Buffer，ROB)的硬件缓存中<br>3、当操作3的条件判断为真时，就把该计算结果写入变量i中，多线程程序的语义被重排序破坏</p>
<h3 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3.顺序一致性"></a>3.顺序一致性</h3><p>数据竞争的定义：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序</p>
<p>顺序一致性：如果程序是正确同步的，程序的执行将具有顺序一致性(即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)【是一个理想化的概念】</p>
<h4 id="✅顺序一致性模型"><a href="#✅顺序一致性模型" class="headerlink" title="✅顺序一致性模型"></a>✅顺序一致性模型</h4><p>在顺序一致性模型（理论参考模型）中（不管有没有同步）：<br>任意时刻最多只有一个线程可以连接到内存。<br>一个线程的所有操作按程序的顺序串行执行。<br>每个操作必须立即对任意线程可见。<br>所有线程都只能看到一个一致的整体执行顺序。</p>
<blockquote>
<p>JMM中没有上述保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致</p>
</blockquote>
<h4 id="✅同步程序的执行效果"><a href="#✅同步程序的执行效果" class="headerlink" title="✅同步程序的执行效果"></a>✅同步程序的执行效果</h4><p>在JMM中，临界区（一个同步块儿）内的代码可以重排序(因为JMM目的是在不改变程序执行结果的前提下，尽可能优化编译器和处理器)。</p>
<p>结果是：重排序提高了执行效率，而且没有改变程序的执行结果。</p>
<h4 id="✅未同步程序的执行效果"><a href="#✅未同步程序的执行效果" class="headerlink" title="✅未同步程序的执行效果"></a>✅未同步程序的执行效果</h4><p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致（一致也没意义）。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化，这对程序的执行性能会产生很大的影响。</p>
<p>JMM不保证单线程内的操作会按程序顺序执行。所有线程看到的操作顺序可能不一致。执行顺序可能是：2-3-4-1，语义被破坏。可能是4的右边-1-2-3-4的左边，语义被破坏。</p>
<h4 id="✅处理器总线事务"><a href="#✅处理器总线事务" class="headerlink" title="✅处理器总线事务"></a>✅处理器总线事务</h4><p>总线事务包括读事务（内存-处理器）和写事务（处理器-内存），中间都要通过总线，总线会同步试图并发使用总线的事务，一次只有一个事务可以操作总线访问内存。</p>
<p>所以，一次最多只有一个处理器可以访问内存，这保证了单个总线事务之中的内存读写（读跟写，不是i++）具有原子性。</p>
<p>但是：32位的处理器上，对long型和double型这俩64位的数据的写操作拆分成了两个写事务，会分配在不同的总线事务中执行。所以不具有原子性。</p>
<h3 id="4-volatile的内存语义"><a href="#4-volatile的内存语义" class="headerlink" title="4.volatile的内存语义"></a>4.volatile的内存语义</h3><h4 id="✅volatile的特性："><a href="#✅volatile的特性：" class="headerlink" title="✅volatile的特性："></a>✅volatile的特性：</h4><p>1、可见性：对volatile变量的单个读写，相当于是用同一个锁对单个读写方法做了同步。对volatile变量的读，总能看到最后的写入。被volatile修饰的变量对所有线程总是立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中。</p>
<p>2、原子性：对单个volatile变量的读写（64位的long和double类型也是）具有原子性，volatile++的复合操作不具有原子性。</p>
<h4 id="✅volatile变量读写实现线程之间通信"><a href="#✅volatile变量读写实现线程之间通信" class="headerlink" title="✅volatile变量读写实现线程之间通信"></a>✅volatile变量读写实现线程之间通信</h4><p>volatile变量的写、读，与锁的释放、获取有相同的内存效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">public void writer() &#123;</span><br><span class="line">    a = 1;//1</span><br><span class="line">    flag = true;//2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reader() &#123;</span><br><span class="line">    if (flag) &#123;  //3</span><br><span class="line">        int i = a; //4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1 happens-before 2  (执行顺序可能在一个临界区内重排序)<br>3 happens-before 4<br>2 happens-before 3 （volatile带来的）<br>so: 1 happens-before 4</p>
<p>疑问：1.2没有数据依赖，可能被重排序。<br>指令重排使得执行顺序不会变成：2-3-4-1 吗？ 下面给答案。</p>
<h4 id="✅volatile写读的内存语义"><a href="#✅volatile写读的内存语义" class="headerlink" title="✅volatile写读的内存语义"></a>✅volatile写读的内存语义</h4><p>线程 - 本地内存 - 主内存</p>
<p>1、当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量（那个a）值刷新到主内存。（实质就是A向接下来要读这个volatile变量的某个线程发出了消息（我对共享变量做出的修改））</p>
<p>2、当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。（实质就是接受了之前某个线程发出的消息）</p>
<p>3、A写，B读，实质就是A通过主内存向B发送消息，实现线程之间通信</p>
<h4 id="✅volatile内存语义的实现-禁止指令重排。"><a href="#✅volatile内存语义的实现-禁止指令重排。" class="headerlink" title="✅volatile内存语义的实现-禁止指令重排。"></a>✅volatile内存语义的实现-禁止指令重排。</h4><p>背景：上面实现线程间通信那一小节，疑惑的是1.2是不是能重排序，3.4是不是能重排序。在这里给出答案，</p>
<p>为了实现volatile的内存语义，JMM会限制重排序类型。</p>
<p>1、当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到写之后。</p>
<p>2、当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到读之前。</p>
<p>3、当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。</p>
<p>那么，如何实现限制指令重排？<br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>尽管内存屏障会降低效率，但是JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<h4 id="✅JSR-133增强volatile的内存语义"><a href="#✅JSR-133增强volatile的内存语义" class="headerlink" title="✅JSR-133增强volatile的内存语义"></a>✅JSR-133增强volatile的内存语义</h4><p>Java内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存模型远比想象要更难。JSR133为Java语言定义了一个新的内存模型，它修复了早期内存模型中的缺陷。为了实现JSR133，final和volatile的语义需要重新定义。</p>
<p>旧的内存模型中，volatile的写读没有锁的释放和获取的内存语义，也就是实现线程之间通信那一小节里，会指令重排。</p>
<p>JSR-133，严格限制编译器和处理器对volatile变量与普通变量的重排序，确保了volatile的写读有锁的释放和获取的内存语义。</p>
<p>volatile与锁对比：<br>锁在功能上比volatile更强大，可以确保整个临界区代码具有原子性。volatile只能对单个volatile变量读写具有原子性。（所以不能单纯用volatile实现计数器）<br>在可伸缩性和执行性能上，volatile更具有优势。</p>
<h3 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5.锁的内存语义"></a>5.锁的内存语义</h3><p>达到效果：线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立即变得对B线程可见。</p>
<h4 id="✅锁释放和获取的内存语义"><a href="#✅锁释放和获取的内存语义" class="headerlink" title="✅锁释放和获取的内存语义"></a>✅锁释放和获取的内存语义</h4><p>1、当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。（实质上是线程A向接下来要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。）</p>
<p>2、当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器锁保护的临界区代码必须从主内存中读取共享变量。（实质上是线程B接受了之前某个线程发出的（在释放这个锁对共享变量锁做的修改的）消息。）</p>
<p>3、线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h4 id="✅锁内存语义的实现"><a href="#✅锁内存语义的实现" class="headerlink" title="✅锁内存语义的实现"></a>✅锁内存语义的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();                 // 获取锁</span><br><span class="line">try &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();          // 释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronized(AQS) 。AQS使用一个整型的volatile变量（state）来维护同步状态，这个volatile变量是ReentrantLock内存语义实现的关键。</p>
<p><strong>公平锁：</strong></p>
<p>加锁方法首先读取volatile变量state。<br>释放锁的最后写volatile变量state。</p>
<p>效果：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取到同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<p><strong>非公平锁：</strong></p>
<p>非公平锁的释放和公平锁的释放完全一致。</p>
<p>加锁：用了：<code>unsafe.compareAndSwapInt(this, stateOffset, expect, update);</code></p>
<p>该方法以原子操作的方式更新state变量，也就是compareAndSet() (CAS)操作。JDK文档对该方法说明如下：如果当前状态值等于预期值，则以原子方式同步状态设置为给定更新的值。此操作具有volatile读和写的内存语义。<br>（编译器不能对CAS与CAS前面和后面任意内存操作重排序。）</p>
<p>CAS具有volatile读写内存语义的实现方式：lock前缀<br>intel手册对lock前缀的说明：<br>对内存的读-改-写操作原子执行。（总线锁定/缓存锁定）<br>禁止该指令，与之前的读和写指令重排序<br>把写缓冲区的所有数据刷新到内存中<br>上面的2、3两点所具有的内存屏障的效果，足以同时实现volatile读和volatile写的内存语义。所以JDK文档说CAS 具有volatile读和volatile写的内存语义对于处理器也是符合的。</p>
<p><strong>总结：</strong><br>释放锁-获取锁的内存语义的实现方式总结 ：<br>利用volatile变量的写-读所具有的内存语义<br>利用CAS所附带的volatile读和volatile写的内存语义</p>
<h4 id="✅concurrent包的实现"><a href="#✅concurrent包的实现" class="headerlink" title="✅concurrent包的实现"></a>✅concurrent包的实现</h4><p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器实现同步的关键。同时volatile变量的读/写和CAS可以实现线程之间的通信。这些特性就是Java整个concurrent包的基石。</p>
<p>concurrent包的通用化实现模式：<br>1、声明共享变量volatile<br>2、使用CAS的原子条件更新来实现线程之间的同步<br>3、配合volatile的读/写和CAS具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）、非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中基础类都是使用这个模式来实现的，而concurrent包中的高层类又是依赖于这些基础类。</p>
<p>图示concurrent包的实现示意图：</p>
<p><img src="/images/concurrent%E5%8C%85.png"></p>
<h3 id="6-final域的内存语义"><a href="#6-final域的内存语义" class="headerlink" title="6.final域的内存语义"></a>6.final域的内存语义</h3><p>文中探讨的变量对线程可见，是保证线程安全的方式，如果不可见，那就要同步加锁，反言之，加锁也是为了变量对线程可见。</p>
<h4 id="✅final域的重排序规则"><a href="#✅final域的重排序规则" class="headerlink" title="✅final域的重排序规则"></a>✅final域的重排序规则</h4><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<p>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<blockquote>
<p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。</p>
<p>写普通域的操作可能被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值，很可能obj对象还没有构造完成，初始值1还没有写入普通域i。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。</p>
</blockquote>
<blockquote>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
</blockquote>
<p>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<blockquote>
<p>编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器的。</p>
</blockquote>
<blockquote>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    int i;  //普通变量</span><br><span class="line">    final int j;  //final变量</span><br><span class="line">    static FinalExample obj;</span><br><span class="line">    public FinalExample() &#123; //构造函数</span><br><span class="line">        i = 1; //写普通域</span><br><span class="line">        j = 2; //写final域</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程B执行</span><br><span class="line">        FinalExample object = obj; //读对象引用</span><br><span class="line">        int a = object.i; //读普通域</span><br><span class="line">        int b = object.j; //读final域</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅final域为引用类型"><a href="#✅final域为引用类型" class="headerlink" title="✅final域为引用类型"></a>✅final域为引用类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">    final int[] intArray; //final是引用类型</span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    public FinalReferenceExample() &#123; //构造函数</span><br><span class="line">        intArray = new int[1]; //1</span><br><span class="line">        intArray[0] = 1; //2</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerOne() &#123; //写线程A执行</span><br><span class="line">        obj = new FinalReferenceExample(); //3</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writerTwo() &#123; //写线程B执行</span><br><span class="line">        obj.intArray[0] = 2; //4</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; //读线程C执行</span><br><span class="line">        if (obj != null) &#123; //5</span><br><span class="line">            int temp1 = obj.intArray[0]; //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在<strong>构造函数内</strong>对一个final引用的对象的成员域的写入(2)，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量(3)，这两个操作之间不能重排序。</p>
<p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="✅为什么含final的对象引用不能从构造函数内“溢出”"><a href="#✅为什么含final的对象引用不能从构造函数内“溢出”" class="headerlink" title="✅为什么含final的对象引用不能从构造函数内“溢出”"></a>✅为什么含final的对象引用不能从构造函数内“溢出”</h4><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    final int                          i;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1; //1写final域</span><br><span class="line">        obj = this; //2 this引用在此“逸出”</span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123;  //线程B</span><br><span class="line">        if (obj != null) &#123; //3</span><br><span class="line">            int temp = obj.i; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作2使得对象还未完成构造前就为线程B可见。这里的操作1和操作2之间可能被重排序。线程B看到了此时的final域可能还没有被初始化。</p>
<p>final不同于普通变量达到的效果是：在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="✅处理器中如何实现final语义"><a href="#✅处理器中如何实现final语义" class="headerlink" title="✅处理器中如何实现final语义"></a>✅处理器中如何实现final语义</h4><p>本来应该要插入内存屏障的。<br>X86处理器不会对写-写操作做重排序，X86处理器不会对存在间接依赖关系的操作做重排序，也就是说，在X86处理器中，final域的读/写不会插入任何内存屏障！（普通变量也有依赖关系吧，也有final语义？）</p>
<h4 id="✅JSR-133为什么要增强final的语义"><a href="#✅JSR-133为什么要增强final的语义" class="headerlink" title="✅JSR-133为什么要增强final的语义"></a>✅JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h3 id="7-happens-before"><a href="#7-happens-before" class="headerlink" title="7.happens-before"></a>7.happens-before</h3><h4 id="✅设计初衷"><a href="#✅设计初衷" class="headerlink" title="✅设计初衷"></a>✅设计初衷</h4><p>设计内存模型JMM的初衷：让程序员易于理解，易于编程，提供内存可见性保证。对编译器和处理器的束缚越少越好，方便它们优化来提高性能。</p>
<p>JMM 对于这两种类型的重排序做了不同的处理：<br>对于有数据依赖的重排序，JMM 要求编译器和处理器禁止这种重排序<br>对于没有数据依赖的重排序，JMM 要求编译器和处理器不做处理</p>
<p>JMM 的 happens - before 向程序员提供了足够强的内存可见性保证，但是其中有些内存可见性保证其实不一定存在，【比如 int a=1; int b=2; 这个就只是可见，不保证执行顺序，但也是happens-before】。</p>
<p>JMM 对于编译器和处理器的优化已经尽可能少了。JMM 其实在遵循一个规则：单线程下或者已经同步的多线程下（synchronized，volatile等），只要不改变程序的执行结果，编译器和处理器想要怎么优化都可以。【比如 对于volatile 变量，如果编译器分析后认定这个变量只会被单线程访问，不存在多线程的可见性问题，那么编译器就会把 volatile 变量当作普通变量进行处理】。</p>
<h4 id="✅happens-before的定义"><a href="#✅happens-before的定义" class="headerlink" title="✅happens-before的定义"></a>✅happens-before的定义</h4><p>JSR - 133中提出，JSR - 133 使用 happens - before 关系来向程序员提供跨线程的内存可见性保证。</p>
<p>1、如果一个操作 happens - before 另一个操作，那么另一个操作的执行结果将对第二个操作可见。</p>
<p>2、两个操作之间存在 happens - before 关系，并不意味这 Java 平台必须要按照 happens - before 规定的顺序来执行。只要重排序之后的结果是不改变的，那么 JMM 是默认不对这种重排序处理的</p>
<p>核心原则是：只要不改变程序的执行结果（<strong>单线程和正确同步的多线程</strong>），编译器和处理器怎么优化都行。程序员对于这两个操作是否真的被重排序并不关心，程序员只需要关系的是程序执行时的语义不能被改变（就是执行结果不能被改变）。</p>
<p>happens - before 给编写正确同步的多线程程序的程序员一个幻觉：正确同步的多线程程序是按照 happens - before 指定的顺序来执行的。实际上不是，但是语义和按顺序执行是一样的。<br>（实际上是可见性，但也是一种假的顺序）</p>
<h4 id="✅happens-before规则"><a href="#✅happens-before规则" class="headerlink" title="✅happens-before规则"></a>✅happens-before规则</h4><p>1、程序顺序规则：一个线程中的每个操作，happens - before 于该程序的任意后续操作。</p>
<p>2、监视器规则：对一个锁的解锁，happens - before 于随后对这个锁的加锁。</p>
<p>3、volatile 变量规则：对一个 volatile 域的写，happens - before 于任意后续对这个 volatile 域的读。</p>
<p>4、传递性，如果 A happens - before B， B happens - before C，那么 A happens - before C</p>
<p>5、start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么线程 A 的 ThreadB.start() 操作 happens - before 线程 B 中的任意操作。</p>
<p>6、join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens- before 于线程 A 从 Thread.join() 操作成功返回。</p>
<p>⚠️像volitale变量一样，线程a写volatile变量前还写一个共享变量，线程b读那个volatile变量后还读那个共享变量，如何保证共享变量的安全性，因为线程a里的操作可能重排序，是由volitile的内存屏障插入策略和volatile的禁止编译器重排序规则来保证的，其他start方法和join方法也一样。因为重排序了的话，执行结果会不一样。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/laohuangaa/article/details/122773633">https://blog.csdn.net/laohuangaa/article/details/122773633</a></p>
<h3 id="8-双重检查锁定与延迟初始化"><a href="#8-双重检查锁定与延迟初始化" class="headerlink" title="8.双重检查锁定与延迟初始化"></a>8.双重检查锁定与延迟初始化</h3><p>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。</p>
<p>下面会讲述双重检查锁定为什么错误，以及两种线程安全的延迟初始化方案。</p>
<h4 id="✅双重检查锁定的由来"><a href="#✅双重检查锁定的由来" class="headerlink" title="✅双重检查锁定的由来"></a>✅双重检查锁定的由来</h4><p>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。</p>
<p>因为初始化可能在多线程环境下，它们共用一个对象，是需要一个线程创建就好了。非线程安全的延迟初始化对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) //1：A线程执行</span><br><span class="line">            instance = new Instance(); //2：B线程执行</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A线程执行代码1的同时，B线程执行代码2。此时，线程A可能会看到instance引用的对象还没有完成初始化. 导致AB线程都初始化对象。</p>
<p>同步处理来实现线程安全的延迟初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Instance instance;</span><br><span class="line">    public synchronized static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Instance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：synchronized将导致性能开销。如果getInstance()方法被多个线程频繁的调用，将会导致程序执行性能的下降。</p>
<p>因此，双重检查锁定来实现延迟初始化诞生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckedLocking &#123; //1</span><br><span class="line">    private static Instance instance; //2</span><br><span class="line">    public static Instance getInstance() &#123; //3</span><br><span class="line">        if (instance == null) &#123; //4:第一次检查</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123; //5:加锁</span><br><span class="line">                if (instance == null) //6:第二次检查</span><br><span class="line">                    instance = new Instance(); //7:问题的根源出在这里</span><br><span class="line">            &#125; //8</span><br><span class="line">        &#125; //9</span><br><span class="line">        return instance; //10</span><br><span class="line">    &#125; //11</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：不会每个线程都加锁，检查instance不为null，那么就不需要执行下面的加锁和初始化操作。获取锁之后，再检查一次是不是为null，因为在第一次判断是否为null时，可能另一个线程正在初始化。<br>（获取锁之前检查一次，获取锁之后检查一次）</p>
<p>但是是错误的：在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h4 id="✅双重检查锁定的问题"><a href="#✅双重检查锁定的问题" class="headerlink" title="✅双重检查锁定的问题"></a>✅双重检查锁定的问题</h4><p>第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<p>memory = allocate();　　// 1<strong>：分配对象的内存空间（引用变量）<br>ctorInstance(memory);　 // 2</strong>：初始化对象<br>instance = memory;　　 // 3**：设置instance指向刚分配的内存地址（赋值引用变量）（这个时候就不为null了）</p>
<p>上面3行伪代码中的2和3之间，可能会被重排序，因为这个重排序在没有改变单线程程序执行结果的前提下，可以提高程序的执行性能。</p>
<p>如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<strong>线程B将会访问到一个还未初始化的对象</strong>。</p>
<p>如何解决，来实现线程安全的延迟初始化：<br>1） 不允许2和3重排序。<br>2）允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<h4 id="✅基于volatile的解决方案"><a href="#✅基于volatile的解决方案" class="headerlink" title="✅基于volatile的解决方案"></a>✅基于volatile的解决方案</h4><p>把instance声明为volatile型，就可以实现线程安全的延迟初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SafeDoubleCheckedLocking &#123;</span><br><span class="line">    private volatile static Instance instance;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                    instance = new Instance();//instance为volatile，现在没问题了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要JDK 5或更高版本（因为从JDK 5开始使用新的JSR-133内存模型规范).</p>
<p>原理：使用了volatile修饰后，2、3将不会重排序。</p>
<h4 id="✅基于类初始化的解决方案"><a href="#✅基于类初始化的解决方案" class="headerlink" title="✅基于类初始化的解决方案"></a>✅基于类初始化的解决方案</h4><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory &#123;</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        public static Instance instance = new Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return InstanceHolder.instance; //这里将导致InstanceHolder类被初始化</span><br><span class="line">    &#125;</span><br><span class="line">    static class Instance &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设两个线程并发执行getInstance()方法，但是只有一个线程能获取class对象的初始化锁，然后执行对象初始化。</p>
<p>💡初始化类的时机和原理：</p>
<p>初始化一个类，包括<strong>执行这个类的静态初始化和初始化在这个类中声明的静态字段</strong>。根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：<br>1）T是一个类，而且一个T类型的实例被创建。<br>2）T是一个类，且T中声明的一个静态方法被调用。<br>3）T中声明的一个静态字段被赋值。<br>4）T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。<br>5）T是一个顶级类（Top Level Class），而且一个断言语句嵌套在T内部被执行。</p>
<p>在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化，是情况4.<br>（相当于是用一个工厂类来初始化另一个类？）</p>
<p>Java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口（比如这里多个线程可能在同一时刻调用getInstance()方法来初始化InstanceHolder类）。因此，在Java中初始化一个类或者接口时，需要做细致的同步处理。</p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</p>
<p>（<strong>多个线程初始化类不是创建不同的对象吗？难道初始化类和创建对象不一样？</strong> 是的，先初始化类再创建对象）</p>
<p>对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下：</p>
<p>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化，获取锁之后，初始化维护一个状态，设置state=initialing，然后释放锁。获取不到的话，这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</p>
<p>第2阶段：线程A执行类的初始化（上面的三步），同时线程B获取到初始化锁，发现状态是initialing，然后释放锁。后在初始化锁对应的condition上等待。</p>
<p>第3阶段：线程A获取初始化锁，设置state=initialized后，唤醒在condition中等待的所有线程，释放锁。</p>
<p>第4阶段：线程B获取锁，发现状态是initialed，释放锁，结束类的初始化处理。</p>
<p>所以，线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定能看到。</p>
<p>注意：这里的condition和state标记是本文虚构出来的。</p>
<p><strong>总结：</strong></p>
<p>基于类初始化的方案的实现代码更简洁，但只能对静态字段使用。但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://dandelioncloud.cn/article/details/1462953051467345921/">https://dandelioncloud.cn/article/details/1462953051467345921/</a></p>
<h3 id="9-java内存模型综述"><a href="#9-java内存模型综述" class="headerlink" title="9.java内存模型综述"></a>9.java内存模型综述</h3><h4 id="✅处理器的内存模型"><a href="#✅处理器的内存模型" class="headerlink" title="✅处理器的内存模型"></a>✅处理器的内存模型</h4><p>JMM：相当于是java编译器的内存模型</p>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。内存模型的束缚越少，处理器性能越好。</p>
<p>根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：<br>1、放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）<br>2、在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。<br>3、在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</p>
<p>这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，<strong>处理器不会对存在数据依赖性的两个内存操作做重排序</strong>）。</p>
<p>所有处理器内存模型都允许写-读重排序，原因是：使用了写缓存区。写缓存区可能导致写-读操作重排序。都允许更早读到当前处理器的写，原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
<p><strong>虚拟机对不同操作系统反映的一致性：</strong></p>
<p>由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h4 id="✅各种内存模型之间的关系"><a href="#✅各种内存模型之间的关系" class="headerlink" title="✅各种内存模型之间的关系"></a>✅各种内存模型之间的关系</h4><p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。</p>
<p>处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</p>
<p>执行性能越好，易编程性越差。</p>
<h4 id="✅JMM的内存可见性保证"><a href="#✅JMM的内存可见性保证" class="headerlink" title="✅JMM的内存可见性保证"></a>✅JMM的内存可见性保证</h4><p>1、单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2、正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3、未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</p>
<p>最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中（写共享变量）。如果是写了一半的，那就是线程B写了一半的，并不是null。<br>最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h4 id="✅JSR-133对旧内存模型的修补"><a href="#✅JSR-133对旧内存模型的修补" class="headerlink" title="✅JSR-133对旧内存模型的修补"></a>✅JSR-133对旧内存模型的修补</h4><p>JSR-133对JDK 5之前的旧内存模型的修补主要有两个。</p>
<p>· 增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p>· 增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</p>
<h2 id="第四章-java并发编程"><a href="#第四章-java并发编程" class="headerlink" title="第四章 java并发编程"></a>第四章 java并发编程</h2><p>Java从诞生开始就明智地选择了内置对多线程的支持，这使得Java语言相比同一时期的其他语言具有明显的优势。</p>
<p>线程作为操作系统调度的最小单元，多个线程能够同时执行（多核同时，单核并发），这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。</p>
<h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h3><h4 id="✅什么是线程"><a href="#✅什么是线程" class="headerlink" title="✅什么是线程"></a>✅什么是线程</h4><p>现代操作系统在运行一个程序时，会为其创建一个进程。操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<p>Java程序天生就是多线程程序，使用JMX来查看一个普通的Java程序包含哪些线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取Java线程管理 MXBean</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);</span><br><span class="line">        // 遍历线程信息，仅打印线程 ID 和 线程名称信息</span><br><span class="line">        for (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + threadInfo.getThreadId() + &quot;] &quot; + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅为什么使用多线程"><a href="#✅为什么使用多线程" class="headerlink" title="✅为什么使用多线程"></a>✅为什么使用多线程</h4><p>1、更多的处理器核心<br>如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</p>
<p>2、更快的响应时间<br>使用多线程技术，将数据一致性不强的操作派发给不同线程处理（消息队列也可以做到），响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<p>3、更好的编程模式<br>Java为多线程编程提供了良好、考究并且一致的编程模型，使开发人员能够更加专注于问题的解决</p>
<h4 id="✅线程优先级"><a href="#✅线程优先级" class="headerlink" title="✅线程优先级"></a>✅线程优先级</h4><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。</p>
<p>时间片就是分配给线程的处理器资源，在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。</p>
<p>一个计数线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">            private int priority;</span><br><span class="line">            private long jobCount;</span><br><span class="line">            public Job(int priority) &#123;</span><br><span class="line">                    this.priority = priority;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (notStart) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">                while (notEnd) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                    jobCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看10s多个不同优先级的计数，操作系统可能会忽略对线程优先级的设定。</p>
<h4 id="✅线程的状态"><a href="#✅线程的状态" class="headerlink" title="✅线程的状态"></a>✅线程的状态</h4><p>线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态（释放锁）。</p>
<p>进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。</p>
<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</p>
<p>等待和超时等待的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//该线程在waiting.class实例上等待</span><br><span class="line">static class Waiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (Waiting.class) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Waiting.class.wait();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//该线程不断进行睡眠，超时等待</span><br><span class="line">static class TimeWaiting implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            SleepUtils.second(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。<br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</p>
</blockquote>
<h4 id="✅Daemon线程"><a href="#✅Daemon线程" class="headerlink" title="✅Daemon线程"></a>✅Daemon线程</h4><p>守护线程。</p>
<p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出，所有Daemon线程都需要立即终止。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。因此，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h3 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2.启动和终止线程"></a>2.启动和终止线程</h3><p>调用start方法进行启动线程，随着run方法的执行完毕，线程随之终止。</p>
<h4 id="✅构造线程"><a href="#✅构造线程" class="headerlink" title="✅构造线程"></a>✅构造线程</h4><p>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</p>
<p>个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。</p>
<p>一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</p>
<h4 id="✅启动线程"><a href="#✅启动线程" class="headerlink" title="✅启动线程"></a>✅启动线程</h4><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<p>线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</p>
<h4 id="✅中断线程"><a href="#✅中断线程" class="headerlink" title="✅中断线程"></a>✅中断线程</h4><p>中断，效果是终止一个线程，可以理解为线程的一个标识位属性 （并不能直接终止一个线程），它表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的 interrupt() 方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted() 来进行判断是否被中断。</p>
<p>从Java的API中可以看到，许多声明抛出InterruptedException的方法（例如Thread.sleep （long millis）方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</p>
<p>如下所示的例子中，首先创建了两个线程，SleepThread和BusyThread，前者不停地睡眠，后者一直运行，然后对这两个线程分别进行中断操作，观察二者的中断标识位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Interrupted &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // sleepThread不停的尝试睡眠</span><br><span class="line">        Thread sleepThread = new Thread(new SleepRunner(), &quot;SleepThread&quot;);</span><br><span class="line">        sleepThread.setDaemon(true);</span><br><span class="line">        // busyThread不停的运行</span><br><span class="line">        Thread busyThread = new Thread(new BusyRunner(), &quot;BusyThread&quot;);</span><br><span class="line">        busyThread.setDaemon(true);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        // 休眠5秒，让sleepThread和busyThread充分运行</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(&quot;SleepThread interrupted is &quot; + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(&quot;BusyThread interrupted is &quot; + busyThread.isInterrupted());</span><br><span class="line">        // 防止sleepThread和busyThread立刻退出</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">    static class SleepRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 对于Sleep，如果发生了中断，就会抛出中断异常。抛出后，interrupt的表示位会被重置。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class BusyRunner implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，抛出InterruptedException的线程SleepThread，其中断标识位被清除了，返回false。而一直忙碌运作的线程BusyThread，中断标识位没有被清除，返回true。</p>
<h4 id="✅过期的suspend-、resume-和stop"><a href="#✅过期的suspend-、resume-和stop" class="headerlink" title="✅过期的suspend()、resume()和stop()"></a>✅过期的suspend()、resume()和stop()</h4><p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p>不建议使用的原因主要是：</p>
<p>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。<br>同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<p>暂停和恢复操作可以用后面提到的等待/通知机制来替代。</p>
<h4 id="✅安全地终止线程"><a href="#✅安全地终止线程" class="headerlink" title="✅安全地终止线程"></a>✅安全地终止线程</h4><p>中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<p>除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<p>方法1：使用中断interrupt方法进行中断。按说是直接中断线程了，没加代码中的判断也应该中断的。❓<br>方法2：使用一个volatile的boolean类型变量来控制，实际上是中断while方法，然后执行完run方法，终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Shutdown &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runner one = new Runner();</span><br><span class="line">        Thread countThread = new Thread(one, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = new Runner();</span><br><span class="line">        countThread = new Thread(two, &quot;CountThread&quot;);</span><br><span class="line">        countThread.start();</span><br><span class="line">        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Runner implements Runnable &#123;</span><br><span class="line">        private long i;</span><br><span class="line">            private volatile boolean on = true;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            while (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Count i = &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        public void cancel() &#123;</span><br><span class="line">            on = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例在执行过程中，main线程通过中断操作和cancel()方法均可使CountThread得以终止。</p>
<p>这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅。</p>
<h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3.线程间通信"></a>3.线程间通信</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。多个线程配合工作，才更有价值。</p>
<h4 id="✅volatile和synchronized关键字"><a href="#✅volatile和synchronized关键字" class="headerlink" title="✅volatile和synchronized关键字"></a>✅volatile和synchronized关键字</h4><p>背景：<br>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性）（就是线程的本地内存），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</p>
<p>volatile怎么解决：<br>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
<p>sychronized怎么解决：<br>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
<p>一点sychronized的实现原理：</p>
<p>看字节码文件，monitorenter和monitorexit指令，是对一个对象的监视器的获取，这个获取过程是排他的，一个时刻只有一个线程能够获取到由sychronized保护的对象的监视器。</p>
<p>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处（进入同步队列），进入BLOCKED状态。当获锁线程释放了锁，该释放操作唤醒阻塞在同步队列中的线程，重新尝试对监视器的获取。</p>
<h4 id="✅等待-通知机制"><a href="#✅等待-通知机制" class="headerlink" title="✅等待/通知机制"></a>✅等待/通知机制</h4><p>背景：生产者线程修改某个变量的值，消费者线程能够感知到。简单的办法是让消费者线程不断地循环检查变量是否符合预期。但是开销大。</p>
<p>Java通过内置的等待/通知机制能够很好地解决这个矛盾并实现所需的功能。<br>等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上。（监视器方法）</p>
<p>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。（两个notify都是通知等待队列里的，不是阻塞状态的同步队列，notify通知一个，notifyAll通知所有）。</p>
<p>例子：创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotify &#123;</span><br><span class="line">    static boolean flag = true;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Wait implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 当条件不满足时，继续wait，同时释放了lock的锁</span><br><span class="line">                while (flag) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + &quot; flag is true. wait@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 条件满足时，完成工作</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; flag is false. running@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Notify implements Runnable &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 加锁，拥有lock的Monitor</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span><br><span class="line">                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; +</span><br><span class="line">                        new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 再次加锁</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + &quot; hold lock again. sleep@ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用wait()、notify()以及notifyAll()时需要注意的细节:</p>
<p>1、使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</p>
<p>2、调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列，并释放锁。</p>
<p>3、notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</p>
<p>4、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</p>
<p>5、从wait()方法返回的前提是获得了调用对象的锁。<strong>等待/通知机制依托于同步机制</strong>，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改（也就是flag变量）。</p>
<p>梳理一下等待线程的状态变化：<br>1、wait线程首先获取锁，调用lock的wait方法，放弃了锁，进入等待队列，等待状态。（可以有很多个wait线程）<br>2、notify线程获取了锁，调用lock的notify方法，将wait线程从等待队列移动到了同步队列，是阻塞状态。（notify只能唤醒一个）<br>3、notify线程运行完了，释放锁，wait线程获取到锁，从wait方法返回并继续执行。</p>
<p>sleep不会释放锁<br>wait会释放锁</p>
<h4 id="✅等待-通知的经典范式"><a href="#✅等待-通知的经典范式" class="headerlink" title="✅等待/通知的经典范式"></a>✅等待/通知的经典范式</h4><p>范式分为两部分，分别针对等待方（消费者）和通知方（生产者）</p>
<p>等待方遵循如下原则：<br>1、获取对象的锁。<br>2、如果条件不满足（flag变量），那么调用对象的wait()方法，被通知后仍要检查条件。<br>3、条件满足则执行对应的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	while(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方遵循如下原则：<br>1、获得对象的锁。<br>2、改变条件。<br>3、通知所有等待在对象上的线程。（先改变条件还是先通知都行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	改变条件(flag)</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1、flag的目的：相当于是一个线程修改了某个值，另一个线程能感知到，起到一个多线程通信达到什么条件做什么事的效果。<br>2、同步的目的：获取了锁才能wait和notify，同步的目的是把修改变量和notify包在一起，让wait出来的时候能感知到变量的变化。<br>3、其实这个模式已经是偏底层了。<br>4、flag和lock可以用一个，直接用flag来当锁（就像后面的手写线程池）</p>
<h4 id="✅管道输入-输出流"><a href="#✅管道输入-输出流" class="headerlink" title="✅管道输入/输出流"></a>✅管道输入/输出流</h4><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
<p>管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<p>例子：printThread线程接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        PipedWriter out = new PipedWriter();</span><br><span class="line">        PipedReader in = new PipedReader();</span><br><span class="line">        // 将输出流和输入流进行连接，否则在使用时会抛出IOException</span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);</span><br><span class="line">        printThread.start();</span><br><span class="line">        int receive = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while ((receive = System.in.read()) != -1) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Print implements Runnable &#123;</span><br><span class="line">        private PipedReader in;</span><br><span class="line"></span><br><span class="line">        public Print(PipedReader in) &#123;</span><br><span class="line">            this.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int receive = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ((receive = in.read()) != -1) &#123;</span><br><span class="line">                    System.out.print((char) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。</p>
<h4 id="✅Thread-join-的使用"><a href="#✅Thread-join-的使用" class="headerlink" title="✅Thread.join()的使用"></a>✅Thread.join()的使用</h4><p>如果一个线程A执行了thread.join()语句，其含义是：<br>当前线程A等待thread线程终止之后才从thread.join()返回，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p>
<p>例子：创建了10个线程，编号0~9，每个线程调用前一个线程的join()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Join &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span><br><span class="line">            Thread thread = new Thread(new Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Domino implements Runnable &#123;</span><br><span class="line">        private Thread thread;</span><br><span class="line"></span><br><span class="line">        public Domino(Thread thread) &#123;</span><br><span class="line">            this.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。加锁、循环和处理逻辑3个步骤。</p>
<p>1、线程a执行线程b的join方法，相当于用线程b对象做同步，内部本线程wait进入等待，并用一个变量flag进行条件判断。<br>2、线程b终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。</p>
<h4 id="✅ThreadLocal的使用"><a href="#✅ThreadLocal的使用" class="headerlink" title="✅ThreadLocal的使用"></a>✅ThreadLocal的使用</h4><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。它不是线程共有的，而是私有的。即修改不会影响其他线程。一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的值。set()方法设置，get()方法获取设置的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">取出后，(T)value强转即可</span><br></pre></td></tr></table></figure>

<p>例子：一个Profile类，具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Profiler &#123;</span><br><span class="line">    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span><br><span class="line">    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static final void begin() &#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final long end() &#123;</span><br><span class="line">        return System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;Cost: &quot; + Profiler.end() + &quot; mills&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用途：Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法。好处是两个方法的调用不用在一个方法或者类中。</p>
<h3 id="4-线程应用案例"><a href="#4-线程应用案例" class="headerlink" title="4.线程应用案例"></a>4.线程应用案例</h3><h4 id="✅等待超时模式"><a href="#✅等待超时模式" class="headerlink" title="✅等待超时模式"></a>✅等待超时模式</h4><p>在前面等待/通知模式的基础上，如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</p>
<p>范式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对当前对象加锁</span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">	long future = System.currentTimeMillis() + mills;</span><br><span class="line">	long remaining = mills;</span><br><span class="line">	// 当超时大于0并且result返回值不满足要求</span><br><span class="line">	while ((result == null) &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">		wait(remaining);</span><br><span class="line">		remaining = future - System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。</p>
<p>并且，不是只wait固定的时间就完事，而是循环检查是不是wait够了，够了就直接返回不wait了。</p>
<h4 id="✅一个简单的数据库连接池示例"><a href="#✅一个简单的数据库连接池示例" class="headerlink" title="✅一个简单的数据库连接池示例"></a>✅一个简单的数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。</p>
<p>设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</p>
<p>首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPool &#123;</span><br><span class="line">	//连接池</span><br><span class="line">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    //构造</span><br><span class="line">    public ConnectionPool(int initialSize) &#123;</span><br><span class="line">        if (initialSize &gt; 0) &#123;</span><br><span class="line">        	//创建数据库连接</span><br><span class="line">            for (int i = 0; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());//该类在后面实现，用于初始化线程池</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void releaseConnection(Connection connection) &#123;</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            synchronized (pool) &#123;</span><br><span class="line">                // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                // 唤醒所有等待，让他们去竞争锁</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在mills内无法获取到连接，将会返回null</span><br><span class="line">    //获取连接</span><br><span class="line">    public Connection fetchConnection(long mills) throws InterruptedException &#123;</span><br><span class="line">        synchronized (pool) &#123;</span><br><span class="line">        	// 该部分代码逻辑为</span><br><span class="line">        	// 当完全超时时，必然会获得一个连接池对象,也即是无线等待时间。当传入mills &gt; 0时，不会走入该分支。因为else分支会处理其中超时情况</span><br><span class="line">        	// 非完全超时时，获得就返回一个连接池对象，不然就返回空</span><br><span class="line">        	</span><br><span class="line">            // 完全超时</span><br><span class="line">            if (mills &lt;= 0) &#123;</span><br><span class="line">            	// 连接池为空</span><br><span class="line">                while (pool.isEmpty()) &#123;</span><br><span class="line">                    //以连接池为通知对象，等待直到被唤醒，不在主动醒来</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                // 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                return pool.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            //未超时 </span><br><span class="line">            else &#123;</span><br><span class="line">                long future = System.currentTimeMillis() + mills;</span><br><span class="line">                long remaining = mills;</span><br><span class="line">                //连接池为空且未超时</span><br><span class="line">                while (pool.isEmpty() &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">                	//以连接池为通知对象，等待remaining毫秒,或者被唤醒</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    // 获取剩余时间，通过它来判断是主动醒来（超时），还是被动唤醒（notify）</span><br><span class="line">                    // 无论是被动还是主动醒来，都尝试获取连接池这个对象锁</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                    // 获得锁以后判断连接池是不是空的，空的的话再判断是否超时，超时就离开循环</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Connection result = null;</span><br><span class="line">                //抢到连接池这个对象锁后，若此时连接池不为空</span><br><span class="line">                if (!pool.isEmpty()) &#123;</span><br><span class="line">                	// 拿出连接池中第一个连接，并返回给当前请求者</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                // 否则此时为空</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过<strong>动态代理</strong>构造了一个Connection，该Connection的代理实现仅仅是在commit()方法（提交sql）调用时休眠100毫秒，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionDriver &#123;</span><br><span class="line"></span><br><span class="line">    static class ConnectionHandler implements InvocationHandler &#123;</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123;</span><br><span class="line">         // 在方法执行之前</span><br><span class="line">        // 当方法是提交时，我们睡眠100毫秒</span><br><span class="line">        if (method.getName().equals(&quot;commit&quot;))&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 执行原本方法，此处就不执行了</span><br><span class="line">       	// Object invoke = method.invoke(vehical, args);</span><br><span class="line">       	</span><br><span class="line">		// 执行方法之后，此处也不处理，直接放回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个Connection的代理，在commit时休眠100毫秒</span><br><span class="line">    public static final Connection createConnection() &#123;</span><br><span class="line">    	// 创建一个代理实例</span><br><span class="line">    	// 类加载器(用哪个类加载器去加载代理对象) + 代理的类(接口，切入点) + 代理方法</span><br><span class="line">    	// 可以理解我们为Connection的&quot;commit&quot;方法，通过JDK的方式代理了一层(AOP)</span><br><span class="line">    	// 返回的就是我们Spring中学习的 代理额外增加的层 + 原本的类对象</span><br><span class="line">        return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),new Class &lt;?&gt;[]&#123;</span><br><span class="line">            Connection.class</span><br><span class="line">        &#125;,new ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionPoolTest &#123;</span><br><span class="line">    static ConnectionPool pool = new ConnectionPool(10);</span><br><span class="line">    // 保证所有ConnectionRunner能够同时开始</span><br><span class="line">    static CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">    // main线程将会等待所有ConnectionRunner结束后才能继续执行</span><br><span class="line">    static CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 线程数量，可以修改线程数量进行观察</span><br><span class="line">        int threadCount = 10;</span><br><span class="line">        end = new CountDownLatch(threadCount);</span><br><span class="line">        int count = 20;</span><br><span class="line">        // 用原子记录 获取到的与没有获取到的</span><br><span class="line">        AtomicInteger got = new AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = new AtomicInteger();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        	// 运行线程</span><br><span class="line">            Thread thread = new Thread(new ConnetionRunner(count, got, notGot),</span><br><span class="line">                    &quot;ConnectionRunnerThread&quot;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //运行到这里start值-1，此时为0，因此所有线程不再会被阻塞，开始执行</span><br><span class="line">        start.countDown();</span><br><span class="line">        //主线程阻塞在这里，等待end为0，即等待所有线程结束</span><br><span class="line">        end.await();   //等10个线程都执行完</span><br><span class="line">        System.out.println(&quot;total invoke: &quot; + (threadCount * count));</span><br><span class="line">        System.out.println(&quot;got connection: &quot; + got);</span><br><span class="line">        System.out.println(&quot;not got connection &quot; + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ConnetionRunner implements Runnable &#123;</span><br><span class="line">        int count;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">		// got、noteGot因为是引用，所以本质还是原来的那个</span><br><span class="line">        public ConnetionRunner(int count, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            this.count = count;</span><br><span class="line">            this.got = got;</span><br><span class="line">            this.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 阻塞在这里，等待start为0</span><br><span class="line">                start.await();  //等10个线程都创建好后一起执行</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当count &gt; 0 时，再次执行</span><br><span class="line">            while (count &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span><br><span class="line">                    // 分别统计连接获取的数量got和未获取到的数量notGot</span><br><span class="line">                    Connection connection = pool.fetchConnection(1000);</span><br><span class="line">                    // 如果获取到了</span><br><span class="line">                    if (connection != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                        	// 创建SQL语句</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            // 执行提交</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                        	// 释放</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            // 获取到got + 1</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                     // 没有获取到</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	// 没有获取到notGot + 1</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                </span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 线程结束 end - 1</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部结束之后，才使main线程从等待状态中返回。</p>
<p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。</p>
<h4 id="✅线程池技术及其示例"><a href="#✅线程池技术及其示例" class="headerlink" title="✅线程池技术及其示例"></a>✅线程池技术及其示例</h4><p>如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p>
<p>线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p>
<p>线程池的好处：<br>1、消除了频繁创建和消亡线程的系统资源开销<br>2、面对过量任务的提交能够平缓的劣化。</p>
<p>线程池接口定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface ThreadPool&lt;Job extends Runnable&gt; &#123;</span><br><span class="line">    // 执行一个Job，这个Job需要实现Runnable</span><br><span class="line">    void execute(Job job);</span><br><span class="line"></span><br><span class="line">    // 关闭线程池</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    // 增加工作者线程</span><br><span class="line">    void addWorkers(int num);</span><br><span class="line"></span><br><span class="line">    // 减少工作者线程</span><br><span class="line">    void removeWorker(int num);</span><br><span class="line"></span><br><span class="line">    // 得到正在等待执行的任务数量</span><br><span class="line">    int getJobSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。<br>除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。<br>这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p>
<p>手写一个线程池，不用Executor创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; &#123;</span><br><span class="line">    // 线程池最大限制数</span><br><span class="line">    private static final int MAX_WORKER_NUMBERS = 10;</span><br><span class="line">    // 线程池默认的数量</span><br><span class="line">    private static final int DEFAULT_WORKER_NUMBERS = 5;</span><br><span class="line">    // 线程池最小的数量</span><br><span class="line">    private static final int MIN_WORKER_NUMBERS = 1;</span><br><span class="line">    // 这是一个工作列表，将会向里面插入工作</span><br><span class="line">    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;Job&gt;();</span><br><span class="line">    // 工作者列表</span><br><span class="line">    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;Worker&gt;());</span><br><span class="line">    // 工作者线程的数量</span><br><span class="line">    private int workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    // 线程编号生成</span><br><span class="line">    private AtomicLong threadNum = new AtomicLong();</span><br><span class="line">	</span><br><span class="line">    //构造函数</span><br><span class="line">    public DefaultThreadPool() &#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DefaultThreadPool(int num) &#123;</span><br><span class="line">    	// num &gt; max ， 取 max，num &lt; min 取 min。其他取 num</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS:(num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num);</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Job job) &#123;</span><br><span class="line">        if (job != null) &#123;</span><br><span class="line">            // 添加一个工作，然后进行通知</span><br><span class="line">            synchronized (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();   //通知（这里jobs既是flag又是lock）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        for (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addWorkers(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            // 限制新增的Worker数量不能超过最大值</span><br><span class="line">            if (num + this.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - this.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            this.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeWorker(int num) &#123;</span><br><span class="line">        synchronized (jobs) &#123;</span><br><span class="line">            if (num &gt;= this.workerNum) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;beyond workNum&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 按照给定的数量停止Worker</span><br><span class="line">            int count = 0;</span><br><span class="line">            while (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                if (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getJobSize() &#123;</span><br><span class="line">        return jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化线程工作者</span><br><span class="line">    private void initializeWokers(int num) &#123;</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = new Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.inrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 工作者，负责消费任务</span><br><span class="line">    class Worker implements Runnable &#123;</span><br><span class="line">        // 是否工作</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (running) &#123;</span><br><span class="line">                Job job = null;</span><br><span class="line">                synchronized (jobs) &#123;</span><br><span class="line">                    // 如果工作者列表是空的，那么就wait</span><br><span class="line">                    while (jobs.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            jobs.wait();  //等待</span><br><span class="line">                        &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                            // 感知到外部对WorkerThread的中断操作，返回</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 取出一个Job</span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                if (job != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        // 忽略Job执行中的Exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void shutdown() &#123;</span><br><span class="line">            running = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Job是要放入线程池的线程，Worker是线程池内执行Job线程的工作线程。里面用了等待通知模式，放入一个job会通知一下，jobs为空了就会等待。</p>
<p>当客户端调用execute(Job)方法时，会不断地向任务列表jobs中添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p>
<p>添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p>
<p>可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p>
<h4 id="✅一个基于线程池技术的简单Web服务器"><a href="#✅一个基于线程池技术的简单Web服务器" class="headerlink" title="✅一个基于线程池技术的简单Web服务器"></a>✅一个基于线程池技术的简单Web服务器</h4><p>目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取。</p>
<p>大部分Web服务器也都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p>
<p>使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleHttpServer &#123;</span><br><span class="line">    // 处理HttpRequest的线程池</span><br><span class="line">    static ThreadPool&lt;HttpRequestHandler&gt; threadPool = new DefaultThreadPool&lt;HttpRequestHandler&gt;(1);</span><br><span class="line">    // SimpleHttpServer的根路径</span><br><span class="line">    static String basePath;</span><br><span class="line">    static ServerSocket serverSocket;</span><br><span class="line">    // 服务监听端口</span><br><span class="line">    static int port = 8080;</span><br><span class="line"></span><br><span class="line">    public static void setPort(int port) &#123;</span><br><span class="line">        if (port &gt; 0) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setBasePath(String basePath) &#123;</span><br><span class="line">         if (basePath != null &amp;&amp; new File(basePath).exists() &amp;&amp; new File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动SimpleHttpServer，一个客户端请求</span><br><span class="line">    public static void start() throws Exception &#123;</span><br><span class="line">        serverSocket = new ServerSocket(port);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        //accept():3次握手结束，接受连接</span><br><span class="line">        while ((socket = serverSocket.accept()) != null) &#123;</span><br><span class="line">            // 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span><br><span class="line">            threadPool.execute(new HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class HttpRequestHandler implements Runnable &#123;</span><br><span class="line">        private Socket socket;</span><br><span class="line"></span><br><span class="line">        public HttpRequestHandler(Socket socket) &#123;</span><br><span class="line">            this.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            String line = null;</span><br><span class="line">            BufferedReader br = null;</span><br><span class="line">            BufferedReader reader = null;</span><br><span class="line">            PrintWriter out = null;</span><br><span class="line">            InputStream in = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                // 由相对路径计算出绝对路径</span><br><span class="line">                String filePath = basePath + header.split(&quot; &quot;)[1];</span><br><span class="line">                out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                 // 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span><br><span class="line">                if (filePath.endsWith(&quot;jpg&quot;) || filePath.endsWith(&quot;ico&quot;)) &#123;</span><br><span class="line">                    in = new FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    while ((i = in.read()) != -1) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] array = baos.toByteArray();</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: image/jpeg&quot;);</span><br><span class="line">                    out.println(&quot;Content-Length: &quot; + array.length);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    System.out.println(&quot;传回！&quot;);</span><br><span class="line">                    socket.getOutputStream().write(array, 0, array.length);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    br = new BufferedReader(new InputStreamReader(new</span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = new PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(&quot;HTTP/1.1 200 OK&quot;);</span><br><span class="line">                    out.println(&quot;Server: yjx23332&quot;);</span><br><span class="line">                    out.println(&quot;Content-Type: text/html; charset=UTF-8&quot;);</span><br><span class="line">                    out.println(&quot;&quot;);</span><br><span class="line">                    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                out.println(&quot;HTTP/1.1 500&quot;);</span><br><span class="line">                out.println(&quot;&quot;);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭流或者Socket</span><br><span class="line">    private static void close(Closeable... closeables) &#123;</span><br><span class="line">        if (closeables != null) &#123;</span><br><span class="line">            for (Closeable closeable : closeables) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleHttpServer提供设置端口和跟路径的方法，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。</p>
<p>在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。Worker处理请求资源生成响应内容后，异步输出内容到客户端。</p>
<p>html页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;测试页面&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">&lt;body &gt;</span><br><span class="line">	&lt;h1&gt;第一张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;1.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第二张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;2.jpg&quot; /&gt;</span><br><span class="line">	&lt;h1&gt;第三张图片&lt;/h1&gt;</span><br><span class="line">	&lt;img src=&quot;3.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    SimpleHttpServer.setBasePath(&quot;C:\Users\Administrator\Desktop\server&quot;);</span><br><span class="line">    SimpleHttpServer.setPort(8080);</span><br><span class="line">    SimpleHttpServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️线程池中的线程不是越多越好：<br>线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46949627/article/details/127009251">https://blog.csdn.net/weixin_46949627/article/details/127009251</a></p>
<h2 id="第五章-java中的锁"><a href="#第五章-java中的锁" class="headerlink" title="第五章 java中的锁"></a>第五章 java中的锁</h2><p>介绍java并发包中与锁相关的API和组件，以及这些API和组件的使用方式和实现细节。</p>
<h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1.Lock接口"></a>1.Lock接口</h3><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</p>
<h4 id="✅Lock接口和synchronized关键字的对比"><a href="#✅Lock接口和synchronized关键字的对比" class="headerlink" title="✅Lock接口和synchronized关键字的对比"></a>✅Lock接口和synchronized关键字的对比</h4><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p>使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。例如：先获得锁A，然后再获取锁B。</p>
<p>Lock的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock具备的sychronized关键字不具备的特点：<br>1、非阻塞地获取锁<br>2、能被中断地获取锁（获取到锁的线程能响应中断，中断异常被抛出，同时锁释放）<br>3、超时获取锁（截止时间无法获取锁，则返回）</p>
<h4 id="✅Lock接口中的API"><a href="#✅Lock接口中的API" class="headerlink" title="✅Lock接口中的API"></a>✅Lock接口中的API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void lock()</span><br><span class="line">获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</span><br><span class="line"></span><br><span class="line">void lockInterruptibly() throws InterruptedException	</span><br><span class="line">可中断地获取锁，和 lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</span><br><span class="line"></span><br><span class="line">boolean tryLock()	</span><br><span class="line">尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">boolean tryLock(1ong time,TimeUnit unit) throws InterruptedException	</span><br><span class="line">超时的获取锁，当前线程在以下3种情况下会返回：①当前线程在超时时间内获得了锁 ②当前线程在超时时间内被中断 ③超时时间结束，返回false</span><br><span class="line"></span><br><span class="line">void unlock() </span><br><span class="line">释放锁</span><br><span class="line"></span><br><span class="line">Condition newCondition()	</span><br><span class="line">获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁</span><br></pre></td></tr></table></figure>

<p>随后会详细介绍同步器AbstractQueuedSynchronizer以及常用Lock接口的实现ReentrantLock。Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<h3 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2.队列同步器"></a>2.队列同步器</h3><p>队列同步器 AbstractQueuedSynchronizer（AQS，以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p>
<p>同步器提供的3个方法来对同步状态进行更改，它们能够保证状态的改变是安全的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()  获取当前同步状态。</span><br><span class="line">setState(int newState)  设置当前同步状态。</span><br><span class="line">compareAndSetState(int expect,int update)） 使用CAS设置当前状态，该方法能够保证状态</span><br></pre></td></tr></table></figure>

<p>子类通过继承同步器并实现它的抽象方法来管理同步状态，子类推荐被定义为自定义同步组件的静态内部类。同步器自身没有实现任何同步接口，它仅仅是定义了上面同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件：<br>ReentrantLock<br>ReentrantReadWriteLock<br>CountDownLatch</p>
<p>队列同步器与锁的关系：</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<p>1、锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节<br>2、同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<h4 id="✅队列同步器的接口与示例"><a href="#✅队列同步器的接口与示例" class="headerlink" title="✅队列同步器的接口与示例"></a>✅队列同步器的接口与示例</h4><p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器作为静态内部类组合在自定义同步组件的实现中，并调用同步器提供的模板方法。</p>
<p><strong>同步器可重写的方法</strong>，包含两种，一种是获取独占锁，一种是获取共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态，实现该方法需要查询当前状态，并判断同步状态是否符合预期，然后通过CAS设置同步状态（非阻塞的？）</span><br><span class="line"> */</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态，此时等待获取同步状态的线程将有机会获取同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态，返回结果大于等于0，表示获取成功，否则获取失败</span><br><span class="line"> */</span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否被当前线程所独占</span><br><span class="line"> */</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义的同步器组件时，将会调用<strong>同步器提供的模板方法</strong>，同步器提供的模板方法分为三类：一是独占式获取与释放同步状态、二是共享式获取与释放同步状态、三是查询同步队列中等待线程的情况。自定义的同步器将使用这些提供的模板方法来实现自己的同步语义。同步器提供的模板方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 如果当前线程获取同步状态成功，则该方法执行完毕，否则，当前线程将会进入</span><br><span class="line"> * 同步队列等待，该方法将会调用重写的tryAcquire方法（区别：一个有返回，一个没有，输入没什么用？）</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 与acquire 相同，但是该方法响应中断，当前线程未获取到同步状态则进入同步队列；如果当前线程被中断，则该方法会抛出异常并返回</span><br><span class="line"> */</span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式获取同步状态</span><br><span class="line"> * 该方法在 acquireInterruptibly(int arg) 基础上增加了超时限制，如果当前线程在超时时间内没有获取同步状态，那么将返回false，否则返回true</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 独占式释放同步状态</span><br><span class="line"> * 该方法会在释放同步状态后，将同步队列中第一个节点中的线程唤醒</span><br><span class="line"> */</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与独占式的区别在于，同一时刻可以有多个线程获得同步状态</span><br><span class="line"> */</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 与方法acquireShared(int arg) 一样，只是该方法响应中断</span><br><span class="line"> */</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式获取同步状态</span><br><span class="line"> * 在方法 acquireSharedInterruptibly(int arg) 基础上，增加了超时限制</span><br><span class="line"> */</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquireShared(arg) &gt;= 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 共享式释放同步状态</span><br><span class="line"> */</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取在同步队列上等待的线程的集合</span><br><span class="line"> */</span><br><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null)</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，独占锁是在同一时刻只能有一个线程获得锁，而其他获取锁的线程只能在同步队列中等待，只有持有锁的线程释放了，其他线程才能获得锁。<strong>独占锁的示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class Mutex implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类自定义同步器</span><br><span class="line">     */</span><br><span class="line">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 是否处于独占状态</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() == 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式获取锁，状态为0时获取锁</span><br><span class="line">         * 如果经过CAS设置成功（同步状态设置为1）</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;  //0是期望，1是更新</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 独占式释放锁，只是将状态置为0</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            if (getState() == 0) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 实例化一个 Condition，每个 Condition 都包含一个队列</span><br><span class="line">         */</span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、自定义定义独占锁实现Lock，所以需要实现Lock接口中的API<br>2、自定义同步器作为静态内部类继承自同步器，重写同步器方法，实现独占式获取和释放同步状态<br>3、Lock的API中使用同步器的重写方法/模版方法</p>
<p>在使用自定义同步器Mutex 时，不会直接与内部同步器交互，而是通过Mutex 提供的方法。</p>
<p>lock和tryLock的区别：<br>lock是非阻塞的，会一直尝试或锁，用acquire方法（内部用tryAcquire方法）线程调用该方法获取同步状态失败后会被加入到同步队列中等待；tryLock是阻塞的，获取一次，所以直接用tryAcquire方法。</p>
<p>Condition是什么？<br>ConditionObject 是AQS的内部类，用来维护等待队列<br>AQS内部实际上有两个队列<br>同步队列：公平/非公平，共享/非共享<br>等待队列：条件等待队列，也就是Condition<br>等待队列中就是用await方法时任务进入的队列（类似之前使用的wait，该队列中的任务只有唤醒才会尝试获取锁，以此减少CPU频繁的获取锁），通过signal唤醒。</p>
<h4 id="✅队列同步器的实现分析"><a href="#✅队列同步器的实现分析" class="headerlink" title="✅队列同步器的实现分析"></a>✅队列同步器的实现分析</h4><p>接下来将从实现角度分析同步器是如何完成线程同步的。<br>主要包括：同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放以及超时获取同步状态等同步器的核心数据结构与模板方法。</p>
<h5 id="一、同步队列"><a href="#一、同步队列" class="headerlink" title="一、同步队列"></a>一、同步队列</h5><p>同步器依赖内部的同步队列（一个FIFO双向队列,FIFO先进先出）来完成同步状态的管理。</p>
<p>当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node，它也是AQS的内部类）并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</p>
<p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：<code>compareAndSetTail(Node expect,Node update)</code>，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>
<p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。（只有一个线程获取到同步状态，所以设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。）</p>
<h5 id="二、独占式同步状态获取和释放"><a href="#二、独占式同步状态获取和释放" class="headerlink" title="二、独占式同步状态获取和释放"></a>二、独占式同步状态获取和释放</h5><p>同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态（阻塞型的，相当于是获锁），该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，<strong>线程不会从同步队列中移出</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作。首先tryAcquire非阻塞型地获取，如果获取到直接返回了，获取不到，就构造节点加入同步队列，在同步队列中会一直自旋尝试获取同步状态。</p>
<p>步骤：<br>1、调用自定义同步器实现的 tryAcquire(int arg) 方法，该方法保证线程安全的获取同步状态</p>
<p>2、如果同步状态获取失败，则构造同步节点（独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部。</p>
<blockquote>
<p>enq(final Node node) 方法中，同步器通过 “死循环” 来保证节点的正确添加，在 “死循环” 中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线程不断地尝试设置。<br>可以看出，enq(final Node node) 方法将并发添加节点的请求通过CAS变得 “串行化” 了。</p>
</blockquote>
<p>3、节点进入同步队列之后，就进入了一个自旋的过程（acquireQueued(Node node,int arg) 方法），每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，代表获取了锁，否则依旧留在这个自旋过程中（并会阻塞节点的线程，阻塞线程也就是进入等待，自旋不停？）</p>
<blockquote>
<p>虽然同步队列中每个线程都会自旋，但是只有前驱节点是头节点才能够尝试获取同步状态：<br>头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br>维护同步队列的FIFO原则。</p>
</blockquote>
<p>4、如果获取不到则阻塞节点中的线程，而<strong>被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现</strong>。</p>
<blockquote>
<p>节点自旋，发现前驱不是头节点，就进入等待状态，只有线程被中断或前驱节点被释放才会再判断是不是前驱是头节点。前驱是头节点后，获取同步状态，如果获取失败，则进入等待状态。（几个等待状态应该不一样？）</p>
</blockquote>
<p>独占式同步状态获取流程，见P128</p>
<p>5、线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。调用同步器的 release(int arg) 模版方法（内部用tryRelease重写方法）可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //头节点不为空或者状态不是0</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点</span><br><span class="line">            unparkSuccessor(h);  //用来唤醒处于等待状态的线程</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>独占式同步状态获取和释放过程总结：<br>1、在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被自旋地加入到队列中并在队列中进行自旋<br>2、移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。<br>3、如果线程被中断，只是会唤醒被阻塞线程，是不会立刻被移出队列的，而是FIFO到该节点才移出。<br>4、不管是获取还是释放，都是模版方法里调用了重写的try方法。acquire是阻塞的，tryAcquire是非阻塞的，试一次，会返回是否成功。</p>
<p>疑问❓：<br>同步队列中节点的自旋和线程被阻塞的关系是什么？自旋发现前驱节点不是头节点或者获取不到同步状态的话，会阻塞线程，阻塞后是依靠前驱节点释放同步状态后唤醒或是中断唤醒还是一直自旋？</p>
<h5 id="三、共享式同步状态获取与释放"><a href="#三、共享式同步状态获取与释放" class="headerlink" title="三、共享式同步状态获取与释放"></a>三、共享式同步状态获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。以文件的读写为例，读可以是共享锁，可以同时读，写是独占锁，一个在写，其他既不能读也不能写。</p>
<p>在 acquireShared(int arg) 方法中，同步器调用 tryAcquireShared(int arg) 方法尝试获取同步状态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。在doAcquireShared(int arg)方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 小于零获取锁失败</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    // 共享模式加入同步队列</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 如果前一个线程为头结点</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取锁</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                // 成功</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 将自己设置为头节点同时，传播状态，r就是之前返回的值</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null;</span><br><span class="line">                    // 如果过被当前线程状态为true，就设置当前线程的中断状态</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 逻辑同前</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 逻辑同前</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用releaseShared(int arg)方法可以释放同步状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    // 尝试释放锁</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        // 成功就修改自己节点状态</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。因为可能多个线程获取锁，所以，它和独占式主要区别在于tryReleaseShared(int arg)方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为释放同步状态的操作会同时来自多个线程。</p>
<h5 id="四、独占式超时获取同步状态"><a href="#四、独占式超时获取同步状态" class="headerlink" title="四、独占式超时获取同步状态"></a>四、独占式超时获取同步状态</h5><p>通过调用同步器的 doAcquireNanos(int arg,long nanosTimeout) 【模版方法】方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<p>在Java 5之前，当一个线程获取不到锁而被阻塞在synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧会阻塞在synchronized上，等待着获取锁。</p>
<p>在Java 5中，同步器提供了acquireInterruptibly(int arg)方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出InterruptedException。</p>
<p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性。</p>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。</p>
<p>如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待 nanosTimeout 纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object<br>blocker,long nanos)方法返回）。</p>
<p><strong>总结：</strong><br>独占式超时获取同步状态doAcquireNanos(int arg,long nanosTimeout)和独占式获取同步状态acquire(int args)在流程上非常相似，其主要区别在于未获取到同步状态时的处理逻辑：<br>1、acquire(int args)在未获取到同步状态时，将会使当前线程一直处于等待状态<br>2、doAcquireNanos(int arg,long nanosTimeout)会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。</p>
<h5 id="五、自定义同步组件——TwinsLock"><a href="#五、自定义同步组件——TwinsLock" class="headerlink" title="五、自定义同步组件——TwinsLock"></a>五、自定义同步组件——TwinsLock</h5><p>设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞。</p>
<p>TwinsLock在同一时刻允许至多两个线程的同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2，其中0表示当前已经有两个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class TwinsLock implements Lock &#123;</span><br><span class="line">    private final Sync sync = new Sync(2);</span><br><span class="line"></span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            if (count &lt;= 0) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;count must large than zero.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 在本方法中，用状态去代指资源数目</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int tryAcquireShared(int reduceCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int newCount = current - reduceCount;</span><br><span class="line">                if (newCount &lt; 0 || compareAndSetState(current,newCount)) &#123;</span><br><span class="line">                	// 返回当前剩余资源</span><br><span class="line">                    return newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryReleaseShared(int returnCount) &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                // 当前数目 + 释放数目</span><br><span class="line">                int newCount = current + returnCount;</span><br><span class="line">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">    	// 获取共享锁，state + 1</span><br><span class="line">    	// 使用的是node节点的方法</span><br><span class="line">        sync.acquireShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 释放共享锁 -1</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.releaseShared(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 其他接口方法略</span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, @NotNull TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @NotNull</span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：<br>1、TwinsLock实现Lock接口，提供面向使用者的接口，使用者调用lock()<br>方法获取锁，随后调用unlock()方法释放锁，而同一时刻只能有两个线程同时获取到锁。<br>2、自定义同步器Sync作为静态内部类，该同步器面向线程访问和同步状态控制。共享式获取同步状态。<br>3、重写tryAcquireShared(int reduceCount)等方法，内部用过CAS确保状态的正确设置。acquireShared方法里是判断tryAcquireShared方法返回值大于等于0时，当前线程才获取同步状态。</p>
<p>总结：<br>1、acquireShared方法里输入的int，都是1呢。啥意思？<br>2、同步器作为一个桥梁，连接线程访问以及同步状态控制等底层技术与不同并发组件（比如Lock、CountDownLatch等）的接口语义。</p>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">public class TwinsLockTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        final Lock lock = new TwinsLock();</span><br><span class="line">        class Worker extends Thread &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        throw new RuntimeException(e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 启动10个线程</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Worker w = new Worker();</span><br><span class="line">            w.setDaemon(true);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        // 每隔1秒换行</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程名称成对输出，在同一时刻只有两个线程能够获取到锁。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46949627/article/details/127078972">https://blog.csdn.net/weixin_46949627/article/details/127078972</a><br><a target="_blank" rel="noopener" href="http://t.zoukankan.com/liukaifeng-p-10052596.html">http://t.zoukankan.com/liukaifeng-p-10052596.html</a><br>Lock和sychronized区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41010294/article/details/123528508">https://blog.csdn.net/weixin_41010294/article/details/123528508</a></p>
<h3 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3.重入锁"></a>3.重入锁</h3><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<p>上一节的独占锁示例中，调用Mutex的lock()方法获取锁之后，如果再次调用lock()方法，则该线程将会被自己所阻塞，原因是Mutex在实现tryAcquire(int acquires)方法时没有考虑占有锁的线程再次获取锁的场景，而在调用tryAcquire(int acquires)方法时返回了false，导致该线程被阻塞。</p>
<p>所以说，Mutex是一个不支持重进入的锁。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获取了锁，而在下一次获取锁时出现阻塞自己的情况。</p>
<p>重入锁：在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p>
<p>公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</p>
<h4 id="✅实现重进入"><a href="#✅实现重进入" class="headerlink" title="✅实现重进入"></a>✅实现重进入</h4><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<p>1、线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p>
<p>2、锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p>非公平锁获取的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 非公平锁获取</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    // 当前线程</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    // 获取锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 0 代表无锁</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 设置状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置独享锁的拥有者</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    // 如果当前线程是独有线程的线程ID</span><br><span class="line">    &#125; else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 是则增加次数</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //设置</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值.</p>
<p>非公平锁释放的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 减去释放的值</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    // 如果当前线程不是拥有者</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 如果是 0 则完全释放</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        // 抹去拥有者</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h4 id="✅公平与非公平获取锁的区别"><a href="#✅公平与非公平获取锁的区别" class="headerlink" title="✅公平与非公平获取锁的区别"></a>✅公平与非公平获取锁的区别</h4><p>公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<p>对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>【因此，上面的独占锁和共享锁也都是公平的】</p>
<p>测试公平和非公平锁在获取锁时的区别，五个线程循环获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairAndUnfairTest &#123;</span><br><span class="line">    private static Lock fairLock = new ReentrantLock2(true);</span><br><span class="line">    private static Lock unfairLock = new ReentrantLock2(false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void fair() &#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void unfair() &#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void testLock(Lock lock)&#123;</span><br><span class="line">        // 启动5个Job</span><br><span class="line">        for(int i = 0; i &lt; 5;i++)&#123;</span><br><span class="line">            new Job(lock).start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Job extends Thread &#123;</span><br><span class="line">        private Lock lock;</span><br><span class="line"></span><br><span class="line">        public Job(Lock lock) &#123;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 连续2次打印当前的Thread和等待队列中的Thread</span><br><span class="line">                lock.lock();</span><br><span class="line">                ReentrantLock2 reentrantLock2 = (ReentrantLock2) lock;</span><br><span class="line">                System.out.println(&quot;Fair:&quot; + reentrantLock2.isFair() + &quot;,Lock By 【&quot; + Thread.currentThread().getName() + &quot;】，waitting by  &quot; + reentrantLock2.getQueuedThreads().toString());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReentrantLock2 extends ReentrantLock &#123;</span><br><span class="line">        public ReentrantLock2(boolean fair) &#123;</span><br><span class="line">            super(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = new ArrayList&lt;Thread&gt;(super.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。（刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。）</p>
<p>2、公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平锁虽然可能造成线程饥饿，但是极少的线程切换，保证了其更大的吞吐量。</p>
<h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h3><p>之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，提供写操作对读操作的可见性以及并发性的提升。</p>
<p>适用场景：在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p>
<p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。</p>
<h4 id="✅读写锁的接口和示例"><a href="#✅读写锁的接口和示例" class="headerlink" title="✅读写锁的接口和示例"></a>✅读写锁的接口和示例</h4><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    static Lock r = rwl.readLock();</span><br><span class="line">    static Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    // 获取一个key对应的value</span><br><span class="line">    public static final Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置key对应的value，并返回旧的value</span><br><span class="line">    public static final Object put(String key, Object value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空所有的内容</span><br><span class="line">    public static final void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非线程安全的HashMap作为缓存,使用读写锁的读锁和写锁来保证Cache是线程安全的.Cache使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性，同时简化了编程方式。</p>
<h4 id="✅读写锁的实现分析"><a href="#✅读写锁的实现分析" class="headerlink" title="✅读写锁的实现分析"></a>✅读写锁的实现分析</h4><h5 id="一、读写状态的设计"><a href="#一、读写状态的设计" class="headerlink" title="一、读写状态的设计"></a>一、读写状态的设计</h5><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</p>
<p>回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，如果在一个整型变量上维护多种状态，就一定需要 “按位切割使用” 这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<p>通过位运算可以迅速确定读和写各自的状态，假设当前同步状态值为 S ，写状态等于 S&amp;0x0000FFFF （将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。</p>
<h5 id="二、写锁的获取与释放"><a href="#二、写锁的获取与释放" class="headerlink" title="二、写锁的获取与释放"></a>二、写锁的获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 锁状态</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 通过状态计算写锁数量</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    // 锁不为0，说明有读或者写</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // 写锁不存在（说明现在是读锁）或者当前获取线程不是已经获取写锁的线程</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 如果重入次数大于最大冲入数目</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 尝试获取写锁</span><br><span class="line">    // writerShouldBlock：公平锁会调用 hasQueuedPredecessors判断轮得到自己吗，非公平直接返回false去竞争锁</span><br><span class="line">    //  compareAndSetState 失败就会返回false</span><br><span class="line">    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置当前线程拥有锁</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</p>
<p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h5 id="三、读锁的获取与释放"><a href="#三、读锁的获取与释放" class="headerlink" title="三、读锁的获取与释放"></a>三、读锁的获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在 没有其他写线程访问（或者写状态为0） 时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。</p>
<p>获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount() 方法，作用是返回当前线程获取读锁的次数。由于读状态是 所有线程获取读锁次数的总和 ，所以每个线程 各自获取读锁的次数只能选择保存在ThreadLocal中 ，由线程自身维护，于是使获取读锁的实现变得复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        // 获取锁状态</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 读数目+1</span><br><span class="line">        int nextc = c + (1 &lt;&lt; 16);</span><br><span class="line">        // 溢出</span><br><span class="line">        if (nextc &lt; c)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 现在是写状态 且 拥有者不是自己</span><br><span class="line">        if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            return -1;</span><br><span class="line">        // 修改状态</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p>
<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&lt;&lt;16）。</p>
<h5 id="四、锁降级"><a href="#四、锁降级" class="headerlink" title="四、锁降级"></a>四、锁降级</h5><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void processData() &#123;</span><br><span class="line">		//锁住读锁</span><br><span class="line">        readLock.lock();</span><br><span class="line">        // 数据在更新吗</span><br><span class="line">        if (!update) &#123;</span><br><span class="line">			// 必须先释放读锁</span><br><span class="line">            readLock.unlock();</span><br><span class="line">			// 锁降级从写锁获取到开始</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!update) &#123;</span><br><span class="line">					// 准备数据的流程（略）</span><br><span class="line">                    update = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //开始降级</span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	// 锁降级完成，写锁降级为读锁</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">			// 使用数据的流程（略）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锁降级：先获取写锁，变更数据，再获取读锁，再释放写锁。此时还有读锁，还可以读数据，其他线程也可以获取读锁读数据。<br>这样变更完数据之后，可以多个读线程一起读取数据。</p>
<p>不支持锁升级：有线程获取读锁的时候，不能获取写锁，数据更新对其他线程的可见性。</p>
<h3 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5.LockSupport工具"></a>5.LockSupport工具</h3><p>队列同步器中，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>
<p>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p>
<p>比如说，线程dump结果结果中，有阻塞对象的parkNanos方法能够传递给开发人员阻塞对象的信息。</p>
<p>为什么要加阻塞对象信息？<br>由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p>
<h3 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6.Condition接口"></a>6.Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。</p>
<p>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的：<br>1、前置条件不但要获取锁，还要调用<code>Lock.newCondition()</code>获取Condition对象<br>2、等待队列支持多个<br>3、支持超时等待状态<br>4、支持在等待状态中不响应中断（可以对中断不敏感）</p>
<p>总结一下：<br>synchronized + Object监视器方法 - 实现等待通知 - 案例线程池<br>Lock(队列同步器) + Condition接口 - 实现等待通知 - 案例有界队列<br>可以直接使用synchronized实现同步<br>可以直接使用Lock实现锁，只不过只有同步队列，里面线程是阻塞状态，没有等待队列</p>
<h4 id="✅Condition接口与示例"><a href="#✅Condition接口与示例" class="headerlink" title="✅Condition接口与示例"></a>✅Condition接口与示例</h4><p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。</p>
<p>Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<p>等待通知模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void conditionWait() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void conditionSignal() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Condition对象作为成员变量。通过Lock的newCondition()方法</p>
<p>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>Condition接口方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await() ：造成当前线程在接到信号或被中断之前一直处于等待状态，对中断敏感。</span><br><span class="line">await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span><br><span class="line">awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</span><br><span class="line">awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</span><br><span class="line">awaitUntil(Date deadline) ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</span><br><span class="line">signal() ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</span><br><span class="line">signalAll() ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</span><br></pre></td></tr></table></figure>

<p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程（进入等待队列），直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。有点像线程池。</p>
<p>线程池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    private Object[] items;</span><br><span class="line">    // 添加的下标，删除的下标和数组当前数量</span><br><span class="line">    private int addIndex, removeIndex, count;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition notEmpty = lock.newCondition();</span><br><span class="line">    private Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public BoundedQueue(int size) &#123;</span><br><span class="line">        items = new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            if (++addIndex == items.length)</span><br><span class="line">                addIndex = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            if (++removeIndex == items.length)</span><br><span class="line">                removeIndex = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以添加方法为例：首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p>
<p>在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p>
<p>⚠️线程的阻塞、等待的区别：<br>在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。<br>相同点：<br>（1）都会暂停线程的执行。<br>区别点：<br>（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。<br>阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。<br>等待状态的主动：线程在同步代码内await，等待其他线程唤醒时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</p>
<h4 id="✅Condition的实现分析"><a href="#✅Condition的实现分析" class="headerlink" title="✅Condition的实现分析"></a>✅Condition的实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。</p>
<p>每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<h5 id="一、等待队列"><a href="#一、等待队列" class="headerlink" title="一、等待队列"></a>一、等待队列</h5><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>等待队列：当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列（每个Condition对象一个）。</p>
<h5 id="二、等待"><a href="#二、等待" class="headerlink" title="二、等待"></a>二、等待</h5><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p>
<p>ConditionObject的await方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 节点是否在同步队列中</span><br><span class="line">    // Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.</span><br><span class="line">    // 如果节点在同步队列中，现在等待重新去获取锁，返回true</span><br><span class="line">    // 一般总是在条件队列</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        // 暂停自己，等待被唤醒或者被中断</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        // 是否被中断了</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取锁成功且异常模式不为THROW_IE，就修改interruptMode</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    // 该方法是内部类Condition中的，设置下一个在首位的等待者</span><br><span class="line">    if (node.nextWaiter != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    // 如果interruptMode 不是0，唤醒后报告中断</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。（同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。）</p>
<p>（2）当等待队列中的节点被唤醒，则唤醒节点的线程进入同步队列，开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p>
<h5 id="三、通知"><a href="#三、通知" class="headerlink" title="三、通知"></a>三、通知</h5><p>调用Condition的signal()方法的前置条件是当前线程必须获取了锁，将在等待队列中等待时间最长的节点（首节点），线程安全地移动到同步队列，并使用LockSupport唤醒节点中的线程，然后就竞争锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    // 锁是否处于占用状态</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 获取第一个线程</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        // 唤醒</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p>
<p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。如果未获取到锁，将在同步队列中阻塞。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>
<h2 id="第六章-java并发容器和框架"><a href="#第六章-java并发容器和框架" class="headerlink" title="第六章 java并发容器和框架"></a>第六章 java并发容器和框架</h2><h3 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h3><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h4 id="✅为什么使用ConcurrentHashMap"><a href="#✅为什么使用ConcurrentHashMap" class="headerlink" title="✅为什么使用ConcurrentHashMap"></a>✅为什么使用ConcurrentHashMap</h4><p>（1）<strong>HashMap线程不安全会死循环</strong></p>
<p>HashMap 在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(2); // 容量为2的Map</span><br><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    map.put(UUID.randomUUID().toString(),&quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;ftf&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&quot;ftf&quot;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br></pre></td></tr></table></figure>

<p>HashMap的实现原理：<br>HashMap的主干是一个Entry数组（Entry是以链表的形式存储的）。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。(其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合)。</p>
<p>Entry结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next; // 存储指向下一个Entry的引用，单链表结构。</span><br><span class="line"> </span><br><span class="line">    int hash;	   // 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以：HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>HashMap在put的时候，插入的元素超过了容量(由负载因子决定)的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在其他的元素也在put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p>HashMap的线程不安全主要体现在会造成死循环，数据丢失，数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在Jdk1.8中已经得到解决，然而JDK1.8仍会有数据覆盖这样的问题。</p>
<p>（2）<strong>效率低下的HashTable</strong></p>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其它线程也访问HashTable的同步方法时，会进入阻塞或轮询状态，所以竞争越激烈效率越低。</p>
<p>（3）ConcurrentHashMap的锁分段技术可有效提升并发访问率。</p>
<p>HashTable的线程都必须竞争同一把锁，假如容器里有多把锁每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其它段的数据也能被其他线程访问。</p>
<h4 id="✅ConcurrentHashMap的结构"><a href="#✅ConcurrentHashMap的结构" class="headerlink" title="✅ConcurrentHashMap的结构"></a>✅ConcurrentHashMap的结构</h4><p>类图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock),在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。<strong>一个Segment里包含一个HashEntry数组</strong>，<strong>每个HashEntry是一个链表结构的元素（一个包含数据的链表）</strong>，每个Segment里守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<h4 id="✅ConcurrentHashMap的初始化与定位"><a href="#✅ConcurrentHashMap的初始化与定位" class="headerlink" title="✅ConcurrentHashMap的初始化与定位"></a>✅ConcurrentHashMap的初始化与定位</h4><p>ConcurrentHashMap初始化方法是通过initialCapacity, loadFactor和concurrencyLevel等几个参数来初始化segment数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组来实现。</p>
<p>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。而且，会使用再散裂算法对元素的hashCode进行一次再散列。</p>
<p>再散列的目的：减少散列冲突，使元素均匀地分布在不同的segmrnt上，提高容器的存取效率。</p>
<h4 id="✅ConcurrentHashMap的操作"><a href="#✅ConcurrentHashMap的操作" class="headerlink" title="✅ConcurrentHashMap的操作"></a>✅ConcurrentHashMap的操作</h4><p>（1）get(key)</p>
<p>经过一次再散列，先定位到segment，然后再通过散列运算定位到元素。<br>不需要加锁，除非读到的值是空的才会加锁重读。原因是：将共享变量（segment大小、HashEntry里的value）定义为volatile。利用volatile在多线程中的可见性，可以被多线程读，保证不会读到过期的值。</p>
<p>（2）put(key, value)</p>
<p>先定位到segment，然后在segment里进行插入操作。分两步：<br>1.是否需要扩容？<br>先判断HashEntry数组是否超过阈值，如果超过了就扩容，扩容之后再插入数据。而HashMap是先插入再扩容，这样不好，因为下次可能就没有数据进来了，那就白扩容了。<br>2.如何扩容？<br>先创建一个容量是原来2倍的数组，然后通过对原数组元素进行再散列后插入到新数组。扩容只会对某个segment进行。</p>
<p>（3）size()</p>
<p>Segment中有一个全局变量count是一个volatile变量，可以累加各个segment的count来计算大小。但是可能累加前count发生了变化，统计结果不准。但是锁住所有的segment再计算也不合适。</p>
<p>在每个segment中有一个volatile修饰的count属性，表示这个segment中的元素个数，先通过2次不加锁的方法统计所有count的总和，如果两次结果不相等，或者容器被修改过了，就将Segment加锁，再进行第三次统计。</p>
<p>ConcurrentHashMap中有一个modCount变量，每次put\remove\clean操作，都会对这个值加一，通过比较这个值，就知道是否容器是否被修改了。</p>
<h3 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2.ConcurrentLinkedQueue"></a>2.ConcurrentLinkedQueue</h3><p>无界线程安全队列。</p>
<p>在并发编程中，有时候需要使用线程安全的对列。如果要实现一个线程安全的对列有2种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的对列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。【锁也是基于CAS和volatile来实现的吧】</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全对列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到对列的尾部；当我们获取一个元素时，它会返回对列头部的元素。它采用了”wait-free”算法(即CAS算法)来实现。</p>
<h4 id="✅ConcurrentLinkedQueue的结构"><a href="#✅ConcurrentLinkedQueue的结构" class="headerlink" title="✅ConcurrentLinkedQueue的结构"></a>✅ConcurrentLinkedQueue的结构</h4><p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素(item)和指向下一个节点(next)的引用组成，节点和节点之间就是通过这个next关联起来，从而组成一张链表结构的对列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p>继承了AbstractQueue，不是阻塞队列。</p>
<p>ConcurrentLinkedQueue由head节点和tail节点组成。head、tail、next、item均使用volatile修饰，保证其内存可见性。</p>
<h4 id="✅入队列-offer-E-e"><a href="#✅入队列-offer-E-e" class="headerlink" title="✅入队列:offer(E e)"></a>✅入队列:offer(E e)</h4><p>入队列就是将入队节点添加到对列的尾部。入队主要做两件事情：<br>第一：是将入队节点设置成当前队列尾节点的下一个节点；<br>第二：是更新tail节点，如果tail节点的next不为空，则将入队节点设置为tial节点，成为队尾节点的next节点，如果tail节点的next为空，则将入队节点的设置为tail的next节点。所以tail节点不总是尾节点。【效果是两格两格得跳】</p>
<p>1.定位尾节点<br>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。</p>
<p>2.设置入队节点为尾节点<br>p.casNext(null,n)方法用于将入队节点设置为当前对尾节点的next节点，如果p是null，表示p是当前节点的尾节点，如果不为null，表示有其它线程更新了尾节点，则需要重新获取当前对列的尾节点。</p>
<p>⚠️不是每次入队都更新tail节点：<br>如果将tail节点永远作为尾节点，这样每次都需要循环CAS更新tail节点，而设置一个到尾节点的距离，当tail到尾节点的距离大于某个值（通常为1）的时候再更新tail，这样可以减少更新的次数，提高入队的效率。定位尾节点时就需要增加对volatile变量读操作，但是对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p><strong>入队方法永远返回true，所以不要通过返回值判断入队是否成功。</strong></p>
<h4 id="✅出队列：poll"><a href="#✅出队列：poll" class="headerlink" title="✅出队列：poll()"></a>✅出队列：poll()</h4><p>不是每次出队都更新head节点，当head中有元素，就直接弹出head的元素，如果没有元素，就弹出head的next，然后更新head节点，head节点变为弹出节点的next节点。【一次走两格】<br>也是通过控制距离的方式，减少CAS更新节点的消耗。</p>
<h3 id="3-阻塞队列"><a href="#3-阻塞队列" class="headerlink" title="3.阻塞队列"></a>3.阻塞队列</h3><p>阻塞对列(BlockingQueue)是一个支持两个附加操作的对列。这两个附加操作支持阻塞的插入和移除方法。</p>
<p>1）支持阻塞的插入方法：意思是当对列满时，对列会阻塞插入元素的线程，直到对列不满。<br>2）支持阻塞的移除方法：意思是当对列为空时，获取元素的线程会等待对列不为空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向对列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------------------插入和移除操作的4种处理方式--------------</span><br><span class="line"></span><br><span class="line">方法/处理方式    抛出异常    返回特殊值    一直阻塞    超时退出</span><br><span class="line">插入方法        add(e)     offer(e)     put(e)      offer(e,time,unit)</span><br><span class="line">移除方法       remove()    poll()       take()     poll(time,unit)</span><br><span class="line">检查方法      element()    peek()       不可用      不可用</span><br><span class="line"></span><br><span class="line">1）抛出异常：当队列满时，如果再往对列里插入元素，会抛出IllegalStateException(&quot;Queue full&quot;)异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</span><br><span class="line">2）返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有返回null。</span><br><span class="line">3）一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到对列可用或者响应中断退出。当队列为空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</span><br><span class="line">4）超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</span><br></pre></td></tr></table></figure>

<p>如果是无界阻塞队列，队列不可能出现满的情况，岁月使用put和offer永远不会被阻塞，而且使用offer方法时，总返回true。</p>
<h4 id="✅java提供的几种阻塞队列"><a href="#✅java提供的几种阻塞队列" class="headerlink" title="✅java提供的几种阻塞队列"></a>✅java提供的几种阻塞队列</h4><p>ArrayBlockingQueue:    一个由数组结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue是一个用数组实现的有界阻塞队列。</span><br><span class="line">此队列按照先进先出(FIFO)的原则对元素进行排序。</span><br><span class="line">默认情况下不保证线程公平的访问队，即不保证先阻塞线程先访问队列。</span><br><span class="line"></span><br><span class="line">如果想保证公平性，可以用可重入锁来实现</span><br><span class="line">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue&lt;&gt;(1000, true);</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue:    一个由链表结构组成的有界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue是一个用链表实现的有界阻塞队列。</span><br><span class="line">此队列的默认和最大长度为Inter.MAX_VALUE。</span><br><span class="line">此队列按照先进先出的原则对元素进行排序。</span><br></pre></td></tr></table></figure>

<p>PriorityBlockingQueue:    一个支持优先级排序的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue是一个支持优先级的无界阻塞队列。</span><br><span class="line">默认情况下元素采取自然顺序升序排列。</span><br><span class="line">也可以自定义实现compareTo()方法来指定元素排序规则，</span><br><span class="line">或者初始化PriorityBlockingQueue时，指定构造参数(Comparator)来对元素进行排序。</span><br><span class="line">需要注意的是不能保证同优先级元素的排序。</span><br></pre></td></tr></table></figure>

<p>DelayQueue:    一个使用优先级队列实现的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue是一个支持延时获取元素的无界阻塞队列.</span><br><span class="line">队列使用PriorityQueue来实现。</span><br><span class="line">队列中的元素必须实现Delayed接口，在创建元素时可以指定多久（元素存在了多久）才能从队列中获取当前元素。</span><br><span class="line">只有在延迟期满时才能从队列里提取元素。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line">1）缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue获取元素时，表示缓存有效期到了。</span><br><span class="line">2）定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimeQueue就是使用DelayQueue实现的。</span><br><span class="line"></span><br><span class="line">a.如何实现Delayed接口</span><br><span class="line">DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</span><br><span class="line"></span><br><span class="line">第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。</span><br><span class="line"></span><br><span class="line">private static final AtomicLong sequencer = new AtomicLong(0);</span><br><span class="line">private class ScheduledFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; &#123;</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, long ns) &#123;</span><br><span class="line">    super(r, result);</span><br><span class="line">    this.time = ns;</span><br><span class="line">    this.period = 0;</span><br><span class="line">    this.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒</span><br><span class="line"></span><br><span class="line">public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">    return unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第三步：实现compareTo()方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。</span><br><span class="line"></span><br><span class="line">public int compareTo(Delayed other) &#123;</span><br><span class="line">    if (other == this) // compare zero ONLY if same object</span><br><span class="line">        return 0;</span><br><span class="line">    if (other instanceof ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        long diff = time - x.time;</span><br><span class="line">        if (diff &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        else if (diff &gt; 0)</span><br><span class="line">            return 1;</span><br><span class="line">        else if (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            return -1;</span><br><span class="line">        else</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">            other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    return (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b. 如何实现延时阻塞队列</span><br><span class="line">延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</span><br><span class="line"></span><br><span class="line">public RunnableScheduledFuture take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture first = queue[0];</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return finishPoll(first);</span><br><span class="line">                else if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; queue[0] != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中的变量leader是一个等待获取队列头部元素的线程。</span><br><span class="line">如果leader不等于空，表示已经有线程在等待获取队列的头元素。</span><br><span class="line">所以，使用await()方法让当前线程等待信号。</span><br><span class="line">如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</span><br></pre></td></tr></table></figure>

<p>SynchronousQueue:    一个不存储元素的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</span><br><span class="line">它支持公平访问队列.</span><br><span class="line">默认情况下线程采用非公平性策略访问队列。创建公平性访问的SynchronousQueue，如果设置true，则等待的线程会采用先进先出的顺序访问队列。</span><br><span class="line">负责把生产者线程处理的数据直接传递给消费者线程。</span><br><span class="line">队列本身并不存储任何元素，非常适合传递性场景。</span><br><span class="line">SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</span><br><span class="line">有点像go的channel</span><br></pre></td></tr></table></figure>

<p>LinkedTransferQueue:    一个由链表结构组成的无界阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。</span><br><span class="line">相对于其它阻塞队列，linkedTransferQueue多了tryTransfer和transfer方法。</span><br><span class="line"></span><br><span class="line">（1）transfer方法</span><br><span class="line">如果当前有消费者正在等待接收元素(消费者使用take()方法或带有时间限制的poll()方法时)，</span><br><span class="line">transfer方法可以把生产者传入的元素立刻transfer(传输)给消费者。</span><br><span class="line">如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</span><br><span class="line">会让CPU自旋等待消费者消费元素。</span><br><span class="line">因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其它线程。</span><br><span class="line"></span><br><span class="line">（2）tryTransfer方法</span><br><span class="line">tryTransfer方法是用来试探生产者传入的元素是否能直接传递给消费者。</span><br><span class="line">如果没有消费者等待接收元素，则返回false。</span><br><span class="line">和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，</span><br><span class="line">而transfer方法是必须等到消费者消费了才返回。</span><br><span class="line"></span><br><span class="line">对于带有时间限制的tryTransfer(E e,long timeout,TimeUnit unit)方法，</span><br><span class="line">试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回。</span><br><span class="line">如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true.</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingDeque:    一个由链表结构组成的双向阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。</span><br><span class="line">所谓双向队列指的是可以从队列的两端插入和移出元素。</span><br><span class="line">双向队列因为多了个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</span><br><span class="line">相比其它的阻塞队列，LinkedBlockingDeque多了addFirst,addLast,offerFirst,offerLast,peekFirst和peekLast等方法，</span><br><span class="line">以First单词结尾的方法，表示插入，获取(peek)或移除双端队列的第一个元素。</span><br><span class="line">以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。</span><br><span class="line">另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst.</span><br><span class="line"></span><br><span class="line">在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外双向阻塞队列可以运用在&quot;工作窃取&quot;模式中。</span><br></pre></td></tr></table></figure>

<h4 id="✅阻塞队列的实现原理"><a href="#✅阻塞队列的实现原理" class="headerlink" title="✅阻塞队列的实现原理"></a>✅阻塞队列的实现原理</h4><p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源代码发现ArrayBlockingQueue使用了Condition来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notEmpty = lock.newCondition();</span><br><span class="line">notFull = lock.newChonditon();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果队列满：添加元素的时候，通过调用notFull.await()阻塞当前线程；移除元素额时候，用notFull.signal()唤醒在notFull上等待的线程。</li>
<li>如果队列空：读取元素的时候，通过notEmpty.await()阻塞当前线程；当添加元素时，调用notEmpty.signal()唤醒在notEmpty上等待的线程。</li>
</ul>
<p>阻塞生产者await()主要通过LockSupport.park(this)来实现。其中，首先调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p>
<h3 id="4-Fork-Join框架"><a href="#4-Fork-Join框架" class="headerlink" title="4.Fork/Join框架"></a>4.Fork/Join框架</h3><p>Fork/Join框架是Java 7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<h4 id="✅工作窃取-work-stealing-算法"><a href="#✅工作窃取-work-stealing-算法" class="headerlink" title="✅工作窃取(work-stealing)算法"></a>✅工作窃取(work-stealing)算法</h4><p>工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>做一个比较大的任务，可以把这个任务分割成若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。<br>比如A线程负责处理A队列里的任务。但是，有的线程会把自己队列里的任务干完，而其它线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用双端队列，被窃取任务线程永远从双端队列头部拿任务执行，而窃取任务的线程永远从双队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h4 id="✅Fork-Join框架的设计"><a href="#✅Fork-Join框架的设计" class="headerlink" title="✅Fork/Join框架的设计"></a>✅Fork/Join框架的设计</h4><p>步骤1：分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</p>
<p>步骤2：执行任务并合并结果。分割的子任务分别放在双端队列，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p>
<p>Fork/Join使用两个类来完成以上两个事情：</p>
<p>1)ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。<br>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。<br>a.RecursiveAction: 用于没有返回结果的任务。<br>b.RecursiveTask:用于有返回结果的任务。</p>
<p>2）ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p>
<p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程队列的尾部获取一个任务。</p>
<h4 id="✅使用Fork-Join的例子"><a href="#✅使用Fork-Join的例子" class="headerlink" title="✅使用Fork/Join的例子"></a>✅使用Fork/Join的例子</h4><p>计算1+2+3+4的结果：</p>
<p>1.如何fork：设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务</p>
<p>2.如何join：join两个子任务的结果。因为是有结果的任务，因此必须继承RecursiveTask</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class CountTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"> </span><br><span class="line">    private static final int THRESHOLD = 2;//阈值</span><br><span class="line"> </span><br><span class="line">    private int start;</span><br><span class="line"> </span><br><span class="line">    private int end;</span><br><span class="line"> </span><br><span class="line">    public CountTask(int start,int end)&#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        // 如果任务足够小就计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        if (canCompute)&#123;</span><br><span class="line">            for (int i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">            int middle = (start + end)/2;</span><br><span class="line">            CountTask leftTask = new CountTask(start,middle);</span><br><span class="line">            CountTask rightTask = new CountTask(middle+1,end);</span><br><span class="line"> </span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"> </span><br><span class="line">            // 等待子任务执行完，并得到结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"> </span><br><span class="line">            // 合并子任务</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        // 生成一个计算任务，负责计算 1+2+3+4</span><br><span class="line">        CountTask task = new CountTask(1,4);</span><br><span class="line">        // 执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;魔法革的日志信息：----&gt;&quot;+ result.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork方法是执行，join方法是等待执行完获取运行结果。需要实现computer方法，在这个方法里看怎么拆分任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完成并得到结果。</p>
<h4 id="✅Fork-Join框架的异常处理"><a href="#✅Fork-Join框架的异常处理" class="headerlink" title="✅Fork/Join框架的异常处理"></a>✅Fork/Join框架的异常处理</h4><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (task.isCompletedAbnormally())&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p>
<h4 id="✅Fork-Join框架的实现原理"><a href="#✅Fork-Join框架的实现原理" class="headerlink" title="✅Fork/Join框架的实现原理"></a>✅Fork/Join框架的实现原理</h4><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成的，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p>
<p>（1）fork方法实现原理：</p>
<p>调用ForkJoinTask的fork()方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。</p>
<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>
<p>（2）join方法实现原理</p>
<p>Join方法的主要作用是阻塞当前线程并等待获取结果。</p>
<p>它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：<br>已完成(NORMAL)，被取消(CANCELLED)，信号(SIGNAL)和出现异常(EXCEPTION)。</p>
<p>a. 如果任务状态已完成，则直接返回任务结果。<br>b. 如果任务状态是被取消，则直接抛出CancellationException。<br>c. 如果任务状态是抛出异常，则直接抛出对应的异常。</p>
<p>在doJoin()方法里，首先通过任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。<br>如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>
<h2 id="第七章-java中的13个原子操作类"><a href="#第七章-java中的13个原子操作类" class="headerlink" title="第七章 java中的13个原子操作类"></a>第七章 java中的13个原子操作类</h2><p>多线程同时更新一个变量，通常我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p>
<p>Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<blockquote>
<p>Unsafe类位于sun.misc包下，它是java实现高并发的基础，通过它可以执行一些不安全的操作，如像C语言一样直接操作内存资源，<br>它提供的这些方法增强了java对底层资源的操作能力，但同时也增加了程序出错的风险.<br>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障相关、数组相关等。</p>
</blockquote>
<blockquote>
<p>CAS(compareAndSwap)即比较并替换，是实现并发算法时常用到的一种技术。CAS底层为一条原子指令cmpxchg，可以保证原子性，Unsafe提供的CAS方法如compareAndSwapInt底层就是CPU指令cmpxchg。<br>CAS在java并发包中的原子类如AtomicInteger，AQS(AbstractQueuedSynchronizer)，ConcurrentHashMap等实现中都有广泛的使用。<br>因此，不管是Atomic还是什么锁里的CAS都依托于Unsafe包里的方法。</p>
</blockquote>
<p>Unsafe类：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/strongmore/p/15468423.html">https://www.cnblogs.com/strongmore/p/15468423.html</a></p>
<h3 id="1-原子更新基本类型类"><a href="#1-原子更新基本类型类" class="headerlink" title="1.原子更新基本类型类"></a>1.原子更新基本类型类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicBoolean：原子更新布尔类型。</span><br><span class="line">· AtomicInteger：原子更新整型。</span><br><span class="line">· AtomicLong：原子更新长整型。</span><br><span class="line"></span><br><span class="line">AtomicInteger为例：</span><br><span class="line">· int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</span><br><span class="line"></span><br><span class="line">· int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</span><br><span class="line"></span><br><span class="line">· void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br><span class="line"></span><br><span class="line">·int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    int current = get(); </span><br><span class="line">    int next = current + 1;</span><br><span class="line">    if (compareAndSet(current, next)) </span><br><span class="line">        return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Atomic包里的类基本都是使用Unsafe实现的.<br>Unsafe只提供了3种CAS方法：compareAndSwapObject、compare- AndSwapInt和compareAndSwapLong.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object o,  long offset, Object expected, Object x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,  int expected, int x);  </span><br><span class="line">  </span><br><span class="line">public final native boolean compareAndSwapLong(Object o, long offset,  long expected, long x);  </span><br></pre></td></tr></table></figure>

<h3 id="2-原子更新数组"><a href="#2-原子更新数组" class="headerlink" title="2.原子更新数组"></a>2.原子更新数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三个类：</span><br><span class="line">· AtomicIntegerArray：原子更新整型数组里的元素。</span><br><span class="line">· AtomicLongArray：原子更新长整型数组里的元素。</span><br><span class="line">· AtomicReferenceArray：原子更新引用类型数组里的元素。</span><br><span class="line"></span><br><span class="line">AtomicIntegerArray为例：</span><br><span class="line">· int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</span><br><span class="line"></span><br><span class="line">· boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</span><br><span class="line"></span><br><span class="line">static int[] value = new int[] &#123; 1， 2 &#125;;  </span><br><span class="line">static AtomicIntegerArray ai = new AtomicIntegerArray(value); </span><br><span class="line">ai.getAndSet(0， 3);</span><br><span class="line">System.out.println(ai.get(0)); //3</span><br><span class="line">System.out.println(value[0]);  //1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="3-原子更新引用类型"><a href="#3-原子更新引用类型" class="headerlink" title="3.原子更新引用类型"></a>3.原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">· AtomicReference：原子更新引用类型。</span><br><span class="line">· AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</span><br><span class="line">· AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</span><br><span class="line"></span><br><span class="line">AtomicReference为例：</span><br><span class="line"></span><br><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;user&gt; atomicUserRef = new AtomicReference&lt;user&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;conan&quot;， 15); atomicUserRef.set(user);</span><br><span class="line">        User updateUser = new User(&quot;Shinichi&quot;， 17); atomicUserRef.compareAndSet(user， updateUser);</span><br><span class="line">        System.out.println(atomicUserRef.get().getName());</span><br><span class="line">        System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-原子更新字段类"><a href="#4-原子更新字段类" class="headerlink" title="4.原子更新字段类"></a>4.原子更新字段类</h3><p>更新静态类里的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">· AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</span><br><span class="line">· AtomicLongFieldUpdater：原子更新长整型字段的更新器。</span><br><span class="line">· AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</span><br></pre></td></tr></table></figure>

<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>
<p>AstomicIntegerFieldUpdater例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerFieldUpdaterTest &#123;</span><br><span class="line"></span><br><span class="line">   // 创建原子更新器，并设置需要更新的对象类和对象的属性</span><br><span class="line">    private static AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class， &quot;old&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User conan = new User(&quot;conan&quot;， 10);</span><br><span class="line">        System.out.println(a.getAndIncrement(conan)); //10</span><br><span class="line">        System.out.println(a.get(conan));  //11</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class User &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public volatile int old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">静态变量和成员变量：</span><br><span class="line">由static修饰的变量称为静态变量，其实质上就是一个全局变量。</span><br><span class="line">如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；</span><br><span class="line">没有被静态修饰的内容，其实是属于对象的特殊描述。</span><br><span class="line"></span><br><span class="line">成员变量和静态变量的区别：</span><br><span class="line">1.生命周期不同</span><br><span class="line">成员变量随着对象的创建而存在，随着对象被回收而释放。</span><br><span class="line">静态变量随着类的加载而存在，随着类的消失而消失。</span><br><span class="line">2.调用方式不同</span><br><span class="line">成员变量只能被对象调用。</span><br><span class="line">静态变量可以被对象调用，还可以被类名调用。</span><br><span class="line">3.别名不同</span><br><span class="line">成员变量也称为实例变量。</span><br><span class="line">静态变量也称为类变量。</span><br><span class="line">4.数据存储位置不同</span><br><span class="line">成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</span><br><span class="line">静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">静态方法和非静态方法：</span><br><span class="line">静态方法:是使用static关键字修饰的方法，又叫类方法.属于类的，</span><br><span class="line">不属于对象， 在实例化对象之前就可以通过类名.方法名调用静态方法。</span><br><span class="line">非静态方法：又称为实例方法，成员方法。属于对象的，不属于类的。</span><br><span class="line"></span><br><span class="line">静态方法和非静态方法的区别：</span><br><span class="line">1.调用方法</span><br><span class="line">静态方法中，可以调用静态方法，不能调用非静态方法。在静态方法中，不能使用super和this关键字。不能引用成员变量。</span><br><span class="line">普通方法中，可以调用普通方法，也可以调用静态方法。</span><br><span class="line">2.使用方法</span><br><span class="line">静态方法可以直接调用，类名调用和对象调用。</span><br><span class="line">但是非静态方法只能通过对象调用。（对象名.方法名）</span><br><span class="line">3.生命周期不同</span><br><span class="line">静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。</span><br><span class="line">非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。</span><br><span class="line"></span><br><span class="line">静态方法优点：常住在内存中，调用快捷方便，全剧唯一，用类调用就行。</span><br><span class="line">应用场景：</span><br><span class="line">1. 静态方法最适合工具类中方法的定义；比如文件操作，日期处理方法等.</span><br><span class="line">2. 静态方法适合入口方法的定义；如单例模式，因为从外部拿不到构造函数，所有定义一个静态的方法获取对象非常有必要.</span><br><span class="line">3. 静态变量适合全局变量的定义.（如布尔型静态成员变量做控制符）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">静态类：</span><br><span class="line">java允许我们在一个类里面定义静态类。比如内部类（nested class）。</span><br><span class="line">把nested class封闭起来的类叫外部类。</span><br><span class="line">在java中，我们不能用static修饰顶级类（top level class）。只有内部类可以为static。</span><br><span class="line">（一般工具类也不是static的，方法是static的）</span><br><span class="line">（一般在一个类里再定义一个类用于包装数据，用public static class）</span><br><span class="line"></span><br><span class="line">静态内部类和非静态内部类的区别：</span><br><span class="line">1.内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。（此话怎样，意思是非静态内部类需要对象.类名，静态内部类需要外部类名.类名）</span><br><span class="line">2.非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。</span><br><span class="line">3.一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。</span><br><span class="line"></span><br><span class="line">class OuterClass&#123;</span><br><span class="line">  private static String msg = &quot;GeeksForGeeks&quot;;</span><br><span class="line">  // 静态内部类</span><br><span class="line">  public static class NestedStaticClass&#123;</span><br><span class="line">    // 静态内部类只能访问外部类的静态成员</span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">     // 试着将msg改成非静态的，这将导致编译错误 </span><br><span class="line">     System.out.println(&quot;Message from nested static class: &quot; + msg); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 非静态内部类</span><br><span class="line">  public class InnerClass&#123;</span><br><span class="line">    // 不管是静态方法还是非静态方法都可以在非静态内部类中访问</span><br><span class="line">    public void display()&#123;</span><br><span class="line">     System.out.println(&quot;Message from non-static nested class: &quot;+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">class Main</span><br><span class="line">&#123;</span><br><span class="line">  // 怎么创建静态内部类和非静态内部类的实例</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    // 创建静态内部类的实例</span><br><span class="line">    OuterClass.NestedStaticClass printer = new OuterClass.NestedStaticClass();</span><br><span class="line">    // 创建静态内部类的非静态方法</span><br><span class="line">    printer.printMessage();  </span><br><span class="line">    // 为了创建非静态内部类，我们需要外部类的实例</span><br><span class="line">    OuterClass outer = new OuterClass();    </span><br><span class="line">    OuterClass.InnerClass inner = outer.new InnerClass();</span><br><span class="line">    // 调用非静态内部类的非静态方法</span><br><span class="line">    inner.display();</span><br><span class="line">    // 我们也可以结合以上步骤，一步创建的内部类实例</span><br><span class="line">    OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();</span><br><span class="line">    // 同样我们现在可以调用内部类方法</span><br><span class="line">    innerObject.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Inner class &#x27;Person&#x27; may be &#x27;static&#x27; </span><br><span class="line">ide提示内部类最好是静态的. 不然不能在所在外部类里直接new一个对象。</span><br><span class="line"></span><br><span class="line">一个类包在另一个外部类里面，叫做内部类，可以和其他内部类重名。</span><br><span class="line">但是和一个类并列在一个类文件里，不是内部类，不能重名。不同于内部类，是可以直接使用的，相当于一个单独的文件，不建议这么做。</span><br></pre></td></tr></table></figure>

<p>静态内部类和非静态内部类：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/74838.htm">https://www.jb51.net/article/74838.htm</a></p>
<h2 id="第八章-java中的并发工具类"><a href="#第八章-java中的并发工具类" class="headerlink" title="第八章 java中的并发工具类"></a>第八章 java中的并发工具类</h2><p>JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类提供了在线程间交换数据的一种方法。</p>
<h3 id="1-等待多线程完成的CountDownLatch"><a href="#1-等待多线程完成的CountDownLatch" class="headerlink" title="1.等待多线程完成的CountDownLatch"></a>1.等待多线程完成的CountDownLatch</h3><p>应用场景：等待其他多个线程执行完了，再执行当前线程。</p>
<p>在JDK1.5之后的并发包中提供的CountDownLatch可以实现join的功能，一个countDownLatch的await()方法相当于多个线程的join方法。join线程终止后，其实是调用了<code>this.notifyAll()方法</code>，在JVM里实现的，在JDK里看不到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(1);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(2);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用CountDownLatch的countDown方法时，CountDownLatch的await方法会阻塞当前线程，直到N变为0。可以是N个线程，也可以是1个线程的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<p>超时机制：<code>await(long time, TimeUnit unit)</code>，这个方法等待特定时间后，就会不再阻挡当前线程。</p>
<p>⚠️CountDownLatch不可能重新初始化或者修改其内部计数器的值。</p>
<h3 id="2-同步屏障CyclicBarrier"><a href="#2-同步屏障CyclicBarrier" class="headerlink" title="2.同步屏障CyclicBarrier"></a>2.同步屏障CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>应用场景：一辆车装10个人，上够10个人才开车。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程和子线程的调度是有CPU决定的，两个线程都有可能先执行。可能是1，2，也可能是2，1.</p>
<p>CyclicBarrier还提供了一个高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在所有线程都到达屏障时，优先执行barrierAction。注意，这个barrierAction不一定是要用cyclicBarrier.await()的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:50</span><br><span class="line"> **/</span><br><span class="line">public class CyclicTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(2, new A());</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class A implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出3-1-2 或者3-2-1.</p>
<h4 id="✅线程的阻塞状态和中断状态"><a href="#✅线程的阻塞状态和中断状态" class="headerlink" title="✅线程的阻塞状态和中断状态"></a>✅线程的阻塞状态和中断状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">线程的阻塞状态和中断状态</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">wait和notify：</span><br><span class="line">执行了监视器的wait()方法后，放弃锁进入等待状态。</span><br><span class="line">执行了监视器的notify()方法后，让一个线程从等待队列到同步队列，进入阻塞状态。</span><br><span class="line">wait()和notify()方法使用的前提是要获取对象的锁的，也就是在synchronized(obj)&#123;&#125;内。</span><br><span class="line">sleep方法进入定时等待状态，不会释放锁(如果写在synchronized内)。</span><br><span class="line"></span><br><span class="line">sleep和wait区别：</span><br><span class="line">1.sleep是Thread类的方法，是「静态方法」。wait是Object类的方法，调用需要具体的对象。</span><br><span class="line">2.sleep是不释放锁的，解除方法要么是timeout，或者interrupt一下让它抛出InterruptedException。wait是释放锁的，可以被notify/notifyAll恢复，同样也可以timeout或者interrupt。</span><br><span class="line">3.sleep在哪里都可以调用，wait必须在同步方法或同步块里调用，并且同步的对象要跟wait的对象一样。</span><br><span class="line">4.sleep作用只是线程的操作，用于短时间暂停线程，wait/notify可以用作线程间通信，达到资源调度的功能。</span><br><span class="line"></span><br><span class="line">Thread.yield():</span><br><span class="line">yield方法也是Thread类的静态方法，重新分配。</span><br><span class="line">会把当前线程从可运行状态变成就绪状态。</span><br><span class="line">之后会cpu会从众多就绪状态的线程中选择一个来执行。</span><br><span class="line"></span><br><span class="line">thread.join():</span><br><span class="line">join是Thread类方法，非静态，表示等待该线程结束，当前线程才继续执行</span><br><span class="line">join进入等待状态。</span><br><span class="line"></span><br><span class="line">线程中断：</span><br><span class="line">suspend()暂停和resume()继续容易造成死锁，stop()具有固有的不安全性。已废弃。</span><br><span class="line">终止线程的几种方式：</span><br><span class="line">1.设计标记位法：volatile的boolean类型变量来控制</span><br><span class="line">缺点：如果代码并没有这种循环语句，或者线程被其他语句阻塞了，线程可能一直不会去检查标记位。</span><br><span class="line">2.thread.interrupt()方法中断</span><br><span class="line">线程里有一个boolean类型的中断状态，是一个标记位，是存在Native层的。</span><br><span class="line">当使用Thread的interrupt()方法时，线程的中断状态会被设置为true。</span><br><span class="line">一些阻塞方法就会抛出一个异常InterruptedException。如果没有这种阻塞方法，那就什么都不会做。</span><br><span class="line">interrupt()方法是实例方法</span><br><span class="line">还有两个方法：isInterrupted() 和 interrupted() </span><br><span class="line">相同点是这两个都是返回一个boolean值，true表示中断，false表示未被中断。</span><br><span class="line">不同点是interrupted()是静态方法，只能在当前线程调用，判断是true后会清除标记，也就是重置为false。isInterrupted()是实例方法，不会清除标记，所以可以多次判断。</span><br><span class="line"></span><br><span class="line">*在Thread.sleep这些方法，抛出InterruptedException异常后会清除标记位状态。</span><br><span class="line">一个关于中断的例子见下面代码</span><br><span class="line"></span><br><span class="line">*所谓的interrupt线程中断，只是修改了一个标记位，需要我们判断标记位做后续的处理。</span><br><span class="line">如果catch代码块什么都不处理，会继续跑完剩下的代码。所以应该理解为『并不是中断，而是通知你应该自行中断了』</span><br><span class="line">线程不应该交给别的线程中断，应该由自己中断自己，过程中保证资源和变量已合理的处理了（该关的关，该释放的释放）。</span><br><span class="line"></span><br><span class="line">线程阻塞：</span><br><span class="line">阻塞和非阻塞是形容多个线程之间的相互影响的，一个线程占用了临界区资源，那么其他线程必须在临界区外等待。</span><br><span class="line">如果一个线程一直占用不释放资源，那么其他需要该临界区资源的线程都必须一直等待。</span><br><span class="line">非阻塞就是运行多个线程同时进入临界区，只要保证不把数据修改坏就行。</span><br><span class="line"></span><br><span class="line">线程阻塞的场景：</span><br><span class="line">运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</span><br><span class="line">发出I/O请求时，JVM会把该线程置为阻塞状态，I/O处理完毕时，线程重新转入就绪状态。</span><br><span class="line"></span><br><span class="line">线程阻塞和等待的区别：</span><br><span class="line">在java中，线程阻塞状态是线程本身不可计划的，而线程等待状态是线程本身计划之内的。</span><br><span class="line">相同点：</span><br><span class="line">（1）都会暂停线程的执行。</span><br><span class="line">区别点：</span><br><span class="line">（1）线程进入阻塞状态是被动的, 而线程进入等待状态是主动的。</span><br><span class="line">阻塞状态的被动：线程在同步代码外，获取对象锁失败时，线程进入阻塞状态；何时获取对象锁失败不可知，即线程阻塞状态是线程本身不可计划的。</span><br><span class="line">等待状态的主动：线程在同步代码内，等待其他线程操作时，线程接入等待状态；何时等待其他线程操作可知，即线程等待状态是线程本身计划之内的。</span><br><span class="line"></span><br><span class="line">countDownLatch/cyclicBarrier的await方法进入阻塞状态，会不会释放锁？</span><br><span class="line">经测试，测试代码如下，不会释放锁。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">wait进入等待状态，释放锁。</span><br><span class="line">sleep进入定时等待状态，不释放锁。</span><br><span class="line">await进入阻塞状态，不释放锁。</span><br></pre></td></tr></table></figure>

<p>线程中断的讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/alcoholdi/article/details/79475029">https://blog.csdn.net/alcoholdi/article/details/79475029</a></p>
<p>关于线程中断的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> </span><br><span class="line">    // 中断目标线程</span><br><span class="line">    public void interrupt() &#123;</span><br><span class="line">        if (this != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"> </span><br><span class="line">        synchronized (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            if (b != null) &#123;</span><br><span class="line">                interrupt0();           // Just to set the interrupt flag</span><br><span class="line">                b.interrupt(this);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 返回目标线程的中断状态	static在这里理解为：只供当前线程使用这个方法</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 判断目标线程是否中断</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个关于中断的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 09:06</span><br><span class="line"> **/</span><br><span class="line">public class InterruptDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        InterruptThread t = new InterruptThread();</span><br><span class="line">        Interrupt2Thread t = new Interrupt2Thread();</span><br><span class="line">//        Interrupt3Thread t = new Interrupt3Thread();</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class InterruptThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 在catch中直接return结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted() + &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //不输出</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt2Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                    // 可以再次调用interrupt恢复中断</span><br><span class="line">                    // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                    System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                    //interrupt();</span><br><span class="line">                    //如果不在catch里再中断，会一直执行</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">//                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，不会停</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Interrupt3Thread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @SneakyThrows</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!isInterrupted()) &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                // 抛出InterruptedException后中断标志被清除</span><br><span class="line">                // 可以再次调用interrupt恢复中断</span><br><span class="line">                // catch中再次调用interrupt恢复中断状态，while中下次判断isInterrupted()中结束线程</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; catch &quot; + isInterrupted()+ &quot; &quot; + interrupted()); //false false</span><br><span class="line">                interrupt();</span><br><span class="line">                //System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot;);</span><br><span class="line">                System.out.println(sdf.format(new Date()) + Thread.currentThread() + &quot; &quot; + isInterrupted()+ &quot; &quot; + interrupted());</span><br><span class="line">                //如果用了上面的那个，中断标识为会输出true后被重置为false，继续循环，直到在主线程内中断，抛出InterruptedException</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试await方法会不会释放锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 22:33</span><br><span class="line"> **/</span><br><span class="line">public class AwaitTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object lock = 1;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">        Thread thread1 = new Thread()&#123;</span><br><span class="line">            @SneakyThrows</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread1 get lock&quot;);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(&quot;thread2 get lock&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier的使用场景：多用于多线程计算数据，最后合并计算结果的场景。<br>一个合并计算结果的例子，用了barrierAction参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-18 23:02</span><br><span class="line"> **/</span><br><span class="line">public class CyclicDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BankWaterService bankWaterService = new BankWaterService();</span><br><span class="line">        bankWaterService.count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BankWaterService implements Runnable &#123;</span><br><span class="line">        private final CyclicBarrier c = new CyclicBarrier(4, this);  //这里屏障解除后执行本线程。</span><br><span class="line">        private final ExecutorService executor = Executors.newFixedThreadPool(4);</span><br><span class="line">        private final ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        private void count() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                executor.execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        sheetBankWaterCount.put(Thread.currentThread().getName(), 3);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            c.await();</span><br><span class="line">                            System.out.println(sdf.format(new Date()) + &quot; &quot; + Thread.currentThread().getName());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class="line">                result += sheet.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sdf.format(new Date()) + &quot; &quot; + &quot;result:&quot; + result);</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3.CyclicBarrier和CountDownLatch的区别"></a>3.CyclicBarrier和CountDownLatch的区别</h3><p>1、使用的场景不一样，CyclicBarrier阻塞每个线程（每个线程都等待最后一个线程到达屏障），像分布式问题，屏障清除了，每个线程可以继续做自己的事情；CountDownLatch阻塞等待线程（等待线程等待其他线程完成）向集中式的，最后由等待线程统一处理。</p>
<p>2、CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重弄下执行一次。</p>
<p>3、CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</p>
<p>cyclicBarrier线程中断示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 18:37</span><br><span class="line"> **/</span><br><span class="line">public class CyclicInterruptTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier c = new CyclicBarrier(3);</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                //e.printStackTrace();</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(2);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        try &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">2</span><br><span class="line">true</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明：尽管屏障数是3，但是其中一个中断了的话，其他的await也会跑出异常。被中断的抛出InterruptedException，其他的抛出BrokenBarrierException。</p>
<h3 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4.控制并发线程数的Semaphore"></a>4.控制并发线程数的Semaphore</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>应用场景：Semaphore可以做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库连接数只有10个，这是我们必须控制只有10个线程同时获取数据库连接保持数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final int THREAD_COUNT = 30;</span><br><span class="line">private static final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">private static final Semaphore s = new Semaphore(10);</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(&quot;save data&quot;);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有30个线程在执行，但是只允许10个线程并发执行。<br>为什么不开始创建10个线程的线程池呢？因为前面需要30个，只是在代码某部分限制10个。<br>构造方法Semaphore(int permits)接收一个整型的数组，表示可用的许可证数量。<br>Semaphore的acquire()方法获取一个许可证，获取不到就阻塞，使用完之后调用release()方法归还许可证。还可以使用tryAcquire()方法尝试获取许可证。</p>
<p>其他方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">intavailablePermits():返回信号量中当前可用的许可证数目。</span><br><span class="line">ingetQueueLength():返回正在等待获取许可证的线程数。</span><br><span class="line">booleanhasQueueThreads():是否有线程正在等待获取许可证</span><br><span class="line">void reducePermits(int reduction):减少reduction个许可证，是个protected方法。</span><br><span class="line">Collection getQueuedThreads():返回所有等待获取许可证的线程集合，是个protected方法。</span><br></pre></td></tr></table></figure>

<h3 id="5-线程间交互数据的Exchanger"><a href="#5-线程间交互数据的Exchanger" class="headerlink" title="5.线程间交互数据的Exchanger"></a>5.线程间交互数据的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exhange()方法交换数据，如果第一个线程先执行exhange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都达到同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p>应用场景：可用于遗传算法，将两个人作为交配对象，交换两个人的数据。还可以用于校对工作，比如我们需要将纸质银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入之后比对。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-19 19:23</span><br><span class="line"> **/</span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;&gt;();</span><br><span class="line">    private static final ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String a = &quot;银行流水A&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(a);</span><br><span class="line">                System.out.println(&quot;B 录入的是:&quot; + exchange + &quot; A录入的是：&quot; + a);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            String b = &quot;银行流水B&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                String exchange = exgr.exchange(b);</span><br><span class="line">                System.out.println(&quot;A 录入的是:&quot; + exchange + &quot; B录入的是：&quot; + b);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程一个没有执行exchange()方法，则会一直等待，如果单向特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeout, TimeUnit unit)</code>设置最大等待时间。</p>
<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tianzhonghaoqing/article/details/123976376">https://blog.csdn.net/tianzhonghaoqing/article/details/123976376</a></p>
<h2 id="第九章-java中的线程池"><a href="#第九章-java中的线程池" class="headerlink" title="第九章 java中的线程池"></a>第九章 java中的线程池</h2><p>合理地使用线程池能够带来3个好处：<br>降低资源消耗(通过重复利用已创建的线程降低线程创建和销毁造成的消耗)<br>提高响应速度(当任务到达时，任务可以不需要等到线程创建就能立即执行)<br>提高线程的可管理性(线程池可以进行统一分配、调优和监控线程)</p>
<h3 id="1-线程池的实现原理"><a href="#1-线程池的实现原理" class="headerlink" title="1.线程池的实现原理"></a>1.线程池的实现原理</h3><p>ThreadPoolExecutor执行execute方法分下面4种情况：</p>
<p>1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务，不管已有线程是不是空闲(需要获取全局锁)</p>
<p>2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</p>
<p>3、如果BlockingQueue队列已满，则创建新的线程(非核心线程)来处理任务(需要获取全局锁）</p>
<p>4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法</p>
<p>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p>
<h3 id="2-线程池的创建"><a href="#2-线程池的创建" class="headerlink" title="2.线程池的创建"></a>2.线程池的创建</h3><p><code>new ThreadPoolExecutor(xxx)</code>，其中参数具体含义如下：</p>
<p>1、corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务(即使其他空闲的基本线程能够执行新任务也会创建，满了不再创建。）如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
<p>2、runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue:基于数组结构的有界阻塞队列，按FIFO原则对元素排序。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue:基于链表结构的有界阻塞队列，FIFO原则，吞吐量高于ArrayBlockingQueue，</span><br><span class="line">静态工厂方法Executors.newFixedThreadPool()使用该队列。</span><br><span class="line"></span><br><span class="line">SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直阻塞。吞吐量高于LinkedBlockingQueue。</span><br><span class="line">静态工厂方法Executors.newCachedThreadPool使用该队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue:一个具有优先级的无限阻塞队列。</span><br></pre></td></tr></table></figure>

<p>3、maximumPoolSize(线程池最大数量)：线程池允许创建的最大线程数，如果队列满了且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用的是无界队列，改参数没效果。</p>
<p>4、ThreadFactory：设置创建线程的工厂，可以给线程命名。</p>
<p>5、RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，则采取一种策略处理提交的新任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy(默认)：直接抛出异常。</span><br><span class="line">CallerRunsPolicy：用调用者所在线程来运行任务。</span><br><span class="line">DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span><br><span class="line">DiscardPolicy：不处理，丢弃掉且不抛出异常</span><br></pre></td></tr></table></figure>

<p>6、keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后保持存活的时间(超过该时长，非核心线程就会被回收)</p>
<p>7、TimeUnit(线程活动保持时间的单位)</p>
<h3 id="3-向线程池提交任务"><a href="#3-向线程池提交任务" class="headerlink" title="3.向线程池提交任务"></a>3.向线程池提交任务</h3><ul>
<li>execute()：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>submit()：用于提交需要返回值的任务(返回future类型的对象，该对象可以判断任务是否执行成功且可以通过对象的get()来获取返回值).<br>get()方法会阻塞当前线程直到任务完成。<code>get(long timeout, TimeUnit unit)</code>可阻塞一段时间后立即返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line">    try &#123;</span><br><span class="line">    	Object s = future.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    	// 处理中断异常</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">    	// 处理无法执行任务异常</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	// 关闭线程池</span><br><span class="line">    	executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-关闭线程池"><a href="#4-关闭线程池" class="headerlink" title="4.关闭线程池"></a>4.关闭线程池</h3><p>线程池的shutdown或shutdownNow方法关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。</p>
<p>无法响应中断的线程可能永远无法终止。</p>
<p>shutdown =&gt; 平缓关闭，等待所有已添加到线程池中的任务执行完再关闭<br>shutdownNow =&gt; 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shutdown和shutdownNow：</span><br><span class="line">1、shutdown()</span><br><span class="line">阻止新来的任务提交，对已经提交了的任务不会产生任何影响。</span><br><span class="line">当已经提交的任务执行完后，它会将那些闲置的线程（idleWorks）进行中断，这个过程是异步的。</span><br><span class="line">将线程池的状态改成SHUTDOWN，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的。</span><br><span class="line"></span><br><span class="line">2、shutdownNow()</span><br><span class="line">阻止新来的任务提交，同时会中断当前正在运行的线程，即workers中的线程。</span><br><span class="line">它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。</span><br><span class="line">通过将线程池的状态改成STOP，当再将执行execute提交任务时，如果测试到状态不为RUNNING，则抛出rejectedExecution，从而达到阻止新任务提交的目的.</span><br><span class="line">一个特例：</span><br><span class="line">一个线程正在sleep状态中，此时执行shutdownNow()，</span><br><span class="line">它向该线程发起interrupt()请求，而sleep()方法遇到有interrupt()请求时，会抛出InterruptedException，并清除中断标志</span><br><span class="line">如果catch了，并没有在catch中再interrupt()，会继续往下执行。</span><br><span class="line">如果向外抛出异常，会中断</span><br></pre></td></tr></table></figure>

<h3 id="5-合理配置线程池"><a href="#5-合理配置线程池" class="headerlink" title="5.合理配置线程池"></a>5.合理配置线程池</h3><p>1、任务的性质：</p>
<p>CPU密集型任务：配置尽可能小的线程(Ncpu+1)，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数能增加上下文切换的次数，带来额外的开销。</p>
<p>IO密集型任务：配置尽可能多的线程(2*Ncpu)，因为CPU使用率并不高，可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p>
<p>混合型任务：可将任务分成IO密集型和CPU密集型任务(两个任务执行时间相差不大时)，然后分别用不同的线程池去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU密集型和IO密集型：</span><br><span class="line">CPU密集型：需非常多CPU计算资源，让每个CPU核心都参与计算，CPU性能充分利用，应避免过多线程上下文切换。</span><br><span class="line">IO密集型：网络、磁盘 IO （与DB、缓存），一旦IO，线程就等待，结束才执行。多设线程数，等待时去做其它事，提高效率。</span><br></pre></td></tr></table></figure>

<p>2、任务的优先级：优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理</p>
<p>3、任务的执行时间：可以交给不同规模的线程池来处理，或者优先级队列。执行时间短的先执行</p>
<p>4、任务的依赖性：比如依赖数据库连接池的任务，线程提交SQL后需要等待数据库返回结果，等待的时间越长，CPU空闲时间就越长(相当于IO密集型任务，应设置较大线程数)</p>
<p>5、建议使用有界队列，可以增加系统稳定性和预警能力，再抛弃任务的时候加监控，无界队列会撑满内存，导致整个系统不能用。</p>
<h3 id="6-线程池的监控"><a href="#6-线程池的监控" class="headerlink" title="6.线程池的监控"></a>6.线程池的监控</h3><p>如果在系统中大量使用线程池，则需要对线程池进行监控，在出现问题时，可根据线程池的使用状况快速定位问题。可使用以下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">taskCount：线程池需要执行的任务数量</span><br><span class="line">completedTaskCount：线程池在运行过程中已完成的任务数量</span><br><span class="line">largestPoolSize：线程池里曾经创建过的最大线程数量</span><br><span class="line">getPoolSize：线程池的线程数量(线线程池不销毁的话，线程池里的线程不会自动销毁)</span><br><span class="line">getActiveCount：获取活动的线程数</span><br></pre></td></tr></table></figure>

<p>可以继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法进行监控。在执行前、执行后、线程池关闭前监控，比如：任务平均执行时间，最大执行时间，最小执行时间。</p>
<h3 id="7-Executors的线程池："><a href="#7-Executors的线程池：" class="headerlink" title="7.Executors的线程池："></a>7.Executors的线程池：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">定长线程池(FixedThreadPool)：用于控制线程最大并发数</span><br><span class="line">只有核心线程</span><br><span class="line">线程数量固定</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br><span class="line"></span><br><span class="line">定时线程池(ScheduledThreadPool)：用于执行定时或周期性的任务</span><br><span class="line">核心线程数量固定</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置10ms后回收</span><br><span class="line">任务队列为延时阻塞队列</span><br><span class="line"></span><br><span class="line">可缓存线程池(CachedThreadPool)：执行大量且耗时少的任务</span><br><span class="line">无核心线程</span><br><span class="line">非核心线程数量无限(线程过多导致内存溢出)</span><br><span class="line">执行完闲置60s后回收</span><br><span class="line">任务队列为不存储元素的阻塞队列</span><br><span class="line"></span><br><span class="line">单线程化线程池(SingleThreadExecutor)：应用于不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作</span><br><span class="line">只有1个核心线程</span><br><span class="line">无非核心线程</span><br><span class="line">执行完立即回收</span><br><span class="line">任务队列为链表结构的有界队列(消耗内存)</span><br></pre></td></tr></table></figure>

<p>原书笔记：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41398418/article/details/126279652">https://blog.csdn.net/qq_41398418/article/details/126279652</a></p>
<h2 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h2><p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时， 为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h3 id="1-Executor框架"><a href="#1-Executor框架" class="headerlink" title="1.Executor框架"></a>1.Executor框架</h3><h4 id="✅Executor框架的两级调度模型"><a href="#✅Executor框架的两级调度模型" class="headerlink" title="✅Executor框架的两级调度模型"></a>✅Executor框架的两级调度模型</h4><p>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p><strong>两级调度模型</strong>：<br>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。<br><em>应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</em></p>
<h4 id="✅Executor框架的结构"><a href="#✅Executor框架的结构" class="headerlink" title="✅Executor框架的结构"></a>✅Executor框架的结构</h4><p>Executor框架主要由3大部分组成：</p>
<p>1、任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。</p>
<p>2、任务的执行。包括任务执行机制的核心接口Executor，以及实现自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和<br>ScheduledThreadPoolExecutor）。</p>
<p>3、异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</p>
<hr>
<p>Executor框架的类与接口：</p>
<p>1、Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</p>
<p>2、ExecutorService接口，实现自Executor接口。</p>
<p>3、ThreadPoolExecutor类是线程池的核心实现类，用来执行被提交的任务。</p>
<p>4、ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</p>
<p>5、Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<p>6、Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。</p>
<hr>
<p>使用步骤：</p>
<p>1.创建任务对象：主线程创建实现Runnable或者Callable接口的任务对象。<code>工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））</code></p>
<p>2.任务提交给线程池执行：把Runnable对象直接交给ExecutorService执行<code>（ExecutorService.execute（Runnable command））</code>；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行<code>（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callabletask））</code><br>如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</p>
<p>3.submit的获取结果：主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</p>
<h4 id="✅-Executor框架的成员"><a href="#✅-Executor框架的成员" class="headerlink" title="✅ Executor框架的成员"></a>✅ Executor框架的成员</h4><p>Executor框架的主要成员：ThreadPoolExecutor、<br>ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</p>
<hr>
<p>（1） ThreadPoolExecutor</p>
<p>ThreadPoolExecutor可以使用工厂类Executors来创建。Executors可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">固定线程数的FixedThreadPool的 API。</span><br><span class="line">适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单个线程的SingleThreadExecutor的API.</span><br><span class="line">适用于需要保证顺序地执行各个任务；只要一个线程的应用场景。</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,</span><br><span class="line">        0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">        threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CachedThreadPool是大小无界的线程池，</span><br><span class="line">适用于执行很多的短期异步任务的小程序，或者 是负载较轻的服务器。</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">        60L, TimeUnit.SECONDS,</span><br><span class="line">        new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（2） ScheduledThreadPoolExecutor<br>ScheduledThreadPoolExecutor可以使用工厂类Executors来创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor。</span><br><span class="line">包含若干个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">适用于需要多个后台线程执行周期任务</span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SingleThreadScheduledExecutor。</span><br><span class="line">只包含一个线程的ScheduledThreadPoolExecutor。</span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>（3） Future接口</p>
<p>Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当我们把Runnable 接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或<br>ScheduledThreadPoolExecutor时，会向我们返回一个FutureTask对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api:</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>到目前最新的JDK 8为止，Java通过上述API返回的是一个FutureTask对象。但从API可以看到，Java仅仅保证返回的是一个实现了Future接口的对象。</p>
<hr>
<p>（4） Runnable接口和Callable接口</p>
<p>Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。它们之间的区别是Runnable不会返回结果，而Callable可以返回结果。</p>
<p>工厂类Executors可以把一个Runnable包装成一个Callable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Callable&lt;Object&gt; callable(Runnable task) //结果是null</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)  //结果是result</span><br></pre></td></tr></table></figure>

<h3 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2.ThreadPoolExecutor详解"></a>2.ThreadPoolExecutor详解</h3><p>介绍一下Executors创建的三种用的是什么参数</p>
<p>1.FixThreadPool内部使用无界队列LinkedBlockingQueue作为任务队列，队列的容量为Integer.MAX_VALUE，由于是无界队列，所以不会拒绝任务，maximumPool没有意义，可能会造成任务无限堆积，从而导致系统资源耗尽的情况。</p>
<p>2.SingleThreadExecutor：与FixThreadPool类似，只是SingleThreadExecutor的线程数固定为1</p>
<p>3.CachedThreadPool的corePool为空，maximumPoolSize为Integer.MAX_VALUE，keepAliveTime为60L，这意味着线程空闲超过60秒则会进行回收。CachedThreadPool内部使用不存储元素的阻塞队列SynchronousQueue作为任务队列，每个插入操作必须等待另一个线程的移除操作。这意味着如果任务的提交速度高于线程的处理速度，那么CachedThreadPool则会不断的创建新的线程，在极端的情况下，会耗尽CPU和内存资源。</p>
<h3 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3.ScheduledThreadPoolExecutor"></a>3.ScheduledThreadPoolExecutor</h3><p>ScheduledThreadPoolExecutor主要用来执行需要延迟或者定时执行的任务，功能与Timer类似，不同的是Timer只能单线程允许，ScheduledThreadPoolExecutor可以指定多个线程。</p>
<p>ScheduledThreadPoolExecutor执行<code>scheduleAtFixedRate()方法或者scheduleWithFixedDelay()</code>方法时，会把要执行的任务放在一个无界队列DelayQueue中，<code>ScheduledThreadPoolExecutor会把Runable对象封装成ScheduledFutureTask（实现了RunnableScheduledFuture接口）</code>。线程池中的线程从DelayQueue中获取ScheduledFutureTask。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private class ScheduledFutureTask&lt;V&gt;</span><br><span class="line">    extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>ScheduledFutureTask内部包含三个成员变量。<br>time：任务要被执行的具体时间<br>sequenceNumber：任务排序编号，如果两个任务的time相同，那么则sequenceNumber较小的会先执行<br>period：任务执行的周期</p>
<hr>
<p>ScheduledThreadPoolExecutor执行任务的流程大体是：<br>1.从DelayQueue中获取ScheduledFutureTask（time大于当前时间的任务）<br>2.执行ScheduledFutureTask<br>3.修改ScheduledFutureTask的time为下次要执行的时间<br>4.将ScheduledFutureTask再次放入DelayQueue中</p>
<h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3.FutureTask"></a>3.FutureTask</h3><p>Future接口和FutureTask实现类代表线程异步执行的结果，可以通过FutureTask.get()方法获取异步返回的结果。</p>
<p>FutureTask类还实现了Runnable接口，因此可以交给Executor执行，也可以直接在当前线程中执行：<code>FutureTask.run()</code>。</p>
<hr>
<p>根据FutureTask.run被执行的时机，FutureTask可处于下面3种状态：<br>未启动：方法还没有被执行之前，FutureTask处于未启动状态<br>已启动：方法被执行的过程中，FutureTask处于已启动状态<br>已完成：方法执行完后正常结束或、取消(即执行FutureTask.cancel)或抛异常，FutureTask处于已完成状态</p>
<hr>
<p>FutureTask状态决定get和cancel方法执行结果：</p>
<p>1.gei方法：如果未启动或已启动状态，get方法将导致调用线程阻塞，如果已完成状态，get方法将导致调用线程立即返回结果或抛出异常。</p>
<p>2.cancel方法：当处于未启动状态，该任务将不会执行，当处于已启动状态，<code>Future.cancel(true)</code>将中断此任务线程来停止任务，<code>Future.cancel(false)</code>将不会对正在执行此任务的线程产生影响，当处于已完成状态时，cancel方法将返回false。</p>
<p>当一个线程需要等待另一个线程把某个任务执行完后并获取结果它才能继续执行，可使用FutureTask。</p>
<hr>
<p>FutureTask的实现：</p>
<p>FutureTask的实现基于AbstractQueuedSynchronizer(AQS是同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列)。java.util.concurrent里的很多阻塞类：ReetrantLock、Semaphore、ReetrantReadWriteLock、CountDownLatch都是基于AQS实现。</p>
<hr>
<p>AQS遗忘的知识：<br>AQS实现的同步器都会包含两种类型的操作：<br>1.acquuire操作，获取同步状态，用来阻塞调用线程。FutureTask中为get方法。<br>2.release操作，释放同步状态，用来解除阻塞线程的阻塞，FutureTask中为run方法和cancel方法。</p>
<hr>
<p>基于复合优先于基础原则，FutureTask的内部私有类Sync继承自AQS。实现了AQS的<code>tryAcquireShared(int) 和 tryReleaseShared(int)</code>.</p>
<p>🤔因为FutureTask涉及到线程的阻塞唤醒也就是同步，所以用AQS。</p>
<h2 id="第十一章-java并发编程实践"><a href="#第十一章-java并发编程实践" class="headerlink" title="第十一章 java并发编程实践"></a>第十一章 java并发编程实践</h2><h3 id="1-生产者和消费者模式"><a href="#1-生产者和消费者模式" class="headerlink" title="1.生产者和消费者模式"></a>1.生产者和消费者模式</h3><p>什么是生产者和消费者模式？</p>
<p>生产者和消费者模式是<strong>通过一个容器来解决生产者和消费者的强耦合问题</strong>。生产者和消费者彼此之间不直接通信，而是<strong>通过阻塞队列来进行通信</strong>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<strong>阻塞队列就相当于一个缓冲区</strong>，平衡了生产者和消费者的处理能力。</p>
<p>这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会<strong>找一个第三者出来进行解耦</strong>，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些设计模式的过程中，先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式。</p>
<p>获取机器有多少个CPU，来决定线程池大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int corePoolSize = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>


<h3 id="2-多生产者和多消费者场景"><a href="#2-多生产者和多消费者场景" class="headerlink" title="2.多生产者和多消费者场景"></a>2.多生产者和多消费者场景</h3><p>在多核时代，多线程并发处理速度比单线程处理速度更快，所以可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理.</p>
<h3 id="3-线程池就是生产者消费者模式"><a href="#3-线程池就是生产者消费者模式" class="headerlink" title="3.线程池就是生产者消费者模式"></a>3.线程池就是生产者消费者模式</h3><p>Java 中的线程池类其实就是一种生产者和消费者模式的实现方式，但是更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能够处理直接就处理掉了（不用中转队列），这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。</p>
<p>生产者消费者例子：</p>
<p>调用一个远程接口查询数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请查询任务放数据库中，然后该接口立刻返回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口取数据。</p>
<p>再比如：</p>
<p>1.有一些任务，这些任务放在db里，表示完成进程，同时将表的id放入redis队列中。</p>
<p>2.任务处理端，从redis队列中取出id，再用id从数据库读出一个任务进行处理，并更新db中任务完成的进程。</p>
<p>3.因为redis缓存稳定性考虑，定时任务搂db中长时间未完成的任务，将id放入redis队列中。</p>
<h3 id="4-线上问题定位"><a href="#4-线上问题定位" class="headerlink" title="4.线上问题定位"></a>4.线上问题定位</h3><p>看日志、系统状态和 dump 线程。</p>
<p>在 Java 进程这一行里可以看到 CPU 利用率是 300%，不用担心，这个是当前机器所有核加在一起的 CPU 利用率。</p>
<p>jstack命令可以把线程 dump 下来，看看究竟是哪个线程、执行什么代码造成的 CPU 利用率高。</p>
<p>dump 出来的线程 ID（nid）是十六进制的，而我们用 TOP 命令看到的线程 ID 是十进制的，所以要用 printf 命令转换一下进制。然后用十六进制的 ID 去 dump 里找到对应的线程。</p>
<p>十进制转十六进制：<br><code>printf &quot;%x\n&quot; 31558</code></p>
<p><code>netstat -nat | grep 8080 -c</code> 多少台机器连接到本机8080端口</p>
<p><code>ps -eLf|grep java -c</code> 看java线程数</p>
<h3 id="5-异步任务池"><a href="#5-异步任务池" class="headerlink" title="5.异步任务池"></a>5.异步任务池</h3><p>如果一个任务仍进线程池之后，运行线程池的程序重启了，那么线程池里的任务就会丢失。另外，线程池只能处理本机的任务，在集群环境下不能有效地调度所有机器的任务。所以，结合线程池开发一个异步任务处理池。</p>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p>
<p>每个任务有几种状态，分别是创建（NEW）、执行中（EXECUTING）、RETRY（重试）、挂起（SUSPEND）、中止（TEMINER）和执行完成（FINISH）。</p>
<p>创建：提交给任务池之后的状态。<br>执行中：任务池从数据库中拿到任务执行时的状态。<br>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间。<br>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行。<br>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。<br>执行完成：任务执行结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/myblog/%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/idea%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Idea日常使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-22 21:43:06" itemprop="dateCreated datePublished" datetime="2022-07-22T21:43:06+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 17:33:36" itemprop="dateModified" datetime="2022-11-20T17:33:36+08:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="替换文字"><a href="#替换文字" class="headerlink" title="替换文字"></a>替换文字</h2><p>command + R ：当前文件替换<br>command + shift + R ：全局文件替换</p>
<h2 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h2><p>换行符：LF<br>编码：UTF-8<br>提交代码之后中文乱码：设置里 File Encodings 里的都选UTF-8，Transparent native-to-ascii conversion（透明转换为ascii）不勾选。</p>
<h2 id="变量高亮"><a href="#变量高亮" class="headerlink" title="变量高亮"></a>变量高亮</h2><p>变量写操作颜色设置：Settings-&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Code -&gt; identifier under caret(write) -&gt; 设置底色</p>
<p>变量读操作颜色设置：Settings-&gt; Editor -&gt; Color Scheme -&gt; General -&gt; Code -&gt; identifier under caret -&gt; 设置底色</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/03/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/03/myblog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/python/" class="post-title-link" itemprop="url">python语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-03 16:22:40" itemprop="dateCreated datePublished" datetime="2022-07-03T16:22:40+08:00">2022-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 15:56:58" itemprop="dateModified" datetime="2023-08-20T15:56:58+08:00">2023-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>✅计算机组成：<br>硬件：中央处理器CPU（处理指令、运算数据的）、存储器（内存（存临时数据读写速度快）、外存（硬盘、U盘））、输入设备、输出设备<br>软件：应用软件、系统软件（操作系统）</p>
<p>✅编译型语言和解释型语言：</p>
<ul>
<li><p>编译型语言：在执行之前要先经过编译过程，编译成为一个可执行的机器语言的文件，比如exe。因为翻译只做一遍，以后都不需要翻译，所以执行效率高。<br>  代表：C、C++<br>  优缺点：执行速度快、跨平台差（操作一步，与操作系统联系紧密）、不便调试。</p>
</li>
<li><p>解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。执行时才翻译执行。程序每执行一次就要翻译一遍。解释一句，执行一句，直至结束。<br>  代表：Java、C#、Python、JavaScript<br>  优缺点：速度较慢、跨平台好（操作两步，跨平台有优势，可在windows上运行，也可在linux上运行）、易于调试</p>
</li>
</ul>
<p>怎么选：<br>编译型语言由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言。</p>
<p>而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、MATLAB等等。</p>
<p>一个比较好的例子：编译型语言就像炒菜吃饭，只有将全部的菜炒好了才能吃饭，解释型语言就像吃火锅，边放菜边吃，不需要将菜全部放在火锅里面。</p>
<p>✅java是解释型语言，javac编译成.class字节码文件是？<br>java的编译器（javac.exe）先将java文件编译为class文件，也就是字节码；然后将字节码交由jvm(java虚拟机)解释执行；<br>所以很多地方都说“java是一种半编译、半解释执行”的语言；</p>
<p>java是解释型的语言，因为虽然java也需要编译，编译成.class文件，<br>但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释（逐行解释为特定平台机器码），才能在各个平台执行，这同时也是java跨平台的原因。<br>所以可以说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。</p>
<p>✅编译器和解释器之间的主要区别<br>1、编译器将一个程序作为一个整体进行翻译，而解释器则一条一条地翻译一个程序<br>2、在编译器的情况下生成中间代码或目标代码。而解释器不创建中间代码<br>3、编译器比解释器要快得多，因为编译器一次完成整个程序，而解释器则是依次编译每一行代码<br>4、由于要生成目标代码，编译器比解释器需要更多的内存<br>5、编译器同时显示所有错误，很难检测错误，而解释器则逐个显示每条语句的错误，更容易检测错误<br>6、在编译器中，当程序中出现错误时，它会停止翻译，并在删除错误后重新翻译整个程序。相反，当解释器中发生错误时，它会阻止其翻译，在删除错误后，翻译将继续<br>7、在编译器中，这个过程需要两个步骤，首先将源代码翻译成目标程序，然后执行。而在解释器中，这是一个一次性的过程，源代码在编译的同时执行<br>8、编译器用于编程语言，如C、c++、c#、Scala等。解释器用于PHP、Ruby、Python等语言。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CodeHouse/article/details/121846119">https://blog.csdn.net/CodeHouse/article/details/121846119</a></p>
<p>✅脚本语言（动态语言）和静态语言</p>
<p>脚本语言:又被称为扩建的语言，或者动态语言，用来控制软件应用程序，脚本通常以文本保存，只 在被调用时进行解释或编译。脚本语言有:PHP、Python、JavaScript、Lua、Scala、VBScript， ActionScript，MAXScript，ASP，JSP，SQL，Perl，Shell，Ruby，JavaFX，AutoIt等 脚本语言是一种解释性的语言，它不象c/c++等可以编译成二进制代码，以可执行文件的形式存在，脚本 语言不需要编译，可以直接用，由解释器来负责解释。在运行时才确定数据类型的语言。</p>
<p>静态语言:要求在使用变量之前必须声明数据类型。 例如:C、C++、Golang、Java、C#等。 </p>
<p>so：脚本语言一定是解释型语言，解释型语言不一定是脚本语言。</p>
<p>✅Python解释器：<br>CPU不能直接处理 Python 语言，只能直接处理机器指令语言，那是一种由0和1数字组成的语言。.py结尾的文件需要解释器去运行执行。解释器就是能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序。它的执行方式是一边翻译一边执行，因此其执行效率一般偏低，但是解释器的实现较为简单，而且编写源程序的高级语言可以使用更加灵活和富于表现力的语法。</p>
<p>常见的Python解释器：</p>
<p>　　1、CPython：这个解释器是用C语言开发的，所以叫CPython。在命令行下运行Python就是启动CPython解释器。CPython是使用最广的Python解释器。</p>
<p>2、IPython：IPython是基于CPython之上的一个交互解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</p>
<p>　　3、PyPy：PyPy是另一个解释器，它的目标是执行速度。采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。</p>
<p>　　4.Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h3 id="mac安装python环境"><a href="#mac安装python环境" class="headerlink" title="mac安装python环境"></a>mac安装python环境</h3><p>终端输入python，跳出的是2.7版本<br>终端输入python3，跳出的是3.9版本<br>就没安装了，要找解析器去官网下载安装</p>
<p>终端执行.py文件：<br>1、写文件，前面要加个注释<br><code>#!/usr/bin/env python3</code><br><code>print(&quot;hello!&quot;)</code><br>2、给文件以执行权限<br><code>chmod a+x hi.py</code><br>3、运行文件<br><code>./hi.py</code></p>
<p>✅安装pycharm<br>官网下载：<a target="_blank" rel="noopener" href="https://www.jetbrains.com.cn/en-us/pycharm/download">https://www.jetbrains.com.cn/en-us/pycharm/download</a><br>下载的社区版本。破解太费劲。<br>新建工程，选择解析器，不选虚拟的那个，选previously configured nterpret.<br>警告：PEP 8: W292 no newline at end of file，因为没有换行，换个行就好了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/25/myblog/JAVA/ssm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/myblog/JAVA/ssm/" class="post-title-link" itemprop="url">ssm是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-25 16:32:52 / Modified: 17:38:44" itemprop="dateCreated datePublished" datetime="2022-06-25T16:32:52+08:00">2022-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SSM框架：Spring + SpringMVC + MyBatis</p>
<p>Spring和SpringMVC是当前企业开发必用框架之一，MyBatis则是与数据库交互的持久层框架之一，由于易用性和轻便性，则被大多互联网公司所选用。SSM基础框架的掌握是当前企业开发最基本的要求，也是其他技术学习和进阶的必要基础。</p>
<p>b站视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42">https://www.bilibili.com/video/BV1WZ4y1P7Bp?p=42</a></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h3><p>MVC模式是什么？</p>
<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p>SpringMVC概述？</p>
<p>SpringMVC是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。</p>
<p>SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Structs2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。web文件夹内servelet？</p>
<h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><p>持久层框架，方便数据库操作的。</p>
<p>原始比较繁琐的jdbc操作：注册驱动–获得连接–获得statement–执行查询–遍历结果集（封装实体，传递）–释放资源。</p>
<p>缺点：代码重复（比如获得连接资源），资源频繁连接关闭，消耗资源，sql语句比较死，得解耦合，用配置文件。</p>
<p>jdbc缺点：（1）数据库创建、释放资源造成系统资源浪费从而影响系统性能。（2）sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码，耦合性高。（3）查询操作时，需要手动将结果集中的数据手动封装到实体中，插入操作时，需要手动将实体的数据设置到sql语句的占位符位置。</p>
<p>应对上述问题给出的解决方案：（1）使用数据库连接池初始化连接资源。（2）将sql语句抽到xml配置文件中。（3）使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射。</p>
<p>MyBatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，</p>
<p>MyBatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>MyBatis框架执行sql并将结果集映射为java对象并返回，采用ORM（对象关系映射）思想解决了实体和数据库映射的问题，对jdbc进行封装，屏蔽jdbc api底层访问细节，不与jdbc打交道就可以完成对数据库的持久化操作。</p>
<h3 id="mvc和servlet的关系"><a href="#mvc和servlet的关系" class="headerlink" title="mvc和servlet的关系"></a>mvc和servlet的关系</h3><p>1、Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。</p>
<p>2、Springmvc的核心是一个DispatcherServlet，并且DispatcherServlet继承自 FrameworkServlet继承自HttpServletBean 继承自HttpServlet（也就是你说的servelt） 本质上是一样的东西。其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情，如校验，拦截（AOP思想），后期渲染等等，好让我们专注于业务的开发。</p>
<p>总结</p>
<p>1、servlet就是一个Java接口，是JavaEE规范的一种<br>2、Servlet容器也叫做Servlet引擎：全称server applet，意为服务程序。主要作用是给上级容器(Tomcat)提供doGet()和doPost()等方法。其生命周期实例化、初始化、调用、销毁受控于 Tomcat容器。<br>3、而Tcomcat、webLogic等web容器包含servlet容器。<br>4、Tomcat容器属于web容器的一种，web容器还包括weblogic容器、JBoss容器等。<br>5、web容器：可以部署多个WEB应用程序的环境。<br>6、Spring MVC （SpringBoot）其实就是基于tomcat等这些web容器对我们的CS请求能做更多的事情</p>
<p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/295173834">https://zhuanlan.zhihu.com/p/295173834</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/myblog/JAVA/war%E5%8C%85jar%E5%8C%85%E6%89%93%E5%8C%85tomcat%E9%83%A8%E7%BD%B2servlet%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">jar、war、tomcat、servlet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-04 14:47:55" itemprop="dateCreated datePublished" datetime="2022-06-04T14:47:55+08:00">2022-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-28 23:29:11" itemprop="dateModified" datetime="2022-11-28T23:29:11+08:00">2022-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="tomcat与servlet"><a href="#tomcat与servlet" class="headerlink" title="tomcat与servlet"></a>tomcat与servlet</h3><p>1.tomcat就是一个web应用服务器，相当于市存放java程序的容器。以便服务被访问。<br>2.servlet实际上是java类，java语言编写的服务器端程序，它用来处理http协议相关的所有内容，没有main方法，需要在servlet容器中进行管理，可以是tomact。如何使用：继承HttpServlet（tomcat里的jar包支持），它帮助我们完成通信的规则。<br>3.tomcat与servlet关系：tomcat是servlet/jsp容器，servlet时web应用开发的组件，tomcat负责处理客户请求，把请求传送给servlet，再将servlet的响应传送回给客户。<br>4.新建web工程时，如果不用maven，java enterprise - web application，再引入jdk、tomcat（tomcat的lib下有servlet包）。如果用maven，就选archetype-webapp。</p>
<h3 id="war包与jar包"><a href="#war包与jar包" class="headerlink" title="war包与jar包"></a>war包与jar包</h3><p>1.Jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。<br>2.jar包是java打的包，一般只是包括一些编译后class文件和一些部署文件，在声明了Main_class之后是可以用java命令运行的。<br>3.jar包通常是开发时要引用通用类，打成包便于存放管理。<br>————————————————<br>1.War文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对war文件进行封装，并把它作为小型服务程序（servlet）来访问。<br>2.war包可以理解为javaweb打的包，是一个web模块，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。<br>3.war包需要发布到一个容器里面，拿Tomcat来说,将war文件包放置它的\webapps\目录下，启动Tomcat,这个包可以自动进行解压，也就是你的web目录，相当于发布了。<br>4.WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（JavaBean）。另外还有META-INF目录，里面有MANIFEST.MF文件。存储了项目的元信息。其中文件manifest.mf仅此一份，描述了程序的基本信息、Main-Class的入口、jar依赖路径Class-Path。<br>————————————————</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Sunny5319/article/details/90933532">https://blog.csdn.net/Sunny5319/article/details/90933532</a></p>
<p>jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件</p>
<hr>
<p>什么时候用jar、war?<br>当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p>
<h3 id="jar包打包"><a href="#jar包打包" class="headerlink" title="jar包打包"></a>jar包打包</h3><p>安装好JDK之后,jar.exe就已经安装好了。在命令行中键入jar命令之后，会有详细的用法介绍。</p>
<h4 id="✅单个文件打包"><a href="#✅单个文件打包" class="headerlink" title="✅单个文件打包"></a>✅单个文件打包</h4><p>将一个单独的java文件打包：<br><code>jar cvf /Users/liuxuan/MyProject/java/test.jar /Users/liuxuan/MyProject/java/jartest/hello.java</code><br>使用<code>java -jar test.jar</code> 提示没有主清单属性。</p>
<p>所以增加清单配置文件：MANIFEST.MF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: hello</span><br><span class="line"></span><br><span class="line">//注意：1. 冒号后面加一个空格，2. 最后必须回车到新的空行</span><br></pre></td></tr></table></figure>
<p>再打包：<code>jar cvfm test.jar ./*</code><br>java -jar运行，找不到或无法加载主类 hello。</p>
<p>所以在打包前先编译：<code>javac hello.java</code>，生成class文件，然后再打包，运行，可以执行。</p>
<blockquote>
<p>META-INF文件夹相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务。这个文件夹和其中的 MANIFEST.MF文件，在用jar打包时自动生成。<br>执行jar文件的时候，这个jar里是需要具备 META-INF/MANIFEST.MF的，否则java -jar就找不到main class。</p>
</blockquote>
<p>多个文件也可以如此打包，首先应该javac编译，然后增加主清单配置文件，其中可以指示默认入口函数（其中有main方法）。如果打的包中有其他类，java -jar jar包 是运行默认类，运行其他类方法：<code>java -cp test.jar com.test.sum 3 9</code>。<br>main函数可以有输入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class sum&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        if(args.length &lt; 2)&#123;</span><br><span class="line">            System.out.println(&quot;Paras: num1 num2&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final int num1 = Integer.valueOf(args[0]);</span><br><span class="line">        System.out.println(&quot;Num1: &quot; + num1);</span><br><span class="line">        final int num2 = Integer.valueOf(args[1]);</span><br><span class="line">        System.out.println(&quot;Num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">        final int sum = num1 + num2;</span><br><span class="line">        System.out.println(num1 + &quot; + &quot; + num2 + &quot; = &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Xminyang/article/details/108059776">https://blog.csdn.net/Xminyang/article/details/108059776</a></p>
<h4 id="✅使用idea打包"><a href="#✅使用idea打包" class="headerlink" title="✅使用idea打包"></a>✅使用idea打包</h4><p>🤔不可以java -jar的打包：<br>1.点击intellij idea左上角的“File”菜单 -&gt; Project Structure<br>2.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; Empty<br>3. Name栏填入自定义的名字，Output ditectory选择jar包目标目录，Available Elements里双击需要添加到jar包的文件（添加java工程编译文件）<br>4. OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>5. 点击弹出框中待生成jar包下面的build即可</p>
<p>生成了jar包，直接java -jar执行，报<code>Error: Invalid or corrupt jarfile testjar.jar</code>.<br>需要用 -cp 指定类来执行，例如：<code>java -cp testjar.jar leecode.JianPanHang500</code></p>
<p>🤔可以直接java -jar的打包：<br>如果需要直接java -jar 执行的jar包：<br>1.点击”Artifacts” -&gt; 绿色的”+” -&gt; “JAR” -&gt; from modules…<br>2.选择主类，选择META-INF位置<br>3.OK之后，点击菜单中“Build” -&gt; “Build Artifacts”<br>4.点击弹出框中待生成jar包下面的build即可</p>
<p>注意：在选择主类时需要全路径，rebuild之后可以重新编译，<code>java -jar lee.jar</code>直接运行主类。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42239765/article/details/123236019">https://blog.csdn.net/qq_42239765/article/details/123236019</a></p>
<h4 id="✅使用maven打包"><a href="#✅使用maven打包" class="headerlink" title="✅使用maven打包"></a>✅使用maven打包</h4><p>🤔不包含依赖包，也不指定入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!-- 项目最终打包成的名字 --&gt;</span><br><span class="line">    &lt;finalName&gt;mylogmavenpackage&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔指定入口，将依赖的jar包输出到指定目录<br>指定了入口类，可以直接使用java -jar project.jar执行，但是第三方依赖存在一个指定的外部目录下，迁移时需将jar和依赖目录一起迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类 --&gt;</span><br><span class="line">            &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 在jar的MF文件中生成classpath属性 --&gt;</span><br><span class="line">            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- classpath前缀,即依赖jar包的路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;copy&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;install&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;!-- 指定依赖包的输出路径，需与上方的classpathPrefix保持一致 --&gt;</span><br><span class="line">            &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>🤔将项目依赖和项目打成一个jar包（胖包）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;!-- 指定项目编译时的java版本和编码方式 --&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">          &lt;manifest&gt;</span><br><span class="line">            &lt;mainClass&gt;com.netty.client.SignalClient&lt;/mainClass&gt; &lt;!-- 指定入口类路径 --&gt;</span><br><span class="line">          &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">          &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;!-- jar包后缀，生成的jar包形式为：project-1.0-SNAPSHOT-jar-with-dependencies.jar --&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">      &lt;!-- 添加此项后，可直接使用mvn package | mvn install --&gt;</span><br><span class="line">      &lt;!-- 不添加此项，需直接使用mvn package assembly:single --&gt;</span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">          &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h3><p>上面打jar包，其实都有对应的打war包的方法：</p>
<p>✅手动打war包<br><code>jar cvf test.war ./*</code></p>
<p>✅idea打war包<br>artifact中选择web application，explode对于war explode，archive对应war。</p>
<p>✅maven打war包<br>pom.xml中指示<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>maven有多种打包方式。</p>
<h3 id="war包和war-explode包"><a href="#war包和war-explode包" class="headerlink" title="war包和war explode包"></a>war包和war explode包</h3><p>1.war模式<br>这种可以称之为是发布模式，就是先将WEB工程打成war包，然后再将其上传到服务器进行发布 。</p>
<p>2.war exploded模式<br>是将WEB工程以当前文件夹的位置关系上传到服务器，即直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。<br>在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。<br>（热部署，对于Java应用程序来说，热部署就是在运行时更新Java类文件。）</p>
<p>问题：<br>idea进行部署，会将war包移到tomcat webapp文件夹下吗？</p>
<h3 id="java-web工程目录结构"><a href="#java-web工程目录结构" class="headerlink" title="java web工程目录结构"></a>java web工程目录结构</h3><p>1.src文件夹：这是用来存放Java源文件。下面有main文件夹和test文件夹。<br>1.1.src/main/java：存放相应的Java代码，并根据对应的Java项目继续分层<br>1.2.src/main/resource：存放一些配置文件，例如application.properties、logback.xml<br>1.3.src/main/webapp：Web应用的网页，用来放静态资源比如HTML、CSS、图片等文件。WEB-INF目录所在。WEB-INF中存放网站配置文件目录，web.xml等配置信息。</p>
<p>2..idea文件夹：是存储IntelliJ IDEA项目的配置信息，主要内容有IntelliJ IDEA项目本身的一些编译配置、文件编码信息、jar包的数据源和相关的插件配置信息。一般用git做版本控制的时候会把.idea文件夹排除，因为这个文件下保存的都是个人本地Idea编译器的配置。</p>
<p>3.target文件夹：是用来存放项目构建后的文件和目录、jar包、war包、编译的class文件，都是maven构建时生成的。存放的是单个module的编译结果。</p>
<p>4.out文件夹：存放该项目下所有module的编译结果。</p>
<p>5.pom.xml：项目对象模型</p>
<h3 id="新建个web工程并部署"><a href="#新建个web工程并部署" class="headerlink" title="新建个web工程并部署"></a>新建个web工程并部署</h3><p>1.new project，选maven，选maven-archetype-webapp<br>2.选择maven setting，新建工程<br>3.简单写个index.jsp，在webapp目录下（主页）<br>4.通过idea部署，生成war_explode包，热部署<br>5.lsof -i:8080 查看端口占用<br>6.target文件夹下有war包了，但是在tomcat-webapp文件夹下并没有该项目。<br>7.关闭idea，web也无法访问了，所以要想一直运行，得打jar包放在webapp目录下？<br>8.并且发现，没用servlet，不用导入servlet包。</p>
<h3 id="pom-xml结构"><a href="#pom-xml结构" class="headerlink" title="pom.xml结构"></a>pom.xml结构</h3><p>pom.xml 就是 maven 的配置文件，用以描述项目的各种信息。</p>
<p><code>&lt;project </code>  是 pom.xml 中描述符的根。</p>
<p><code>&lt;modelVersion&gt;</code> 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。</p>
<p>在 maven 中，根据 groupId、artifactId、version 组合来唯一识别一个 jar 包。<br><code>&lt;groupId&gt;</code> - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。<br><code>&lt;artifactId&gt;</code> - 单独项目的唯一标识符。例如junit。不要在 artifactId 中包含点号(.)。<br><code>&lt;version&gt;</code> - 一个项目的特定版本。</p>
<blockquote>
<p>maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 1.0-SNAPSHOT。各个部分的含义和处理逻辑如下说明：<br>SNAPSHOT - 这个版本一般用于开发过程中，表示不稳定的版本。<br>LATEST - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。<br>RELEASE ：指最后一个发布版。</p>
</blockquote>
<p><code>&lt;packaging&gt;</code> - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, maven-plugin, ejb, war, ear, rar, par。</p>
<p><code>&lt;name&gt;</code> - 项目名字</p>
<p><code>&lt;url&gt;</code> - 项目网站</p>
<p><code>&lt;description&gt;</code> - 项目描述</p>
<p><code>&lt;parent&gt;</code> - maven 支持继承功能。子 POM 可以使用 parent 指定父 POM ，然后继承其配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;my-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">relativePath ： 在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。</span><br></pre></td></tr></table></figure>

<p><code>&lt;modules&gt;</code> - 子模块列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;my-project-api&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;my-project-repository&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;properties&gt;</code> - 属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 ${propertie} 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;!-- Test --&gt;</span><br><span class="line">		&lt;junit.version&gt;1.16.1&lt;/junit.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencies&gt;</code> - 依赖配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">groupId, artifactId, version - 和基本配置中的 groupId、artifactId、version 意义相同。</span><br><span class="line"></span><br><span class="line">type - 对应 packaging 的类型，如果不使用 type 标签，maven 默认为 jar。</span><br><span class="line"></span><br><span class="line">scope - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：</span><br><span class="line">compile : 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</span><br><span class="line">provided : 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</span><br><span class="line">runtime : 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</span><br><span class="line">test : 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</span><br><span class="line">system : 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</span><br><span class="line"></span><br><span class="line">systemPath - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如\$ &#123;java.home&#125; / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</span><br><span class="line"></span><br><span class="line">optional - optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。</span><br><span class="line"></span><br><span class="line">exclusions - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</span><br></pre></td></tr></table></figure>

<p><code>&lt;dependencyManagement&gt;</code> - 是在<code>&lt;dependencies&gt;</code>外用的。表示依赖 jar 包的声明。即你在项目中的 dependencyManagement 下声明了依赖，maven 不会加载该依赖，dependencyManagement 声明可以被子 POM 继承。<br>它的一个使用案例是当有父子项目的时候，父项目中可以利用 <code>&lt;dependencyManagement&gt;</code> 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 dependencies 节点只配置 groupId 和 artifactId 就可以完成依赖的引用。<br><code>&lt;dependencyManagement&gt;</code> 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有plugins和pluginManagement。</p>
<p><code>&lt;build&gt;</code> - 构建配置。<br><code>&lt;plugins&gt;</code> - 配置插件，在<code>&lt;build&gt;</code>下。<br><code>pluginManagement</code> - 与 dependencyManagement 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 groupId 和 artifactId 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。<br>它的目的在于统一所有子 POM 的插件版本。<br><code>&lt;extensions&gt;</code> - 扩展配置，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。</p>
<p>pom.xml解析：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76874769">https://zhuanlan.zhihu.com/p/76874769</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/02/myblog/JAVA/mybatis%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">mybatis实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-02 21:45:44" itemprop="dateCreated datePublished" datetime="2022-06-02T21:45:44+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-01 12:10:50" itemprop="dateModified" datetime="2023-05-01T12:10:50+08:00">2023-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>1、mybatis <code>&lt;if&gt;</code> 标签不是必须在<code>&lt;where&gt;</code>标签下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select * from table</span><br><span class="line">&lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">        uid = #&#123;uid&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">where status = 0</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    and uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">&lt;if test=&quot;uis != null&quot;&gt;</span><br><span class="line">    where uid = #&#123;uid&#125;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>

<p>2、mybatis中，<code>select * from in &lt;foreach&gt; #&#123;list&#125;</code>，中的list不能是空，不能为null，会报错。</p>
<p>3、mybatis查出的结果是list，如果结果是一条都没有，那么返回的是空list，而不是null。</p>
<p>4、mybatis sum 如果没有记录，返回的是null，所以要注意mybatis返回结果都用包装类型来接。</p>
<p>5.mybatis查出的Date类型，是毫秒时间戳，可以用String接Date类型，只不过是：2023-01-01 11:11:11.1，所以得用.substring(0,19)，注意该方法string是null不行，位数不够也会报错。</p>
<p>6.mybatis来select，in一个list，如果传入的list是null或者空会报错。<br>null会报错：org.mybatis.spring.MybatisSystemException<br>空list会error sql<br>如果加了<code>&lt;where&gt;</code>标签和<code>&lt;if&gt;</code>标签，会导出所有的。<br><code>&lt;if test=&quot;list != null and list.size() &gt; 0&quot;&gt;</code></p>
<h3 id="mybatis-error"><a href="#mybatis-error" class="headerlink" title="mybatis error"></a>mybatis error</h3><h4 id="✅Mybatis-Exception-Translator-translateExceptionIfPossible"><a href="#✅Mybatis-Exception-Translator-translateExceptionIfPossible" class="headerlink" title="✅Mybatis Exception Translator.translateExceptionIfPossible"></a>✅Mybatis Exception Translator.translateExceptionIfPossible</h4><p>原因：插入时找不到参数，批量插入时传的list为空也会报此问题。</p>
<h3 id="resultMap和resultType"><a href="#resultMap和resultType" class="headerlink" title="resultMap和resultType"></a>resultMap和resultType</h3><p>ResultType和ResultMap都是执行查询语句时返回的结果集。<br>ResultType相对与ResultMap而言更简单一点。只有满足ORM（Object Relational Mapping，对象关系映射）时，即数据库表中的字段名和实体类中的属性完全一致时，才能使用，否则会出现数据不显示的情况。<br>ResultMap和ResultType的功能类似，但是ResultMap更强大一点，ResultMap可以实现将查询结果映射为复杂类型的pojo。</p>
<h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><p>1.java的基础类型及其包装类int,double和java.lang.Integer,java.lang.Double等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为int，resultType为int ,java.lang.Integer也可以--&gt;</span><br><span class="line">&lt;select id=&quot;countUser&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">    select count(*) from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>2.自己定义的实体类,实体类和数据库字段需要一致，如果不一致需要使用resulMap自定义map，也可以直接使用map。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为实体类，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUser&quot; resultType=&quot;com.entity.User&quot;&gt;</span><br><span class="line">   select * from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3.map类型，Dao层的返回类型为<code>Map&lt;String, Object&gt;</code>，key是对应的column值，value是数据中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 返回值为Map&lt;String,Object&gt;，resultType为map--&gt;</span><br><span class="line">&lt;select id=&quot;getUserSelective&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select name,address,salary from User where id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>4.List集合，其中该集合的类型可以为1,2,3中提到的类型。Dao层的返回类型为<code>List&lt;User&gt;</code>，这里只展示了实体类集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值为List&lt;User&gt;，resultType为User--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>结果集的映射是 MyBatis 最强大的特性,通过使用resultMap或resultType可以解决复杂映射问题。基础简单的使用resultType就可以了，但是如果出现table中列和实体类中的属性不一致或者多表级联。那么这时resultMap就可以发挥作用了。</p>
<p>TestDao.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.repository.TestDao&quot;&gt;</span><br><span class="line">    //定义映射</span><br><span class="line">    &lt;resultMap id=&quot;TestResultMap&quot; type=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        &lt;result column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    //定义返回栏目</span><br><span class="line">    &lt;sql id=&quot;all_colum_without_id&quot;&gt;</span><br><span class="line">        name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;all_colum&quot;&gt;</span><br><span class="line">        name,&lt;include refid=&quot;all_colum_without_id&quot;/&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    //插入语句</span><br><span class="line">    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values (#&#123;name&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //批量插入</span><br><span class="line">    &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">        insert into table (&lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;testDOList&quot; separator=&quot;,&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">            (#&#123;item.name&#125;,</span><br><span class="line">            #&#123;item.age&#125;)</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    //查询</span><br><span class="line">    &lt;select id=&quot;findById&quot; resultMap=&quot;TestResultMap&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;all_colum&quot;/&gt; from table where id=#&#123;id&#125;</span><br><span class="line">        &lt;if test=&quot;age != null&quot;&gt;</span><br><span class="line">            and age=#&#123;age&#125;</span><br><span class="line">        &lt;if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>TestDao.java接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface TestDao &#123;</span><br><span class="line">    //插入</span><br><span class="line">    Integer insertOne(TestDO testDO);</span><br><span class="line">    //批量插入</span><br><span class="line">    Integer insertBatch(List&lt;TestDO&gt; testDOList);</span><br><span class="line">    //查询</span><br><span class="line">    TestDO findById(Long id, Integer age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdbcType告诉框架如何解析这个属性（对应数据库中的类型），column是数据库中table的列名，property是实体类中对应的属性名字，type是对应的实体类，id=”TestResultMap”是这个resultMap的一个引用标志。</p>
<p>这样使用resultMap就像用resultType对应实体类，在select出来的语句中直接对字段就行as，as为实体类属性名，或驼峰形式就行。</p>
<p>resultMap更复杂的用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wobuaizhi/article/details/83104464">https://blog.csdn.net/wobuaizhi/article/details/83104464</a></p>
<h3 id="返回映射下划线转驼峰"><a href="#返回映射下划线转驼峰" class="headerlink" title="返回映射下划线转驼峰"></a>返回映射下划线转驼峰</h3><p>意思是返回值对应到对象，mysql返回的字段名（app_id），直接映射到对象属性名（appId）。</p>
<p>第一种 Spring Boot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

<p>第二种 mybatis-config.xml配置中加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 全局配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!-- 是否开启自动驼峰命名规则映射</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt; </span><br></pre></td></tr></table></figure>

<h3 id="mybatis-useGeneratedKeys-keyProperty"><a href="#mybatis-useGeneratedKeys-keyProperty" class="headerlink" title="mybatis useGeneratedKeys keyProperty"></a>mybatis useGeneratedKeys keyProperty</h3><p>useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</p>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。</p>
<p>作用：在inset时，可以不用管主键插入多少，而且插入后，还能直接用对象里的值，因为自动返回了。建表时必须设置主键自增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;</span><br><span class="line">    keyProperty=&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="DUPLICATE"><a href="#DUPLICATE" class="headerlink" title="DUPLICATE"></a>DUPLICATE</h3><p>duplicate在mybatis中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertOne&quot; parameterType=&quot;com.entity.TestDO&quot;&gt;</span><br><span class="line">    insert into table (id, &lt;include refid=&quot;all_colum_without_id&quot;/&gt;)</span><br><span class="line">    values (0, #&#123;name&#125;)</span><br><span class="line">    ON DUPLICATE KEY UPDATE name=values(name), age=values(age)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">values后面就是插入要查哪些。</span><br><span class="line">update后面是更新要更新哪些</span><br><span class="line">什么时候更新要看表的主键索引和唯一索引</span><br><span class="line">id可选，加了id，就传0</span><br></pre></td></tr></table></figure>

<p>因为更新的时候是不会返回id的，所以要去掉：<code>useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</code><br>如果不去掉，会报<code>executorexception: error getting generated key or setting result to parameter object</code></p>
<h3 id="xml里面foreach标签里面的属性separator"><a href="#xml里面foreach标签里面的属性separator" class="headerlink" title="xml里面foreach标签里面的属性separator"></a>xml里面foreach标签里面的属性separator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;if test=&quot;myList != null&quot;&gt;</span><br><span class="line">    AND dm in</span><br><span class="line">    &lt;foreach collection=&quot;myList &quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item , jdbcType=VARCHAR &#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
<p>渲染为sql：<code>AND dm in ( &#39;03&#39; , &#39;04&#39;)</code></p>
<p>如果separator属性为or，渲染为：<code>AND ( dm  = &#39;01&#39;or dm   = &#39;02&#39; or dm   = &#39;03&#39;) </code></p>
<h3 id="where标签的作用"><a href="#where标签的作用" class="headerlink" title="where标签的作用"></a>where标签的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> WHERE</span><br><span class="line"> &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line"> state = #&#123;state&#125;</span><br><span class="line"> &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>如果state参数为空时，最终生成SQL语句为<br>SELECT * FROM hdc WHERE<br>执行会出错，可以在where 后加一个1=1，但是累赘</p>
<p>用<code>&lt;where&gt;...&lt;/where&gt;</code>标签就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectOne&quot; resultType=&quot;DO&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line"> &lt;where&gt;</span><br><span class="line">  &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line"> &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>总结：<code>&lt;where&gt;</code>标签，1、在后面if null都是空时，可以自动删除where。2、在后面多个if null，第一个为null时，会自动删掉后面有的and。</p>
<h3 id="trim实现动态sql"><a href="#trim实现动态sql" class="headerlink" title="trim实现动态sql"></a>trim实现动态sql</h3><p>场景：想使用having，having后面用if null标签，如果后面的if null都是null，having会留着，导致出错。</p>
<p>trim 在英语中有“点缀物”，修剪的意思。可以把‘’标签为一个装饰sql的标签。trim标签常用于动态生成sql的场景下。</p>
<p>基本格式：<br><code>&lt;trim prefix=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;&quot; prefixOverrides=&quot;&quot;&gt;&lt;/trim&gt;</code><br>prefix：<br>表示在trim包裹的SQL语句前面添加的指定内容。<br>suffix：<br>表示在trim包裹的SQL末尾添加指定内容<br>prefixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定首部内容<br>suffixOverrides：<br>表示去掉（覆盖）trim包裹的SQL的指定尾部内容</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/425922768">https://zhuanlan.zhihu.com/p/425922768</a></p>
<p>例子(查输入的list的元素是不是在查处的一个list字段里有)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">group by id</span><br><span class="line">&lt;trim prefix=&quot;having&quot; prefixOverrides=&quot;and&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line"></span><br><span class="line">    &lt;if test=&quot;nameList != null and nameList.size() &gt; 0&quot;&gt;</span><br><span class="line">        and</span><br><span class="line">        &lt;foreach collection=&quot;nameList&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;name&quot; index=&quot;index&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            find_in_set(#&#123;name&#125;, names) &gt; 0</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>


<h3 id="条件构造器QueryWrapper"><a href="#条件构造器QueryWrapper" class="headerlink" title="条件构造器QueryWrapper"></a>条件构造器QueryWrapper</h3><p>QueryWrapper是在使用Mybatis-plus中用到的一种技术，也叫作构造器，能简化sql的操作。MyBatisPlus 依赖：mybatis-plus-boot-starter</p>
<p>首先，Mapper接口需要继承<code>BaseMapper&lt;T&gt;</code>抽象类，加@Mapper注解。</p>
<p>LambdaQueryWrapper和QueryWrapper查询是一样的，但是使用Lambda语法更加方便，更容易理解。</p>
<p>LambdaQueryWrapper和QueryWrapper的区别：<br>首先它们都是Mybatis-plus提供的查询构造器，用于构建查询条件。<br>1、LambdaQueryWrapper支持Lambda表达式作为查询条件，而QuerryWrapper不支持。<br>2、LambdaQueryWrapper可以避免手写错误的字段名，因为它会在编译期间进行类型检查。而QueryWrapper只能在运行时才发现错误。<br>3、LambdaQueryWrapper可以链式调用，更加优雅简洁。而QueryWrapper需要每次重新创建一个实例来添加新的查询条件。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public List&lt;Student&gt; list(Student student)&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Student&gt; lqw = new LambdaQueryWrapper&lt;Student&gt;();</span><br><span class="line">    lqw.eq(Student::getName, student.getName()); </span><br><span class="line">    //也可以：lqw.eq(&quot;name&quot;, student.getName());</span><br><span class="line">    lqw.like(Student::getClass,student.getClass());</span><br><span class="line">    lqw.between(&quot;age&quot;,student.getAge1(),student.getAge2());</span><br><span class="line">    lqw.orderByAsc(&quot;age&quot;);</span><br><span class="line">    List&lt;Student&gt; list = studentDao.list(lqw);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对应sql：<code>select * from student where name = &#39;?&#39; and class like &#39;%?%&#39; and age between &#39;?&#39; and &#39;?&#39; order by &#39;?&#39; asc</code></p>
<p>QueryWrapper其实可以理解成一个放查询条件的盒子，我们把查询条件放在里面，他就会自动按照对应的条件进行查询数据。</p>
<p>根据不同的查询要求，有不同的用法，常用到的比如：eq（相等）、like、and、or、isNull、isNotNull、ne（不相等）、likeRight、between、gt（大于）、lt（小于）等</p>
<hr>
<p>使用QueryWrapper来更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;user&gt; qw = new QueryWrapper&lt;&gt;();</span><br><span class="line">qw.eq(&quot;id&quot;, 1);</span><br><span class="line">User user = new User();</span><br><span class="line">user.setName(&quot;liu&quot;);</span><br><span class="line">int rows = userMapper.update(user, qw);</span><br></pre></td></tr></table></figure>


<h3 id="使用Map接收mybatis结果"><a href="#使用Map接收mybatis结果" class="headerlink" title="使用Map接收mybatis结果"></a>使用Map接收mybatis结果</h3><p>ResultSet是一个表示数据库结果集的接口，在java中用于表示从数据库查询的结果，允许通过行和列的方式访问数据，从而从数据库中检索和操作数据。</p>
<p>但是Mybatis不支持直接用ResultSet接收查询结果。因为Mybatis采用的是物理映射技术，而ResultSet只能获取行列数据，得不到物理映射的结果。</p>
<p>那么除了定义DO，还可以用什么接收mybatis返回的数据呢？ 用Map。</p>
<p>dao接口怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@MapKey(&quot;某字段名&quot;)</span><br><span class="line">Map&lt;String, Object&gt; selectAll();</span><br></pre></td></tr></table></figure>

<p>xml怎么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;select&quot; resultType=&quot;java.util.Map&quot;&gt;</span><br><span class="line"> SELECT * FROM hdc</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>@MapKey 是MyBatis框架的注解，作用是将List结果集转换成key-value形式的Map结果集，方便快速从结果集中查询指定结果。</p>
<p>@MapKey(value=””) 是mybatis的注解，用来映射Map类型的联合查询结果。作用是指定从查询结果的某个字段映射到Map的Key，这个注解是必须的，必须指定一个字段为key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class UserMapper()&#123;</span><br><span class="line"> </span><br><span class="line">    //使用list接收</span><br><span class="line">    //[&#123;id:1111,name:&quot;foo&quot;&#125;,&#123;id:2222,name:&quot;bar&quot;&#125;]</span><br><span class="line">    public List&lt;User&gt; useList();</span><br><span class="line"> </span><br><span class="line">    //使用带有@Mapkey(&quot;id&quot;)的Map&lt;Integer,User&gt;接收</span><br><span class="line">    //&#123;1111:&#123;id:1111,name:&quot;foo&quot;&#125;,2222:&#123;id:2222,name:&quot;bar&quot;&#125;&#125;</span><br><span class="line">    @Mapkey(&quot;id&quot;)</span><br><span class="line">    public Map&lt;Integer,User&gt; useMap();</span><br><span class="line"></span><br><span class="line">    //不想定义DO，直接用List&lt;Map&lt;String, Object&gt;&gt;接收</span><br><span class="line">    //返回的结果Map是字段名：值，跟@MapKey里的value没啥关系</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不能用<code>List&lt;Object&gt;</code>接结果。<br>如果@MapKey中的value是null，会展示一个key为null的map。</p>
<hr>
<p>MyBatis中的动态SQL以及@ResultMap,@MapKey和@Options的使用：<br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/2930425356/">https://www.freesion.com/article/2930425356/</a></p>
<h3 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h3><p>ResultHandler，顾名思义，对返回的结果进行处理，最终得到自己想要的数据格式或类型。也就是说，可以自定义返回类型。可以迭代查询结果集，将其存储在集合中，或执行自定义处理。它是mybatis的一个接口，用来处理结果集，从而获取特定的数据或者操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ResultHandler&lt;T&gt; &#123;</span><br><span class="line">    void handleResult(ResultContext&lt;? extends T&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface GoodsDao &#123;</span><br><span class="line">    public void selectGoods(ResultHandler resultHandler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;   </span><br><span class="line">&lt;!DOCTYPE mapper   </span><br><span class="line">PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;  </span><br><span class="line">&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.yht.mybatisTest.dao.GoodsDao&quot;&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;select id=&quot;selectGoods&quot; resultType=&quot;map&quot;&gt;  </span><br><span class="line">        select price,name from goods</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">                                                        </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>selectGoods方法的查询结果是<code>List&lt;Map&gt;</code>，假如现在有这么一个需求：想统计价格低于50的书籍有哪些，价格高于50的书籍有哪些，该怎么处理呢？这个时候就用到了ResultHandler，我们创建一个SelectGoodsResultHandler。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SelectGoodsResultHandler implements ResultHandler&#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, List&lt;String&gt;&gt; resultMap = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void handleResult(ResultContext context) &#123;</span><br><span class="line">        if(resultMap.get(&quot;lowPrice&quot;) == null &amp;&amp; resultMap.get(&quot;highPrice&quot;) == null)&#123;</span><br><span class="line">            List&lt;String&gt; lowList = new ArrayList&lt;String&gt;();</span><br><span class="line">            List&lt;String&gt; highList = new ArrayList&lt;String&gt;();</span><br><span class="line">            resultMap.put(&quot;lowPrice&quot;, lowList);</span><br><span class="line">            resultMap.put(&quot;highPrice&quot;, highList);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Map&lt;String,Object&gt; resultObject = (Map&lt;String, Object&gt;)context.getResultObject();</span><br><span class="line">        BigDecimal price = (BigDecimal) resultObject.get(&quot;price&quot;);</span><br><span class="line">        String name = (String) resultObject.get(&quot;name&quot;);</span><br><span class="line">        if(price.intValue() &lt; 50)&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;lowPrice&quot;)).add(name);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ((List&lt;String&gt;)resultMap.get(&quot;highPrice&quot;)).add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Map&lt;String, List&lt;String&gt;&gt; getResults()&#123;</span><br><span class="line">        return resultMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class GoodsDaoTest &#123;</span><br><span class="line">    </span><br><span class="line">    private static SqlSessionFactory sqlSessionFactory = null;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void selectGoodsTest()&#123;</span><br><span class="line">        </span><br><span class="line">        SqlSession sqlSession = getSqlSessionFactory().openSession(true);</span><br><span class="line">        GoodsDao goodsMapper = sqlSession.getMapper(GoodsDao.class);</span><br><span class="line">        SelectGoodsResultHandler resultHandler = new SelectGoodsResultHandler();</span><br><span class="line">        goodsMapper.selectGoods(resultHandler);</span><br><span class="line">        System.out.println(resultHandler.getResults().toString());;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static SqlSessionFactory getSqlSessionFactory() &#123;</span><br><span class="line">        String resource = &quot;spring-ibatis.xml&quot;;</span><br><span class="line">        if(sqlSessionFactory == null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources</span><br><span class="line">                        .getResourceAsReader(resource));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/51life/p/9633002.html">https://www.cnblogs.com/51life/p/9633002.html</a></p>
<p>mybatis之ResultHandler如何使用：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8773d0e786d8">https://www.jianshu.com/p/8773d0e786d8</a></p>
<h3 id="mybatis传表名"><a href="#mybatis传表名" class="headerlink" title="mybatis传表名"></a>mybatis传表名</h3><p>mybatis 怎么传入表名来控制插入哪个表？<br>在 MyBatis 中，我们可以通过动态 SQL 的方式来传入表名，从而控制插入哪个表。</p>
<p>貝体操作如下：<br>1.在Mapperxml 文件中，使用 parameterType 指定一个参数类型为 string，用于接收要插入的表名。</p>
<p>2.在插入语句中，使用 ＄{} 操作待将该参数传递到 SQL中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void insertIntoTable(@Param(&quot;tableName&quot;) String tableName, ...)</span><br><span class="line"></span><br><span class="line">&lt;insert id=&quot;insertIntoTable&quot;&gt;</span><br><span class="line">    INSERT INTO $&#123;tableName&#125; (column, column2) VALUES (#&#123;value1&#125;, #&#123;value2&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>如果除了表名参数，另一个参数是对象，在xml文件中加对象名.字段名来调用。</p>
<p>3.在调用该方法时，传递要插入的表名即可。<br>String tableName = user;<br>mapper.insertIntoTable (tableName, value1, value2);<br>注意：使用＄{}操作符传递参数，需要注意 SQL 注入的问题，因此需要进行必要的安全措施，如输入参数的参数校验等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/01/myblog/JAVA/maven%E5%92%8Cnuxus/" class="post-title-link" itemprop="url">maven与nexus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-01 22:34:23" itemprop="dateCreated datePublished" datetime="2022-06-01T22:34:23+08:00">2022-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-26 11:08:59" itemprop="dateModified" datetime="2023-03-26T11:08:59+08:00">2023-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ol>
<li><p>优秀的构建工具<br>通过简单的命令，能够完成清理、编译、测试、打包、部署等一系列过程。同时，不得不提的是，Maven是跨平台的，无论是在Windows、还是在Linux或Mac上，都可以使用同样的命令。</p>
</li>
<li><p>依赖管理工具<br>项目依赖的第三方的开源类库，都可以通过依赖的方式引入到项目中来。代替了原来需要首先下载第三方jar，再加入到项目中的方式。从而更好的解决了合作开发中依赖增多、版本不一致、版本冲突、依赖臃肿等问题。<br>具体是怎么实现的呢？Maven通过坐标系统准确的定位每一个构件，即通过坐标找到对应的java类库。</p>
</li>
<li><p>项目信息管理工具<br>能够管理项目描述、开发者列表、版本控制系统地址、许可证等一些比较零散的项目信息。除了直接的项目信息，通过Maven自动生成的站点，以及一些已有的插件，还能够轻松获得项目文档、测试报告、静态分析报告、源码版本、日志报告等非常具有价值的项目信息。</p>
</li>
</ol>
<h3 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h3><p>✅常见打包命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true		-- 跳过单测打包</span><br><span class="line">mvn clean install -Dmaven.test.skip=true		-- 跳过单测打包，并把打好的包上传到本地仓库</span><br><span class="line">mvn clean deploy -Dmaven.test.skip=true			-- 跳过单测打包，并把打好的包上传到远程仓库</span><br></pre></td></tr></table></figure>

<p>✅mvn命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mvn -v //查看版本 </span><br><span class="line">mvn archetype:create //创建 Maven 项目 </span><br><span class="line">mvn compile //编译源代码 </span><br><span class="line">mvn test-compile //编译测试代码 </span><br><span class="line">mvn test //运行应用程序中的单元测试 </span><br><span class="line">mvn site //生成项目相关信息的网站 </span><br><span class="line">mvn package //依据项目生成 jar 文件 </span><br><span class="line">mvn install //在本地 Repository 中安装 jar </span><br><span class="line">mvn -Dmaven.test.skip=true //忽略测试文档编译 </span><br><span class="line">mvn clean //清除目标目录中的生成结果 </span><br><span class="line">mvn clean compile //将.java类编译为.class文件 </span><br><span class="line">mvn clean package //进行打包 </span><br><span class="line">mvn clean test //执行单元测试 </span><br><span class="line">mvn clean deploy //部署到版本仓库 </span><br><span class="line">mvn clean install //使其他项目使用这个jar,会安装到maven本地仓库中 </span><br><span class="line">mvn archetype:generate //创建项目架构 </span><br><span class="line">mvn dependency:list //查看已解析依赖 </span><br><span class="line">mvn dependency:tree com.xx.xxx //看到依赖树 </span><br><span class="line">mvn dependency:analyze //查看依赖的工具 </span><br><span class="line">mvn help:system //从中央仓库下载文件至本地仓库 </span><br><span class="line">mvn help:active-profiles //查看当前激活的profiles </span><br><span class="line">mvn help:all-profiles //查看所有profiles </span><br><span class="line">mvn help:effective -pom //查看完整的pom信息</span><br></pre></td></tr></table></figure>



<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><p>maven的依赖管理功能，通过在Pom中指定坐标的形式将jar引入到项目中。jar包就存放在仓库中。</p>
<p>Maven的仓库分为本地仓库和远程仓库。远程仓库分为：中央仓库、私服、其他远程仓库。</p>
<p>当Maven根据坐标寻找构件时，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用；如果本地仓库不存在此构件，或者需要查看是否有更新的构件版本，Maven会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。</p>
<p>为什么需要私服？</p>
<p>1.一些无法从外部仓库下载的构件，例如内部的项目，可以部署到私服上，以便供其他依赖项目使用。</p>
<p>2.为了节省带宽和时间，在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。当本地Maven项目需要下载构件时，先去私服请求，如果私服没有，则再去远程仓库请求，从远程仓库下载构件后，把构件缓存在私服上。这样，即使暂时没有Internet链接，由于私服已经缓存了大量构件，整个项目还是可以正常使用的。同时，也降低了中央仓库的负荷。</p>
<p>如果没有私服，我们所需的所有构件都需要通过maven的中央仓库和第三方的Maven仓库下载到本地，而一个团队中的所有人都重复的从maven仓库下载构件无疑加大了仓库的负载和浪费了外网带宽，如果网速慢的话，还会影响项目的进程。很多情况下项目的开发都是在内网进行的，连接不到maven仓库怎么办呢？开发的公共构件怎么让其它项目使用？这个时候我们不得不为自己的团队搭建属于自己的maven私服，这样既节省了网络带宽也会加速项目搭建的进程，当然前提条件就是你的私服中拥有项目所需的所有构件。<br>————————————————</p>
<p>总而言之：私服在用户局域网内的特殊远程仓库，私服起到了maven用户与中央仓库的中间作用，私服从中央仓库缓存构件，maven用户从私服下载构件。</p>
<h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><p>nexus就是私服的一种。</p>
<p>nexus是一个强大的maven仓库管理器,它极大的简化了本地内部仓库的维护和外部仓库的访问.</p>
<p>nexus提供了强大的仓库管理功能,构件搜索功能,它基于REST,友好的UI是一个extjs的REST客户端,占用较少的内存,基于简单文件系统而非数据库.</p>
<p>节省外网带宽；加速Maven构建；部署第三方构件；提高稳定性，增强控制；降低中央仓库的负荷；控制和审计；建立本地内部公用仓库。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/youngdeng/p/15098442.html">https://www.cnblogs.com/youngdeng/p/15098442.html</a></p>
<p>如何配置：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b06b2541336">https://www.jianshu.com/p/5b06b2541336</a></p>
<h3 id="配置项目遇到的几个问题"><a href="#配置项目遇到的几个问题" class="headerlink" title="配置项目遇到的几个问题"></a>配置项目遇到的几个问题</h3><p>背景：把之前的包想移动到新创建的一个子包里。</p>
<p>✅父子工程引用的问题</p>
<p>1、Parent怎么能找到childA和childB呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">   &lt;module&gt;childA&lt;/module&gt;</span><br><span class="line">   &lt;module&gt;childB&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>2、pom”继承”的概念</p>
<p>如果分别去在各自的pom里引用包，就会导致pom文件引入的包重复。<br>父pom写好了，子pom就通过<code>&lt;parent&gt;</code>标签继承父pom的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">   &lt;groupId&gt;com.sang.main&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Parent-Moduel&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class="line">   &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;  &lt;!--本例中此处是可选的，不是在外层包下的话用--&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p>子pom中引入<code>&lt;parent&gt;</code>标签后，就会从父pom继承<code>&lt;version&gt;</code>等属性了,主pom中把依赖通过<code>&lt;dependecyManagement&gt;</code>引起来，表示子pom可能会用到的jar包依赖，子包引用的话，可以不加version属性，便于统一管理，加了的话表示子包单独用这个版本。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SunFlowerXT/article/details/105531109">https://blog.csdn.net/SunFlowerXT/article/details/105531109</a></p>
<p>✅Junit找不到的问题，test放在main里，结构限定scope为test</p>
<p>✅class notFound 以及 找不到或无法加载主类</p>
<p>项目结构没有安排明白的原因，点project structure，父包下面的main包和test包下的java包啥的都不作为source和test，resource也不作为reesource。子包下面的模块选好。就可以了。</p>
<p>✅打包时注意</p>
<p>打包时注意：</p>
<p>当mvn仓库里缺少jar包，同时又从中央仓库自动下载不下来的时候，就需要自己下载jar包然后放仓库里了，<br>但是有时候只是简单的把jar和source放仓库的文件夹下，并不管用，这个时候你可以用命令把jar把打进去：<br><code>mvn install:install-file -Dfile=D:\xxx.jar -DgroupId=commons-dbcp -DartifactId= commons-dbcp -Dversion= 1.4 -Dpackaging=jar</code><br>-Dfile 是存在本地磁盘里jar 的路径</p>
<p>✅jar包冲突</p>
<p>mvn dependency:tree命令解决jar包冲突<br>当项目出现jar包冲突时,用命令mvn dependency:tree 查看依赖情况<br>mvn dependency:tree 查看依赖树,查看包结构间的依赖<br>mvn dependency:tree &gt;d:/tmp 把结果输出到文件，<br>然后再pom.xml文件里排除掉冲突的jar包</p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/good_good_xiu/article/details/116740333">https://blog.csdn.net/good_good_xiu/article/details/116740333</a></p>
<p>⚠️本地启动项目，有包显红，在maven - root - compile一下。<br>maven中的compile命令是用来将源代码编译成可执行的class文件，或者把它打包成jar文件，以便他人使用。</p>
<p>✅为什么包没有在pom中引入，但是compile编译之后在target文件中却出现了呢。<br>maven会自动寻找依赖并自动加载它们，在某些情况下，即使它们没有在pom文件中显式引入，也会被自动加载到项目中。也有可能其他依赖引入了该包。这些jar包会被编译成class文件，maven把它们放在target目录下，以便正常使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/myblog/JAVA/Geometry%E5%92%8CCoordinate/" class="post-title-link" itemprop="url">Geometry和Coordinate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-21 13:25:10" itemprop="dateCreated datePublished" datetime="2022-05-21T13:25:10+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-08 22:04:08" itemprop="dateModified" datetime="2023-02-08T22:04:08+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LineString与Coordinate"><a href="#LineString与Coordinate" class="headerlink" title="LineString与Coordinate"></a>LineString与Coordinate</h3><p>Geometry对象转换为LineString对象，前面加(LineString)强转。</p>
<p><code>Coordinate coor = new Coordinate(lng, lat);</code><br>//lng、lat是Double类型经度纬度</p>
<p>LineString转换为Coordinate数组：<br><code>Coordinate[] coor = road.getCoordinates();</code></p>
<h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h3><p>com.vividsolutions.jts.geom下<br>Geometry可以是一系列的点组成的线。<br>数据库中查看需要加：select st_astext(geo) from table;</p>
<p>Geometry里的点：<br><code>Coordinate[] coordinates = geo.getCoordinates();</code></p>
<h3 id="GeometryUtils工具类"><a href="#GeometryUtils工具类" class="headerlink" title="GeometryUtils工具类"></a>GeometryUtils工具类</h3><p>GeometryUtils类属于mil.nga.giat.geowave.core.geotime包。</p>
<p><a target="_blank" rel="noopener" href="https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html">https://vimsky.com/examples/detail/java-class-mil.nga.giat.geowave.core.geotime.GeometryUtils.html</a></p>
<h3 id="redisTemplate的GEO-API："><a href="#redisTemplate的GEO-API：" class="headerlink" title="redisTemplate的GEO API："></a>redisTemplate的GEO API：</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39274753/article/details/107783674">https://blog.csdn.net/weixin_39274753/article/details/107783674</a></p>
<h3 id="string和geometry的转换"><a href="#string和geometry的转换" class="headerlink" title="string和geometry的转换"></a>string和geometry的转换</h3><p>需要导入jts包。（vividsolution）</p>
<p>WKT，是一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换。它的二进制表示方式，亦即WKB(well-known binary)则胜于在传输和在数据库中存储相同的信息。该格式由开放地理空间联盟(OGC)制定。</p>
<p>WKT可以表示的几何对象包括：点，线，多边形，TIN（不规则三角网）及多面体。可以通过几何集合的方式来表示不同维度的几何对象。<br>几何物体的坐标可以是2D(x,y),3D(x,y,z),4D(x,y,z,m),加上一个属于线性参照系统的m值。<br>以下为几何WKT字串样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POINT(6 10)</span><br><span class="line">LINESTRING(3 4,10 50,20 25)</span><br><span class="line">POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))</span><br><span class="line">MULTIPOINT(3.5 5.6, 4.8 10.5)</span><br><span class="line">MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))</span><br><span class="line">MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))</span><br><span class="line">GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))</span><br><span class="line">POINT ZM (1 1 5 60)</span><br><span class="line">POINT M (1 1 80)</span><br><span class="line">POINT EMPTY</span><br><span class="line">MULTIPOLYGON EMPTY</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void geoTest() throws ParseException, com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    //1.string类型转为geometry</span><br><span class="line">    //GeometryFactory工厂，参数一：数据精度 参数二空间参考系SRID</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line"></span><br><span class="line">    //熟知文本WKT阅读器，可以将WKT文本转换为Geometry对象</span><br><span class="line">    WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line"></span><br><span class="line">    //Geometry对象，包含Point、LineString、Polygon等子类</span><br><span class="line">    Geometry geometry = wktReader.read(&quot;POINT (113.53896635 22.36429837)&quot;);</span><br><span class="line">    System.out.println(&quot;geometry:&quot; + geometry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2.geometry对象转为string</span><br><span class="line">    //单纯的一个坐标点，单点可以创建Point，多点可以创建LineString、Polygon等</span><br><span class="line">    Coordinate coordinate = new Coordinate(113.53896635, 22.36429837);</span><br><span class="line">    Point point = geometryFactory.createPoint(coordinate);</span><br><span class="line"></span><br><span class="line">    Polygon polygon = geometryFactory.createPolygon(new Coordinate[]&#123;</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">            new Coordinate(1, 2),</span><br><span class="line">    &#125;);</span><br><span class="line">    Geometry geometry1 = point;</span><br><span class="line">    Geometry geometry2 = polygon;</span><br><span class="line"></span><br><span class="line">    //WKT输出器，将Geometry对象写出为WKT文本</span><br><span class="line">    WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">    String pointString = wktWriter.write(point);</span><br><span class="line">    System.out.println(&quot;point string: &quot; + pointString);</span><br><span class="line">    String geoString = wktWriter.write(geometry1);</span><br><span class="line">    System.out.println(&quot;geo string: &quot; + geoString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br>Java Geometry空间几何数据的处理应用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/An1090239782/article/details/123509504">https://blog.csdn.net/An1090239782/article/details/123509504</a></p>
<p>Geometry在数据库和Java中的应用：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/76343e71d6f1">https://www.jianshu.com/p/76343e71d6f1</a></p>
<h3 id="两个geometry拼接"><a href="#两个geometry拼接" class="headerlink" title="两个geometry拼接"></a>两个geometry拼接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    WKTReader wktReader = new WKTReader();</span><br><span class="line">    Geometry geometry1 = wktReader.read(&quot;LineString(113.53896635 22.36429837, 113.53896645 22.36429847)&quot;);</span><br><span class="line">    Geometry geometry2 = wktReader.read(&quot;LineString(113.53896645 22.36429847, 113.53896655 22.36429857)&quot;);</span><br><span class="line">    Geometry geometry3 = geometry1.union(geometry2);</span><br><span class="line">    System.out.println(geometry3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：MULTILINESTRING ((113.53896635 22.36429837, 113.53896645 22.36429847), (113.53896645 22.36429847, 113.53896655 22.36429857))</p>
<h3 id="jts里的geometry的一些操作"><a href="#jts里的geometry的一些操作" class="headerlink" title="jts里的geometry的一些操作"></a>jts里的geometry的一些操作</h3><p>✅<code>org.locationtech.jts.geom.Geometry.isValid()</code></p>
<p>验证此Geometry是否在拓扑上有效。</p>
<p>✅<code>geo.buffer(distance)</code></p>
<p>buffer(double distance): 加buffer缓冲区<br>buffer(double distance, int quadrantSegments): 加buffer,边界样式</p>
<p>✅<code>geometry1.equals(geometry2)</code> 是否完全重叠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void equalsGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">    WKTReader reader = new WKTReader( geometryFactory );</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.equals(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line"></span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(10 0, 0 0)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.equals(geometry2);//true</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅geometry1.crosses(geometry2) 是否交叉</p>
<p>得有交点。但交点不能是线的起点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void crossGeometry() throws com.vividsolutions.jts.io.ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    //情景1</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    String wkt2 = &quot;LINESTRING(3 0, 1 0)&quot;;</span><br><span class="line">    LineString geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    LineString geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b1 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b1);</span><br><span class="line">    //情景2</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b2 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b2);</span><br><span class="line">    //情景3</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(4 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b3 = geometry1.crosses(geometry2);//false</span><br><span class="line">    System.out.println(b3);</span><br><span class="line">    //情景4</span><br><span class="line">    wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">    wkt2 = &quot;LINESTRING(0 4, 3 0, -1 -1)&quot;;</span><br><span class="line">    geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">    geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">    boolean b4 = geometry1.crosses(geometry2);//true</span><br><span class="line">    System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅intersects ：两个对象是否空间相交（至少有一个点）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wkt1 = &quot;LINESTRING(0 0, 3 0, 10 0)&quot;;</span><br><span class="line">wkt2 = &quot;LINESTRING(3 0, 1 1)&quot;;</span><br><span class="line">geometry1 = (LineString) reader.read(wkt1);</span><br><span class="line">geometry2 = (LineString) reader.read(wkt2);</span><br><span class="line">boolean b2 = geometry1.intersects(geometry2);//true</span><br></pre></td></tr></table></figure>

<p>geometry的更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaobing1226/article/details/124467098">https://blog.csdn.net/qiaobing1226/article/details/124467098</a></p>
<p>常用的Geometry数据结构和GeometryFactory：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3add14bdee7b">https://www.jianshu.com/p/3add14bdee7b</a></p>
<p>jts使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40294332/article/details/124124361">https://blog.csdn.net/weixin_40294332/article/details/124124361</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaobing1226/article/details/127204644">https://blog.csdn.net/qiaobing1226/article/details/127204644</a></p>
<h3 id="数据库相关的geo操作"><a href="#数据库相关的geo操作" class="headerlink" title="数据库相关的geo操作"></a>数据库相关的geo操作</h3><p>✅mysql空间数据有哪些</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Geometry  空间数据	任意一种空间类型	</span><br><span class="line">Point	点	坐标值	POINT(104.00924 30.46872)</span><br><span class="line">LineString	线	线，由一系列点连接而成	LINESTRING(1 1,  1 1, 1 1)</span><br><span class="line">Polygon	多边形	由多条线组成	POLYGON((1 1, 2 2, 3 3,  4 4, 5 5))</span><br><span class="line">MultiPoint	点集合	集合类，包含多个点	MULTIPOINT(1 1, 2 2, 1 1)</span><br><span class="line">MultiLineString	线集合	集合类，包含多条线	MULTILINESTRING((1 1, 2 2), (1 1, 1 1))</span><br><span class="line">MultiPolygon	多边形集合	集合类，包含多个多边形	MULTIPOLYGON(((0 0, 1 0, 1 1, 0 1, 0 0)), ((1 1, 1 1, 1 1, 1 1, 1 1)))</span><br><span class="line">GeometryCollection	空间数据集合	集合类，可以包括多个点、线、多边形	GEOMETRYCOLLECTION(POINT(1 1), POINT(3 3), LINESTRING(1 1, 2 2))</span><br></pre></td></tr></table></figure>

<p>mysql中几何对象的表达格式：<br>WKT：（Well-known Text）可以通过文本来描述几何对象。<br>WKB（Well-known Binary）通过序列化的字节对象来描述几何对象（一般在数据库中使用）。</p>
<p>常用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ST_GEOMFROMTEXT</span><br><span class="line">用于将几何数据从可读的文本类型转换成内部存储的二进制类型。</span><br><span class="line">ST_ASTEXT</span><br><span class="line">将几何数据转换成可读的文本类型。</span><br><span class="line"></span><br><span class="line">st_union(g1, g2) 将g1和g2合并为一个集合类对象</span><br><span class="line">st_difference(g1, g2)  返回几何对象，该对象表示了几何值g1与g2的点集合差异</span><br><span class="line">st_intersection(g1,g2)  返回几何对象，该对象表示了几何值g1与g2的点集合交集</span><br><span class="line"></span><br><span class="line">st_contains(g1, g2)</span><br><span class="line">g1完全包含g2；返回0: g1未包含g2</span><br><span class="line"></span><br><span class="line">st_crosses(g1, g2), st_intersects(g1, g2)</span><br><span class="line">返回1: g1与g2相交；返回0:g1与g2未相交</span><br><span class="line"></span><br><span class="line">st_disjoint(g1, g2)</span><br><span class="line">是st_crosses的反函数</span><br><span class="line"></span><br><span class="line">st_within(g1, g2)</span><br><span class="line">g1在g2内则返回1，否则返回0</span><br></pre></td></tr></table></figure>

<p>创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对表中的geometry类型的字段进行索引可以优化搜索，mysql中通过对geometry对象的mbr创建索引</span><br><span class="line">创建：</span><br><span class="line">create spatial index i_shape on `t_geo_test`(shape);</span><br><span class="line">删除：</span><br><span class="line">drop index i_shape on `t_geo_test`;</span><br><span class="line"></span><br><span class="line">目前mysql中支持的空间坐标系统没有gcj02,bd09等国内坐标系，</span><br><span class="line">默认使用wgs84地球坐标系，所以在创建几何对象时输入的坐标值尽量使用wgs84坐标，以避免误差。</span><br><span class="line"></span><br><span class="line">mysql中的计算距离，长度，面积等绝对数值的空间计算函数（area(), glength(), st_distance()）存在一定的误差，尽量不要使用。</span><br></pre></td></tr></table></figure>

<p>mysql的geometry相关的函数：<a target="_blank" rel="noopener" href="https://jiuaidu.com/jianzhan/906169/">https://jiuaidu.com/jianzhan/906169/</a></p>
<p>✅创建表时带geometry字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`geo` geometry default null comment &#x27;坐标点&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists `geo_table`(</span><br><span class="line">    `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增&#x27;,</span><br><span class="line">    `geo` geometry default null comment &#x27;坐标点&#x27;,</span><br><span class="line">    PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COMMENT=&quot;geo&quot;;</span><br><span class="line"></span><br><span class="line">set @geo = st_geomfromtext(&quot;LineString(104.009241 30.468972,104.009229 30.468961)&quot;);</span><br><span class="line">insert into geo_table values(0, @geo);</span><br><span class="line">select st_astext(geo) from geo_table;</span><br></pre></td></tr></table></figure>

<p>✅Intersects相交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where Intersects(geome1, geo2);</span><br></pre></td></tr></table></figure>

<p>✅mysql根据经纬度计算距离</p>
<p>st_distance_sphere函数返回以米为单位.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select st_distance_sphere(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>st_distance返回的度<br>st_distance 计算的结果单位是度，需要乘111195（地球半径6371000*PI/180）是将值转化为米。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select st_distance(point(113.264435, 23.129163), point(113.274436, 23.129164));</span><br></pre></td></tr></table></figure>

<p>直接计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">*,ROUND(</span><br><span class="line">6378.138 * 2 * ASIN(</span><br><span class="line">SQRT(</span><br><span class="line">POW( SIN(( 23.129163 * PI()/ 180-latitudes * PI()/ 180 )/ 2 ), 2 )+ COS( 23.129163 * PI()/ 180 )* COS( latitudes * PI()/ 180 )* POW( SIN(( 113.264435 * PI()/ 180-longitudes * PI()/ 180 )/ 2 ), 2 )))* 1000 </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="几个坐标系"><a href="#几个坐标系" class="headerlink" title="几个坐标系"></a>几个坐标系</h3><p>总的来说，坐标系可以分为两大类：地理坐标系（Geographic Coordinate System, GCS）和投影坐标系（Projected Coordinate System, PCS），地理坐标系进行地图投影后就变成了投影坐标系。例如我们常见的世界地图，使用的就是一种 墨卡托投影。</p>
<p>其中地理坐标系又可分为 参心坐标系 和 地心坐标系，常见的地心坐标系有WGS84、GCJ-02、BD-09、GCS2000。</p>
<p>✅WGS84（World Geodetic System 1984）</p>
<p>WGS84是为 GPS 全球定位系统建立的坐标系统，是世界上第一个统一的地心坐标系，因此也被称为大地坐标系、原始坐标系。一般通过GPS记录仪记录下来的经纬度，就是基于WGS84坐标系的数据。</p>
<p>✅GCJ-02（国家测量局02号标准）</p>
<p>GCJ-02 是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统，是在WGS84经纬度的基础上执行加密算法而成（为了数据安全和保密，通过地形图非线性保密处理算法（俗称火星加密）加密）。因为GPS得到的经纬度直接在 GCJ-02 坐标系下会定位到错误的地点，有种到了火星的感觉，因此在坊间也将 GCJ-02 戏称为火星坐标系。</p>
<p>国测局规定，国内出版的各种地图系统（包括电子形式），必须至少采用 GCJ-02 对地理位置进行首次加密的坐标系，高德和Google在国内都是使用 GCJ－02 坐标系，而百度使用的是在 GCJ-02 基础上再一次加密的 BD-09 坐标系。</p>
<p>举个例子，北京天安门中心的GPS经纬度是39°54’26.2”N，116°23’28.4”E，转化为度的单位就是39.907270, 116.391213（提示：小数部分 = 分 / 60 + 秒 / 3600）<br>将 GPS 坐标转换为 GCJ-02 坐标：116.397454,39.908671，才能在高德地图上找到正确的位置。<br>需要注意的是，如果切换到谷歌地图的卫星地图模式，它使用的是WGS84坐标系。</p>
<p>参考：<br>几种坐标系：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/559029832a67">https://www.jianshu.com/p/559029832a67</a><br>地心坐标系和投影坐标系：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62864791">https://zhuanlan.zhihu.com/p/62864791</a></p>
<p>三个坐标总结：WGS84是大地坐标系，这是一种国际通用的坐标，一般的终端设备，如果自己有定位功能，比如车载系统，他们发出的gps坐标就是原始坐标。我们在一些地图应用中使用的定位，比如打车软件，其他自带地图的软件，他们一般都是火星坐标系GCJ02，需要进行一个坐标转换。而百度地图相关的应用，基本都是使用的百度坐标，这个是在火星坐标基础上进行的再次加密，所以它还是与火星坐标有关系。</p>
<p>✅坐标转换</p>
<p>从WGS84坐标系不能直接转BD09，中间需要跨越一个GCJ02，反过来，需要将GCJ02或者BD09转为WGS84就是纠偏算法，相当于逆向解密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">克拉索索夫斯基椭球系数:</span><br><span class="line">public static double pi = 3.1415926535897932384626;</span><br><span class="line">public static double a = 6378245.0;</span><br><span class="line">public static double ee = 0.00669342162296594323;</span><br><span class="line">经纬度偏移值：&#123;105,35&#125;。这个其实是中华人民共和国大地原点坐标。位置在中国陕西省咸阳市下的泾阳县。</span><br></pre></td></tr></table></figure>

<p>转换代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">package org.example.geometry;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * wgs84 84年提出，大地坐标，也是原始坐标。</span><br><span class="line"> * gcj02 02年提出，火星坐标，经过加密算法。大多数非百度中国地图厂商基本都是使用的火星坐标：高德，腾讯，谷歌中国cn</span><br><span class="line"> * bd09  09年提出，百度坐标，经过火星坐标再次加密，相当于对大地坐标经过了二次加密。百度自己使用</span><br><span class="line"> * 一般的算法，没有直接bd09-&gt;wgs84或者wgs84-&gt;bd09，都需要借助wgs84-&gt;gcj02或者gcj02-&gt;wgs84算法推导。</span><br><span class="line"> */</span><br><span class="line">public class GpsTransfer &#123;</span><br><span class="line">    //π的定义</span><br><span class="line">    public static double pi = 3.1415926535897932384626;</span><br><span class="line">    //椭球长半径，依据克拉索索夫斯基椭球系数计算</span><br><span class="line">    public static double a = 6378245.0;</span><br><span class="line">    //第一偏心率的平方</span><br><span class="line">    public static double ee = 0.00669342162296594323;</span><br><span class="line"></span><br><span class="line">    public static double transformLat(double x, double y) &#123;</span><br><span class="line">        double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y</span><br><span class="line">                + 0.2 * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static double transformLon(double x, double y) &#123;</span><br><span class="line">        double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1</span><br><span class="line">                * Math.sqrt(Math.abs(x));</span><br><span class="line">        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">        ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0</span><br><span class="line">                * pi)) * 2.0 / 3.0;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断是否在中国范围之内</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean outOfChina(double lat, double lon) &#123;</span><br><span class="line">        if (lon &lt; 72.004 || lon &gt; 137.8347)</span><br><span class="line">            return true;</span><br><span class="line">        if (lat &lt; 0.8293 || lat &gt; 55.8271)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 把公式部分抽取出来</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps transform(double lat, double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return new Gps(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double dLat = transformLat(lon - 105.0, lat - 35.0);</span><br><span class="line">        double dLon = transformLon(lon - 105.0, lat - 35.0);</span><br><span class="line">        double radLat = lat / 180.0 * pi;</span><br><span class="line">        double magic = Math.sin(radLat);</span><br><span class="line">        magic = 1 - ee * magic * magic;</span><br><span class="line">        double sqrtMagic = Math.sqrt(magic);</span><br><span class="line">        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);</span><br><span class="line">        dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);</span><br><span class="line">        double mgLat = lat + dLat;</span><br><span class="line">        double mgLon = lon + dLon;</span><br><span class="line">        return new Gps(mgLat, mgLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * wgs84到gcj02转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps wgs84_To_Gcj02(double lat, double lon) &#123;</span><br><span class="line">        return transform(lat, lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 简单的gcj02到wgs84坐标类型转换，只做了一次迭代</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84(double lat, double lon) &#123;</span><br><span class="line">        Gps gps = transform(lat, lon);</span><br><span class="line">        double lontitude = lon * 2 - gps.lon;</span><br><span class="line">        double latitude = lat * 2 - gps.lat;</span><br><span class="line">        return new Gps(latitude, lontitude);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 稍微精确一点的gcj02到wgs84转换</span><br><span class="line">     * @param lat</span><br><span class="line">     * @param lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Wgs84_exact(double lat,double lon) &#123;</span><br><span class="line">        if (outOfChina(lat, lon)) &#123;</span><br><span class="line">            return gcj02_To_Wgs84(lat, lon);</span><br><span class="line">        &#125;</span><br><span class="line">        double initDelta = 0.01;</span><br><span class="line">        double threshold = 0.000001;</span><br><span class="line">        double dLat = initDelta;</span><br><span class="line">        double dLon = initDelta;</span><br><span class="line">        double mLat = lat - dLat;</span><br><span class="line">        double mLon = lon - dLon;</span><br><span class="line">        double pLat = lat + dLat;</span><br><span class="line">        double pLon = lon + dLon;</span><br><span class="line">        double wgsLat = 0;</span><br><span class="line">        double wgsLon = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            wgsLat = (mLat + pLat) / 2;</span><br><span class="line">            wgsLon = (mLon + pLon) / 2;</span><br><span class="line">            Gps tmp = wgs84_To_Gcj02(wgsLat, wgsLon);</span><br><span class="line">            dLat = tmp.lat - lat;</span><br><span class="line">            dLon = tmp.lon - lon;</span><br><span class="line">            if ((Math.abs(dLat) &lt; threshold) &amp;&amp; (Math.abs(dLon) &lt; threshold)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dLat &gt; 0) &#123; pLat = wgsLat; &#125; else &#123; mLat = wgsLat;&#125;</span><br><span class="line">            if (dLon &gt; 0) &#123; pLon = wgsLon; &#125; else &#123; mLon = wgsLon;&#125;</span><br><span class="line"></span><br><span class="line">            if (++i &gt; 1000) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Gps(wgsLat, wgsLon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标是在火星坐标基础上做的二次加密</span><br><span class="line">     * @param gg_lat</span><br><span class="line">     * @param gg_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps gcj02_To_Bd09(double gg_lat, double gg_lon) &#123;</span><br><span class="line">        double x = gg_lon, y = gg_lat;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double bd_lon = z * Math.cos(theta) + 0.0065;</span><br><span class="line">        double bd_lat = z * Math.sin(theta) + 0.006;</span><br><span class="line">        return new Gps(bd_lat, bd_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 百度坐标与火星坐标逆向转换</span><br><span class="line">     * @param bd_lat</span><br><span class="line">     * @param bd_lon</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Gps bd09_To_Gcj02(double bd_lat, double bd_lon) &#123;</span><br><span class="line">        double x = bd_lon - 0.0065, y = bd_lat - 0.006;</span><br><span class="line">        double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);</span><br><span class="line">        double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);</span><br><span class="line">        double gg_lon = z * Math.cos(theta);</span><br><span class="line">        double gg_lat = z * Math.sin(theta);</span><br><span class="line">        return new Gps(gg_lat, gg_lon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Gps gps = new Gps(39.907270, 116.391213);</span><br><span class="line">        System.out.println(gps);//&#123;39.90727,116.391213&#125;</span><br><span class="line">        Gps gps2 = wgs84_To_Gcj02(gps.lat, gps.lon);</span><br><span class="line">        System.out.println(gps2);//&#123;39.90867122432153,116.39745410656687&#125;</span><br><span class="line">        Gps gps3 = gcj02_To_Wgs84(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps3);//&#123;39.907267736339556,116.3912105466475&#125;</span><br><span class="line">        Gps gps4 = gcj02_To_Wgs84_exact(gps2.lat, gps2.lon);</span><br><span class="line">        System.out.println(gps4);//&#123;39.90727046748559,116.39121326184032&#125; 相对一次迭代是精确了，但是好像也不是完全还原</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Gps&#123;</span><br><span class="line">    double lat,lon;</span><br><span class="line">    public Gps() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Gps(double lat,double lon)&#123;</span><br><span class="line">        this.lat = lat;</span><br><span class="line">        this.lon = lon;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;&#123;&quot;+lat+&quot;,&quot;+lon+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feinifi/article/details/120547127">https://blog.csdn.net/feinifi/article/details/120547127</a></p>
<h3 id="mysql-java-redis三种地理位置算法"><a href="#mysql-java-redis三种地理位置算法" class="headerlink" title="mysql,java,redis三种地理位置算法"></a>mysql,java,redis三种地理位置算法</h3><p>获取附近信息，以用户当前位置为中心点，指定范围为半径，查询出在该圆圈内的所有信息。</p>
<h4 id="MySQL-基于st-distance函数"><a href="#MySQL-基于st-distance函数" class="headerlink" title="MySQL 基于st_distance函数"></a>MySQL 基于st_distance函数</h4><p>mysql 5.6.1 加入了空间数据支持功能，新增了st_*相关函数，可以非常方便的计算两个地理坐标点的距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	p.* </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		park_info.*,</span><br><span class="line">		st_distance (</span><br><span class="line">			point ( park_info.lng, park_info.lat ),</span><br><span class="line">		point ( 116.403694, 39.913828 ))* 111195 AS distance </span><br><span class="line">	FROM</span><br><span class="line">		park_info park_info </span><br><span class="line">	) p </span><br><span class="line">WHERE</span><br><span class="line">	p.distance &lt; 10000</span><br></pre></td></tr></table></figure>


<h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class DistanceUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 地球半径,单位 km</span><br><span class="line">     */</span><br><span class="line">    private static final double EARTH_RADIUS = 6378137;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据经纬度，计算两点间的距离</span><br><span class="line">     *</span><br><span class="line">     * @param longitude1 第一个点的经度</span><br><span class="line">     * @param latitude1  第一个点的纬度</span><br><span class="line">     * @param longitude2 第二个点的经度</span><br><span class="line">     * @param latitude2  第二个点的纬度</span><br><span class="line">     * @return 返回距离 单位米</span><br><span class="line">     */</span><br><span class="line">    public static double getDistance(double longitude1, double latitude1, double longitude2, double latitude2) &#123;</span><br><span class="line">        // 纬度</span><br><span class="line">        double lat1 = Math.toRadians(latitude1);</span><br><span class="line">        double lat2 = Math.toRadians(latitude2);</span><br><span class="line">        // 经度</span><br><span class="line">        double lng1 = Math.toRadians(longitude1);</span><br><span class="line">        double lng2 = Math.toRadians(longitude2);</span><br><span class="line">        // 纬度之差</span><br><span class="line">        double a = lat1 - lat2;</span><br><span class="line">        // 经度之差</span><br><span class="line">        double b = lng1 - lng2;</span><br><span class="line">        // 计算两点距离的公式</span><br><span class="line">        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) +</span><br><span class="line">                Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(b / 2), 2)));</span><br><span class="line">        // 弧长乘地球半径, 返回单位: 米</span><br><span class="line">        s =  s * EARTH_RADIUS;</span><br><span class="line">        return Math.round(s * 10000) / 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double distance = DistanceUtils.getDistance(109.49081, 36.596537, 111.128971, 37.524041);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance);</span><br><span class="line">        double distance1 = DistanceUtils.getDistance(109.500603,36.594125, 111.151761,37.52671);</span><br><span class="line">        log.info(&quot;distance=&#123;&#125;&quot;, distance1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key 停车场地理位置键</span><br><span class="line"> * @param lng 坐标</span><br><span class="line"> * @param lat 坐标</span><br><span class="line"> * @param t 停车场标示</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long addGeo(String key, Double lng, Double lat, T t) &#123;</span><br><span class="line">    RedisGeoCommands.GeoLocation&lt;T&gt; geoLocation = new RedisGeoCommands.GeoLocation&lt;&gt;(t, new Point(lng, lat));</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, geoLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 批量添加</span><br><span class="line"> * @param key</span><br><span class="line"> * @param list</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Long batchAddGeo(String key, List&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt; list) &#123;</span><br><span class="line">    return redisTemplate.opsForGeo().add(key, list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除经纬度</span><br><span class="line"> *</span><br><span class="line"> * @param key</span><br><span class="line"> */</span><br><span class="line">public void removeGeo(String key, T... t) &#123;</span><br><span class="line">    redisTemplate.opsForGeo().remove(key, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取经纬度指定距离内的数据</span><br><span class="line"> *</span><br><span class="line"> * @param lng</span><br><span class="line"> * @param lat</span><br><span class="line"> * @param distance</span><br><span class="line"> * @param key</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt;</span><br><span class="line">getCacheListByPointAndDistance(Double lng, Double lat, Double distance, String key) &#123;</span><br><span class="line">    Circle circle = new Circle(new Point(lng, lat), new Distance(distance, Metrics.KILOMETERS));</span><br><span class="line">    RedisGeoCommands.GeoRadiusCommandArgs args =</span><br><span class="line">            // includeCoordinates：返回结果包含坐标信息</span><br><span class="line">            // includeDistance：返回结果包含具中心坐标距离信息</span><br><span class="line">            // sortAscending：按照距离升序排序</span><br><span class="line">            // sortDescending：按照距离降序排序</span><br><span class="line">            // limit：返回结果数量限制</span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates()</span><br><span class="line">                    .sortAscending();</span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;T&gt;&gt;&gt; content =</span><br><span class="line">            redisTemplate.opsForGeo().radius(key, circle, args).getContent();</span><br><span class="line">    return content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Elasticsearch-Geo"><a href="#Elasticsearch-Geo" class="headerlink" title="Elasticsearch Geo"></a>Elasticsearch Geo</h4><p>【toStudy】</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37923316/article/details/108978101">https://blog.csdn.net/m0_37923316/article/details/108978101</a></p>
<h3 id="点到线的最近线段"><a href="#点到线的最近线段" class="headerlink" title="点到线的最近线段"></a>点到线的最近线段</h3><p>使用JTSFactoryFinder 创建GeometryFactory，是在org.geotools.geometry.jts下的。</p>
<p>需要导入的包：gt-main、gt-metadata</p>
<p><code>GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory(null);</code></p>
<p>返回点到线段的最近线段，可能是垂线，不能垂直的话，是点到线段两端点的连线。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testNearest() throws ParseException &#123;</span><br><span class="line">    GeometryFactory geometryFactory = new GeometryFactory();</span><br><span class="line">    Coordinate coordinate = new Coordinate(1, 1);</span><br><span class="line">    WKTReader reader = new WKTReader(geometryFactory);</span><br><span class="line">    String wkt = &quot;LINESTRING(0 0, 1 0, 2 0)&quot;;</span><br><span class="line">    LineString road = (LineString) reader.read(wkt);</span><br><span class="line">    Coordinate[] shadow = com.vividsolutions.jts.operation.distance.DistanceOp.nearestPoints(road,</span><br><span class="line">            geometryFactory.createPoint(coordinate));</span><br><span class="line">    System.out.println(Arrays.toString(shadow)); //[(1.0, 0.0, NaN), (1.0, 1.0, NaN)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="道格拉斯抽稀"><a href="#道格拉斯抽稀" class="headerlink" title="道格拉斯抽稀"></a>道格拉斯抽稀</h3><p>道格拉斯-普克算法（Douglas-Peuker算法）是我们常用的一种轨迹点的抽稀算法，抽稀出来的点可以尽可能的维持原先轨迹点的大体轮廓，剔除一些非必要的点。</p>
<p>道格拉斯-普克原理：<br>（1）在曲线首尾两点A，B之间连接一条直线AB，该直线为曲线的弦；<br>（2）得到曲线上离该直线段距离最大的点C，计算其与AB的距离d；<br>（3）比较该距离与预先给定的阈值threshold的大小，如果小于threshold，则该直线段作为曲线的近似，该段曲线处理完毕。<br>（4）如果距离大于阈值，则用C将曲线分为两段AC和BC，并分别对两段取信进行1~3的处理。<br>（5）当所有曲线都处理完毕时，依次连接各个分割点形成的折线，即可以作为曲线的近似。</p>
<p>java使用方法：jts是一套用于处理几何要素拓扑关系的函数库，提供了基本二位平面线形图形运算算法实现。</p>
<p>mvn依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jts&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326);</span><br><span class="line">WKTReader wktReader = new WKTReader(geometryFactory);</span><br><span class="line">Geometry geometry1 = wktReader.read(&quot;lineString(0 0, 1 1, 2 0)&quot;);</span><br><span class="line">Geometry geometry2 = DouglasPeuckerSimplifier.simplify(geometry1, 0.9);</span><br><span class="line">WKTWriter wktWriter = new WKTWriter();</span><br><span class="line">String res = wktWriter.write(geometry2);</span><br><span class="line">System.out.println(res);  //LINESTRING (0 0, 1 1, 2 0)</span><br></pre></td></tr></table></figure>

<p><code>Geometry simplify(Geometry geom, double distanceTolerance)</code>中的参数distanceTolerance是跟首尾点距离比(单纯平方间的距离，不是实际m的距离)。</p>
<p>自己实现道格拉斯抽稀(python)：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/046bcaeb2cb6">https://www.jianshu.com/p/046bcaeb2cb6</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/21/myblog/JAVA/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">java多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-21 10:52:08" itemprop="dateCreated datePublished" datetime="2022-05-21T10:52:08+08:00">2022-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-01 18:32:22" itemprop="dateModified" datetime="2023-05-01T18:32:22+08:00">2023-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程池Executor、ExecutorService、Executors三者关系"><a href="#线程池Executor、ExecutorService、Executors三者关系" class="headerlink" title="线程池Executor、ExecutorService、Executors三者关系"></a>线程池Executor、ExecutorService、Executors三者关系</h3><p><img src="/images/Executor%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<p>层次关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;&#125;</span><br><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;&#125;</span><br><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125;</span><br><span class="line">public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1.ExecutorService 接口继承了Executor 接口，是Executor 的子接口。</p>
<p>2.Executor接口中定义了execute()方法，用来接收一个Runnable接口的对象，而ExecutorService接口中定义的submit()方法可以接收Runnable和Callable接口对象。</p>
<p>3.Executor接口中execute()方法不返回任何结果，而ExecutorService接口中submit()方法可以通过一个 Future 对象返回运算结果。</p>
<p>4.Executor和ExecutorService除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。<br>比如：调用 shutDown() 方法终止线程池。</p>
<p>5.Executors 是一个工具类，类似于 Collections。Executors 类提供工厂方法用来创建不同类型的线程池。比如:<br>　　 Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池，<br>　　 Executors.newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，<br>　　 Executors.newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>　　 Executors.newScheduledThreadPool(int corePoolSize) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whx20100101/p/9862392.html">https://www.cnblogs.com/whx20100101/p/9862392.html</a></p>
<p>使用Executors还是ExecutorService？<br>当线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。总共有四种策略：<br>AbortPolicy: 直接抛异常<br>CallerRunsPolicy: 用调用者的线程来运行任务<br>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>DiscardPolicy 直接将新任务丢弃</p>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<p>所以我们可以根据需要创建 ThreadPoolExecutor(ExecutorService接口的实现类) 对象，自定义一些参数，而不是调用 Executors 的工厂方法创建。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43921491/article/details/115717604">https://blog.csdn.net/weixin_43921491/article/details/115717604</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(...);</span><br><span class="line">executor.submit(()-&gt;单条语句);</span><br><span class="line"></span><br><span class="line">executor.submit(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="线程池java-util-concurrent-ThreadPoolExecutor"><a href="#线程池java-util-concurrent-ThreadPoolExecutor" class="headerlink" title="线程池java.util.concurrent.ThreadPoolExecutor"></a>线程池java.util.concurrent.ThreadPoolExecutor</h3><p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(int corePoolSize, </span><br><span class="line">int maximumPoolSize, </span><br><span class="line">long keepAliveTime, </span><br><span class="line">TimeUnit unit, </span><br><span class="line">BlockingQueue workQueue,  </span><br><span class="line">RejectedExecutionHandler handler) </span><br><span class="line"></span><br><span class="line">corePoolSize： 线程池维护线程的最少数量 </span><br><span class="line">maximumPoolSize：线程池维护线程的最大数量 </span><br><span class="line">keepAliveTime： 线程池维护线程所允许的空闲时间 </span><br><span class="line">unit： 线程池维护线程所允许的空闲时间的单位 </span><br><span class="line">workQueue： 线程池所使用的缓冲队列 </span><br><span class="line">handler： 线程池对拒绝任务的处理策略 </span><br><span class="line"></span><br><span class="line">unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性： </span><br><span class="line">NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。 </span><br><span class="line"></span><br><span class="line">workQueue可用的队列类是：java.util.concurrent.ArrayBlockingQueue </span><br><span class="line"></span><br><span class="line">handler有四个选择： </span><br><span class="line">（1）ThreadPoolExecutor.AbortPolicy()   抛出java.util.concurrent.RejectedExecutionException异常 </span><br><span class="line">（2）ThreadPoolExecutor.CallerRunsPolicy()  重试添加当前的任务，他会自动重复调用execute()方法 </span><br><span class="line">（3）ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务 （等待队列里面最早进入的）</span><br><span class="line">（4）ThreadPoolExecutor.DiscardPolicy()     抛弃当前的任务 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个任务（ Runnable类型的对象）通过execute(Runnable)方法欲添加到线程池时：<br>1、如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br>2、如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br>3、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量小于maximumPoolSize，建新的线程来处理被添加的任务。<br>4、如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的线程数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 </p>
<p>也就是：处理任务的优先级为：<br>核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。 </p>
<p>当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 </p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws InterruptedException &#123;</span><br><span class="line">    ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 3, TimeUnit.SECONDS,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(3), new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    class ThreadPoolTask implements Runnable, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 0;</span><br><span class="line">        // 保存任务所需要的数据</span><br><span class="line">        private Object threadPoolTaskData;</span><br><span class="line"></span><br><span class="line">        ThreadPoolTask(Object tasks) &#123;</span><br><span class="line">            this.threadPoolTaskData = tasks;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + getTask());</span><br><span class="line">            try &#123;</span><br><span class="line">                // //便于观察，等待一段时间</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            threadPoolTaskData = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getTask() &#123;</span><br><span class="line">            return this.threadPoolTaskData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= 8; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 产生一个任务，并将其加入到线程池</span><br><span class="line">            String task = &quot;task@ &quot; + i;</span><br><span class="line">            System.out.println(&quot;put &quot; + task);</span><br><span class="line">            threadPool.submit(new ThreadPoolTask(task));</span><br><span class="line">            // 便于观察，等待一段时间</span><br><span class="line">            Thread.sleep(2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">    // 也可以直接用lambda表达式往线程池里加线程</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;start ..&quot; + &quot;lambda&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">put task@ 1</span><br><span class="line">pool-1-thread-1start ..task@ 1</span><br><span class="line">put task@ 2</span><br><span class="line">pool-1-thread-2start ..task@ 2</span><br><span class="line">put task@ 3</span><br><span class="line">put task@ 4</span><br><span class="line">put task@ 5</span><br><span class="line">put task@ 6</span><br><span class="line">pool-1-thread-3start ..task@ 6</span><br><span class="line">put task@ 7</span><br><span class="line">pool-1-thread-4start ..task@ 7</span><br><span class="line">put task@ 8</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util....</span><br><span class="line">pool-1-thread-1start ..task@ 3</span><br><span class="line">pool-1-thread-2start ..task@ 4</span><br><span class="line">pool-1-thread-3start ..task@ 5</span><br><span class="line"></span><br><span class="line">因为线程加入线程池很快，线程都还没处理完，所以最开始先2个线程，</span><br><span class="line">然后3个加入队列，然后再来2个，扩大线程池，再一个就抛出异常了，</span><br><span class="line">慢慢队列中的三个会被执行。</span><br><span class="line"></span><br><span class="line">如果是DiscardOldestPolicy策略，就把最早进入队列的怼出去。</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/abcwywht/article/details/54744152">https://blog.csdn.net/abcwywht/article/details/54744152</a></p>
<p>✅规范创建线程池<br>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。目的是规避资源耗尽的风险。FixedThreadPool和SingleThreadPool允许请求队列长度Integer.MAX_VALUE，可能堆积大量请求，OOM。CachedThreadPool允许创建线程数量Integer.MAX_VALUE，可能创建大量线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(2, 4, 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;Runnable&gt;(6),</span><br><span class="line">                new ThreadFactory() &#123;</span><br><span class="line">                    AtomicInteger id = new AtomicInteger(0);</span><br><span class="line">                    @Override</span><br><span class="line">                    public Thread newThread(Runnable r) &#123;</span><br><span class="line">                        return new Thread(r, &quot;thread-poolName-&quot; + id.incrementAndGet());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        threadPool.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //可以直接用lambda表达式：</span><br><span class="line">        threadPool.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面没加线程池到最大和队列满了该怎么办的参数，可以加。</p>
<h3 id="ThreadPoolExecutor的execute方法和submit方法"><a href="#ThreadPoolExecutor的execute方法和submit方法" class="headerlink" title="ThreadPoolExecutor的execute方法和submit方法"></a>ThreadPoolExecutor的execute方法和submit方法</h3><p>1、execute是Executor接口的方法，而submit是ExecutorService的方法，并且ExecutorService接口继承了Executor接口。</p>
<p>2、execute只接受Runnable参数，没有返回值；而submit可以接受Runnable参数和Callable参数，并且返回了Future对象，可以进行任务取消、获取任务结果、判断任务是否执行完毕/取消等操作。</p>
<p>3、submit会对Runnable或Callable入参封装成RunnableFuture对象（同时继承了Runnable接口和Future接口），调用execute方法并返回。FutureTask是实现了RunnableFuture接口</p>
<p>4、通过execute方法提交的任务如果出现异常则直接抛出原异常，是在线程池中的线程中；而submit方法是捕获了异常的，只有当调用Future的get方法时，才会抛出ExecutionException异常，且是在调用get方法的线程。（FutureTask则是将catch到的异常存下来，在get的时候再去判断任务执行状态，如果任务状态是异常，则再抛出ExecutionException异常。）</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/happyyear1/article/details/122378013">https://blog.csdn.net/happyyear1/article/details/122378013</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Zhang____/article/details/121866974">https://blog.csdn.net/Mr_Zhang____/article/details/121866974</a></p>
<h3 id="ThreadPoolExecutor的submit返回值Future"><a href="#ThreadPoolExecutor的submit返回值Future" class="headerlink" title="ThreadPoolExecutor的submit返回值Future"></a>ThreadPoolExecutor的submit返回值Future</h3><p>✅Executor接口中的execute方法：<br>这个方法是没有返回值的，而且只接受Runnable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ExecutorService接口中的submit方法：<br>这个方法接收两种参数，Callable和Runnable。返回值是Future。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>✅Callable接口和Runnable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">  V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Runnable &#123;</span><br><span class="line">  public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：<br>1、Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值<br>2、Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。</p>
<p>✅Future接口<br>通过他可以获得任务执行的返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean var1);</span><br><span class="line"> </span><br><span class="line">    boolean isCancelled();</span><br><span class="line"> </span><br><span class="line">    boolean isDone();</span><br><span class="line"> </span><br><span class="line">    V get() throws InterruptedException, ExecutionException;  //获取返回值</span><br><span class="line"> </span><br><span class="line">    V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅submit(Callable task)实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(2);</span><br><span class="line">        //创建一个Callable，3秒后返回String类型</span><br><span class="line">        Callable myCallable = new Callable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">                return &quot;call方法返回值&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">        Future future = executor.submit(myCallable);</span><br><span class="line">        System.out.println(&quot;提交任务之后，获取结果之前 &quot;+getStringDate());</span><br><span class="line">        System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">        System.out.println(&quot;获取到结果之后 &quot;+getStringDate());</span><br><span class="line">    &#125;</span><br><span class="line">    public static String getStringDate() &#123;</span><br><span class="line">        Date currentTime = new Date();</span><br><span class="line">        SimpleDateFormat formatter = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line">        String dateString = formatter.format(currentTime);</span><br><span class="line">        return dateString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">提交任务之前 09:09:28</span><br><span class="line">提交任务之后，获取结果之前 09:09:29</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取到结果之后 09:09:32</span><br></pre></td></tr></table></figure>

<p>✅get()方法的阻塞性</p>
<p>通过上面的输出可以看到，在调用submit提交任务之后，主线程本来是继续运行了。但是运行到future.get()的时候就阻塞住了，一直等到任务执行完毕，拿到了返回的返回值，主线程才会继续运行。</p>
<p>这里注意一下，他的阻塞性是因为调用get()方法时，任务还没有执行完，所以会一直等到任务完成，形成了阻塞。</p>
<p>任务是在调用submit方法时就开始执行了，如果在调用get()方法时，任务已经执行完毕，那么就不会造成阻塞。</p>
<p>submit多个任务时，总阻塞时间是最长的那个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Callable myCallable = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(&quot;calld方法执行了&quot;);</span><br><span class="line">        return &quot;call方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Callable myCallable2 = new Callable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;calld2方法执行了&quot;);</span><br><span class="line">        return &quot;call2方法返回值&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(&quot;提交任务之前 &quot;+getStringDate());</span><br><span class="line">Future future = executor.submit(myCallable);</span><br><span class="line">Future future2 = executor.submit(myCallable2);</span><br><span class="line">System.out.println(&quot;提交任务之后 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;开始获取第一个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值: &quot;+future.get());</span><br><span class="line">System.out.println(&quot;获取第一个返回值结束，开始获取第二个返回值 &quot;+getStringDate());</span><br><span class="line">System.out.println(&quot;获取返回值2: &quot;+future2.get());</span><br><span class="line">System.out.println(&quot;获取第二个返回值结束 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">提交任务之前 14:14:47</span><br><span class="line">提交任务之后 14:14:48</span><br><span class="line">开始获取第一个返回值 14:14:48</span><br><span class="line">calld2方法执行了</span><br><span class="line">calld方法执行了</span><br><span class="line">获取返回值: call方法返回值</span><br><span class="line">获取第一个返回值结束，开始获取第二个返回值 14:14:53</span><br><span class="line">获取返回值2: call2方法返回值</span><br><span class="line">获取第二个返回值结束 14:14:53</span><br></pre></td></tr></table></figure>

<p>✅submit(Runnable task, T result)实现</p>
<p>虽然submit传入Runnable不能直接返回内容，但是可以通过submit(Runnable task, T result)传入一个载体，通过这个载体获取返回值。这个其实不能算返回值了，是交给线程处理一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(2); //不推荐这样创建</span><br><span class="line">    Result res = new Result();</span><br><span class="line">    Future&lt;Result&gt; future = executor.submit(new MyThread(res), res);</span><br><span class="line">    System.out.println(&quot;返回的结果  name: &quot; + future.get().getName()); //新名字</span><br><span class="line">    System.out.println(&quot;原来的Data  name: &quot; + res.getName()); //原来的也变成了新名字</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyThread implements Runnable &#123;</span><br><span class="line">    private Result result;</span><br><span class="line">    public MyThread(Result result) &#123;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            System.out.println(&quot;线程  执行:&quot;);</span><br><span class="line">            result.setName(&quot;新名字&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public static class Result &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️T是Runnable里面的属性，创建时传入，线程中赋值，get方法拿到，之前传入的变量也跟着变化。</p>
<p>✅get(long var1, TimeUnit var3)<br>前面都是用的get()方法获取返回值，那么因为这个方法是阻塞的，有时需要等很久。所以有时候需要设置超时时间。</p>
<p>get(long var1, TimeUnit var3)这个方法就是设置等待时间的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future future1 = executor.submit(myCallable);</span><br><span class="line">System.out.println(&quot;开始拿结果 &quot;+getStringDate());</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;返回的结果是： &quot;+future1.get(3, TimeUnit.SECONDS)+ &quot; &quot;+getStringDate());</span><br><span class="line">&#125; catch (TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(&quot;超时了 &quot;+getStringDate());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;结束拿结果 &quot;+getStringDate());</span><br><span class="line"></span><br><span class="line">过了三秒就抛出超时异常了，主线程继续运行，不会再继续阻塞。</span><br></pre></td></tr></table></figure>


<p>✅execute与submit的异常处理</p>
<p>使用submit方法还有一个特点就是，他的异常可以在主线程中catch到。<br>而使用execute方法执行任务是捕捉不到异常的。<br>用下面这个Runnable来说,这个 里面一定会抛出一个异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable myRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        executor.execute(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用execute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            executor.execute(myRunnable);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不会输出抓到异常那行日志，输出是在线程pool-1-thread-1中，并不是在主线程中。说明主线程的catch不能捕捉到这个异常。异常在线程中直接抛出。</p>
<p>使用submit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">           Future future1= executor.submit(myCallable);</span><br><span class="line">            future1.get();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;抓到异常 &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以抓到异常。得有get方法。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zdx1515888659/article/details/109537577">https://blog.csdn.net/zdx1515888659/article/details/109537577</a></p>
<p>✅项目中的线程池中异常捕获<br>项目中想将线程池中线程的异常在外面捕获到，传递给前端。<br>所以用submit方法，返回Future&lt;?&gt;，在submit方法后直接get，future.get()，有两个异常需要处理：ExecutionException、InterruptException，直接方法上throws出去。调用这个方法的方法要不也throws（给前端透出异常），要不就try..catch..打log（这样无法给前端透出异常）。<br>⚠️注意：用get方法相当于是阻塞了，本来起线程，把要执行的动作交给线程池里的线程(submit)，然后不需要管线程执行完就直接退出干别的了，加了get的话，就要等线程执行完了。如果是大量任务一次交给线程池(线程池里的队列)，需要考虑get带来的阻塞性是否能接受。本来想异步，加了get捕获异常之后，变成同步的了。</p>
<p>🤔线程池中的线程出现异常，get方法这里会报异常，如果是throws，异常抛出到外面，线程池里的其他线程不受影响。外面的方法如果没有catch会中断。</p>
<p>🤔那么问题来了，get超时了的话，线程池中的线程还在继续做吗？<br>首先，countDownLatch超时了是继续做的。<br>future.get(2,TimeUnit.SECOND);<br>如果超时了，线程中断，会报异常TimeOutExcepTion，看是不是要捕获了。<br>即使捕获了，线程也不会继续执行了。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>场景：做多线程并行优化，多线程写入一个文件，首先输入流是可以共享的，只是需要重新定义一个做传递（不管是普通变量还是引用变量），但是for循环里面线程submit完，直接走到主线程上传文件的部分，这时线程池内线程还没往文件里写东西，上传了一个空文件。</p>
<p>想要：做一个同步，知道线程都执行完了，才进行下一步，起到阻塞的作用。</p>
<p>CountDownLatch可以做到，当做一个计数器，计算多少个线程执行完了：</p>
<p>让一些线程阻塞直到另外一些完成后才被唤醒。<br>CountDownLatch主要有两个方法：<br>（1）当一个或多个线程调用await方法时,线程会被阻塞，直到满足条件.<br>（2）其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/li1325169021/article/details/122353217">https://blog.csdn.net/li1325169021/article/details/122353217</a></p>
<p>实例：模拟公司所有员工都下班后，值班人员锁门离开公司。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void closeDoor() throws InterruptedException &#123;</span><br><span class="line">        //创建CountDownLatch,初始容量为10，模拟10名员工</span><br><span class="line">        CountDownLatch countDownLatch=new CountDownLatch(10);</span><br><span class="line">        for (int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;忙完工作，下班。&quot;);</span><br><span class="line">                //计数器减1</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,&quot;员工编号：&quot;+String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t值班人员锁门离开公司&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三步：</p>
<p>1、线程池外定义初始计数：<br>CountDownLatch countDownLatch=new CountDownLatch(10);<br>2、线程池内executorService.submit()的线程new Runnable(){@Overide public void run() {}} run方法内，线程执行完毕后：<br>countDownLatch.countDown();<br>3、最后要进行操作前：<br>countDownLatch.await();</p>
<p>✅countDownLatch超时终止：<br><code>latch.await(10, TimeUnit.SECONDS);  //等待10秒后，如果线程没有执行完，则不再等待，进入后续</code></p>
<p>超时后，线程依然会执行，不会中断。</p>
<h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>1、public interface ScheduledExecutorService extends ExecutorService 延迟或定期执行任务。 </p>
<p>2、schedule 方法使用各种延迟创建任务，并返回一个可用于取消或检查执行的任务对象</p>
<p>3、scheduleAtFixedRate 和 scheduleWithFixedDelay 方法创建并执行某些在取消前一直定期运行的任务</p>
<p>4、所有的 schedule 方法都接受相对延迟和周期作为参数，而不是绝对的时间或日期</p>
<p>5、SheduleExecutorService 是JDK 1.5出来的，比以前的 Timer 性能好</p>
<p>Timer用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    TimerTask task = new TimerTask() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Task performed on: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;later: &quot; + new Date() + &quot;n&quot; +</span><br><span class="line">                    &quot;Thread&#x27;s name: &quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer timer = new Timer(&quot;Timer&quot;);</span><br><span class="line"></span><br><span class="line">    long delay = 100L;</span><br><span class="line">    // 第一个参数是TimeTask对象，第二个参数是延迟（只有第二个参数时执行一次），第三个参数是周期执行的周期</span><br><span class="line">    timer.schedule(task, delay, 4000);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Timer中，如果任务执行时间&gt;周期，则会等待上一个任务执行完，立马执行第二个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test5() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; run : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果任务执行时间&gt;周期，则会等上一个执行完立马执行下一个。</p>
<p>✅用ScheduledExecutorService.scheduleAtFixedRate：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test6() throws InterruptedException &#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; go : &quot;+ System.currentTimeMillis());</span><br><span class="line">    &#125;, 0, 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与scheduleAtFixedRate：不同的是：这个是等上一个执行完，delay多长时间后，再执行下一个。</p>
<p>✅ScheduledExecutorService对象的创建方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(3);</span><br><span class="line">创建一个线程池，它可安排在给定延迟后运行任务或者定期地执行任务。</span><br><span class="line">corePoolSize - 池中所保存的线程数，即使线程是空闲的也包括在内。</span><br><span class="line">运行发现有多个线程执行，但是效果一样。</span><br><span class="line"></span><br><span class="line">可以传参ThreadFactory，用来命名和设置守护线程</span><br><span class="line">ScheduledExecutorService executorService2 = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;</span><br><span class="line">    Thread t = new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    t.setDaemon(true); //设置为守护线程</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2、Executors工具类来创建</span><br><span class="line">ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行任务。</span><br><span class="line">可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。 </span><br><span class="line">同样这是一个无界的任务队列，即虽然线程只有一个，但是新增的任务会在队列中排队等待执行</span><br><span class="line"></span><br><span class="line">3、用ScheduledExecutorService 的实现类 ScheduledThreadPoolExecutor（推荐）</span><br><span class="line">ScheduledExecutorService executorService1 = new ScheduledThreadPoolExecutor(1);</span><br></pre></td></tr></table></figure>

<p>✅规范创建：<br>要使用带有ThreadFactory参数的ScheduledThreadPoolExecutor构造方法创建，这样可以方便设置线程名字。方便出措时回溯。并且提供自定义的ThreadFactory实现或三方实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService3 = new ScheduledThreadPoolExecutor(1, new ThreadFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;myThread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService executorService4 = new ScheduledThreadPoolExecutor(1,</span><br><span class="line">    new BasicThreadFactory.Builder().namingPattern(&quot;myThread&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure>


<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>用来创建线程的，其中也只是有一个newthread方法。</p>
<p>作用：<br>给线程命名，查看创建线程数<br>给线程设置是否是后台运行<br>设置线程优先级</p>
<p>自定义ThreadFactory：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.factory;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadFactory;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class MyThreadFactory implements ThreadFactory&#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    private boolean isDaemon;</span><br><span class="line"></span><br><span class="line">    public MyThreadFactory(boolean isDaemon)&#123;</span><br><span class="line">        this.isDaemon = isDaemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">        Thread thread =  new MyWorkThread(atomicInteger,r);</span><br><span class="line">        thread.setDaemon(isDaemon);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(new MyThreadFactory(false));</span><br><span class="line">        for (int i=0;i&lt;1000;i++)&#123;</span><br><span class="line">            executorService.execute(new TestRunnable(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestRunnable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        private String msg;</span><br><span class="line"></span><br><span class="line">        public TestRunnable(String msg)&#123;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;runnable:&quot;+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅三种创建 ThreadFactory 的方式</p>
<p>第一种 CustomizableThreadFactory<br>Spring 框架提供的 CustomizableThreadFactory。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory springThreadFactory = new CustomizableThreadFactory(&quot;springThread-pool-&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种 ThreadFactoryBuilder<br>Google guava 工具类 提供的 ThreadFactoryBuilder ,使用链式方法创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory guavaThreadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;retryClient-pool-&quot;).build();</span><br><span class="line">//-pool-后面加%d ？</span><br></pre></td></tr></table></figure>

<p>第三种 BasicThreadFactory<br>Apache commons-lang3 提供的 BasicThreadFactory.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory basicThreadFactory = new BasicThreadFactory.Builder().namingPattern(&quot;basicThreadFactory-&quot;).build();</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010648555/article/details/106137206/">https://blog.csdn.net/u010648555/article/details/106137206/</a></p>
<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><p>进程：操作系统结构的基础、操作系统进行资源分配和调度的独立单元<br>线程：进程中独立运行的子任务，程序执行的单元。<br>例如：启动jvm相当于起了一个进程，jvm内：main方法、垃圾回收等相当于多个线程。<br>cpu是运算和控制的中心，在cpu的运行过程中，同一时刻只能执行一个进程。<br>多线程下，cpu在不同的线程之间进行切换，多线程不一定比单线程快。<br>多线程执行时，执行顺序是随机的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);  //休息1s，以毫秒为单位。</span><br><span class="line"></span><br><span class="line">新建Thread线程：</span><br><span class="line">Thread thread = new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        dosomething();</span><br><span class="line">    &#125;, &quot;name&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h4 id="start、run、join方法"><a href="#start、run、join方法" class="headerlink" title="start、run、join方法"></a>start、run、join方法</h4><p>start： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。 </p>
<p>run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
<p>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p>
<p>join方法在线程外使用，表示等待thread线程执行完毕，再继续执行当前join方法所在的线程。在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<p>✅多线程累加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 线程安全的累加</span><br><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">/**</span><br><span class="line">    * 创建线程</span><br><span class="line">    */</span><br><span class="line">class CreateThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private final Object lock = new Object(); //使用一个Java对象作为一个锁</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (num &lt;= 100) &#123;</span><br><span class="line">                    System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot;  num: &quot; + num );</span><br><span class="line">                    num++;</span><br><span class="line">                    lock.notifyAll(); //不加也一样</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必须共用一个Runnable</span><br><span class="line">CreateThread myThread1 = new CreateThread();</span><br><span class="line">Thread thread1 = new Thread(myThread1, &quot;thread1&quot;);</span><br><span class="line">Thread thread2 = new Thread(myThread1, &quot;thread2&quot;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅线程休眠等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws InterruptedException &#123;</span><br><span class="line">    // 线程类还必须放前面</span><br><span class="line">    class CreateThread1 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程执行&quot;);</span><br><span class="line">            Thread.yield(); //线程让步</span><br><span class="line">            System.out.println(&quot;继续执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread thread1 = new Thread(new CreateThread1(), &quot;thread1&quot;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();  //插队执行</span><br><span class="line">    System.out.println(&quot;main线程&quot;);</span><br><span class="line">    Thread.sleep(1000 * 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>单测方法有一个问题，当单测方法结束的时候，里面的线程也要结束，不管是不是执行完成。单测方法结束的时候会把里面的资源释放掉，导致里面的线程提前结束。<br>结论：尽量不要在test中开启线程，开启的话，sleep一下，等线程执行完。</p>
<p>但是在main方法中，main方法执行完以后子线程并不会退出，因为子线程是非守护线程。</p>
<p>首先，JVM程序在什么情况下能够正常退出<br>The Java Virtual Machine exits when the only threads running are all daemon threads.<br>当JVM中不存在任何一个正在运行的非守护线程时，则JVM进程即会退出。<br>main线程是一个非守护线程。只剩下守护线程，就会退出。</p>
<p>什么是守护线程？<br>在Java中有两类线程：</p>
<ul>
<li>User Thread(用户线程)</li>
<li>Daemon Thread(守护线程)</li>
</ul>
<p>JVM中的垃圾回收就是典型的守护线程，当JVM要退出时，如果垃圾回收线程还在运行，导致程序无法退出。这就很尴尬了。守护线程主要是为了给其他的线程提供服务，比如说计时器，清空高速缓存等等操作。当被守护线程死亡，守护线程往往也会死亡，当虚拟机中只剩下守护线程时，虚拟机就会退出，因为此时也没有运行程序的必要了</p>
<p>守护线程经常被用来执行一些后台任务，如果你希望JVM退出时，线程能够正常退出，守护线程是你的首选。<br>守护线程应该永远不去访问固有资源，比如说文件或者数据库，因为它会在任何时候甚至一个操作的中间发生中断。</p>
<h3 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a>Synchronized同步锁</h3><p>synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p>
<p>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。</p>
<p>在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</p>
<p>synchronized的作用主要有三个：</p>
<p>原子性：确保线程互斥地访问同步代码；<br>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值” 来保证的；<br>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53474063/article/details/112389756">https://blog.csdn.net/m0_53474063/article/details/112389756</a></p>
<p>✅wait方法、notify方法、notifyAll方法</p>
<p>等待池：<br>假设线程 A 调用了锁对象的 wait() 方法，则 A线程就会释放该对象的锁(因为 wait() 方法必须出现在 synchronized 中，所以在执行 wait() 方法之前 A线程就已经拥有了该对象的锁)，同时线程 A进入到了该对象的等待池中。如果有其它线程调用了相同对象的 notifyAll() 方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，重新争夺锁的拥有权。如果另外的一个线程调用了相同对象的 notify() 方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。</p>
<p>锁池：<br>假设线程 A已经拥有了锁，而其它的线程想要调用该对象的 synchronized 方法(或者 synchronized 块)，其他未获得锁的线程在进入对象的 synchronized 方法之前都需要先获得该对象的锁的拥有权，但是该对象的锁目前正被 A线程拥有，所以这些线程就进入了该对象的锁池中。</p>
<h3 id="leeco-按序打印"><a href="#leeco-按序打印" class="headerlink" title="leeco 按序打印"></a>leeco 按序打印</h3><p>三个不同的线程 A、B、C，调用同一个类的三个不同的方法，想要异步调用三个线程，但是实现线程调用类中方法的同步输出。实现异步转同步的操作。<br>线程内run方法里面负责打印。<br>比如先调用second，再调用first，输出的是first-second。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object(); //得定义，不然是null</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 1) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 2) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printSecond.run();</span><br><span class="line">            index++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        synchronized(lock) &#123;</span><br><span class="line">            while(index != 3) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            printThird.run();</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leeco-交替打印FooBar"><a href="#leeco-交替打印FooBar" class="headerlink" title="leeco 交替打印FooBar"></a>leeco 交替打印FooBar</h3><p>两个不同的线程将会共用一个 FooBar实例，分别调用两个打印方法，保证线程是交替打印的。<br>需要加循环，循环里面再抢锁。如果不加循环，wait之后进入等待池，其他线程notifyAll，只是告诉其他线程可以抢锁，并不是唤醒其他线程让他们开始抢锁。抢锁这个动作还是需要自己触发的。<br>如果把循环加在synchronized里面就不对了，没有主动触发抢锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class FooBar &#123;</span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    public FooBar(int n) &#123;</span><br><span class="line">        this.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    private Integer index = 1;</span><br><span class="line"></span><br><span class="line">    public void foo(Runnable printFoo) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 1) &#123; //不需要while，if就行</span><br><span class="line">                //表示的是拿错锁了，释放掉</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    //wait进入锁池，再进来就是重新获锁进来了</span><br><span class="line">                &#125;</span><br><span class="line">                //锁拿对了，就进行处理</span><br><span class="line">                printFoo.run();</span><br><span class="line">                index =2;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void bar(Runnable printBar) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                if(index != 2) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                index =1;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="synchronized的对象锁和类锁"><a href="#synchronized的对象锁和类锁" class="headerlink" title="synchronized的对象锁和类锁"></a>synchronized的对象锁和类锁</h3><p>上面的两个leeco例子中，因为是创建一个对象进行调用，多线程共享那个lock，所以lock不需要static，只需要对象锁。但是如果创建多个对象调用，就需要类锁了。（比如接口的方法要控制多个请求同步）</p>
<p>synchronized关键字可以用在方法和代码块上。这些方法或者代码块可以使静态的也可以是非静态的。</p>
<p>对象锁-一个对象一把锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁-一个类一把锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DemoClass &#123;</span><br><span class="line">    public synchronized static void demoMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass&#123;</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (DemoClass.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DemoClass &#123;</span><br><span class="line">    private final static Object lock = new Object();</span><br><span class="line">    public void demoMethod()&#123;</span><br><span class="line">        synchronized (lock)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类锁：static synchronized 是要控制类的所有实例的并发访问，static synchronized是限制多线程中该类的所有实例同时访问jvm中该类所对应的代码块。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-22 23:44</span><br><span class="line"> **/</span><br><span class="line">public class SynchroObject extends Thread &#123;</span><br><span class="line">    private static volatile int n = 0;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            add();</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(5);</span><br><span class="line">                //测试多线程的private变量，发现多个线程对象的private变量是不同的</span><br><span class="line">                System.out.println(&quot;lock hashcode:&quot; + lock.hashCode());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果同步方法是static的，则多线程正确同步</span><br><span class="line">    //如果同步方法不是static的，则不是正确同步</span><br><span class="line">    private static synchronized void add() &#123;</span><br><span class="line">        n++;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread threads[] = new Thread[100];</span><br><span class="line">        for (int i = 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = new SynchroObject();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.join(); //等待该线程终止</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot; n= &quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：<br>1、synchronized(this){/<em>区块</em>/} 作用域是当前对象。被synchronized修饰符修饰的实例方法，跟整个方法体被一个synchronized(this) { … } 包围住，意思完全一样。</p>
<p>2、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法。</p>
<p>3、根据java语言的规定，你不能在构造方法上使用synchronized关键字，这是非法的并且会导致编译错误。</p>
<p>转自：synchronized的对象锁和类锁：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZenoLiang/p/14713160.html">https://www.cnblogs.com/ZenoLiang/p/14713160.html</a></p>
<p>✅多线程synchronized变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-06-27 09:15</span><br><span class="line"> **/</span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建并开启4个线程，模拟四个售票窗口</span><br><span class="line">        SaleThread saleThread = new SaleThread();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口1&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口2&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口3&quot;).start();</span><br><span class="line">        new Thread(new SaleThread(), &quot;窗口4&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SaleThread implements Runnable&#123;</span><br><span class="line">    //大前提：票得是static的，除非创建线程共用一个SaleThread对象</span><br><span class="line">    //不共用Runnable对象的话，且票不是static的，则每个线程各自卖</span><br><span class="line">    private static Integer tickets = 100;  //多线程共享的变量</span><br><span class="line">    //定义任意一个对象，用作同步代码块的锁</span><br><span class="line">    //如果不是static变量，达不到同步效果</span><br><span class="line">    //如果是static变量，多线程对象共享该变量。正确同步。</span><br><span class="line">    //如果上面创建线程用的是同一个SaleThread对象，则不管是不是static的，都是正确同步的。</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                if(tickets&gt;0)&#123;</span><br><span class="line">                    int i = tickets;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        Thread.sleep(1);  //模拟售票耗时过程</span><br><span class="line">                    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果lock是static，则hashcode一样。tickets的hashcode一直在变</span><br><span class="line">                    System.out.println(lock.hashCode() + &quot;  &quot; + tickets.hashCode());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            +&quot;正在发售第&quot;+tickets--+&quot;张票&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程共享变量问题"><a href="#多线程共享变量问题" class="headerlink" title="多线程共享变量问题"></a>多线程共享变量问题</h3><p>在并发编程的艺术中探讨了静态变量和成员变量的区别。<br>由static修饰的变量称为静态变量，其实质上就是一个全局变量。<br>本质是说静态变量是类所有对象共享，成员变量是对象专有。</p>
<p>这里探讨一下全局变量和局部变量的区别：</p>
<p>首先各种变量的分类：<br>变量分为全局变量（成员变量）和局部变量，全局变量又分为静态变量和实例变量。<br>所以上边对静态变量和成员变量的区分，应该是静态变量</p>
<p>✅什么是静态变量：<br>1：为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。<br>2：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。<br>3：被static修饰后的值可以直接类名.值进行引用，而无需new一个对象进行调用<br>4：在JVM中，静态变量的加载顺序在对象之前，因此静态变量不依附于对象存在，可以在不实例化类的情况下直接使用静态变量</p>
<p>✅局部变量和全局变量（成员变量）：<br>在方法体中声明的变量叫做：局部变量。<br>在方法体外声明的变量叫做：成员变量。成员变量又可以分为：实例变量和静态变量。</p>
<p>全局变量和局部变量的区别:<br>1，作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等<br>2，内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区<br>3，生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了<br>4，使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。</p>
<p>✅多线程访问全局变量(成员变量)和局部变量：</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class HelloThreadTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        HelloThread r = new HelloThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(r);</span><br><span class="line">        Thread t2 = new Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloThread implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        //int i = 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Hello number: &quot; + i++);</span><br><span class="line"></span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep((long) Math.random() * 1000);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (50 == i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，i是成员变量，则HelloThread的对象r只包含这一个i，两个Thread对象因为由r构造，所以共享了同一个i。</p>
<p>如果i改为在run方法中定义，那么就是局部变量，由于局部变量对于每一个线程来说都有自己的拷贝，所以各个线程之间不再共享同一个变量。</p>
<p>总结：<br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，它们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。</p>
<p>如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝（即便是同一个对象中的方法的局部变量，也会对每一个线程有一个拷贝），一个线程对该局部变量的改变不会影响到其他线程。</p>
<p>转自：<a target="_blank" rel="noopener" href="http://t.zoukankan.com/xiaowenwu-p-5077639.html">http://t.zoukankan.com/xiaowenwu-p-5077639.html</a></p>
<p>⚠️这里所说的全局变量和局部变量，说的是线程对象内的，不是传入线程的是局部变量还是全局变量。猜测：不分传入的是全局变量还是局部变量，都是有拷贝的，因为传入的变量对线程来说是成员变量。</p>
<p>实验：一个ArrayList，对代码块儿来说是局部变量，传入线程中，只读list的hashcode，传入线程前和线程中的hashcode一样。</p>
<p>实验：ArrayList增加一个元素，hashCode会变，改变一个对象的某个属性，hashCode不变。</p>
<h3 id="ThreadLocal变量"><a href="#ThreadLocal变量" class="headerlink" title="ThreadLocal变量"></a>ThreadLocal变量</h3><p>成员变量：从上面的例子，如果使用一个Runnable对象创建多个线程，多个线程共享成员变量，多个线程对该变量进行操作是彼此影响的，是线程不安全的。也就是上面加了锁，达到了线程安全。</p>
<p>局部变量：每个线程都会有局部变量的拷贝，一个线程对局部变量的操作不会影响其他线程。（上面的i）</p>
<p>多线程之间就是因为数据共享在多个线程才导致了线程不安全，这就要求线程间的数据需要隔离，从根本上解决了线程安全问题。</p>
<p>因此ThreadLocal：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值(副本)。</p>
<p>✅例子：多个线程共用一个Runnable对象，内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:28</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        int local = 1;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">            local = (int) (Math.random() * 100D);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;threadLocal:&quot; +threadLocal.get());</span><br><span class="line">            System.out.println(&quot;local:&quot; +local);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyRunnable sharedRunnableInstance = new MyRunnable();</span><br><span class="line">        Thread thread1 = new Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = new Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">threadLocal:40</span><br><span class="line">threadLocal:32</span><br><span class="line">local:95</span><br><span class="line">local:95</span><br></pre></td></tr></table></figure>

<p>每个线程拥有自己的ThreadLocal变量，但是共享local变量。</p>
<p>✅例子：多个线程共同对一个对象进行操作，对象内部ThreadLocal变量和普通成员变量区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-23 23:55</span><br><span class="line"> **/</span><br><span class="line">public class ThreadLocalExample2 &#123;</span><br><span class="line">    private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    int local = 1;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalExample2 demo = new ThreadLocalExample2();</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                demo.threadLocal.set((int) (Math.random() * 100D));</span><br><span class="line">                demo.local = (int) (Math.random() * 100D);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;threadLocal:&quot; +demo.threadLocal.get());</span><br><span class="line">                System.out.println(&quot;local:&quot; +demo.local);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(&quot;线程&quot; + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的效果。</p>
<p>多线程变量共享和隔离，ThreadLocal讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/JokerLJG/article/details/121284966">https://blog.csdn.net/JokerLJG/article/details/121284966</a></p>
<p>线程私有变量的另一个方法：多个对象构造方法传入不同的值：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43209615/article/details/124993090">https://blog.csdn.net/qq_43209615/article/details/124993090</a></p>
<p>SimpleDateFormat不是线程安全的解决：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38816924/article/details/122642680">https://blog.csdn.net/sinat_38816924/article/details/122642680</a></p>
<h3 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h3><p>Runnable是接口。Thread是实现了Runnable接口的类，并进行了扩展，而Thread和Runnable的实质是实现的关系，不是同类东西，所以Runnable或Thread本身没有可比性。</p>
<p>Runnable更容易可以实现多个线程间的资源共享，提交给Thread同一个Runnable对象，共享其中的private对象。（只是共享，线程安全要加同步）。<br>而Thread也是可以的，只不过是多个thread对象共享static变量，或者提交同一个Thread对象，并且static只是可见，还需要加同步才是线程安全的。</p>
<blockquote>
<p>这里只探讨共享变量的问题，想实现线程安全，要么加同步，要么volatile+原子性变量。</p>
</blockquote>
<p>还是卖票：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test3  extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private int ticket = 10;</span><br><span class="line"></span><br><span class="line">        public void run()&#123;</span><br><span class="line">            for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">                synchronized (this)&#123;</span><br><span class="line">                    if(this.ticket&gt;0)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(100);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+&quot;卖票----&gt;&quot;+(this.ticket--));</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] arg)&#123;</span><br><span class="line">            Test3 t1 = new Test3();</span><br><span class="line">            new Thread(t1,&quot;线程1&quot;).start();</span><br><span class="line">            new Thread(t1,&quot;线程2&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaojianting/article/details/97664370">https://blog.csdn.net/zhaojianting/article/details/97664370</a></p>
<h3 id="获取线程池中的线程？"><a href="#获取线程池中的线程？" class="headerlink" title="获取线程池中的线程？"></a>获取线程池中的线程？</h3><p>貌似无法获取线程。<br>但是可以获取线程池中活动的线程数：<br>ThreadPoolExecutor的getActiveCount方法。<br><code>public class ThreadPoolExecutor extends AbstractExecutorService &#123;</code><br><code>public abstract class AbstractExecutorService implements ExecutorService &#123;</code><br><code>public interface ExecutorService extends Executor &#123;</code></p>
<p>ExecutorService先转型一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line">System.out.println(((ThreadPoolExecutor)executorService).getActiveCount());  //0</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolTaskExecutor"><a href="#ThreadPoolTaskExecutor" class="headerlink" title="ThreadPoolTaskExecutor"></a>ThreadPoolTaskExecutor</h3><p>ThreadPoolTaskExecutor是一个spring的线程池技术。ThreadPoolTaskExecutor是spring core包中的，而ThreadPoolExecutor是JDK中的JUC。ThreadPoolTaskExecutor是对ThreadPoolExecutor进行了封装处理。</p>
<p>Spring自带的线程池ThreadPoolTaskExecutor：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346086161">https://zhuanlan.zhihu.com/p/346086161</a></p>
<h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><p>Spring内置定时任务调度，主要用于控制任务在某个指定时间执行,或者每隔一段时间执行.注意须要配合@EnableScheduling使用,配置@Scheduled主要有三种配置执行时间的方式,cron,fixedRate,fixedDelay。</p>
<p>Spring内置定时任务调度@Scheduled使用详解：<br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/201373.htm">https://www.jb51.net/article/201373.htm</a></p>
<p>@Scheduled注解：<br><a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-otgzzukq-hc.html">http://www.javashuo.com/article/p-otgzzukq-hc.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/myblog/JAVA/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.gif">
      <meta itemprop="name" content="Jade liu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jadeliu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/myblog/JAVA/java/" class="post-title-link" itemprop="url">java常规</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 12:00:26" itemprop="dateCreated datePublished" datetime="2022-04-30T12:00:26+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-22 21:39:15" itemprop="dateModified" datetime="2023-08-22T21:39:15+08:00">2023-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">java开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>1、sql（dao层）返回的，尽量不要用VO，而使用DO。除非联表查询？dao层查出来的do需要加其他表的一两个字段，可以在原表do的基础上继承封装一下，如果要传入，可以直接输入子类，dao层处理时会自动解析为父类。</p>
<p>2、service里面不要调不想干的dao层方法，而是调dao所在service的方法。</p>
<p>3、继承自同一抽象类的类方法，需要对同一返回处理，并且是串行的，可以输入中用context。</p>
<p>4、main方法是静态方法，同一个类内的方法得加static，不然就是成员方法，成员方法无法在静态方法中调用。</p>
<p>5、运行时异常比如NPE，在方法里throw，不需要在方法上throw了，并且里面方法抛出的异常，可以在外面方法可以catch到。</p>
<p>6、写service什么时候写成类，什么时候写成接口？ 如果对外的话就写接口，如果内部代码用，就service类就行。</p>
<p>7、null不能用来做比较，会报NPE，例如：1 == null，不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer s1 = null;</span><br><span class="line">if(s1 == 1) System.out.println(&quot;不对&quot;);  //报NPE</span><br><span class="line">Integer s1 = 3;</span><br><span class="line">if(null == s1) System.out.println(&quot;对&quot;); //对的</span><br><span class="line">String s1 = null;</span><br><span class="line">if(s1 == &quot;a&quot;) System.out.println(&quot;对&quot;); //String不会NPE</span><br></pre></td></tr></table></figure>

<p>8、如果类报红，没有引用到，尝试更新下仓库：点idea右边maven，点左上角更新圈，更新一下。如果还不行，看一下maven的setting文件对不对。</p>
<p>9、if、while、for关键词的后面和括号之间要有空格，HashMap&lt;Integer, Integer&gt;和变量名之间要有空格。<br>方法名后面到入参的括号不需要空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public voif func(Integer i) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、不要在代码中，特别是主线程中随便Thread.sleep，这样会阻塞住线程。</p>
<p>11、方法返回如果是包装类型Double等，如果用double接，是接不住null的，会报空指针异常。</p>
<p>12、boolean这种类型，如果是一个对象的参数，初始化对象时，会给一个默认值false，但是单独初始化boolean类型，需要给值，不能boolean b;</p>
<p>13、配置可以写在一个接口里 XXXInstance，可以这么取名，直接加类型就行，不用public static。调用的时候就 XXXInstance.SSS。</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>private：仅限类本身可见<br>default：类内部、包访问权限<br>protected：类内部、同一个包、子类中访问<br>public：类内部、同一个包、子类、任意位置都能访问</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>✅java: Compilation failed:</p>
<p>报错原因：<br>项目中Java版本不一致，可以查看项目中的jdk配置.<br>1、查看项目的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt;Project </p>
<p>2、查看工程的jdk<br>File -&gt;Project Structure-&gt;Project Settings -&gt; Modules -&gt; （需要修改的工程名称） -&gt; Sources -&gt;</p>
<p>3、查看idea中Java配置<br>compile 的 java compile中。</p>
<p>✅空指针NPE</p>
<p>空指针(Null Pointer Exception，NPE)<br>空指针异常属于运行时的异常。当Java尝试去调用真实对象上的任何方法时，如果在运行时中，该对象调用的是空引用(Null Reference)，那么就会抛出异常。<br>由于种种原因，开发人员时常会忘记初始化对象和验证对象。这往往是导致空指针异常的根源。<br>例如：对一个为null的对象调用get/set方法，就会NPE。</p>
<p>🤔Optional避免空指针<br>java.util.Optional 是java8中引进的一个新的类，它可以对可能缺失的值进行建模，而不是直接将null赋值给变量。</p>
<p>java引入空指针的危害：<br>1、它是很多问题的错误之源，它是目前开发中最典型的异常。<br>2、它会使代码膨胀，它会使我们的代码充满了深度嵌套的null检查，代码的可读性下降。<br>3、它自身是毫无意义的，null自身没有任何的语义，它表示以一种错误的方式对缺失变量的值建模。<br>4、它破坏了java的哲学，java一直避免引入指针的存在，而唯一的例外就是null指针。<br>5、它破坏了java的类型，null不属于任何类型，这也意味着它可以被赋值给任意引用类型的变量，我们将无法获取这个null值最初的类型是什么。<br>而Optional的出现可以让我们最大程度上规避上述问题。</p>
<p>Optional的使用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/aaaPostcard/article/details/123596787">https://blog.csdn.net/aaaPostcard/article/details/123596787</a><br>（感觉只能避免对自己定义的domain产生空指针异常，无法避免从数据库中获取到null，然后操作造成NPE。）</p>
<p>✅ IllegalStateException:Failed to load ApplicationContext</p>
<p>加载类出问题，往下看是哪个类没加载，获取bean出现问题，看是不是当作对象调用了，但是没加@Service。</p>
<p>✅ for循环内通过new来修改引用变量导致的问题</p>
<p>for循环中声明的变量是局部变量，List中存着对象的引用变量，也就是对象在堆中的地址。for循环中通过set方法来改变堆中的变量，没问题，引用变量并不会改变。</p>
<p>但是，for循环中通过new一个新对象来赋值给局部变量，新对象是在堆中创建了，对象地址赋给局部变量，但是List中的值并没有改变。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test10() &#123;</span><br><span class="line">    A a = new A(&quot;lll&quot;);</span><br><span class="line">    List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">    List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">    list2.addAll(list1);</span><br><span class="line">    System.out.println(list2); //[A(name=lll)]</span><br><span class="line">    a.setName(&quot;www&quot;);</span><br><span class="line">    System.out.println(list1); //[A(name=www)]</span><br><span class="line">    System.out.println(list2); //[A(name=www)]</span><br><span class="line"></span><br><span class="line">    for (A u : list2) &#123;</span><br><span class="line">        u.setName(&quot;bbb&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1642360923</span><br><span class="line">        A u1 = new A(&quot;aaa&quot;);</span><br><span class="line">        u = u1;</span><br><span class="line">        u.setName(&quot;aaa&quot;);</span><br><span class="line">        System.out.println(u.hashCode()); //1343441044</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list2); //[A(name=bbb)]</span><br><span class="line">    System.out.println(list2.get(0).hashCode()); //1642360923</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">class A &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Void-与-void-与-null"><a href="#Void-与-void-与-null" class="headerlink" title="Void 与 void 与 null"></a>Void 与 void 与 null</h3><p>void 是一种基本数据类型。而 Void 是 void 封装类型。<br>Void 之于 void 类似于 Integer 之于 int。但并非如此，Void 比较特别：<br>它不可实例化<br>它没有内置的类型实例，也没有可用的字面值。</p>
<p>声明一个 Void 变量通常是没有什么意义的，因为没有可为其赋值的实例。Void 变量唯一能持有的是 null。Void 一个可用的地方是反射判断方法的返回值时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(m.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">	// 处理返回值为 void 的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也不是必需使用Void.TYPE，也可以用void.class。<br>总结来说，几乎很少会用到 Void 。</p>
<p>null是所有引用类型的默认值，但是要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。</p>
<p>访问一个类里的方法，如果用null赋予的对象访问普通方法，会NullPointerException，而访问static方法，没事，因为访问静态方法不需要实例对象。因此，静态方法的访问，不建议用实例调用，用类调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main m = (Main) null;</span><br><span class="line">System.out.println(m instanceof Main); //返回false</span><br><span class="line">System.out.println(m.getClass()); //空指针</span><br></pre></td></tr></table></figure>

<p>void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        return; //返回void，return可写可不写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void do2() &#123;</span><br><span class="line">        return null; //此处必须返回null 返回其余类型都不好使</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Void.class); //class java.lang.Void</span><br><span class="line">        System.out.println(void.class); //void</span><br><span class="line">        //类似于下面的</span><br><span class="line">        System.out.println(Integer.class); //class java.lang.Integer</span><br><span class="line">        System.out.println(int.class); //int</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Void我们到底有什么用呢？其实在泛型出现之前，Void一般用于反射之中。判断方法返回是否为void。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">  public void print(String v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    for(Method method : Test.class.getMethods()) &#123;</span><br><span class="line">      //判断返回值类型 用到了Void类</span><br><span class="line">      if(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有有的时候，并不需要返回值的抽像性设计，比如下面设计的分布式锁：RedisLock.</p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0">https://blog.csdn.net/f641385712/article/details/80409211?utm_source=blogxgwz0</a></p>
<h3 id="Java中包装类型和基本类型的使用场景"><a href="#Java中包装类型和基本类型的使用场景" class="headerlink" title="Java中包装类型和基本类型的使用场景"></a>Java中包装类型和基本类型的使用场景</h3><p>最简单的理解，基本类型有默认值，而包装类型初始为null。然后再根据这两个特性进行分业务使用，在阿里巴巴的规范里所有的POJO类必须使用包装类型，而在本地变量推荐使用基本类型。定义方法的输入输出参数用包装类型。List里用包装类型(,因为List中的泛型必须是引用类型。)，for循环里用包装类型。</p>
<p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>1、整数：包括int、short、byte、long初始值为0。<br>2、浮点型：float、double初始值为0.0<br>3、字符：char初始值为空格，即’’ “，如果输出，在Console上是看不到效果的。<br>4、布尔：boolean初始值为false </p>
<p>基本类型的包装类<br>Integer 、Long、Short、Byte、Character、Double、Float、Boolean、BigInteger、BigDecimal<br>其中BigInteger、BigDecimal没有相对应的基本类型，主要应用于高精度的运算，BigInteger 支持任意精度的整数，<br>BigDecimal支持任意精度带小数点的运算。</p>
<p>基本类型与包装类型的异同：<br>1、在Java中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型则需new关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值，保存在堆栈中能高效的存取；封装类型需要通过引用指向实例，具体的实例保存在堆中；<br>4、初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。<br>6、什么时候该用包装类，什么时候该用基本类型，看基本的业务来定：这个字段允不允许null值，如果允许，则必然要用封装类；否则，基本类型就可以了。如果用到比如泛型和反射调用函数，就需要用包装类！ </p>
<p>转自 <a target="_blank" rel="noopener" href="http://t.zoukankan.com/east7-p-9887722.html">http://t.zoukankan.com/east7-p-9887722.html</a></p>
<h4 id="parseDouble-和valueOf-方法，类型转换"><a href="#parseDouble-和valueOf-方法，类型转换" class="headerlink" title="parseDouble()和valueOf()方法，类型转换"></a>parseDouble()和valueOf()方法，类型转换</h4><p>✅Double类parseDouble()和valueOf()方法的区别（String转Double）</p>
<p>1、Double.parseDouble(java.lang.String)的参数只能是String。Double.valueOf()的参数类型可以是浮点型或者是字符串均可。</p>
<p>2、Double.parseDouble(java.lang.String)把数字类型的字符串转换成double类型，返回是double类型。入参是String。<br>Double.valueOf()方把数字类型的字符串转换成Double类型，返回是Double类型。入参是String或double。</p>
<p>这两个方法里面都不能是Object类型，得先o.toString转为String，再变Double。注意空指针。</p>
<p>✅Double转String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = Double.toString(1.1);  //里面可以是double也可以是Double,为null会NPE</span><br><span class="line"></span><br><span class="line">Double d = 1.1;</span><br><span class="line">String s1 = d.toString();  //Object的toString方法double类型不能用,d为null会NPE</span><br><span class="line"></span><br><span class="line">double d1 = 1.2;</span><br><span class="line">String s1 = String.valueOf(d);  //里面可以是double也可以是Double,可以是null，nul的话输出“null”</span><br></pre></td></tr></table></figure>

<p>✅强制类型转换<br>首先，每个包装类型都有一个valueOf方法，用来把其他类型转换为自己类型。例如：Double d = Double.valueOf(“1”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    System.out.println((double) 1 / 1000); //输出0.001</span><br><span class="line">    System.out.println((double) (1 / 1000)); //输出0.0</span><br><span class="line">    Integer integer = 1;</span><br><span class="line">    System.out.println((double) integer / 1000); //输出0.001</span><br><span class="line"></span><br><span class="line">    //向上取整</span><br><span class="line">    double d = Math.ceil(2.3);</span><br><span class="line">    Integer i = (int) d;</span><br><span class="line">    System.out.println(i); //输出3</span><br><span class="line"></span><br><span class="line">    int x = 1, y = 2;</span><br><span class="line">    double z = x / y; //waring:&#x27;x / y&#x27;: integer division in floating-point context （意思是说这是浮点数的除法）</span><br><span class="line">    System.out.println(z);  //0.0</span><br><span class="line">    double w = 1.0 * x / y;</span><br><span class="line">    System.out.println(w);  //0.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="String-valueOf-1L-和-l-toString"><a href="#String-valueOf-1L-和-l-toString" class="headerlink" title="String.valueOf(1L)和 l.toString"></a>String.valueOf(1L)和 l.toString</h4><p>String.valueOf 入参是Object。<br>String.valueOf 如果传入null，返回是“null”字符串，而不是空null。<br>null.toString() 会报空指针。<br>不是包装类型的int，.toString()也不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Long l = new Long(1L);</span><br><span class="line">String s1 = String.valueOf(l);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">String s2 = l.toString();</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">l = null;</span><br><span class="line">String s3 = String.valueOf(l);</span><br><span class="line">System.out.println(s3);  //null</span><br><span class="line">String s4 = l.toString(); //NullPointerException</span><br><span class="line">System.out.println(s4);</span><br></pre></td></tr></table></figure>

<h4 id="判断小数精确度"><a href="#判断小数精确度" class="headerlink" title="判断小数精确度"></a>判断小数精确度</h4><p>实现思路：用String的split方法，得到小数点后的String，再看大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (&quot;1231312.12&quot;.split(&quot;\\.&quot;)[1].length()==2) &#123;</span><br><span class="line">    System.out.println(&quot;是两位小数&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较两个double的大小"><a href="#比较两个double的大小" class="headerlink" title="比较两个double的大小"></a>比较两个double的大小</h4><p>1.用bigdecimal，传入string类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bdL = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">BigDecimal bdR = new BigDecimal(&quot;1.22&quot;);</span><br><span class="line">if (bdL.compareTo(bdR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (bdL.compareTo(bdR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>2.使用Double</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Double dL = 1.33;</span><br><span class="line">Double dR = 1.33;</span><br><span class="line">if (dL.compareTo(dR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (dL.compareTo(dR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>3.在误差范围内允许相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 两实数的差在允许的范围内认为相等既可认为是相等的</span><br><span class="line">Double num1 = 1.222;</span><br><span class="line">Double num2 = 1.222;</span><br><span class="line">if (num1 - num2 &gt; 0.000001)</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br><span class="line">else if (num1 - num2 &lt; -0.0000001)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br></pre></td></tr></table></figure>

<p>4.转换成字符串</p>
<p>可以将double数据转换成string然后借助string的compareTo方法来间接实现比较两个double数据是否相等。注意这种方法只适用于比较精度相同的数据，并且是只能用于比较正数的大小，负数比较结果异常，不过可以用于比较两数是否相等，此时正负数对结果没有影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String strL = String.valueOf(num1);</span><br><span class="line">String strR = String.valueOf(num2);</span><br><span class="line">if (strL.compareTo(strR) &lt; 0)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (strL.compareTo(strR) == 0)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>5.使用doubleToLongBits()方法</p>
<p>使用sun提供的Double.doubleToLongBits()方法，该方法可以将double转换成long型数据，从而可以使double按照long的方法（&lt;, &gt;, ==）判断是否大小和是否相等，但是，这种办法还是只能用于比较正数，负数结果异常，比较两数相等与否是没有问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用使用sun提供的Double.doubleToLongBits()方法</span><br><span class="line">long lL = Double.doubleToRawLongBits(num1);</span><br><span class="line">long lR = Double.doubleToRawLongBits(num2);</span><br><span class="line">System.out.println(lL + &quot;:&quot; + lR);</span><br><span class="line">if (lL &lt; lR)</span><br><span class="line">    System.out.println(&quot;num1 &lt; num2&quot;);</span><br><span class="line">else if (lL == lR)</span><br><span class="line">    System.out.println(&quot;num1 == num2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;num1 &gt; num2&quot;);</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_49217297/article/details/124969742">https://blog.csdn.net/qq_49217297/article/details/124969742</a></p>
<h4 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h4><p>1、使用java.math.BigDecimal，四舍五入的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Double value = 1.2355;</span><br><span class="line">BigDecimal bd = new BigDecimal(value);</span><br><span class="line">bd = bd.setScale(2, RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(bd.toString());</span><br><span class="line">System.out.println(bd.doubleValue());</span><br></pre></td></tr></table></figure>

<p>2、使用DecimalFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DecimalFormat df = new DecimalFormat(&quot;0.00&quot;);</span><br><span class="line">df.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(df.format(value));</span><br></pre></td></tr></table></figure>

<p>3、使用NumberFormat,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat nf = NumberFormat.getNumberInstance();</span><br><span class="line">//如果不这么做，那么当value的值是100.00的时候返回100</span><br><span class="line">nf.setMaximumFractionDigits(2);</span><br><span class="line">nf.setMinimumFractionDigits(2);</span><br><span class="line">nf.setRoundingMode(RoundingMode.HALF_UP);</span><br><span class="line">//如果想输出的格式用逗号隔开，可以设置成true</span><br><span class="line">nf.setGroupingUsed(false);</span><br><span class="line">System.out.println(nf.format(value));</span><br></pre></td></tr></table></figure>

<p>4、使用java.util.Formatter,保留小数点后两位，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = new Formatter().format(&quot;%.2f&quot;, value).toString();</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>5、使用String.format来实现，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;%.2f&quot;, value));</span><br></pre></td></tr></table></figure>

<p>六、通过运算，不是四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l =(long)(value*100) ;</span><br><span class="line">double d = l/100D;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<p>Java保留两位小数的几种写法总结：<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2155412">https://cloud.tencent.com/developer/article/2155412</a></p>
<h4 id="int的最大最小值"><a href="#int的最大最小值" class="headerlink" title="int的最大最小值"></a>int的最大最小值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE); //-2147483648</span><br><span class="line">System.out.println(Integer.MAX_VALUE); //2147483647</span><br><span class="line">System.out.println(-Integer.MIN_VALUE); //-2147483648  Numeric overflow in expression</span><br></pre></td></tr></table></figure>

<p>32 位的有符号整数的范围 [−2^31,  2^31 − 1]</p>
<p>问题：为什么-Integer.MIN_VALUE的结果会是-2147483648<br>因为出现了溢出的问题，整数用二进制补码表示，最高位是符号为，0正数，1负数。<br>MIN_VALUE的二进制表示：100000….<br>负数的二进制表示进行取反再加1，就得到绝对值。<br>从绝对值到负数二进制：绝对值二进制，取反，再加1得到。</p>
<p>二进制补码的出现是为了方便负数的加减运算。减法可以通过加上对应正数的补码来实现。</p>
<p>Integer.MIN_VALUE取负的过程：<br>1.MIN_VALUE的二进制表示：100000….每一位取反，得到01111…<br>2.然后将上述结果+1，的到100000… 还是自己</p>
<p>正数的补码等于它的原码；负数的补码等于反码+1。</p>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>使用场景：比较精确的数字的加减法、小数的四舍五入</p>
<p>首先，浮点数为什么不准确？<br>码农在程序里写的10进制小数，计算机内部无法用二进制的小数来精确的表达。<br>对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n）</p>
<p>试一试如何表达十进制的 0.2 吧。</p>
<p>0.01 = 1/4 = 0.25 ,太大</p>
<p>0.001 =1/8 = 0.125 , 又太小</p>
<p>0.0011 = 1/8 + 1/16 = 0.1875 , 逼近0.2了</p>
<p>0.00111 = 1/8 + 1/16 + 1/32 = 0.21875 , 又大了</p>
<p>0.001101 = 1/8+ 1/16 + 1/64 = 0.203125 还是大</p>
<p>0.0011001 = 1/8 + 1/16 + 1/128 = 0.1953125 这结果不错</p>
<p>0.00110011 = 1/8+1/16+1/128+1/256 = 0.19921875<br>已经很逼近了， 就这样吧。</p>
<p>这就是用二进制小数没法精确表达10进制小数的含义。<br>根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值</p>
<p>《Effective Java》在第48条推荐“使用BigDecimal来做精确运算”。</p>
<hr>
<p>float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场啦。</p>
<p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。</p>
<hr>
<h4 id="✅BigDecimal构造方法："><a href="#✅BigDecimal构造方法：" class="headerlink" title="✅BigDecimal构造方法："></a>✅BigDecimal构造方法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal(double val)    将double表示形式转换为BigDecimal *不建议使用</span><br><span class="line">public BigDecimal(int val)　　将int表示形式转换成BigDecimal</span><br><span class="line">public BigDecimal(long)    创建一个具有参数所指定长整数值的对象。 </span><br><span class="line">public BigDecimal(String val)　　将String表示形式转换成BigDecimal *推荐使用</span><br></pre></td></tr></table></figure>
<p>⚠️BigDecimal 不像Double一样可以直接=1.1。 BigDecimal需要new个对象，或者：BigDecimal.ZERO 表示0.0。</p>
<p>为什么不推荐使用Double入参？<br>BigDecimal bDouble = new BigDecimal(2.3);<br>最终输出的数是：2.29999999….</p>
<p>为什么会出现这种情况呢？</p>
<p>JDK的描述：<br>1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p>
<p>2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。</p>
<p>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bDouble1 = BigDecimal.valueOf(2.3); //方法不能传null</span><br><span class="line">BigDecimal bDouble2 = new BigDecimal(Double.toString(2.3));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅BigDecimal用法："><a href="#✅BigDecimal用法：" class="headerlink" title="✅BigDecimal用法："></a>✅BigDecimal用法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a + b =&quot; + a.add(b));</span><br><span class="line">        System.out.println(&quot;a - b =&quot; + a.subtract(b));</span><br><span class="line">        System.out.println(&quot;a * b =&quot; + a.multiply(b));</span><br><span class="line">        System.out.println(&quot;a / b =&quot; + a.divide(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>👋BigDecimal除法可能出现不能整除的情况，比如 4.5/1.3，这时会报错java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p>
<p>其实divide方法有可以传三个参数</p>
<p><code>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) </code><br>第一参数表示除数， 第二个参数表示小数点后保留位数，<br>第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ROUND_CEILING    //向正无穷方向舍入</span><br><span class="line">ROUND_DOWN    //向零方向舍入</span><br><span class="line">ROUND_FLOOR    //向负无穷方向舍入</span><br><span class="line">ROUND_HALF_DOWN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5</span><br><span class="line">ROUND_HALF_EVEN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN</span><br><span class="line">ROUND_HALF_UP    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6</span><br><span class="line">ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式</span><br><span class="line">ROUND_UP    //向远离0的方向舍入</span><br><span class="line"></span><br><span class="line">四舍五入采用 ROUND_HALF_UP</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = new BigDecimal(&quot;1000&quot;);  </span><br><span class="line">BigDecimal b2 = new BigDecimal(&quot;100&quot;);  </span><br><span class="line">System.out.println(b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP).toString());</span><br><span class="line">输出：</span><br><span class="line">10.00,结果返回一个BigDecimal</span><br></pre></td></tr></table></figure>


<p>对BigDecimal进行截断和四舍五入可用setScale方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5635&quot;);</span><br><span class="line"></span><br><span class="line">        a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入</span><br><span class="line">        a = a.setScale(3, BigDecimal.ROUND_HALF_UP);    //这个也行</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        Double d = a.doubleValue();  //转为double/Double类型</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal都是不主动变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        BigDecimal a = new BigDecimal(&quot;4.5&quot;);</span><br><span class="line">        BigDecimal b = new BigDecimal(&quot;1.5&quot;);</span><br><span class="line">        a.add(b);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);  //输出4.5. 加减乘除方法会返回一个新的BigDecimal对象，原来的a不变</span><br><span class="line">        a = a.add(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/YangJavaer/p/6056394.html">https://www.cnblogs.com/YangJavaer/p/6056394.html</a></p>
<hr>
<h4 id="✅BigDecimal比较"><a href="#✅BigDecimal比较" class="headerlink" title="✅BigDecimal比较"></a>✅BigDecimal比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int flag = bigdemical.compareTo(bigdemical1)。</span><br><span class="line"></span><br><span class="line">flag = -1，表示bigdemical小于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =0，表示bigdemical等于bigdemical1。</span><br><span class="line"></span><br><span class="line">flag =1，表示bigdemical大于bigdemical1。</span><br><span class="line"></span><br><span class="line">实际中直接跟0比较就可以了，别跟-1或者1比较。</span><br></pre></td></tr></table></figure>

<p>BigDecimal的equals方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a=BigDecimal.valueOf(1.0);</span><br><span class="line">BigDecimal b=BigDecimal.valueOf(1.000);</span><br><span class="line">System.out.println(a.equals(b));  //true</span><br><span class="line"></span><br><span class="line">BigDecimal c = new BigDecimal(&quot;10.00&quot;);</span><br><span class="line">BigDecimal d = new BigDecimal(&quot;10&quot;);</span><br><span class="line">BigDecimal e = new BigDecimal(10.00);</span><br><span class="line">System.out.println(c.equals(d));  //false</span><br><span class="line">System.out.println(c.equals(e));  //false</span><br><span class="line">// equals是比较内容，“1.0”和“1.000”不一样.</span><br><span class="line"></span><br><span class="line">//toPlainString再equals</span><br><span class="line">System.out.println(c.toPlainString().equals(d.toPlainString())); //false</span><br><span class="line">System.out.println(c.toPlainString().equals(e.toPlainString())); //false</span><br><span class="line"></span><br><span class="line">//longValue方式</span><br><span class="line">System.out.println(c.longValue() == d.longValue()); //true</span><br><span class="line">System.out.println(c.longValue() == e.longValue()); //true</span><br><span class="line"></span><br><span class="line">//compareTo</span><br><span class="line">System.out.println(c.compareTo(d) == 0); //true</span><br><span class="line">System.out.println(c.compareTo(e) == 0); //true</span><br><span class="line"></span><br><span class="line">BigDecimal f = new BigDecimal(&quot;10.100001&quot;);</span><br><span class="line">BigDecimal g = new BigDecimal(10.100001);</span><br><span class="line">System.out.println(f.compareTo(g) == 0); //false</span><br><span class="line">// 这是因为本身Double传参的构造就不准，看上面</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/bijian1013-2366549">https://www.iteye.com/blog/bijian1013-2366549</a></p>
<hr>
<h4 id="✅mysql的decimal"><a href="#✅mysql的decimal" class="headerlink" title="✅mysql的decimal"></a>✅mysql的decimal</h4><p>decimal:数字型，不存在精度损失，常用于银行帐目计算</p>
<p><code>distance decimal(10,1) not null default 0.0 comment &#39;距离&#39;</code></p>
<p>decimal(P,m)<br>P的取值范围是1–65，表示整数位数<br>M的取值是0–30.表示小数位<br>精度M最大为30，表示有30位小数。<br>decimal整数和小数位均不写 默认为decimal(10,0)<br>若小数位不写默认的小数位为0。</p>
<p>decimal(22,6）表示整数位16个小数位6个。</p>
<p>decimal 还可以存储超过bigint的整数位，最大存储65位的整数类型。<br>还可以存储对应位数的负数</p>
<p>例：decimal(2,1)，此时，插入数据“12.3”、“12”等会出现“数据溢出错误”的异常；插入“1.23”或“1.2345…”会自动四舍五入成“1.2”；插入“2”会自动补成“2.0”，以确保2位的有效长度，其中包含1位小数。<br>当用 int类型会有溢出时，可以用 decimal 类型进行处理，把结果可以用 convert 或是 cast 进行转换。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenpp666/article/details/124372731">https://blog.csdn.net/chenpp666/article/details/124372731</a></p>
<h3 id="java位运算"><a href="#java位运算" class="headerlink" title="java位运算"></a>java位运算</h3><p>1、左移( &lt;&lt; )  向左移动，低位补0<br>2、右移( &gt;&gt; )  向右移动，高位补0<br>3、无符号右移( &gt;&gt;&gt; )   正数右移，高位补0，负数右移，高位补1，当负数使用无符号右移时，用0进行补位(自然而然的，就由负数变成了正数了)<br>4、与( &amp; )  都为1，结果为1，否则为0<br>5、或( | )  一个是1，结果为1，否则为0<br>6、异或( ^ )  两个相反，结果为1，否则为0<br>7、非( ~ ) 一元操作符   取相反。</p>
<h3 id="Autowired接口还是现实类？"><a href="#Autowired接口还是现实类？" class="headerlink" title="Autowired接口还是现实类？"></a>Autowired接口还是现实类？</h3><p>答案：接口好</p>
<p>当实现类唯一时，表面上注入接口，其实注入实现类<br>当实现类多个时，通过@Service(“menuService1”)指定实现类</p>
<p>解析：<br>这个其实是创建了实现类的对象但引用了接口类型，<br>即 “InjectionDao injectionDao = new InjectionDaoImpl ()”, 是 Java 多态性（向上转型）的一种应用。<br>在实现类处加 @Repository 注解，意思就是 new InjectionDaoImpl (),</p>
<p>而在 InjectionServiceImpl 中定义属性 InjectionDAO injectionDAO 就是将 new 出来的这个 InjectionDaoImpl 对象向上转型为 InjectionDao 类型。</p>
<p>注意：<br>若一个接口被多个实现类，实现的时候，@Autowired，Spring 会按 byType 的方式寻找接口的实现类，将其注入。存在多个实现类，应该指定名字，可以通过 byName 注入的方式。可以使用 @Resource 或 @Qualifier 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//实现类1</span><br><span class="line">@Service(&quot;menuService1&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line">//实现类2</span><br><span class="line">@Service(&quot;menuService2&quot;)</span><br><span class="line">public class MenuServiceImpl implements IMenuService</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService1实现类</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService1&quot;)</span><br><span class="line">private IMenuService menuService;</span><br><span class="line"></span><br><span class="line">//注入接口，相当于new一个实现类，指定名称menuService2实现类  </span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;menuService2&quot;)</span><br><span class="line">private IMenuService menuService;</span><br></pre></td></tr></table></figure>

<p>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/huangkechen/article/details/122475824">https://blog.csdn.net/huangkechen/article/details/122475824</a></p>
<p>总结：就是Java 多态性（向上转型）的一种应用，但是这样做的好处并没有说。<br>规矩：注入实现类时用@Resource（@Autowired应该也可以），接口单个实现类用@Autowired（@Resource应该也可以），接口多个实现类用@Autowired + @Qualifier(value=””) 或 @Resource(name=””)。</p>
<h3 id="Collection、Collections、CollectionUtils"><a href="#Collection、Collections、CollectionUtils" class="headerlink" title="Collection、Collections、CollectionUtils"></a>Collection、Collections、CollectionUtils</h3><p>Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Collection（单例集合  ） </span><br><span class="line">├-List（有序，可重复 ）  </span><br><span class="line">│  ├-LinkedList（查询速度慢，增删快）   </span><br><span class="line">│  ├-ArrayList（查询速度快，增删慢）  </span><br><span class="line">│  └-Vector（线程安全的，操作效率低 ）  </span><br><span class="line">│　    └-Stack   </span><br><span class="line">└-Set（无序，不可重复） </span><br><span class="line">      ├-HashSet（使用了哈希表存取）</span><br><span class="line">      │    └-LinkedHashSet</span><br><span class="line">      └-SortedSet</span><br><span class="line">               └-TreeSet（有序）</span><br><span class="line">Map（键值对）  </span><br><span class="line">├-Hashtable   </span><br><span class="line">├-HashMap   </span><br><span class="line">└-WeakHashMap</span><br></pre></td></tr></table></figure>
<p>set是在HashMap的基础上实现的，HashSet的存储方式是把HashMap中的Key作为Set的对应存储项。HashMap是非同步的，线程不安全的，Hashtable虽然是同步线程安全的，但是已经过期了。 现在使用ConcurrentHashMap，这个是线程安全同步的。</p>
<p>Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>例如：排序(Sort)、倒序(reverse)、最大(max)、最小(min)、替换(fill)</p>
<p>使用sort方法可以根据元素的自然顺序对指定列表按升序进行排列。列表中所有元素都必须实现Comparable接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);//排序</span><br><span class="line">System.out.println(list);</span><br><span class="line">Collections.reverse(list);//倒序</span><br><span class="line">System.out.println(list);</span><br><span class="line">int max = Collections.max(list);//最大</span><br><span class="line">System.out.println(max);</span><br><span class="line">int min = Collections.min(list);//最小</span><br><span class="line"></span><br><span class="line">Collections.emptyList()  //空list</span><br></pre></td></tr></table></figure>

<p>CollectionUtils是对Collection集合操作的类方法，这个类不是java自带的类方法，需要另外导入一个commons-collections.jar包才可以使用这个类中方法。</p>
<p>例如：CollectionUtils.isEmpty(list)<br>它可以处理null，但是list.isEmpty里面为null，会NPE。</p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chaoge321/article/details/83788667">https://blog.csdn.net/chaoge321/article/details/83788667</a></p>
<h3 id="list的一些操作"><a href="#list的一些操作" class="headerlink" title="list的一些操作"></a>list的一些操作</h3><h4 id="一、Lists-newArrayList-和-new-ArrayList-："><a href="#一、Lists-newArrayList-和-new-ArrayList-：" class="headerlink" title="一、Lists.newArrayList() 和 new ArrayList() ："></a>一、Lists.newArrayList() 和 new ArrayList() ：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">Lists和Maps是谷歌的两个工具类,</span><br><span class="line"></span><br><span class="line">Lists.newArrayList()其实和new ArrayList()几乎一模一样,</span><br><span class="line"></span><br><span class="line">唯一它帮你做的(其实是javac帮你做的),就是自动推导尖括号里的数据类型.</span><br><span class="line"></span><br><span class="line">在 Java 7 之后，都允许类型推断 - 在运行时没有区别。</span><br><span class="line"></span><br><span class="line">java8 的new ArrayList&lt;&gt;()的&lt;&gt;里面可以不写类型，java回帮你自动推导类型</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>同样，还有Sets：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; sets = Sets.newHashSet(&quot;ww&quot;); //可直接定义</span><br><span class="line">Set&lt;String&gt; sets = new HashSet&lt;&gt;(Lists.newArrayList(&quot;11&quot;,&quot;22&quot;));</span><br><span class="line">//还得用list转换</span><br><span class="line"></span><br><span class="line">set没有get(i)方法，遍历得用迭代器。要么先转换成list。</span><br><span class="line">set转换为list：</span><br><span class="line">ArrayList&lt;Long&gt; list = new ArrayList(set);</span><br></pre></td></tr></table></figure>

<p>新建List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(&quot;1&quot;, &quot;2&quot;); 不行</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list2.add(&quot;3&quot;);  //咩问题</span><br><span class="line">System.out.println(list2);</span><br><span class="line">List&lt;String&gt; list3 = Arrays.asList(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">list3.set(1, &quot;3&quot;); //设置除了0、1会报错</span><br><span class="line">System.out.println(list3);</span><br><span class="line">list3.add(&quot;3&quot;);  //报错：java.lang.UnsupportedOperationException</span><br><span class="line">System.out.println(list3);</span><br><span class="line">List&lt;String&gt; list4 = Collections.singletonList(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;); //报错：java.lang.UnsupportedOperationException</span><br><span class="line"></span><br><span class="line">String a[] = new String[] &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot; &#125;;</span><br><span class="line">List&lt;String&gt; list5 = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<p>✅Array.asList创建方式：<br>java.util.Arrays 类的 asList() 方法用于返回一个由指定数组支持的固定大小的列表。<br>Arrays.asList 最大特点是整个集合允许有多个元素存入数组，一旦初始化后，这个数组的长度就是固定的，但数组的元素可以修改，所以也就是为什么 add 和 remove 方法报错的原因。如果在开发中碰到长度可以确定的集合，并且在初始化时已经确定了储存元素的情况下，推荐使用。<br>Arrays.asList 中传入的数组参数中允许存在 null，但不允许只有一个 null</p>
<p>✅Collections.singletonList()创建方式：<br>Collection.singletonList 长度为 1，初始完后不可修改。根据这个特性，在开发的时候遇到只要储存一个元素的集合，并且整个过程存储或者传递为主，不会进行修改或调整的情况下，推荐使用。<br>Collections.singletonList 中保存元素的是一个对象</p>
<p>✅Arrays.asList() 和 Collections.singletonList()区别 ：<br>1、Arrays.asList()得到的List中元素是可变的，大小不可变。<br>而Collections.singletonList是不可变的，一旦修改就会导致UnsupportedOperationException异常抛出<br>2、Collections.singletonList()得到的List元素只能有1个<br>3、Arrays.asList(strArray)不具有add方法，可以通过set方法进行改变值。Collections.singletonList()返回的是不可变的集合，但是这个长度的集合只有1。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41606477/article/details/108449415">https://blog.csdn.net/weixin_41606477/article/details/108449415</a></p>
<p>新建Set，除了上面的，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; list4 = Collections.singleton(&quot;1&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="二、对list排序：Comparator-java工具类"><a href="#二、对list排序：Comparator-java工具类" class="headerlink" title="二、对list排序：Comparator-java工具类"></a>二、对list排序：Comparator-java工具类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(A::getB));</span><br><span class="line"></span><br><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序排序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序排序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一升序 属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line">//返回 对象集合以类属性一降序 属性二升序 注意两种写法</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));//先以属性一降序,再进行属性二升序</span><br><span class="line"></span><br><span class="line">//含Null数据排序,nullsLast空的放后面，距离Date类型属性</span><br><span class="line">list.stream().sorted(Comparator.comparing(item -&gt; item.属性, Comparator.nullsLast(Date::compareTo))).collect(Collectors.toList());</span><br><span class="line">// nullLast或nullFirst里面带类型，可以用Comparator.nullsLast(Comparator.naturalOrder()))</span><br><span class="line"></span><br><span class="line">//空/Null数据分组</span><br><span class="line">Map&lt;String, List&lt;类&gt;&gt; map = list.stream().collect(Collectors.groupingBy(item -&gt; &#123;</span><br><span class="line">  if (item.属性一 == null || item.属性一.equals(&quot;&quot;)) &#123;</span><br><span class="line">  　　return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return DateFormat.getDateInstance().format(item.属性一);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>list可以直接使用sort。<br>用sorted就需要先.stream()，再.collect(Collectors.toList())<br>::都得是get属性</p>
<p>自定义排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;list中元素&gt;()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public int compare(元素 o1, 元素 o2) &#123;</span><br><span class="line">    if(..)  return 1;  //表示o1在前</span><br><span class="line">    if(..)  return 0;  //表示一样</span><br><span class="line">    return -1；  //表示o2在前</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="三、list移除：-removeIf"><a href="#三、list移除：-removeIf" class="headerlink" title="三、list移除： removeIf"></a>三、list移除： removeIf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeIf() 方法用于删除所有满足特定条件的数组元素。</span><br><span class="line">ArrayList&lt;String&gt; sites = new ArrayList&lt;&gt;();</span><br><span class="line">sites.add(&quot;Taobao&quot;);</span><br><span class="line">sites.removeIf(e -&gt; e.contains(&quot;Tao&quot;));</span><br><span class="line">用了String的contains方法</span><br></pre></td></tr></table></figure>
<p>list元素可以先设置，再更改。</p>
<p>不能在循环中用正序索引进行移除，因为移除的过程中索引会变。<br>可以用倒序索引。<br>如果非得用循环移除，用迭代器。</p>
<p>for的下标倒序遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = list.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (&quot;b&quot;.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用list.stream().filter().collect()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; newList = list.stream()</span><br><span class="line">        .filter(e -&gt; !&quot;b&quot;.equals(e))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>用迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    if (&quot;b&quot;.equals(s)) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🤔总结一下list移除方法：<br>1、removeIf<br>2、倒叙for循环<br>3、stream filter<br>4、迭代器</p>
<p>⚠️迭代器中，又移除，又对list增加元素是不行的，会引发并发错误。<br>map也是一样，用Entry遍历时，不能又remove又put，而且再循环里不能put新的，只能put已有的，不然会并发错误。也不能remove。用迭代器移除元素。</p>
<p>所以，替换List中的元素，用set方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">list.set(1, 4L);  //[1, 4, 3]</span><br></pre></td></tr></table></figure>

<p>【JAVA】List常用移除、过滤、去重、flatMap、peek等操作：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38397501/article/details/116494227">https://blog.csdn.net/qq_38397501/article/details/116494227</a></p>
<h4 id="四、判断list为空"><a href="#四、判断list为空" class="headerlink" title="四、判断list为空"></a>四、判断list为空</h4><p>if(CollectionUtils.isEmpty(list)){}</p>
<h4 id="五、indexOf方法"><a href="#五、indexOf方法" class="headerlink" title="五、indexOf方法"></a>五、indexOf方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indexOf() 方法返回动态数组中元素的索引值。</span><br><span class="line">int i = arraylist.indexOf(Object obj)</span><br></pre></td></tr></table></figure>

<h4 id="六、list、set、String转换"><a href="#六、list、set、String转换" class="headerlink" title="六、list、set、String转换"></a>六、list、set、String转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//list直接变set：</span><br><span class="line">Set&lt;Long&gt; set2 = new HashSet&lt;&gt;(list);</span><br><span class="line">Set&lt;Long&gt; set1 = Sets.newHashSet(list);</span><br><span class="line">//set变list：</span><br><span class="line">List&lt;Long&gt; list2 = new ArrayList&lt;&gt;(set1);</span><br><span class="line">List&lt;Long&gt; list3 = Lists.newArrayList(set1);</span><br></pre></td></tr></table></figure>

<p>,分割的String转换为List，看下面Splitter。</p>
<p>List转换为,分割字符串，看下面Joiner连接字符串。</p>
<h4 id="七、foreach"><a href="#七、foreach" class="headerlink" title="七、foreach"></a>七、foreach</h4><p>forEach() 方法用于遍历动态数组中每一个元素并执行特定操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testArray()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 往数组中添加元素</span><br><span class="line">    numbers.add(1);</span><br><span class="line">    numbers.add(2);</span><br><span class="line">    numbers.add(3);</span><br><span class="line">    numbers.add(4);</span><br><span class="line">    System.out.println(&quot;ArrayList: &quot; + numbers);</span><br><span class="line"></span><br><span class="line">    // 将 lambda 表达式传递给 forEach</span><br><span class="line">    numbers.forEach((e) -&gt; &#123;</span><br><span class="line">        System.out.print(e + &quot; &quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach 增强for循环，用于遍历动态数组中每一个元素并执行特定操作。</p>
<p>List的forEach是在Iterable类中，<code>Collection&lt;E&gt; extends Iterable&lt;E&gt;</code>，stream的forEach在Stream中。</p>
<p>Iterable中的方法原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️使用中出现：提示Variable used in lambda expression should be final or effectively final</p>
<p>这句话的意思是：lambda表达式中使用的变量应该是final或者有效的final。</p>
<p>其实在 Java 8 之前：<br>匿名类中如果要访问局部变量的话，那个局部变量必须显式的声明为final。<br>lambda表达式是由匿名内部类演变过来的，他们的作用都是实现接口方法，于是类比匿名内部类，lambda表达式中使用的变量也需要是final类型。</p>
<p>所以：需要赋值到另一个变量中使用。并且为final类型，不是final类型也可以，变量名中加final。<br>因为：Java 8 之后，在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。</p>
<p>为什么 lambda 表达式或者匿名内部类不能访问非 final 的局部变量，为什么呢？</p>
<p>其实这就要说到Jvm内存模型和线程了，因为实例变量存在堆中，而局部变量是在栈上分配，<strong>lambda 表达(匿名内部类) 会在另一个线程中执行</strong>。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://www.liangzl.com/get-article-detail-213550.html">https://www.liangzl.com/get-article-detail-213550.html</a></p>
<p>所以这个问题的原因不在forEach，而是在lambda表达式。<br>java的lambda表达式里不能出现变量，必须是final修饰的，但是可以让变量在定义时候就写入，这样就不算变量了。可以使用lambda表达式，不再报错。（只定义一次不再改，如果是需要多步才能定义出变量，那就写个方法出结果也可以）</p>
<p>不行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean ebola = false;</span><br><span class="line">ebola = list.size()&gt;10;//赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boolean ebola = checkEbola(list);//相当于定义时直接赋值</span><br><span class="line">taskExecutor.execute(() -&gt; &#123;</span><br><span class="line">  if(ebola)&#123;</span><br><span class="line">       //业务代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean checkEbola(ArrayList&lt;Object&gt; list)&#123;</span><br><span class="line">  return list.size()&gt;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="八、List截取"><a href="#八、List截取" class="headerlink" title="八、List截取"></a>八、List截取</h4><p>List自己的suubList方法，传参数起始索引和终点索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 3L);</span><br><span class="line">    System.out.println(list.subList(1, list.size()));</span><br><span class="line">    // 2,3</span><br><span class="line"></span><br><span class="line">    // 新建固定大小的List</span><br><span class="line">    List&lt;Long&gt; list1 = Lists.newArrayListWithExpectedSize(3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="九、数组转换为List"><a href="#九、数组转换为List" class="headerlink" title="九、数组转换为List"></a>九、数组转换为List</h4><p>原文：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/221887.htm">https://www.jb51.net/article/221887.htm</a></p>
<p>1、使用ArrayList.asList(strArray)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">List&lt;String&gt; ints = Arrays.asList(str);</span><br><span class="line">//这里会报错</span><br><span class="line">ints.add(&quot;laopo&quot;);</span><br></pre></td></tr></table></figure>
<p>使用Arrays工具类Arrays.asList(strArray)方式,转换完成后,只能对List数组进行查改,不能增删,增删就会抛出UnsupportedOperationException 异常。<br>报错原因:Arrays.asList(str)返回值是java.util.Arrays类中一个私有静态内部类 java.utiil.Arrays.Arraylist,并不是我们平时用的java.util.ArrayList();</p>
<p>⚠️：使用的asList()方法会返回一个final的,固定长度的ArrayList类，并不是java.util.ArrayList，直接这样利用它进行add()或remove()是无效的。</p>
<p>2、使用new ArrayList(Arrays.asList(strArray))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注意这个List不是Collections包内的List,而是util包里面的List接口</span><br><span class="line">java.util.ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">strings.add(&quot;aop&quot;);</span><br><span class="line">strings.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>通过ArrayList的构造器,将Arrays.asList(strArray)的返回值由java.utilArrays.ArrayList转为java.util.ArrayList.</p>
<p>3、集合工具类Collections.addAll()方法（用这个）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] str = &#123;&quot;fgx&quot;, &quot;lzy&quot;&#125;;</span><br><span class="line">java.util.ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;(str.length);</span><br><span class="line">Collections.addAll(stringList,str);</span><br></pre></td></tr></table></figure>
<p>通过Collections.addAll(arrayList, strArray)方式转换，根据数组的长度创建一个长度相同的List，然后通过Collections.addAll()方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。</p>
<p>4、JDK8的Stream流将3总基本类型数组转为List</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long[] longs = &#123;1, 2, 3&#125;;</span><br><span class="line">double[] doubles = &#123;1, 2, 3&#125;;</span><br><span class="line">Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(longs).boxed().collect(Collectors.toList());</span><br><span class="line">Arrays.stream(doubles).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如果JDK版本在1.8以上,使用流stream来将下列3种数组快速转为List,分别是int[],long[],double[],不支持short[ ],byte[ ],char[]在JDK1.8中暂不支持.</p>
<p>⚠️ 不能把基本数据类型转化为列表<br>asList接受的参数是一个泛型的变长参数，而基本数据类型是无法泛型化的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int [] intarray = &#123; 1 ,  2 ,  3 ,  4 ,  5 &#125;;</span><br><span class="line">//List&lt;Integer&gt; list = Arrays.asList(intarray); 编译通不过</span><br><span class="line">List&lt; int []&gt; list = Arrays.asList(intarray);  //输出一个int[]元素的list</span><br></pre></td></tr></table></figure>

<p>要想把基本数据类型的数组转化为其包装类型的list，可以使用guava类库的工具方法“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] intArray = &#123; 1 ,  2 ,  3 ,  4 &#125;;</span><br><span class="line">List&lt;Integer&gt; list = Ints.asList(intArray);</span><br></pre></td></tr></table></figure>

<p>为什么int[]不能直接转为List,而Integer[]可以转为List,而Integer[]就可以转为List了,因为List中的泛型必须是引用类型。？？？</p>
<p>⚠️asList方法返回的是数组的一个视图</p>
<p>视图意味着，对这个list的操作都会反映在原数组上，而且这个list是定长的，不支持add、remove等改变长度的方法。</p>
<h4 id="十、List转为数组"><a href="#十、List转为数组" class="headerlink" title="十、List转为数组"></a>十、List转为数组</h4><p>一般数组是不能添加元素的，因为他们在初始化时就已定好长度了，不能改变长度。</p>
<p>1、 list.toArray();</p>
<p>直接将 list 转换成 Object[] 类型的 数组；<br>Object ： 对象类，是所有类的父类</p>
<p><code>Object[]  ans1 = list.toArray();</code></p>
<p>2、list.toArray(T[] a);</p>
<p>输出指定类型的数组，输出的数组类型与括号中参数类型一致；<br>必须是包装类（String、Integer、Character等），不能是基本数据类型了（string、int、char）；<br>// 创建数组时： int [ ] arr = new int [ ] {}; 使用的是基本数据类型</p>
<p><code>Integer[] ans2 = list.toArray(new Integer[list.size()]);</code><br>注意：idea提示用空的：<br><code>Integer[] ans2 = list.toArray(new Integer[0]);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个list，并且对list赋值        </span><br><span class="line">List&lt;Integer&gt;  list = new ArrayList&lt;&gt;();       </span><br><span class="line">for (int i = 1; i &lt; 11; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//方法一：</span><br><span class="line">Object[]  ans1 = list.toArray();</span><br><span class="line">System.out.println(&quot;1:&quot; + Arrays.toString(ans1));</span><br><span class="line"> </span><br><span class="line">// 方法二：</span><br><span class="line">Integer[] ans2 = list.toArray(new Integer[list.size()]);</span><br><span class="line">System.out.println(&quot;2:&quot; + Arrays.toString(ans2));</span><br><span class="line"> </span><br><span class="line">1:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">2:[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>


<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Gc_680/article/details/122568085">https://blog.csdn.net/Gc_680/article/details/122568085</a></p>
<h4 id="十、分割list"><a href="#十、分割list" class="headerlink" title="十、分割list"></a>十、分割list</h4><p>Lists的方法，com.google.guava中。</p>
<p>使用场景：list集合中数据量过大，可根据需要进行拆分，进而通过循环或者多线程来处理数据。<br>或者是list拆分后，分批插入数据库。<br>Lists.partition方法，根据传入的size，对list进行拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将集合list按照 2 个元素一份进行划分</span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 2);</span><br></pre></td></tr></table></figure>

<h4 id="十一、list根据对象中某一元素去重"><a href="#十一、list根据对象中某一元素去重" class="headerlink" title="十一、list根据对象中某一元素去重"></a>十一、list根据对象中某一元素去重</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-09-11 22:25</span><br><span class="line"> **/</span><br><span class="line">public class TestRemoveDup &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *     TreeSet的本质是一个&quot;有序的，并且没有重复元素&quot;的集合，它是通过TreeMap实现的。</span><br><span class="line">     *     TreeSet注意事项：</span><br><span class="line">     *     如果向TreeSet集合中添加元素的时候，元素本身没有具备自然顺序的特性，并且元素所属的类也没有</span><br><span class="line">     *     实现Comparable接口，那么必须在创建TreeSet对象的时候传入一个比较器；</span><br><span class="line">     */</span><br><span class="line">    //根据名字进行比较，相等时TreeSet会将该元素视为重复元素，不允许添加；</span><br><span class="line">    private List&lt;Person&gt; removeDupByName(List&lt;Person&gt; people) &#123;</span><br><span class="line">        Set&lt;Person&gt; personSet = new TreeSet&lt;&gt;(Comparator.comparing(Person::getName));</span><br><span class="line">        personSet.addAll(people);</span><br><span class="line">        return new ArrayList&lt;&gt;(personSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;Person&gt; removeDupByName2(List&lt;Person&gt; people) &#123;</span><br><span class="line">        List&lt;Person&gt; unique = people.stream().collect(</span><br><span class="line">                Collectors.collectingAndThen(</span><br><span class="line">                        Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Person::getName))), ArrayList::new)</span><br><span class="line">        );</span><br><span class="line">        return unique;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //filter的使用方式为： filter(item -&gt; item的逻辑判断 ) ，其中filter会保留判断条件为true的记录</span><br><span class="line">    private List&lt;Person&gt; removeDupByName3(List&lt;Person&gt; people) &#123;</span><br><span class="line">        //用一个name的list去重，没用TreeSet</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();//用来临时存储person的id</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = people.stream().filter(// 过滤去重</span><br><span class="line">                v -&gt; &#123;</span><br><span class="line">                    boolean flag = !names.contains(v.getName());</span><br><span class="line">                    names.add(v.getName());</span><br><span class="line">                    return flag;</span><br><span class="line">                &#125;</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        return personList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; people = new ArrayList&lt;&gt;();</span><br><span class="line">        Person p1 = new Person(&quot;Liu&quot;,30);</span><br><span class="line">        people.add(p1);</span><br><span class="line">        Person p2 = new Person(&quot;Mi&quot;,36);</span><br><span class="line">        people.add(p2);</span><br><span class="line">        Person p3 = new Person(&quot;Liu&quot;,31);</span><br><span class="line">        people.add(p3);</span><br><span class="line">        TestRemoveDup testRemoveDup = new TestRemoveDup();</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; people1 = testRemoveDup.removeDupByName(people);</span><br><span class="line">        List&lt;Person&gt; people2 = testRemoveDup.removeDupByName2(people);</span><br><span class="line">        List&lt;Person&gt; people3 = testRemoveDup.removeDupByName3(people);</span><br><span class="line">        System.out.println(people1);</span><br><span class="line">        System.out.println(people2);</span><br><span class="line">        System.out.println(people3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    @ToString</span><br><span class="line">    @RequiredArgsConstructor</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private final String name;</span><br><span class="line">        private final Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的第三种，用filter方法，自定义一个方法，优雅一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unique = books.stream().filter(distinctByKey(o -&gt; o.getId())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter根据Predicate返回的布尔值来判断是否要过滤掉，</span><br><span class="line">会过滤掉返回值为false的数据。</span><br><span class="line">而我们自己定义的distinctByKey返回值就是Predicate，所以可以作为参数传入filter。</span><br><span class="line"></span><br><span class="line">distinctByKey也需要一个Function的参数。</span><br><span class="line">distinctByKey先是定义了一个线程安全的Map(相比于Hashtable以及Collections.synchronizedMap()，</span><br><span class="line">ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，</span><br><span class="line">但同时降低了对读一致性的要求)，因为在流计算中是多线程处理的，需要线程安全。</span><br><span class="line"></span><br><span class="line">然后将值作为key,TRUE作为value put到map中。</span><br><span class="line">这里的put方法使用的是putIfAbsent()。</span><br><span class="line">putIfAbsent()方法是如果key不存在则put如map中，并返回null。若key存在，则直接返回key所对应的value值。</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/zwh0910/p/15877284.html</span><br></pre></td></tr></table></figure>


<h4 id="十二、list-add和addAll的一个NPE问题"><a href="#十二、list-add和addAll的一个NPE问题" class="headerlink" title="十二、list.add和addAll的一个NPE问题"></a>十二、list.add和addAll的一个NPE问题</h4><p>背景：addAll遇到的一个空指针问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test7() &#123;</span><br><span class="line">    Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(1L, 1L);</span><br><span class="line">    List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">    System.out.println(map.get(2L)); //null</span><br><span class="line">    list.add(null); //没问题</span><br><span class="line">    //list.addAll(null); //会报空指针</span><br><span class="line">    //list.addAll(1L);  //addAll只能传Collection</span><br><span class="line"></span><br><span class="line">    list.add(1L);</span><br><span class="line">    list.add(3L);</span><br><span class="line">    list.add(1, 2L);</span><br><span class="line">    System.out.println(list);  //[null, 2, 1, 3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法是将元素可以插在指定的位置，如果参数只有一个的话就默认插在队列的尾部，而对于addAll方法，可以看其实作用差不多，但是参数必须为Collection 集合。</p>
<p>add方法参数为泛型E，所以他是支持任意类型的，但是这里要注意的一点是，如果你使用add方法并且传的参数为集合，那么其实 list集合会把这个参数中的集合当做一个整体，添加到原本的集合中。<br>而addAll方法，则会把参数里面的集合给分别放进原本的集合中。<br>(通过一个forEach 循环遍历后得到参数集合中的每个元素，在循环里面再分别调用add方法来实现这个功能)</p>
<p>⚠️addAll之后修改之前的list的元素：<br>修改是对新的list有效的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">a.setName(&quot;lll&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList();</span><br><span class="line">list2.addAll(list1);</span><br><span class="line">System.out.println(list2); //[A(name=lll)]</span><br><span class="line">a.setName(&quot;www&quot;);</span><br><span class="line">System.out.println(list1); //[A(name=www)]</span><br><span class="line">System.out.println(list2); //[A(name=www)]</span><br></pre></td></tr></table></figure>

<h4 id="十三、list反转"><a href="#十三、list反转" class="headerlink" title="十三、list反转"></a>十三、list反转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.使用stream的sorted (这种方法只能用于普通类型)</span><br><span class="line">List&lt;Long&gt; li = Lists.newArrayList(1L, 2L);</span><br><span class="line">li = li.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line">System.out.println(li);</span><br><span class="line"></span><br><span class="line">2.使用Collections.reverse方法</span><br><span class="line">A a1 = new A(&quot;lll&quot;);</span><br><span class="line">A a2 = new A(&quot;hhh&quot;);</span><br><span class="line">List&lt;A&gt; list = Lists.newArrayList(a1, a2);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">3.保留原List进行反转</span><br><span class="line">List&lt;Integer&gt; listData = new ArrayList&lt;&gt;();</span><br><span class="line">listData.add(1);</span><br><span class="line">listData.add(2);</span><br><span class="line">List&lt;Integer&gt; tempData = Arrays.asList(new Integer[listData.size()]);</span><br><span class="line">Collections.copy(tempData, listData);</span><br><span class="line">Collections.reverse(listData);</span><br><span class="line">System.out.println(&quot;反转后原来:&quot; + tempData);</span><br><span class="line">System.out.println(&quot;反转后现在:&quot; + listData);</span><br></pre></td></tr></table></figure>

<h4 id="十四、list复制"><a href="#十四、list复制" class="headerlink" title="十四、list复制"></a>十四、list复制</h4><p>首先看一下初始化指定长度List的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(new Integer[10]);</span><br><span class="line">System.out.println(list.size());  //10</span><br><span class="line">System.out.println(list);  //都是null</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(10);</span><br><span class="line">System.out.println(list1.size());  //0</span><br><span class="line">System.out.println(list1);  //空[]</span><br></pre></td></tr></table></figure>

<p>list复制的几个方法：</p>
<p>1、copy一个List最简单方式就是使用构造器，这个构造器能接收一个集合参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(list);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.add(4);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br><span class="line">list.set(0, 5);</span><br><span class="line">System.out.println(copy);  //1 2 3</span><br></pre></td></tr></table></figure>
<p>对原来的list进行add，或者set修改某元素，不会影响到复制的。</p>
<p>但是由于使用这种方式的内部机制是：复制对象的引用而不是clone对象，所以对对象的每一个修改都将同时影响两个list。</p>
<p>正式由于上述的原因，使用构造器这种方法比较适用于那些不可改变对象在list间的复制。比如Integer、String…</p>
<p>2、addAll方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; copy = new ArrayList&lt;&gt;();</span><br><span class="line">copy.addAll(list);</span><br></pre></td></tr></table></figure>
<p>和使用构造器一样，在使用这个方法时，两个list中的内容都将引用的是相同对象。</p>
<p>3、Collections.copy</p>
<p>Collections类提供了一些专门用于操作集合的静态方法。其中一个就是copy。Collections.copy(dest,source),这个方法接收两个参数，一个是source list 和一个dest list（dest list的长度应大于source list，不然会报错：IndexOutOfBoundsException）。</p>
<p>这个方法的特点是： 它将保持每一个被copy元素在目标集合中的下标和它们在源集合中的下标一样。  即： 源集合中下标为1的元素会被复制到目标集合的下标为1的位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; source = Arrays.asList(1,2,3);</span><br><span class="line">List&lt;Integer&gt; dest = Arrays.asList(4,5,6);</span><br><span class="line">Collections.copy(dest, source);</span><br><span class="line">System.out.println(dest);  //1 2 3</span><br><span class="line"></span><br><span class="line">A a1 = new A(&quot;111&quot;);</span><br><span class="line">A a2 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list2 = Lists.newArrayList(a1, a2);</span><br><span class="line">// List&lt;A&gt; list3 = new ArrayList&lt;&gt;(2); //这种初始化大小不行</span><br><span class="line">List&lt;A&gt; list3 = Lists.newArrayList(new A[2]);</span><br><span class="line">System.out.println(list3);  //[null, null]</span><br><span class="line">Collections.copy(list3, list2);</span><br><span class="line">System.out.println(list3);  //[ListTest.A(name=111), ListTest.A(name=222)]</span><br><span class="line">list2.get(0).setName(&quot;333&quot;);</span><br><span class="line">System.out.println(list3);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>注意：这种复制方法也是直接复制引用，而不是深拷贝对象，改变原来List的对象会影响复制的List。</p>
<p>4、使用Java8 stream</p>
<p>在Java8中，我们可以使用stream来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;A&gt; list4 = list2.stream().collect(Collectors.toList());</span><br><span class="line">list2.get(0).setName(&quot;444&quot;);</span><br><span class="line">System.out.println(list4);  //会同时改变复制的List</span><br></pre></td></tr></table></figure>

<p>好处是可以用stream进行其他操作，但是还是浅拷贝。</p>
<p>5、对象深拷贝</p>
<p>首先，看下对象怎么深拷贝，重写Object的clone方法，并且需要实现Cloneable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">static</span><br><span class="line">class A implements Cloneable &#123;</span><br><span class="line">    A(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected A clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (A)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想要异常，就在clone方法里自己写set方法，新建对象返回。</p>
<p>对象的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a1 = new A(&quot;11&quot;);</span><br><span class="line">A a2 = a1;  //浅拷贝</span><br><span class="line">System.out.println(a2);</span><br><span class="line">System.out.println(a1 == a2);  //true</span><br><span class="line">A a3 = a1.clone();</span><br><span class="line">System.out.println(a1 == a3);  //false</span><br></pre></td></tr></table></figure>

<hr>
<p>Apache Commons Lang序列化 实现对象深拷贝</p>
<p>第一步、导入commons-lang3包</p>
<p>第二步、实体类实现Serializable接口</p>
<p>第三步、调用SerializationUtils工具类，实现深拷贝（注意：SerializationUtils不能直接拷贝List类型）<br><code>User user2 = SerializationUtils.clone(user1);</code></p>
<p>如果想拷贝List，需要新建一个实体类implements Serializable，然后将list变为其中属性，再用上面的操作深拷贝新建对象，再取其中的list。</p>
<p>或者用循环add深拷贝后的对象的方式实现list的深拷贝。</p>
<p>Java对象深拷贝详解（List深拷贝）:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42675423/article/details/128260074">https://blog.csdn.net/weixin_42675423/article/details/128260074</a></p>
<hr>
<p>6、json序列化实现list深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a4 = new A(&quot;111&quot;);</span><br><span class="line">A a5 = new A(&quot;222&quot;);</span><br><span class="line">List&lt;A&gt; list1 = Lists.newArrayList(a4, a5);</span><br><span class="line">List&lt;A&gt; list2 = JSONObject.parseArray(JSONObject.toJSONString(list1), A.class); //深拷贝</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<h4 id="十五、list交集并集"><a href="#十五、list交集并集" class="headerlink" title="十五、list交集并集"></a>十五、list交集并集</h4><p>求两个list的交集</p>
<p>需要导入apache的包：commons-collections</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Lists.newArrayList(&quot;11&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(&quot;44&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">Collection&lt;String&gt; list3 = CollectionUtils.intersection(list1, list2);</span><br></pre></td></tr></table></figure>

<hr>
<p>从list1中移除存在list2中的元素（差集）：<code>list1.removeAll(list2)</code></p>
<p>调用流程：removeAll-&gt;contains-&gt;equals方法，对于引用类型，要使用removeAll，需要重写equals方法。<br>contains方法中，当对象o不为空时，迭代判断用到了Object的equals方法，而Object的equals方法指的是两个对象的引用是否相等，如果我们要判断两个对象的内容相等，这里就需要重写equals方法。</p>
<p>两个list的并集：<code>a.addAll(b);</code></p>
<p>两个list的交集：<code>a.retainAll(b);</code></p>
<p>要去重的：<code>List newList = b.stream().distinct().collect(Collectors.toList());</code></p>
<hr>
<p>lambda表达式取交集、并集、差集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list1.add(&quot;1&quot;);</span><br><span class="line">    list1.add(&quot;2&quot;);</span><br><span class="line">    list1.add(&quot;3&quot;);</span><br><span class="line">    list1.add(&quot;5&quot;);</span><br><span class="line">    list1.add(&quot;6&quot;);</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();</span><br><span class="line">    list2.add(&quot;2&quot;);</span><br><span class="line">    list2.add(&quot;3&quot;);</span><br><span class="line">    list2.add(&quot;7&quot;);</span><br><span class="line">    list2.add(&quot;8&quot;);</span><br><span class="line"> </span><br><span class="line">    // 交集</span><br><span class="line">    List&lt;String&gt; intersection = list1.stream().filter(item -&gt; list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---交集 intersection---&quot;);</span><br><span class="line">    intersection.parallelStream().forEach(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 差集 (list1 - list2)</span><br><span class="line">    List&lt;String&gt; reduce1 = list1.stream().filter(item -&gt; !list2.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(&quot;---差集 reduce1 (list1 - list2)---&quot;);</span><br><span class="line">    reduce1.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">    // 并集</span><br><span class="line">    List&lt;String&gt; listAll = list1.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = list2.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(&quot;---并集 listAll---&quot;);</span><br><span class="line">    listAll.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    // 去重并集</span><br><span class="line">    List&lt;String&gt; listAllDistinct = listAll.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(&quot;---得到去重并集 listAllDistinct---&quot;);</span><br><span class="line">    listAllDistinct.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;---原来的List1---&quot;);</span><br><span class="line">    list1.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line">    System.out.println(&quot;---原来的List2---&quot;);</span><br><span class="line">    list2.parallelStream().forEachOrdered(System.out :: println);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十六、获取List-lt-DO-gt-中最小的begin"><a href="#十六、获取List-lt-DO-gt-中最小的begin" class="headerlink" title="十六、获取List&lt;DO&gt;中最小的begin"></a>十六、获取<code>List&lt;DO&gt;</code>中最小的begin</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DO do = list.stream().min(Comparator.comparing(DO::getBegin)).orElse(null);</span><br><span class="line">if (do != null) &#123;</span><br><span class="line">    Date min = do.getBegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用下面Stream里的min，结合Optional。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Long&gt; minBegin = list.stream()</span><br><span class="line">    .map(DO::getBegin)</span><br><span class="line">    .min(Long::compareTo);</span><br><span class="line">if(minBegin.isPresent())&#123;</span><br><span class="line">    minBegin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的，是线程不安全的，允许元素为null的双向链表。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/162980143">https://zhuanlan.zhihu.com/p/162980143</a></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="✅移除"><a href="#✅移除" class="headerlink" title="✅移除"></a>✅移除</h4><p>移除Set集合中的指定对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">set.add(&quot;111&quot;);</span><br><span class="line">set.add(&quot;222&quot;);</span><br><span class="line">set.remove(&quot;111&quot;);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<h4 id="获取上一个下一个元素"><a href="#获取上一个下一个元素" class="headerlink" title="获取上一个下一个元素"></a>获取上一个下一个元素</h4><p>用迭代器的<code>previous()</code>方法和<code>next()</code>方法</p>
<h3 id="Comparable、Comparator"><a href="#Comparable、Comparator" class="headerlink" title="Comparable、Comparator"></a>Comparable、Comparator</h3><p>要讲这个，就要讲list的排序，看上面，有几种办法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.list.sort(Comparator.comparing(A::getB))</span><br><span class="line">2.list.stream.sorted(Comparator.comparing(A::getB)).collect(Collectors.toList())</span><br><span class="line">3.list.stream.sorted((a1,a2)-&gt;a1.compareTo(a2))</span><br><span class="line">4.直接Collections.sort(list)  </span><br><span class="line">//这个需要list的元素实现Comparable接口，重写compareTo方法，比如String就实现了</span><br><span class="line">5.Collections.sort(list, new Comparator&lt;A&gt;()&#123;</span><br><span class="line">  @Oerride</span><br><span class="line">  public int compare(A a1, A a2)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>他们都是java的接口, 并且是用来对自定义的实体类比较大小的.</p>
<p>Comparable接口需要进行比较的实体类在定义时实现它，重写compareTo方法。<br>Comparator接口是在集合外部实现的排序，重写compare方法。Comparator接口比Comparable接口要灵活。</p>
<p>✅ compareTo()方法<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则表示两个对象相等，如果该方法返回一个正整数，则表明obj1大于obj2；如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>一些已经实现了Comparable接口的常用类：<br>Character：按照字符的UNICODE值进行比较<br>String：按照字符的UNICODE值进行比较<br>Date\Time：外面比里面新，返回1<br>Long：a.compareTo(b)，a比b大返回1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以特定格式返回日期格式化程序</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date oldTime = dateFormat.parse(&quot;2019-04-07 19:50:11&quot;);</span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">// 日期变为字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="stream流-parallelStream流"><a href="#stream流-parallelStream流" class="headerlink" title="stream流 parallelStream流"></a>stream流 parallelStream流</h3><p>stream(): 是串行执行，按照顺序执行</p>
<p>parallelStream()：是并行执行，异步执行，多线程，并且使用的线程池是ForkJoinPool.common，可能存在共享资源、线程安全等问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">过滤：</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream().filter(i -&gt; i &gt; 3);   //filter里面的条件是留下来的条件</span><br><span class="line">integerList = stream.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">排序：</span><br><span class="line">.stream().sorted((e1,e2)-&gt;e1.compareTo(e2)).</span><br><span class="line"></span><br><span class="line">去重：</span><br><span class="line">.stream().distinct().</span><br><span class="line"></span><br><span class="line">按照对象中某一元素去重：[tolook]</span><br><span class="line">.stream().filter(...)</span><br><span class="line"></span><br><span class="line">返回指定流个数：</span><br><span class="line">.limit(5)</span><br><span class="line"></span><br><span class="line">跳过流中元素：</span><br><span class="line">.skip(2)</span><br><span class="line"></span><br><span class="line">map流映射：将接收的元素映射成另外一个元素：</span><br><span class="line">.map(类::get属性).collect...</span><br><span class="line">.map(对象-&gt;&#123;</span><br><span class="line">  构造另一种对象;</span><br><span class="line">  return 另一对象;</span><br><span class="line">&#125;).</span><br><span class="line">.map(string-&gt;Long.valueOf(string)).  //String变为Long</span><br><span class="line"></span><br><span class="line">对象list根据某一个元素变为map：(变成 元素-对象list的map)</span><br><span class="line">list.stream().collect(Collectors.groupingBy(类::get属性))</span><br><span class="line"></span><br><span class="line">//流的过程中对元素进行操作</span><br><span class="line">List&lt;Long&gt; list = Lists.newArrayList();</span><br><span class="line">list2.stream().forEach(s -&gt; list.add(Long.valueOf(s)));</span><br><span class="line"></span><br><span class="line">anyMatch判断</span><br><span class="line">想比较list1中是否存在list2中的任何对象</span><br><span class="line">可以遍历两个列表并使用.contains()比较所有元素</span><br><span class="line">但是更高效的方法是anyMatch：</span><br><span class="line">List&lt;Item&gt; list1;</span><br><span class="line">List&lt;Item&gt; list2;</span><br><span class="line">boolean anyMatch = list1.stream().anyMatch(x -&gt; x.equals(list2.stream()));</span><br><span class="line">System.out.println(anyMatch);</span><br><span class="line">很容易理解，即是有一个或一个以上的元素满足函数参数计算结果为true那整个方法返回值为true。</span><br></pre></td></tr></table></figure>

<h4 id="✅list-stream-mapToDouble"><a href="#✅list-stream-mapToDouble" class="headerlink" title="✅list.stream().mapToDouble"></a>✅list.stream().mapToDouble</h4><p>求最大最小，求和求平均</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.stream().mapToDouble(User::getAge).sum()//和</span><br><span class="line">list.stream().mapToDouble(User::getAge).max()//最大</span><br><span class="line">list.stream().mapToDouble(User::getAge).min()//最小</span><br><span class="line">list.stream().mapToDouble(User::getAge).average()//平均值</span><br><span class="line"></span><br><span class="line">double sum = list.stream().mapToDouble(Integer::doubleValue).sum();</span><br></pre></td></tr></table></figure>

<h4 id="✅list变map"><a href="#✅list变map" class="headerlink" title="✅list变map"></a>✅list变map</h4><p>第一种：会出现键重复异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//以id为主键转为map</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId,Function.identity()));</span><br></pre></td></tr></table></figure>

<p>第二种：不会出现重复键异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//给出key重复时，使用哪个key作为主键，以下代码中的(key1, key2) -&gt; key2)代表key1和key2键重复时返回key2做主键</span><br><span class="line">Map&lt;Long, User&gt; map = list.stream().collect(Collectors.toMap(User::getId, Function.identity(), (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第三种：对象变为属性-属性map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 不想返回对象，只返回对象里某个属性时 采用这种方式</span><br><span class="line">Map&lt;Long, String&gt; map = list.stream().collect(Collectors.toMap(User::getId, User::getAge, (key1, key2) -&gt; key2));</span><br></pre></td></tr></table></figure>

<p>第四种：以某一属性分组，变为属性-对象list map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&gt; map = list.stream().collect(Collectors.groupingBy(User::getId));</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lizaiismy/article/details/121352640">https://blog.csdn.net/lizaiismy/article/details/121352640</a></p>
<p>ps：<code>Function.identity()</code><br>Function是一个接口，Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。<br><code>Function.identity()</code>返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static  Function identity() &#123;</span><br><span class="line">    return t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>Function.identity()</code>是一个用来返回自己的lambda表达式</p>
<h4 id="✅stream流的max-min方法"><a href="#✅stream流的max-min方法" class="headerlink" title="✅stream流的max,min方法"></a>✅stream流的max,min方法</h4><p>max : 获取最大值<br>min : 获取最小值</p>
<p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></p>
<p>max、min 方法参数类型为 Comparator 接口,利用比较器自定义排序。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; personList = Arrays.asList(</span><br><span class="line">                new Person(1, &quot;大毛&quot;, 30, 175),</span><br><span class="line">                new Person(2, &quot;二毛&quot;, 35, 170),</span><br><span class="line">                new Person(3, &quot;三毛&quot;, 26, 173),</span><br><span class="line">                new Person(4, &quot;小毛&quot;, 30, 175));</span><br><span class="line"> </span><br><span class="line">        // 获取 person 类型流</span><br><span class="line">        Stream&lt;Person&gt; personStream = personList.stream();</span><br><span class="line">        // 按照年龄升序排序,然后获取排序后的最大值 o1-o2 代表升序排序;o2-o1 代表降序排序</span><br><span class="line">        Optional&lt;Person&gt; max = personStream.max(((o1, o2) -&gt; o1.getAge() - o2.getAge()));</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅有一个List-lt-Map-gt-想根据字段统计数量"><a href="#✅有一个List-lt-Map-gt-想根据字段统计数量" class="headerlink" title="✅有一个List&lt;Map&gt;想根据字段统计数量"></a>✅有一个<code>List&lt;Map&gt;</code>想根据字段统计数量</h4><p>使用Collectors.groupingBy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt;list = </span><br><span class="line">Map&lt;String, Long&gt; res = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(map -&gt; (String)map.get(&quot;city&quot;), Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>如果想统计去重后的数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt;list = </span><br><span class="line">Map&lt;String, Long&gt; res = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(map -&gt; (String)map.get(&quot;city&quot;), </span><br><span class="line">    Collectors.maping(map -&gt; map.get(&quot;task_id&quot;), Collectors.toSet())))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry :: getKey, e -&gt; (long)e.getValue().size())));</span><br></pre></td></tr></table></figure>


<h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h4 id="✅now-after"><a href="#✅now-after" class="headerlink" title="✅now.after()"></a>✅now.after()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(oldTime))&#123;</span><br><span class="line">    System.out.println(&quot;now比after新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateFormat类"><a href="#✅DateFormat类" class="headerlink" title="✅DateFormat类"></a>✅DateFormat类</h4><p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p>
<p>在创建 DateFormat 对象时不能使用 new 关键字，而应该使用 DateFormat 类中的静态方法 getDateInstance()：<br><code>DateFormat df = DateFormat.getDatelnstance();</code><br>在创建了一个 DateFormat 对象后，可以调用该对象中的方法来对日期/时间进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//定义对象，日期、时间，也有getDateTimeInstance</span><br><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br><span class="line"></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"></span><br><span class="line">//字符串到Date</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line"></span><br><span class="line">//Date到字符串</span><br><span class="line">String str = dateFormat.format(new Date());</span><br><span class="line"></span><br><span class="line">Date newTime = new Date();</span><br><span class="line">int result = oldTime.compareTo(newTime);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">DateFormat dateformat = DateFormat.getDateInstance();</span><br><span class="line">Date old = dateformat.parse(&quot;2022-04-07 19:50:11&quot;);</span><br><span class="line">Date now = new Date();</span><br><span class="line">if(now.after(old))&#123;</span><br><span class="line">    System.out.println(&quot;now比old新&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅SimpleDateFormat"><a href="#✅SimpleDateFormat" class="headerlink" title="✅SimpleDateFormat"></a>✅SimpleDateFormat</h4><p>DateFormat可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat</p>
<p>SimpleDateFormat 使得可以选择任何用户定义的日期/时间格式的模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date(); // 创建一个Date对象，获取当前时间</span><br><span class="line">// 指定格式化格式</span><br><span class="line">SimpleDateFormat f = new SimpleDateFormat(&quot;今天是 &quot; + &quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;);</span><br><span class="line">// Date转为String</span><br><span class="line">System.out.println(f.format(now)); // 将当前时间袼式化为指定的格式</span><br><span class="line">// String转为Date</span><br><span class="line">String str=&quot;2008-08-08 12:12:12&quot;;</span><br><span class="line">SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date dd=sdf2.parse(str);</span><br><span class="line">System.out.println(dd);</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/878.html">http://c.biancheng.net/view/878.html</a></p>
<h4 id="✅FastDataFormat"><a href="#✅FastDataFormat" class="headerlink" title="✅FastDataFormat"></a>✅FastDataFormat</h4><p>Apache commons-lang中的FastDateFormat。也可以做时间的格式化。<br>FastDateFormat是线程安全的，可以直接使用，不必考虑多线程的情况<br>JDK里自带的SimpleDateFormat存在线程不安全问题。<br>SimpleDateFormat在对时间进行格式化的方法format中，会先对calendar对象进行setTime的赋值，若是有多个线程同时操作一个SimpleDateFormat实例的话，就会对calendar的赋值进行覆盖，进而产生问题。</p>
<p>FastDateFormat用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FastDateFormat f = FastDateFormat.getInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;);  </span><br><span class="line">String s = f.format(new Date());</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">Date dd=f.parse(s);</span><br></pre></td></tr></table></figure>


<h4 id="✅当前时间的后几秒："><a href="#✅当前时间的后几秒：" class="headerlink" title="✅当前时间的后几秒："></a>✅当前时间的后几秒：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前时间的后几秒</span><br><span class="line">Date data = new Date(System.currentTimeMillis() + 10 * 1000);</span><br><span class="line">System.out.println(data);</span><br><span class="line">加的是毫秒</span><br></pre></td></tr></table></figure>

<p>获取当前时间的月份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mon = LocalDate.now().getMonthValue();</span><br></pre></td></tr></table></figure>

<h4 id="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"><a href="#✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】" class="headerlink" title="✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】"></a>✅LocalDate、LocalTime、LocalDateTime【java8新提供的类】</h4><p>为什么需要LocalDate、LocalTime、LocalDateTime</p>
<p>1.Date如果不格式化，打印出的日期可读性差<br>Tue Sep 10 09:34:04 CST 2019<br>Date对时间处理比较麻烦。<br>getYear、getMonth这些方法吗，获取年月日很Easy，但都被弃用了。</p>
<p>2.使用SimpleDateFormat对时间进行格式化，但SimpleDateFormat是线程不安全的。SimpleDateFormat的format方法中的calendar是共享变量，并且这个共享变量没有做线程安全控制。当多个线程同时使用相同的SimpleDateFormat对象【如用static修饰的SimpleDateFormat】调用format方法时，多个线程会同时调用calendar.setTime方法，可能一个线程刚设置好time值。另外的一个线程马上把设置的time值给修改了导致返回的格式化时间可能是错误的。在多并发情况下使用SimpleDateFormat需格外注意 SimpleDateFormat除了format是线程不安全以外，parse方法也是线程不安全的。</p>
<p>多线程并发如何保证线程安全 - 避免线程之间共享一个SimpleDateFormat对象，每个线程使用时都创建一次SimpleDateFormat对象 =&gt; 创建和销毁对象的开销大 - 对使用format和parse方法的地方进行加锁 =&gt; 线程阻塞性能差 - 使用ThreadLocal保证每个线程最多只创建一次SimpleDateFormat对象 =&gt; 较好的方法。</p>
<p>LocalDate用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">只会获取年月日</span><br><span class="line">//获取当前年月日</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">//构造指定的年月日</span><br><span class="line">LocalDate localDate1 = LocalDate.of(2019, 9, 10);</span><br><span class="line"></span><br><span class="line">获取年、月、日、星期几</span><br><span class="line">int year = localDate.getYear();  //2022</span><br><span class="line">int year1 = localDate.get(ChronoField.YEAR); //2022</span><br><span class="line">Month month = localDate.getMonth();  //JUNE</span><br><span class="line">int month1 = localDate.get(ChronoField.MONTH_OF_YEAR);  //6</span><br><span class="line"></span><br><span class="line">//获取当前日期是所在年的第几天、月的第几天、当前星期</span><br><span class="line">int day = localDate.getDayOfMonth();  //26</span><br><span class="line">int day1 = localDate.get(ChronoField.DAY_OF_MONTH);  //26</span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek(); //SUNDAY</span><br><span class="line">int dayOfWeek1 = localDate.get(ChronoField.DAY_OF_WEEK); //7</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">int year = now.getDayOfYear();  //一年的第几天</span><br><span class="line">int month = now.getDayOfMonth();  //月的第几天</span><br><span class="line"></span><br><span class="line">System.out.println(LocalDate.MAX);  //+999999999-12-31</span><br><span class="line">System.out.println(LocalDate.MIN);  //-999999999-01-01</span><br><span class="line"></span><br><span class="line">//获取当前月，当前月天数</span><br><span class="line">Month month = now.getMonth();  //JANUARY</span><br><span class="line">int monthValue = now.getMonthValue();</span><br><span class="line">int i = now.lengthOfMonth();</span><br><span class="line"></span><br><span class="line">//with指定年月日</span><br><span class="line">LocalDate localDate = now.withDayOfMonth(1);  //当月的指定日</span><br><span class="line">LocalDate localDate1 = now.withDayOfYear(21);  //获取今年第第几天</span><br><span class="line">LocalDate localDate2 = now.withMonth(3);  //今年指定月份，日为当天的日期</span><br><span class="line">LocalDate localDate3 = now.withYear(2004);  //指定年份的今天</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LocalTime用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">只会获取几点几分几秒</span><br><span class="line">创建LocalTime</span><br><span class="line">LocalTime localTime = LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">获取时分秒</span><br><span class="line">//获取小时</span><br><span class="line">int hour = localTime.getHour();</span><br><span class="line">int hour1 = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">//获取分</span><br><span class="line">int minute = localTime.getMinute();</span><br><span class="line">int minute1 = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">//获取秒</span><br><span class="line">int second = localTime.getSecond();</span><br><span class="line">int second1 = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">获取年月日时分秒，等于LocalDate+LocalTime</span><br><span class="line">创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2019, 6, 26, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 = localTime.atDate(localDate);</span><br><span class="line">获取LocalDate</span><br><span class="line">LocalDate localDate2 = localDateTime.toLocalDate();</span><br><span class="line">获取LocalTime</span><br><span class="line">LocalTime localTime2 = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure>

<p>Instant: 可以精确到纳秒的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">获取秒数</span><br><span class="line">创建Instant对象</span><br><span class="line">Instant instant = Instant.now();  //提前北京时间8小时</span><br><span class="line"></span><br><span class="line">//根据时期添加偏移量</span><br><span class="line">OffsetDateTime offsetDateTime1 = instance.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">System.out.println(&quot;处理后时间为：&quot;+offsetDateTime1);</span><br><span class="line"></span><br><span class="line">获取秒数</span><br><span class="line">long currentSecond = instant.getEpochSecond();</span><br><span class="line">获取毫秒数</span><br><span class="line">long currentMilli = instant.toEpochMilli();</span><br><span class="line">如果只是为了获取秒数或者毫秒数，使用System.currentTimeMillis()来得更为方便</span><br></pre></td></tr></table></figure>

<p>时间变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate、LocalTime、LocalDateTime、Instant为不可变对象，修改这些对象对象会返回一个副本</span><br><span class="line">增加、减少年数、月数、天数等 以LocalDateTime为例</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">14, 46, 56);</span><br><span class="line">//增加一年</span><br><span class="line">localDateTime = localDateTime.plusYears(1);</span><br><span class="line">localDateTime = localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">//减少一个月</span><br><span class="line">localDateTime = localDateTime.minusMonths(1);</span><br><span class="line">localDateTime = localDateTime.minus(1, ChronoUnit.MONTHS);</span><br><span class="line">通过with修改某些值</span><br><span class="line">//修改年为2019</span><br><span class="line">localDateTime = localDateTime.withYear(2020);</span><br><span class="line">//修改为2022</span><br><span class="line">localDateTime = localDateTime.with(ChronoField.YEAR, 2022);</span><br><span class="line">还可以修改月、日</span><br></pre></td></tr></table></figure>

<p>时间计算:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如有些时候想知道这个月的最后一天是几号、下个周末是几号，通过提供的时间和日期API可以很快得到答案</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">//得到今年第一天</span><br><span class="line">LocalDate localDate1 = localDate.with(firstDayOfYear());</span><br><span class="line">比如通过firstDayOfYear()返回了当前日期的第一天日期，还有很多方法这里不在举例说明</span><br></pre></td></tr></table></figure>

<p>格式化时间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 = localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">//自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;dd/MM/yyyy&quot;);</span><br><span class="line">String s3 = localDate.format(dateTimeFormatter);</span><br><span class="line">DateTimeFormatter默认提供了多种格式化方式，如果默认提供的不能满足要求，可以通过DateTimeFormatter的ofPattern方法创建自定义格式化方式</span><br><span class="line"></span><br><span class="line">//变为字符串：</span><br><span class="line">String currentTime = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(LocalDateTime.now());</span><br><span class="line">System.out.println(currentTime);</span><br><span class="line">String currentTime1 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">System.out.println(currentTime1</span><br></pre></td></tr></table></figure>

<p>解析时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 = LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">和SimpleDateFormat相比，DateTimeFormatter是线程安全的</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1685414035437236647&amp;wfr=spider&amp;for=pc</a></p>
<p>更多用法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158786867">https://zhuanlan.zhihu.com/p/158786867</a></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtilsTest &#123;</span><br><span class="line">    public static final String DATE_PATTERN = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        // 获取指定格式时间字符串</span><br><span class="line">        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_PATTERN));</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        // 获取当前月份</span><br><span class="line">        Integer month = LocalDateTime.now().getMonth().getValue();</span><br><span class="line">        System.out.println(month);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        // 时间戳</span><br><span class="line">        long timeStamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;时间戳：&quot; + timeStamp);</span><br><span class="line">        // 时间戳字符串到时间戳到LocalDateTime</span><br><span class="line">        LocalDateTime time = new Timestamp(timeStamp).toLocalDateTime();</span><br><span class="line">        System.out.println(&quot;LocatDateTime：&quot; + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：获取指定天后的日期字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.now().plusDays(1).format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="✅Calendar、Date、LocalDate-LocalTime关系"><a href="#✅Calendar、Date、LocalDate-LocalTime关系" class="headerlink" title="✅Calendar、Date、LocalDate/LocalTime关系"></a>✅Calendar、Date、LocalDate/LocalTime关系</h4><p>1、Date 类如今很多方法已经没有什么用处了，如今时间的处理并不直接在Date 类中进行，而是通过Calendar，或者LocalDate 来进行，我们在日常使用中，更多的是要来做一个记录日期的实例。</p>
<p>2、Date用于记录某一个含日期的、精确到毫秒的时间。重点在代表一刹那的时间本身。Calendar用于将某一日期放到历法中的互动——时间和年、月、日、星期、上午、下午、夏令时等这些历法规定互相作用关系和互动。Calendar本身代表公历的一个简化缩水版，姑且叫“计算机历”。</p>
<p>3、Java 8新增了LocalDate和LocalTime接口，为什么要搞一套全新的处理日期和时间的API？因为旧的java.util.Date实在是太难用了。<br>java.util.Date月份从0开始，一月是0，十二月是11，变态吧！java.time.LocalDate月份和星期都改成了enum，就不可能再用错了。<br>java.util.Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jaycekon/p/6179700.html">https://www.cnblogs.com/jaycekon/p/6179700.html</a></p>
<h4 id="✅Calender"><a href="#✅Calender" class="headerlink" title="✅Calender"></a>✅Calender</h4><p>Calendar 是一个抽象类, 无法通过直接实例化得到对象. 因此, Calendar 提供了一个方法 getInstance（工厂方法）,来获得一个Calendar的子类对象, 得到的 Calendar 由当前时间初始化.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CalenderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set (2013, 5, 4, 13, 44, 51);//年月日时分秒 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.YEAR, 2014); //年</span><br><span class="line">        cal.set (Calendar.MONTH, 7); //月 (月份0代表1月)</span><br><span class="line">        cal.set (Calendar.DATE, 11); //日</span><br><span class="line">        cal.set (Calendar.HOUR_OF_DAY, 15); //时</span><br><span class="line">        cal.set (Calendar.MINUTE, 33); //分</span><br><span class="line">        cal.set (Calendar.SECOND, 32); //秒</span><br><span class="line"></span><br><span class="line">        //同时还有get、add方法，使用类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calendar是父类，GregorianCalendar是子类。<br>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。可以使用new关键字创建实例。</p>
<p>例子：返回当前时间加10分钟后的日期时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = new GregorianCalendar();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.add(GregorianCalendar.MINUTE, 10);</span><br><span class="line">Date after = calendar.getTime();</span><br><span class="line">System.out.println(after);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//1.创建Calendar对象</span><br><span class="line">Calendar calendar =Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.getTime());//Calender变Date</span><br><span class="line">System.out.println(calendar.getTimeInMillis());//Calender变时间戳</span><br><span class="line">Calendar calendar1 = new GregorianCalendar();</span><br><span class="line">System.out.println(calendar1.getTime()); //输出一样</span><br><span class="line"></span><br><span class="line">//2.获取时间信息</span><br><span class="line">//获取年</span><br><span class="line">int year = calendar.get(Calendar.YEAR);</span><br><span class="line">//月</span><br><span class="line">int month = calendar.get(Calendar.MONTH);</span><br><span class="line">//日</span><br><span class="line">int day = calendar.get(Calendar.DAY_OF_MONTH);//DATE</span><br><span class="line">//小时</span><br><span class="line">int hour = calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">//分钟</span><br><span class="line">int minute = calendar.get(Calendar.MINUTE);</span><br><span class="line">//秒</span><br><span class="line">int second = calendar.get(Calendar.SECOND);</span><br><span class="line">System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+&quot;  &quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;);</span><br><span class="line"></span><br><span class="line">//修改时间</span><br><span class="line">Calendar calendar2 =Calendar.getInstance();</span><br><span class="line">calendar2.set(Calendar.DAY_OF_MONTH,5);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//add方法修改时间</span><br><span class="line">calendar2.add(Calendar.HOUR,-1);</span><br><span class="line">System.out.println(calendar2.getTime().toLocaleString());</span><br><span class="line"></span><br><span class="line">//获取当月多少天</span><br><span class="line">int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH); //30</span><br><span class="line">int min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH); //1</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1439775520/article/details/98442556">https://blog.csdn.net/a1439775520/article/details/98442556</a> </p>
<p>🍎用Calender计算量日期相差天数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private static int differentDays(Date date1,Date date2) &#123;</span><br><span class="line">    Calendar cal1 = Calendar.getInstance();</span><br><span class="line">    cal1.setTime(date1);</span><br><span class="line"></span><br><span class="line">    Calendar cal2 = Calendar.getInstance();</span><br><span class="line">    cal2.setTime(date2);</span><br><span class="line">    int day1= cal1.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">    int day2 = cal2.get(Calendar.DAY_OF_YEAR);</span><br><span class="line"></span><br><span class="line">    int year1 = cal1.get(Calendar.YEAR);</span><br><span class="line">    int year2 = cal2.get(Calendar.YEAR);</span><br><span class="line">    if(year1 != year2) &#123;//不同年</span><br><span class="line">        int timeDistance = 0 ;</span><br><span class="line">        for(int i = year1 ; i &lt; year2 ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%4==0 &amp;&amp; i%100!=0 || i%400==0)    //闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 366;</span><br><span class="line">            &#125;</span><br><span class="line">            else    //不是闰年</span><br><span class="line">            &#123;</span><br><span class="line">                timeDistance += 365;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return timeDistance + (day2-day1) ;</span><br><span class="line">    &#125; else &#123;// 同年</span><br><span class="line">        System.out.println(&quot;判断day2 - day1 : &quot; + (day2-day1));</span><br><span class="line">        return day2-day1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int differentDaysByMillisecond(Date date1,Date date2)&#123;</span><br><span class="line">    int days = (int) ((date2.getTime() - date1.getTime()) / (1000*3600*24));</span><br><span class="line">    return days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅时间戳"><a href="#✅时间戳" class="headerlink" title="✅时间戳"></a>✅时间戳</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void timeStampTest() &#123;</span><br><span class="line">  // 当前时间时间戳</span><br><span class="line">  long nowStamp = System.currentTimeMillis();</span><br><span class="line">  System.out.println(&quot;毫秒时间戳：&quot; + nowStamp);</span><br><span class="line">  long nowhaomiao = System.currentTimeMillis() * 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳&quot; + nowhaomiao);</span><br><span class="line">  long nowhaomiao1 = System.nanoTime() / 1000;</span><br><span class="line">  System.out.println(&quot;微妙时间戳1&quot; + nowhaomiao1); //不行</span><br><span class="line"></span><br><span class="line">  // 昨天这个时间时间戳</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.add(Calendar.DAY_OF_YEAR, -1);</span><br><span class="line">  //calender.getTime变Date，再getTime变时间戳（long型的）</span><br><span class="line">  System.out.println(&quot;昨天此时：&quot; + calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 昨天某时间的时间戳</span><br><span class="line">  Calendar calendar1 = Calendar.getInstance();</span><br><span class="line">  calendar.set(calendar1.get(Calendar.YEAR), calendar1.get(Calendar.MONTH), calendar1.get(Calendar.DAY_OF_MONTH) - 1, 23, 59, 59);</span><br><span class="line">  System.out.println(calendar.getTime().getTime());</span><br><span class="line"></span><br><span class="line">  // 时间戳转换为Date</span><br><span class="line">  Date now = new Date(nowStamp);  //long型</span><br><span class="line">  //如果是时间戳字符串，用下面</span><br><span class="line">  //Date now1 = new Date(Long.parseLong(nowStamp));</span><br><span class="line">  System.out.println(&quot;now: &quot; + now);</span><br><span class="line">  // 再转换为字符串</span><br><span class="line">  String format = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line">  SimpleDateFormat sdf = new SimpleDateFormat(format);</span><br><span class="line">  System.out.println(&quot;now: &quot; + sdf.format(now));</span><br><span class="line"></span><br><span class="line">  // 日期格式字符串转换为时间戳</span><br><span class="line">  String s = &quot;2022-06-25 12:12:12&quot;;</span><br><span class="line">  try &#123;</span><br><span class="line">      // String-Date-long型时间戳</span><br><span class="line">      System.out.println(&quot;时间戳：&quot; + String.valueOf(sdf.parse(s).getTime()));</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅DateUtils工具类"><a href="#✅DateUtils工具类" class="headerlink" title="✅DateUtils工具类"></a>✅DateUtils工具类</h4><p>apache.commons.lang3包下的工具类</p>
<p>1、获取指定日期的开始时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDateUtils() throws ParseException &#123;</span><br><span class="line">    // 获取指定日期的开始时间</span><br><span class="line">    DateFormat df = DateFormat.getDateInstance();</span><br><span class="line">    Date date = df.parse(&quot;2022-06-24 14:01:01&quot;);</span><br><span class="line">    Date begin = org.apache.commons.lang3.time.DateUtils.truncate(date, Calendar.DATE);</span><br><span class="line">    System.out.println(&quot;初始时间：&quot; + begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅计算两个时间段之间的所有天"><a href="#✅计算两个时间段之间的所有天" class="headerlink" title="✅计算两个时间段之间的所有天"></a>✅计算两个时间段之间的所有天</h4><p>输入：begin:‘2022-08-01’ end:‘2022-08-05’<br>输出：”2021-08-01”,”2021-08-02”,”2021-08-03”,”2021-08-04”,”2021-08-05”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; findDates(String beginTime, String endTime)</span><br><span class="line">        throws ParseException &#123;</span><br><span class="line">    List&lt;String&gt; allDate = new ArrayList();</span><br><span class="line">    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    Date dBegin = sdf.parse(beginTime);</span><br><span class="line">    Date dEnd = sdf.parse(endTime);</span><br><span class="line">    allDate.add(sdf.format(dBegin));</span><br><span class="line">    Calendar calBegin = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calBegin.setTime(dBegin);</span><br><span class="line">    Calendar calEnd = Calendar.getInstance();</span><br><span class="line">    // 使用给定的 Date 设置此 Calendar 的时间</span><br><span class="line">    calEnd.setTime(dEnd);</span><br><span class="line">    // 测试此日期是否在指定日期之后</span><br><span class="line">    while (dEnd.after(calBegin.getTime())) &#123;</span><br><span class="line">        // 根据日历的规则，为给定的日历字段添加或减去指定的时间量</span><br><span class="line">        calBegin.add(Calendar.DAY_OF_MONTH, 1);</span><br><span class="line">        allDate.add(sdf.format(calBegin.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;时间==&quot; + allDate);</span><br><span class="line">    return allDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅判断是否同一天"><a href="#✅判断是否同一天" class="headerlink" title="✅判断是否同一天"></a>✅判断是否同一天</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    LocalDate localDate1 = date1.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    LocalDate localDate2 = date2.toInstant()</span><br><span class="line">            .atZone(ZoneId.systemDefault())</span><br><span class="line">            .toLocalDate();</span><br><span class="line">    return localDate1.isEqual(localDate2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSameDay(Date date1, Date date2) &#123;</span><br><span class="line">    SimpleDateFormat fmt = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">    return fmt.format(date1).equals(fmt.format(date2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nandao158/article/details/121905050">https://blog.csdn.net/nandao158/article/details/121905050</a></p>
<h4 id="✅获取今天星期几"><a href="#✅获取今天星期几" class="headerlink" title="✅获取今天星期几"></a>✅获取今天星期几</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = new Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>

<p>获取到的数字，星期一到星期七对应数字{2，3，4，5，6, 7，0}，所以需要减一，减一之后判断是不是等于0，等于0就变成7.</p>
<h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="int变String-String变int"><a href="#int变String-String变int" class="headerlink" title="int变String,String变int"></a>int变String,String变int</h4><p>第一种方式：使用int的封装类Integer，在Integer里面用他的toString方法。（性能最好）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=3；</span><br><span class="line">String s=Integer.toString(i);</span><br></pre></td></tr></table></figure>

<p>第二种方式：String的valueOf方法，传参是Object（性能第二）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">String s=String.valueOf(i);</span><br></pre></td></tr></table></figure>

<p>第三种方式，直接在int后面加一个空的字符串，因为在java里面，默认任务int类型和字符串类型相加，为字符串类型。（性能最差）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i=2；</span><br><span class="line">String s=i+&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>string变int/Long：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = Integer.parseInt(s);</span><br><span class="line">Integer i = Integer.valueOf(s);</span><br><span class="line">Long l = Long.valueOf(s);</span><br><span class="line">Long l1 = Long.parseLong(s);</span><br></pre></td></tr></table></figure>

<p><code>Integer.parseInt</code> 方法：<br>parseInt(String s, int radix)： s表示字符串  radix表示字符串数值的进制，例如：parseInt(“100”, 16) = 256<br>parseInt(String s)：相当于默认是10进制</p>
<h4 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h4><p>String.format(String format, Object… args)<br>字符串格式化方法，sout也这么用。</p>
<p><code>String str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);  </code></p>
<p>%s    字符串类型    “hello”<br>%c    字符类型    ‘m’<br>%b    布尔类型    true<br>%d    整数类型（十进制）    88<br>%x    整数类型（十六进制）    FF<br>%o    整数类型（八进制）    77<br>%f    浮点类型    8.888<br>%a    十六进制浮点类型    FF.35AE<br>%e    指数类型    9.38e+5<br>%g    通用浮点类型（f和e类型中较短的）    不举例(基本用不到)<br>%h    散列码    不举例(基本用不到)<br>%%    百分比类型    ％(%特殊字符%%才能显示%)<br>%n    换行符    不举例(基本用不到)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    String str=null;  </span><br><span class="line">    str=String.format(&quot;Hi,%s&quot;, &quot;小超&quot;);  </span><br><span class="line">    System.out.println(str);  </span><br><span class="line">    str=String.format(&quot;Hi,%s %s %s&quot;, &quot;小超&quot;,&quot;是个&quot;,&quot;大帅哥&quot;);            </span><br><span class="line">    System.out.println(str);                           </span><br><span class="line">    System.out.printf(&quot;字母c的大写是：%c %n&quot;, &#x27;C&#x27;);  </span><br><span class="line">    System.out.printf(&quot;布尔结果是：%b %n&quot;, &quot;小超&quot;.equal(&quot;帅哥&quot;));  </span><br><span class="line">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class="line">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class="line">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class="line">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class="line">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class="line"></span><br><span class="line">日期格式：%tx x代表日期转换符</span><br><span class="line">c	包括全部日期和时间信息	星期六 十月 27 14:21:20 CST 2007</span><br><span class="line">F	“年-月-日”格式	2007-10-27</span><br><span class="line">D	“月/日/年”格式	10/27/07</span><br><span class="line">r	“HH:MM:SS PM”格式（12时制）	02:25:51 下午</span><br><span class="line">T	“HH:MM:SS”格式（24时制）	14:28:16</span><br><span class="line">R	“HH:MM”格式（24时制）	14:28</span><br><span class="line"></span><br><span class="line">Date date=new Date();                                  </span><br><span class="line">//c的使用  </span><br><span class="line">System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class="line">//f的使用  </span><br><span class="line">System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class="line">//d的使用  </span><br><span class="line">System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class="line">//r的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class="line">//t的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class="line">//R的使用  </span><br><span class="line">System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;%f&quot;, d);// &quot;f&quot;表示格式化输出浮点数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%9.2f&quot;, d);// &quot;9.2&quot;中的9表示输出的长度，2表示小数点后的位数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+9.2f&quot;, d);// &quot;+&quot;表示输出的数带正负号。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%-9.4f&quot;, d);// &quot;-&quot;表示输出的数左对齐（默认为右对齐）。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%+-9.3f&quot;, d);// &quot;+-&quot;表示输出的数带正负号且左对齐。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%d&quot;, i);// &quot;d&quot;表示输出十进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%o&quot;, i);// &quot;o&quot;表示输出八进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%x&quot;, i);// &quot;d&quot;表示输出十六进制整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%#x&quot;, i);// &quot;d&quot;表示输出带有十六进制标志的整数。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;%s&quot;, s);// &quot;d&quot;表示输出字符串。  </span><br><span class="line">System.out.println();  </span><br><span class="line">System.out.printf(&quot;输出一个浮点数：%f，一个整数：%d，一个字符串：%s&quot;, d, i, s);  </span><br><span class="line">// 可以输出多个变量，注意顺序。  </span><br><span class="line">System.out.println();  </span><br></pre></td></tr></table></figure>

<h4 id="Strings-nullToEmpty"><a href="#Strings-nullToEmpty" class="headerlink" title="Strings.nullToEmpty"></a>Strings.nullToEmpty</h4><p>Strings、Lists、Maps 都是google提供的工具类。<br>使用之前导入包guava。</p>
<p>vo.setS(String.nullToEmpty(s));  一般用于给对象属性赋值，如果为null，就设空。</p>
<p>其他guava工具类使用：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/article/17770773.html">https://www.w3cschool.cn/article/17770773.html</a></p>
<h4 id="StringUtils工具类"><a href="#StringUtils工具类" class="headerlink" title="StringUtils工具类"></a>StringUtils工具类</h4><p>StringUtils工具类是org.apache.commons.lang3包下的工具类，对String类型的操作作了封装，是对Java自带的API的有效补充，可以帮助我们更高效快速地处理字符串。</p>
<p>导入commons-lang3包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String substringAfter(String str,String separator)：</span><br><span class="line">在第一次出现分隔符后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringAfterLast(String str,String separator)：</span><br><span class="line">在最后一次出现分隔符之后获取子字符串。</span><br><span class="line"></span><br><span class="line">String substringBefore(String str,String separator)：</span><br><span class="line">也是第一次出现之前的</span><br><span class="line">StringUtils.substringBefore(&quot;www.baidu.com&quot;, &quot;.)  www</span><br></pre></td></tr></table></figure>

<p>工具类：一般是直接用它的静态方法，直接用类来调用，例如：Collections、Arrays等jaa自带的工具类；Lists、Maps等google工具类；CollectionUtils、StringUtils等apache工具类。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1662921">https://cloud.tencent.com/developer/article/1662921</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.EMPTY = &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 只替换一次--&gt;结果是：phhhss</span><br><span class="line">StringUtils.replaceOnce(&quot;sshhhss&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 全部替换</span><br><span class="line">StringUtils.replace(&quot;sshhhs&quot;, &quot;ss&quot;, &quot;p&quot;);</span><br><span class="line">// 定义替换次数</span><br><span class="line">StringUtils.replace(&quot;sshhhsshss&quot;, &quot;ss&quot;, &quot;7777&quot;,2);</span><br><span class="line">// 检验字符串是否不为null且不为“”</span><br><span class="line">if(!StringUtils.isEmpty(s))</span><br><span class="line"></span><br><span class="line">//忽略大小写的比较：</span><br><span class="line">System.out.println(StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;aBC&quot;));</span><br></pre></td></tr></table></figure>

<p><code>ObjectUtils.allNotNull(o1, o2)</code> 是commons-lang3包下的，返回boolean，表示是否所有的对象都不为null，false表示有null。</p>
<h4 id="string自己的方法"><a href="#string自己的方法" class="headerlink" title="string自己的方法"></a>string自己的方法</h4><p>✅str.trim()  用于删除字符串的头尾空白符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;   hello   &quot;);</span><br><span class="line">System.out.println( str.trim() );</span><br></pre></td></tr></table></figure>

<p>✅str.replaceAll(正则表达式, 替换字符串)<br>使用给定的参数 replacement 替换字符串所有匹配给定的正则表达式的子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Str = new String(&quot;www.hello.com&quot;);</span><br><span class="line">System.out.println(Str.replaceAll(&quot;(.*)hello(.*)&quot;, &quot;hi&quot; ));</span><br></pre></td></tr></table></figure>

<p>✅str.replace(原字符/字符串, 替换成的新字符/字符串)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String replace(char oldChar, char newChar)</span><br><span class="line">用新字符newChar 替换所有的 旧字符oldChar 。</span><br><span class="line"></span><br><span class="line">String replace(CharSequence target, CharSequence replacement)</span><br><span class="line">用新字符串replacement替换所有的 旧字符串target。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换所有的 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line"></span><br><span class="line">String replaceFirst(String regex, String replacement)</span><br><span class="line">用新字符串replacement 替换第一个 正则模式匹配的串。——（替换的是模糊字串）</span><br><span class="line">————————————————</span><br><span class="line">另外，StringBuilder中也有该方法：</span><br><span class="line">replace(int start，int end，String str)</span><br><span class="line">用str 替换 start–end的子串。//不包括end</span><br></pre></td></tr></table></figure>

<p>✅str.indexof() 用于返回字符串中某部分的索引<br>1、 indexOf(String str): 返回指定字符str在字符串中（方法调用者）第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。<br>2、indexOf(String str, int index): 返回从 index 位置开始查找指定字符str在字符串中第一次出现处的起始索引，如果此字符串中没有这样的字符，则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;01234567890123456789&quot;;</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;));  //return 1</span><br><span class="line">System.out.println(str.indexOf(&quot;123&quot;,5));  //return 11</span><br></pre></td></tr></table></figure>

<p>str.lastIndexOf(“//“)  返回最后一次出现字符/字符串的位置。</p>
<p>✅String.join()静态方法<br>用于将list/set变为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; list = Lists.newArrayList(1L, 2L, 2L);</span><br><span class="line">// 元素中类型变换</span><br><span class="line">List&lt;String&gt; ls = list.stream().distinct().map(String::valueOf).collect(Collectors.toList());</span><br><span class="line">// 里面的ls不能为空，必须是String元素类型</span><br><span class="line">String s = String.join(&quot;,&quot;, ls);</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">//用set也可以</span><br><span class="line">Set&lt;Long&gt; set = Sets.newHashSet(1L, 2L);</span><br><span class="line">Set&lt;String&gt; ss = set.stream().map(i-&gt;String.valueOf(i)).collect(Collectors.toSet());</span><br><span class="line">s = String.join(&quot;,&quot;, ss);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>✅获取某个位置的字符<br><code>char c = s.charAt(index);</code></p>
<h4 id="Splitter工具类（String拆分成list）"><a href="#Splitter工具类（String拆分成list）" class="headerlink" title="Splitter工具类（String拆分成list）"></a>Splitter工具类（String拆分成list）</h4><p>是google出品的，guava包下的工具类，用于对字符串分割处理。</p>
<p>首先，已有的对字符串进行分割的方法：</p>
<p>1.String自带的split()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;1,2,3&quot;;</span><br><span class="line">String[] split = s.split(&quot;,&quot;);</span><br></pre></td></tr></table></figure>
<p>不足之处：如果,后有空格的话，还需要做进一步处理，<br>并且分割后以数组接收，如果数据过多，还需要再转为集合。</p>
<p>2.使用Patter类的split静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;This!!unusual use!!hh!!points&quot;;</span><br><span class="line">System.out.println(Arrays.toString(Pattern.compile(&quot;!!&quot;).split(input)));</span><br></pre></td></tr></table></figure>

<p>3.Splitter来分割字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SplitterTest &#123;</span><br><span class="line"></span><br><span class="line">    //定义一个拆分器，“,”分隔，去空格</span><br><span class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;).trimResults().omitEmptyStrings();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String s = &quot;1,2, 3&quot;;</span><br><span class="line">        List&lt;String&gt; list = splitter.splitToList(s);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        List&lt;Long&gt; list1 = list.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Joiner连接字符串"><a href="#Joiner连接字符串" class="headerlink" title="Joiner连接字符串"></a>Joiner连接字符串</h4><p>google guava提供的用来连接字符串的类。需要导包：guava。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 连接字符串list</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB:CC</span><br><span class="line"></span><br><span class="line">//过滤其中的null</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, null);</span><br><span class="line">String str = Joiner.on(&quot;:&quot;).skipNulls().join(list);</span><br><span class="line">System.out.println(str);</span><br><span class="line">// 输出：AA:BB</span><br><span class="line"></span><br><span class="line">// 可以先定义一个Join对象</span><br><span class="line">private static Joiner MY_JOINER = Joiner.on(&quot;/&quot;).skipNulls();</span><br><span class="line">String s = MY_JOINER.join(..);  里面的参数是Object类型，可以多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44143796/article/details/122998799">https://blog.csdn.net/qq_44143796/article/details/122998799</a></p>
<h4 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h4><p>✅截取字符串</p>
<p>1、string自己的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">System.out.println(s.substring(2)); //llo</span><br><span class="line">System.out.println(s.substring(2, 4)); //ll 左闭右开</span><br></pre></td></tr></table></figure>

<p>2、StringUtils提供的方法（apache）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.substring(&quot;hello world&quot;, 4);   // 返回值，从第4位截取到字符串末尾 : o wrold</span><br><span class="line">StringUtils.substring(&quot;hello world&quot;, 4, 10); // 返回值，从第4位截取到第9位 :   o wrol</span><br><span class="line"></span><br><span class="line">//截取某个字符串之前的字符</span><br><span class="line">StringUtils.substringBefore(&quot;hello world&quot;, &quot;l&quot;); </span><br><span class="line">//结果是：he          这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringBeforeLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：hello wor   这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取某个字符串之后的字符</span><br><span class="line">StringUtils.substringAfter(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果是：lo world   这里是以第一个”l”，为标准。</span><br><span class="line">StringUtils.substringAfterLast(&quot;hello world&quot;, &quot;l&quot;);</span><br><span class="line">//结果为：d          这里以最后一个“l”为准。</span><br><span class="line"></span><br><span class="line">//截取两个字符串之间隔的字符</span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;o&quot;);    </span><br><span class="line">//结果是： w   两个o之间的字符串。   </span><br><span class="line">StringUtils.substringBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;); </span><br><span class="line">//结果是： lo wo   第一个字符“l”与第一个字符“r”之间的字符串   </span><br><span class="line">StringUtils.substringsBetween(&quot;hello world&quot;, &quot;l&quot;, &quot;r&quot;);</span><br><span class="line">//结果是：数组 [lo wo]   第一个字符“l”与第一个字符“r”之间的字符串，以数组形式返回。   </span><br></pre></td></tr></table></figure>

<p>3、string自己的split方法<br>将字符串按照分割符截取，以数组形式返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hello, world, ni,  hao&quot;;</span><br><span class="line">String[]  strs=str.split(&quot;,&quot;);</span><br><span class="line">for(int i=0,len=strs.length;i&lt;len;i++)&#123;</span><br><span class="line">    System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">//空格也算了</span><br><span class="line">hello</span><br><span class="line"> world</span><br><span class="line"> ni</span><br><span class="line">  hao</span><br></pre></td></tr></table></figure>

<p><code>split(String regex)</code> 参数regex称为分割符,可以使用正则表达式来表示。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str= &quot;a33b444c555d&quot;;</span><br><span class="line">//正则表达式中\d+表示一个或多个数字,java中\\表示一个普通\</span><br><span class="line">//String[] split = str.split(Pattern.compile(&quot;\\d+&quot;).toString());</span><br><span class="line">//两种写法都是一样的,下面写法简洁</span><br><span class="line">String[] split = str.split(&quot;\\d+&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa|bbb|ccc&quot;;</span><br><span class="line">//使用|作为分隔符,其余特殊字符同理</span><br><span class="line">//两个\表示一个\,加了\后表示仅匹配字符本身</span><br><span class="line">String[] split = str.split(&quot;\\|&quot;);</span><br><span class="line"></span><br><span class="line">String str= &quot;aaa,bbb#ccc&quot;;</span><br><span class="line">//使用,或#分割字符串</span><br><span class="line">String[] split = str.split(&quot;,|#&quot;);</span><br></pre></td></tr></table></figure>

<p><code>split(String regex,int limit)</code> limit控制分割的次数，只填一个正则表达式的话,limit默认是0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）limit &gt; 0,(从左到右)最多分割 n - 1 次,数组的长度将不会大于 n,结尾的空字符串不会丢弃</span><br><span class="line">//limit=3,切割2次,末尾会分割出一个&quot;&quot;空字符串</span><br><span class="line">String[] split = &quot;abcb&quot;.split(&quot;b&quot;,3);</span><br><span class="line">//split:&#123;&quot;a&quot;,&quot;c&quot;,&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">（2）limit &lt; 0,匹配到多少次就分割多少次,而且数组可以是任何长度。结尾的空字符串不会丢弃</span><br><span class="line"></span><br><span class="line">（3）limit=0不限制分割次数，要注意结尾的空字符串将会丢弃</span><br></pre></td></tr></table></figure>

<p>split方法完整用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41740883/article/details/111696866">https://blog.csdn.net/qq_41740883/article/details/111696866</a></p>
<p>✅字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接用+，内部会替换成StringBuilder的append方法</span><br><span class="line">    // 不建议在 for 循环中使用 “+” 进行字符串拼接，会创建多个StringBuilder 对象</span><br><span class="line">    String s1 = &quot;hel&quot;;</span><br><span class="line">    String s2 = null;</span><br><span class="line">    System.out.println(s1 + s2); //helnull  如果是null，当作字符串null来处理</span><br><span class="line">    </span><br><span class="line">    // 2.StringBuilder的append方法 （非线程安全）</span><br><span class="line">    StringBuilder s3 = new StringBuilder(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s3.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 3.StringBuffer的append方法 （线程安全）</span><br><span class="line">    StringBuffer s4 = new StringBuffer(&quot;hel&quot;);</span><br><span class="line">    System.out.println(s4.append(&quot;lo&quot;));</span><br><span class="line">    </span><br><span class="line">    // 4.String类的concat方法</span><br><span class="line">    System.out.println(s1.concat(&quot;lo&quot;));</span><br><span class="line">    //System.out.println(s1.concat(null)); //NPE</span><br><span class="line">    </span><br><span class="line">    // 5.String类的静态join方法 JDK 1.8 提供，可以分隔符，也可以多个字符串(看上面，也可以是list/set)</span><br><span class="line">    System.out.println(String.join(&quot;&quot;, &quot;hel&quot;, &quot;lo&quot;)); //第一个参数为字符串连接符，后面可以是很多个字符串连接</span><br><span class="line">    </span><br><span class="line">    // 6.org.apache.commons.lang3.StringUtil的join方法（为什么使用这个会慢？？？）</span><br><span class="line">    // 不用担心 NullPointerException,内部使用的仍然是 StringBuilder</span><br><span class="line">    System.out.println(StringUtils.join(&quot;hel&quot;, &quot;lo&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ChineseSoftware/article/details/122956817">https://blog.csdn.net/ChineseSoftware/article/details/122956817</a></p>
<p>concat与+的区别：<br>①如果拼接的字符串是 null，concat 时候就会抛出 NullPointerException，“+” 操作符会当做是 “null” 字符串来处理。<br>②如果拼接的字符串是一个空字符串(“”)，那么 concat 的效率要更高一点。毕竟不需要 new StringBuilder 对象。<br>③如果拼接的字符串非常多，concat 的效率就会下降，因为用到字符数组，开销就大。</p>
<p>✅字符串翻转</p>
<p>1、用stringBuffer或者stringBuilder自带的reverse方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String newS = new StringBuilder(old).reverse().toString();</span><br></pre></td></tr></table></figure>

<p>2、将字符串拆分为char数组，然后交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">char[] charArray = s.toCharArray();</span><br><span class="line">int start = 0, end = charArray.length - 1;</span><br><span class="line">for (; start &lt; end; start++, end--) &#123;</span><br><span class="line">    charArray[start] ^= charArray[end];//采用异或</span><br><span class="line">    charArray[end] ^= charArray[start];</span><br><span class="line">    charArray[start] ^= charArray[end];</span><br><span class="line">&#125;</span><br><span class="line">String newS = new String(charArray);</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">while (start &lt; end) &#123;</span><br><span class="line">    //交换首尾char值</span><br><span class="line">    char c = charArray[end];</span><br><span class="line">    charArray[end] = charArray[start];</span><br><span class="line">    charArray[start] = c;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、stringBuffer倒序拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">for (int i = s.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    sb.append(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>4、利用栈的先进后出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">Stack stack = new Stack();</span><br><span class="line">for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    stack.push(s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">    //stack会返回栈顶值，并且会把该值删除</span><br><span class="line">    sb.append(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line">String newS = sb.toString();</span><br></pre></td></tr></table></figure>

<p>5、切割递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    if (s.length() &lt;= 1) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //每次把第一个放在后面</span><br><span class="line">    return reverse(s.substring(1)) + s.substring(0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、二分递归反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String reverse(String s) &#123;</span><br><span class="line">    int length = s.length();</span><br><span class="line">    if (length &lt;= 1) return s;</span><br><span class="line">    String left = s.substring(0, length / 2);</span><br><span class="line">    String right = s.substring(length / 2, length);</span><br><span class="line">    return reverse(right) + reverse(left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/237801.htm">https://www.jb51.net/article/237801.htm</a></p>
<p>✅删除字符串最后一个字符</p>
<p>1、String的substring方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">System.out.println(s.substring(0, s.length() - 1));</span><br></pre></td></tr></table></figure>

<p>2、replaceFirst方法 正则表达式匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abcd&quot;;</span><br><span class="line">str = str.replaceFirst(&quot;.$&quot;, &quot;&quot;);</span><br><span class="line">//匹配除“\n”和&quot;\r&quot;之外的任何单个字符</span><br><span class="line">//匹配输入行尾。</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35764295/article/details/126106534">https://blog.csdn.net/qq_35764295/article/details/126106534</a></p>
<h4 id="StringBuilder操作"><a href="#StringBuilder操作" class="headerlink" title="StringBuilder操作"></a>StringBuilder操作</h4><p>✅删除最后一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&#x27;a&#x27;).append(&#x27;b&#x27;).append(&#x27;c&#x27;);</span><br><span class="line">sb.deleteCharAt(sb.length()-1);</span><br><span class="line">System.out.println(sb); //ab</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">sb.delete(sb.length()-1, sb.length());</span><br></pre></td></tr></table></figure>

<h3 id="map相关"><a href="#map相关" class="headerlink" title="map相关"></a>map相关</h3><h4 id="map几种遍历方式"><a href="#map几种遍历方式" class="headerlink" title="map几种遍历方式"></a>map几种遍历方式</h4><p>一、Map.Entry遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">  System.out.println(&quot;key= &quot; + entry.getKey());</span><br><span class="line">  System.out.println(&quot;value= &quot; + entry.getValue());</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>二、通过Iterator迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**通过entrySet()方法将key和value存放到Set集合中，Set集合中有迭代器**/</span><br><span class="line">Set&lt;Entry&lt;String,String&gt;&gt; entry = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,String&gt;&gt; iterators = entry.iterator();</span><br><span class="line">while(iterators.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,String&gt; entrys  = iterators.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+entrys.getKey()+&quot;&amp;&amp;value=&quot;+entrys.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、通过keySet()遍历<br>keySet()：将Map中所有的key存放到Set集合中。因为Set集合有迭代器，可以通过迭代器循环key，再通过get()方法，得到每个key所对应的value；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**通过keySet()方法将所有的key值存放到Set集合中,Set集合中有迭代器**/</span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  System.out.println(&quot;key=&quot;+key+&quot;  &quot;+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以不用迭代器，直接for循环</span><br><span class="line">for (String key: map.keySet()) &#123;</span><br><span class="line">  System.out.println(&quot;key:&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、values()遍历<br>values()获取集合中的所有的value值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = map.values();</span><br><span class="line">再for遍历得到value，同样也可以用迭代器</span><br><span class="line">Iterator var3 = values.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">  String value = (String)var3.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、直接foreach map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;第五种:&quot; + key + &quot; ：&quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="MapUtils工具类"><a href="#MapUtils工具类" class="headerlink" title="MapUtils工具类"></a>MapUtils工具类</h4><p>MapUtils是 org.apache.commons.collections 工具包中常用的工具类<br>需要导入包：commons-collections4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int value = MapUtils.getInteger(map, key, 0)</span><br><span class="line">//将结果转换为Integer，如果转换失败则使用默认值</span><br></pre></td></tr></table></figure>

<p>更多用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012894692/article/details/82557843">https://blog.csdn.net/u012894692/article/details/82557843</a></p>
<h4 id="map的一些操作"><a href="#map的一些操作" class="headerlink" title="map的一些操作"></a>map的一些操作</h4><p>✅map的size</p>
<p>map.size() 返回 hashMap 中键/值对的数量。</p>
<p>✅map的put和putIfAbsent<br>1.使用 put 方法添加键值对，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null；如果已经存在对应的值，则会<strong>覆盖旧值</strong>，value 为新的值，返回值为旧的value。<br><code>map.put(key, value)</code></p>
<p>2.使用 putIfAbsent 方法添加键值对，不存在才加入，如果 map 集合中没有该 key 对应的值，则直接添加，并返回 null，如果已经存在对应的值，则依旧为原来的值，返回值为 value（旧的值）。<br><code>map.putIfAbsent(key, value)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;11&quot;, &quot;11&quot;);</span><br><span class="line">    System.out.println(map.put(&quot;11&quot;, &quot;22&quot;));  //输出11</span><br><span class="line">    System.out.println(map.put(&quot;22&quot;, &quot;22&quot;));  //输出null</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;11&quot;, &quot;33&quot;));  //输出22</span><br><span class="line">    System.out.println(map.putIfAbsent(&quot;33&quot;, &quot;44&quot;));  //输出33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>✅map.getOrDefault(key, defaultvalue)<br>用于map获取value，与.get(key)不同的是，如果得到的value是null的话，可以给一个默认值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;StudentGrade&gt; gradeList = Lists.newArrayList();</span><br><span class="line">//把学生成绩list变为map：学生-成绩list</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeMap = Maps.newHashMap();</span><br><span class="line">for(StudentGrade studentGrade : gradeList) &#123;</span><br><span class="line">  List&lt;String&gt; grades = gradeMap.getOrDefault(studentGrade.getName(), Lists.newArrayList());</span><br><span class="line">  grades.add(studentGrade.getGrade());</span><br><span class="line">  gradeMap.put(studentGrade.getName(), grades); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅对map的某个value加一</p>
<p>用<code>map.get(i)++;</code> 不行。得先：<code>int v = map.get(i) + 1;</code> 然后：<code>map.put(i, v);</code></p>
<p>✅某key是否存在<br><code>map.containsKey(key)</code></p>
<p>✅json字符串转换为map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, String&gt; map = JSON.parseObject(jsonString, Map.class);</span><br></pre></td></tr></table></figure>

<p>✅ceilingEntry()</p>
<p>java.util.TreeMap.ceilingEntry() 返回具有最小键值（大于或等于指定键）的键值对，如果没有这样的键，则返回null。(取比输入值大的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;1&quot;);</span><br><span class="line">map.put(3, &quot;3&quot;);</span><br><span class="line">Map.Entry&lt;Integer, String&gt; entry = map.ceilingEntry(2);</span><br><span class="line">System.out.println(entry.getValue()); //3</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>定义枚举类，定义在一个包中，和impl、service、vo包平级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum SexEnum:int &#123;</span><br><span class="line">    male,female;</span><br><span class="line">&#125;</span><br><span class="line">多个枚举成员之间使用逗号分隔，</span><br><span class="line">如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum DemoEnum &#123;</span><br><span class="line">  LIU(&quot;liu&quot;, 1),</span><br><span class="line">  WANG(&quot;wang&quot;, 2);</span><br><span class="line">  UN_KNOW(&quot;unknow&quot;, 99)</span><br><span class="line"></span><br><span class="line">  private final String name;</span><br><span class="line">  private final int age;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  private DemoEnum(String name, int age)&#123; </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //可以存一个map供外部使用，里面是直接的enum类</span><br><span class="line">  static Map&lt;String, DemoEnum&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">    for (DemoEnum enum : DemoEnum.values()) &#123;</span><br><span class="line">      map.put(enum.getName(), enum)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static DemoEnum getEnumByName(String name) &#123;</span><br><span class="line">    return map.get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //根据属性获得enum，再获得另一属性</span><br><span class="line">  //可以使用上面构造个map，再从map获取的方法</span><br><span class="line">  //也可以加个方法，遍历获取，根据属性获取enum</span><br><span class="line">  public static DemoEnum nameOf(String name) &#123;</span><br><span class="line">    for (DemoEnum e : DemoEnum.values()) &#123;</span><br><span class="line">      if (e.name = name) &#123;</span><br><span class="line">        return e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UN_KNOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类的values()方法，获取定义的成员数组：<br><code>DemoEnum[] values = DemoEnum.values();</code></p>
<p>Enum valueOf方法：<br>通过字符串来获取枚举enum：<br><code>DemoEnum e = DemoEnum.valueOf(&quot;LIU&quot;)</code></p>
<h3 id="File相关"><a href="#File相关" class="headerlink" title="File相关"></a>File相关</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。<br>File对象代表磁盘中实际存在的文件和目录。<br>自我理解：File对象就是文件路径在java里的一个抽象，并不代表真实文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">新建文件：</span><br><span class="line">String dirname = &quot;/java&quot;;</span><br><span class="line">File f1 = new File(dirname);</span><br><span class="line"></span><br><span class="line">// 判断该文件是否是一个目录</span><br><span class="line">if (f1.isDirectory()) &#123; &#125;</span><br><span class="line">f1.isFile() 是否是文件</span><br><span class="line"></span><br><span class="line">// 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</span><br><span class="line">String s[] = f1.list();</span><br><span class="line">for (int i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  File f = new File(dirname + &quot;/&quot; + s[i]);</span><br><span class="line">  if (f.isDirectory()) &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a directory&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    System.out.println(s[i] + &quot; is a file&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName()  返回此抽象路径名表示的文件或目录的名称。（文件名）</span><br><span class="line"></span><br><span class="line">public String getPath()  将此抽象路径名转换为一个路径名字符串。（路径名）</span><br><span class="line"></span><br><span class="line">public String getParent()  返回此抽象路径名的父路径名的路径名字符串（路径名）</span><br><span class="line"></span><br><span class="line">public File getParentFile()  返回父文件</span><br><span class="line"></span><br><span class="line">public boolean exists()  测试此抽象路径名表示的文件或目录是否存在。</span><br><span class="line"></span><br><span class="line">// 创建文件所在目录：</span><br><span class="line">File file = new File(&quot;/Users/liuxuan/MyProject/hi.md&quot;);</span><br><span class="line">File dirFile = file.getParentFile();</span><br><span class="line">if(dirFile != null &amp;&amp; !dirFile.exists())&#123;</span><br><span class="line">  dirFile.mkdirs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多方法：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-file.html">https://www.runoob.com/java/java-file.html</a></p>
<p>✅文件读写的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IOException &#123;</span><br><span class="line">    // 1. 新建文件夹</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    File file1 = new File(filePath);</span><br><span class="line">    boolean isSame = file.equals(file1);  //true 重写了，变值比较</span><br><span class="line">    boolean isSame1 = file == file1;  //false 地址比较</span><br><span class="line">    System.out.println(isSame);  //true</span><br><span class="line">    if(!file.getParentFile().exists()) &#123;</span><br><span class="line">        File dirFile = file.getParentFile();</span><br><span class="line">        dirFile.mkdirs();  //建立父文件夹</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.字节数组直接写文件，下面有加一步输出流的方式</span><br><span class="line">    String filePath1 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi.java&quot;;</span><br><span class="line">    File file2 = new File(filePath1);</span><br><span class="line">    if(file2.exists()) &#123;</span><br><span class="line">        boolean res = file2.delete();</span><br><span class="line">        System.out.println(&quot;delete:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] data = &quot;hi&quot;.getBytes();</span><br><span class="line">    byte[] data1 = &quot;System.out.println(\&quot;hi\&quot;)&quot;.getBytes();  //String变字节数组</span><br><span class="line">    try &#123;</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data);</span><br><span class="line">        FileUtils.writeByteArrayToFile(file2, data1);  //覆写的方式</span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组</span><br><span class="line">    FileInputStream in = new FileInputStream(file2);  //也有传入路径字符串的构造函数</span><br><span class="line">    // 输入流变字节数组</span><br><span class="line">    byte[] data2 = IOUtils.toByteArray(in);</span><br><span class="line">    //String content = data2.toString();  //字节数组变String，用这个不对</span><br><span class="line">    String content = new String(data2);  //得用它</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content);</span><br><span class="line">    String content4 = Arrays.toString(data2);</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content4); //这样输出的是数字</span><br><span class="line"></span><br><span class="line">    // 3.读取文件：用输入流 文件-&gt;输入流-&gt;字节数组，另种方法</span><br><span class="line">    FileInputStream in1 = new FileInputStream(file2);</span><br><span class="line">    byte[] data3 = new byte[20];</span><br><span class="line">    String content3 = CharStreams.toString(new InputStreamReader(in1, Charsets.UTF_8)); //这里也消耗输入流</span><br><span class="line">    System.out.println(&quot;前面获取输入流内容：&quot; + content3);</span><br><span class="line">    int num = in1.read(data3);  //输入流消耗20个字节</span><br><span class="line">    System.out.println(&quot;几个字节：&quot; + num);</span><br><span class="line">    String content1 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容：&quot; + content1);   //这里只剩几个可以展示</span><br><span class="line">    String content2 = IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(&quot;输入流内容2：&quot; + content2);  //这里已经没有了</span><br><span class="line"></span><br><span class="line">    // 4.写文件：用输出流 字节数组-&gt;输出流-&gt;文件</span><br><span class="line">    String filePath2 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi2.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file3 = new File(filePath2);</span><br><span class="line">    FileOutputStream out = new FileOutputStream(filePath2);</span><br><span class="line">    byte[] data4 = &quot;System.out.println(\&quot;hi2\&quot;)&quot;.getBytes();</span><br><span class="line">    out.write(data4);  //如果文件存在内容，则是覆盖的方式</span><br><span class="line">    if(file3.exists()) System.out.println(&quot;写入成功&quot;);</span><br><span class="line">    //关闭流</span><br><span class="line">    IOUtils.closeQuietly(in);</span><br><span class="line">    IOUtils.closeQuietly(out);</span><br><span class="line"></span><br><span class="line">    // 5.copy文件：文件-输入流-字节数组-输出流-文件，用IOUtils.copy()一步到位</span><br><span class="line">    String filePath3 = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hi3.java&quot;;  //要写的文件，可以没建立</span><br><span class="line">    File file4 = new File(filePath3);</span><br><span class="line">    FileInputStream in3 = new FileInputStream(file3);</span><br><span class="line">    FileOutputStream out2 = new FileOutputStream(file4);</span><br><span class="line">    IOUtils.copy(in3, out2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅获取文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.方法一：使用java io</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    long size = file.length();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.方法二：使用java nio</span><br><span class="line">    Path filePath1 = Paths.get(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;);  //绝对路径</span><br><span class="line">    FileChannel fileChannel = FileChannel.open(filePath1);</span><br><span class="line">    long size1 = fileChannel.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size1 + &quot;B&quot;);</span><br><span class="line">    Path filePath2 = Paths.get(&quot;src/test/resources/hi.md&quot;);  //项目下路径</span><br><span class="line">    FileChannel fileChannel2 = FileChannel.open(filePath2);</span><br><span class="line">    long size2 = fileChannel2.size();</span><br><span class="line">    System.out.println(&quot;文件大小：&quot; + size2 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 3.方法三：使用  apache commons io (只能读文件夹的大小)</span><br><span class="line">    String dir = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile&quot;;</span><br><span class="line">    File file1 = new File(dir);</span><br><span class="line">    long size3 = FileUtils.sizeOfDirectory(file1);</span><br><span class="line">    System.out.println(&quot;文件夹大小：&quot; + size3 + &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">    // 用户可读视角？</span><br><span class="line">    String display = FileUtils.byteCountToDisplaySize(size);</span><br><span class="line">    System.out.println(display);  //117 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File流"><a href="#File流" class="headerlink" title="File流"></a>File流</h4><p>JAVA中针对文件的读写操作设置了一系列的流，其中主要有FileInputStream,FileOutputStream,FileReader,FileWriter四种最为常用的流</p>
<p>一、FileInputStream流</p>
<p>被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等</p>
<p>若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  File file=new File(&quot;xxxxxxxx&quot;); </span><br><span class="line">  //根据路径创建File类对象--这里路径即使错误也不会报错，因为只是产生File对象，还并未与计算机文件读写有关联</span><br><span class="line">        </span><br><span class="line">  try&#123;</span><br><span class="line">    FileInputStream fileInputStream=new FileInputStream(file);</span><br><span class="line">    //与根据File类对象的所代表的实际文件建立链接创建fileInputStream对象</span><br><span class="line">      &#125;catch (FileNotFoundException e)&#123;</span><br><span class="line">          System.out.println(&quot;文件不存在或者文件不可读或者文件是目录&quot;);</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 也可以根据文件路径名字符串进行建立</span><br><span class="line">FileInputStream fileInputStream=new FileInputStream(filepath);</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ai_bao_zi/article/details/81097898">https://blog.csdn.net/ai_bao_zi/article/details/81097898</a></p>
<p>IO流的关系：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lianshan/p/11911773.html">https://www.cnblogs.com/lianshan/p/11911773.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/q306507291/article/details/118825930">https://blog.csdn.net/q306507291/article/details/118825930</a></p>
<h4 id="FileUtils-工具类"><a href="#FileUtils-工具类" class="headerlink" title="FileUtils 工具类"></a>FileUtils 工具类</h4><p>apache 的commons-io包下的FileUtils，导包：commons-io</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;E:\\java\\file04\\abc雪.jpg&quot;);</span><br><span class="line">//删除指定文件，从不引发异常。</span><br><span class="line">FileUtils.deleteQuietly(file);</span><br><span class="line"></span><br><span class="line">//将byte数组写为File</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">FileUtils.writeByteArrayToFile(new File(path), bytes)</span><br><span class="line"></span><br><span class="line">//删除掉指定目录的文件</span><br><span class="line">FileUtils.deleteExistFile(new File(localpath));</span><br></pre></td></tr></table></figure>
<p>更多方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42402854/article/details/83374559">https://blog.csdn.net/qq_42402854/article/details/83374559</a></p>
<h4 id="IOUtils工具类"><a href="#IOUtils工具类" class="headerlink" title="IOUtils工具类"></a>IOUtils工具类</h4><p>它是 Apache Commons IO 的一部分 。该类的所有成员函数都被用来处理输入 - 输出流。这些方法基于 InputStream,  OutputStream,  Reader 和 Writer工作。</p>
<p>所有成员字段和方法都是静态的，不需要创建对象，直接用类名调用。</p>
<p>✅输入流转为字节数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将输入流转换成字符数组:</span><br><span class="line">byte[] bytes = IOUtils.toByteArray(inputStream);</span><br></pre></td></tr></table></figure>

<p>✅关闭流<br>之前关闭流，往往在finally中，因为会抛出IOException，所以finally中需要try catch，并且close之前需要判断是否为null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">  if (in != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      in.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          LOGGER.warn(&quot;Fail to close stream : &quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以使用 IOUtils.closeQuietly 来精简代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = new byte[1024];</span><br><span class="line">InputStream in = null;</span><br><span class="line">OutputStream out = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">      in = new FileInputStream(&quot;foo.txt&quot;);</span><br><span class="line">      in.read(data);</span><br><span class="line"></span><br><span class="line">      out = new FileOutputStream(&quot;foo.txt&quot;);</span><br><span class="line">      data = &quot;Hello, World&quot;.getBytes();</span><br><span class="line">      out.write(data);</span><br><span class="line"></span><br><span class="line">      IOUtils.copy(in, out);</span><br><span class="line"></span><br><span class="line">      in.close(); //close errors are handled</span><br><span class="line">      out.close();</span><br><span class="line">&#125; catch (IOException e) &#123; </span><br><span class="line">      // error handling</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">      IOUtils.closeQuietly(in);</span><br><span class="line">      IOUtils.closeQuietly(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sulia1234567890/article/details/120569718">https://blog.csdn.net/sulia1234567890/article/details/120569718</a></p>
<p>✅写文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws IOException &#123;</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    OutputStream out = new FileOutputStream(file, true);</span><br><span class="line">    IOUtils.write(&quot;hello&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;\n&quot;, out);</span><br><span class="line">    IOUtils.write(&quot;hi&quot;, out);</span><br><span class="line">    //也可以传字节数组、字符数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️new FileOutputStream(“b.txt”,true);</p>
<p>默认第二个参数是false，表示不追加，每次new对象都会清空之前的内容创建新的内容，ture表示在之前的基础上追加内容</p>
<p>✅字节数组转换为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = &quot;hello world&quot;.getBytes();</span><br><span class="line">//apache里io的IOUtils需要commons-io包</span><br><span class="line">String s1 = IOUtils.toString(data, &quot;utf-8&quot;);</span><br><span class="line">String s2 = new String(data);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>

<h4 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h4><p>需要依赖：spring-web</p>
<p>首先，“流”是一个抽象的概念，它是对输入输出设备的一种抽象理解，在java中，对数据的输入输出操作都是以“流”的方式进行的。“流”具有方向性，输入流、输出流是相对的。当程序需要从数据源中读入数据的时候就会开启一个输入流，相反，写出数据到某个数据源目的地的时候也会开启一个输出流。</p>
<p>MultipartFile是SpringMVC提供简化上传操作的工具类。实现文件的快速上传，不需要先将File转换成output流 再传输过去 接收端接收流再生成文件。</p>
<p>在不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据，文件是以二进制流传递到后端的，然后需要我们自己转换为File类。使用了MultipartFile工具类之后，我们对文件上传的操作就简便许多了。<br>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45393094/article/details/112056436">https://blog.csdn.net/weixin_45393094/article/details/112056436</a></p>
<p>✅内部方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface MultipartFile extends InputStreamSource &#123;</span><br><span class="line">    //getName() 返回参数的名称</span><br><span class="line">    String getName();</span><br><span class="line">    //获取源文件的昵称</span><br><span class="line">    @Nullable</span><br><span class="line">    String getOriginalFilename();</span><br><span class="line">    //getContentType() 返回文件的内容类型</span><br><span class="line">    @Nullable</span><br><span class="line">    String getContentType();</span><br><span class="line">    //isEmpty() 判断是否为空，或者上传的文件是否有内容</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    //getSize() 返回文件大小 以字节为单位</span><br><span class="line">    long getSize();</span><br><span class="line">    //getBytes() 将文件内容转化成一个byte[] 返回</span><br><span class="line">    byte[] getBytes() throws IOException;</span><br><span class="line">    //getInputStream() 返回InputStream读取文件的内容</span><br><span class="line">    InputStream getInputStream() throws IOException;</span><br><span class="line"></span><br><span class="line">    default Resource getResource() &#123;</span><br><span class="line">        return new MultipartFileResource(this);</span><br><span class="line">    &#125;</span><br><span class="line">    //transferTo(File dest) 用来把 MultipartFile 转换换成 File</span><br><span class="line">    void transferTo(File var1) throws IOException, IllegalStateException;</span><br><span class="line"></span><br><span class="line">    default void transferTo(Path dest) throws IOException, IllegalStateException &#123;</span><br><span class="line">        FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅MockMultipartFile</p>
<p>可以用MockMultipartFile创建MultipartFile。需要导入spring-test.jar</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MockMultipartFile(String name, @Nullable String originalFilename, @Nullable String contentType, InputStream contentStream)</span><br><span class="line">第一个参数：传输后的文件名 </span><br><span class="line">第二个：旧文件名字（可为空） </span><br><span class="line">第三：类型</span><br><span class="line">第四：输入流</span><br></pre></td></tr></table></figure>

<p>✅MultipartFile与File的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() throws IOException &#123;</span><br><span class="line">    // 1.File转为MultipartFile：file-InputStream-MultipartFile</span><br><span class="line">    String filePath = &quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/hello.java&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    System.out.println(file.getName());  //hello.java</span><br><span class="line">    System.out.println(FilenameUtils.getExtension(file.getName()));  //后缀java</span><br><span class="line">    FileInputStream in = new FileInputStream(file);</span><br><span class="line">    MultipartFile mf = new MockMultipartFile(file.getName(), file.getName(), &quot;text/plain&quot;, in);</span><br><span class="line">    System.out.println(mf.getName()); //hello.java</span><br><span class="line">    System.out.println(mf.getOriginalFilename());  //hello.java</span><br><span class="line"></span><br><span class="line">    // 2.MultipartFile转为File</span><br><span class="line">    try &#123;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        //得到文件后缀</span><br><span class="line">        String originalName = mf.getOriginalFilename();</span><br><span class="line">        String ext = &quot;.&quot; + FilenameUtils.getExtension(originalName);</span><br><span class="line">        String fileName = uuid + ext;</span><br><span class="line">        File targetFile = new File(&quot;/Users/liuxuan/MyProject/JavaProject/SingleFile/&quot;, fileName);</span><br><span class="line">        //第一个参数：文件夹  第二个参数：文件名</span><br><span class="line">        // 方法一：MultipartFile - 字节数组 - File本地</span><br><span class="line">        FileUtils.writeByteArrayToFile(targetFile, mf.getBytes());</span><br><span class="line">        // 方法二：MultipartFile - 字节数组 - 输出流 - File本地</span><br><span class="line">        byte[] data = mf.getBytes();</span><br><span class="line">        FileOutputStream out = new FileOutputStream(targetFile);</span><br><span class="line">        out.write(data);</span><br><span class="line">        IOUtils.closeQuietly(out);</span><br><span class="line">        // 方法三：直接用MultipartFile内部方法</span><br><span class="line">        mf.transferTo(targetFile);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        System.out.println(&quot;失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅使用MultipartFile实现文件上传的一个case</p>
<p>背景：文件上传备份希望它是和主业务线程处于异步情况下的，这样可以更快的响应给用户反馈，减少等待时间。<br>MultipartFile异步保存文件transferto 报错java.io.FileNotFoundException: XXX.tmp (No such file or directory)</p>
<p>原因：由于SpringBoot上传文件后会形成MultiPartFile的实例，在临时文件夹中生成临时文件，并且此实例执行此临时文件。当主线程执行结束后，<br>SpringMVC会清除掉此临时文件，导致子线程在处理此实例的时候找不到此实例指向的临时文件，MultipartFile对象就变成了null,从而报FileNotFoundException！</p>
<p>解决：先获取传InputStrem，传传InputStrem。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42408648/article/details/126272849">https://blog.csdn.net/weixin_42408648/article/details/126272849</a></p>
<p>✅MultipartFile 对上传的文件大小进行限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MultipartFileUtil &#123;</span><br><span class="line"></span><br><span class="line">private final static Integer FILE_SIZE = 5;//文件上传限制大小</span><br><span class="line">private final static String FILE_UNIT = &quot;M&quot;;//文件上传限制单位（B,K,M,G）</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param len  文件长度</span><br><span class="line">     * @param size 限制大小</span><br><span class="line">     * @param unit 限制单位（B,K,M,G）</span><br><span class="line">     * @描述 判断文件大小</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkFileSize(Long len, int size, String unit) &#123;</span><br><span class="line">        double fileSize = 0;</span><br><span class="line">        if (&quot;B&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len;</span><br><span class="line">        &#125; else if (&quot;K&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1024;</span><br><span class="line">        &#125; else if (&quot;M&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1048576;</span><br><span class="line">        &#125; else if (&quot;G&quot;.equalsIgnoreCase(unit)) &#123;</span><br><span class="line">            fileSize = (double) len / 1073741824;</span><br><span class="line">        &#125;</span><br><span class="line">        return !(fileSize &gt; size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //文件上传调用</span><br><span class="line">    public static String upload(MultipartFile file) &#123;</span><br><span class="line">        boolean flag = checkFileSize(file.getSize(), FILE_SIZE, FILE_UNIT);</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;上传文件大小超出限制&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/w_shimmer/article/details/124341265">https://blog.csdn.net/w_shimmer/article/details/124341265</a></p>
<h4 id="java-nio-file-文件操作"><a href="#java-nio-file-文件操作" class="headerlink" title="java.nio.file 文件操作"></a>java.nio.file 文件操作</h4><p>自 Java7 开始，Java 终于简化了文件读写的基本操作，新增了 java.nio.file 库，通过与 Java8 新增的 stream 结合可以使得文件操作变得更加优雅。</p>
<p>1️⃣文件和目录路径Path</p>
<p>java.nio.file.Paths 类包含一个静态方法 <code>static.get()</code>，可以接受一系列 String 字符串或一个统一资源标识符 URI 作为参数，并且转换返回一个 <code>Path</code> 对象。</p>
<p>一个 Path 对象表示一个文件或者目录的路径，是一个跨操作系统和文件系统的抽象，目的是在构造路径时可以不必关注底层操作系统。如果 Path 仅由一个空的名称元素组成，则认为是空的路径。使用空路径访问文件等同于访问文件系统的默认目录。Path 接口的实现是不可变且安全的，可供多个并行线程使用.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;C:&quot;, &quot;path&quot;, &quot;to&quot;, &quot;nowhere&quot;, &quot;NoFile.txt&quot;);</span><br><span class="line">System.out.println(path1); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path2 = Paths.get(&quot;C:/path/to/nowhere/NoFile.txt&quot;);</span><br><span class="line">System.out.println(path2); //C:/path/to/nowhere/NoFile.txt</span><br><span class="line">URI uri = path2.toUri();  //转换为URI对象，可以用于构建web资源的绝对uri</span><br><span class="line">System.out.println(uri); //file:///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/C:/path/to/nowhere/NoFile.txt</span><br><span class="line">Path path3 = Paths.get(uri);</span><br><span class="line">System.out.println(path3);</span><br><span class="line"></span><br><span class="line">// 返回表示此路径的绝对路径的Path对象</span><br><span class="line">Path p = Paths.get(&quot;FileTest.java&quot;).toAbsolutePath();  //相对于当前项目目录</span><br><span class="line">System.out.println(p); ///Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">// 返回表示此路径的真实路径的Path对象，也即是带上盘符（根路径）</span><br><span class="line">Path p2 = Paths.get(&quot;/Users/liuxuan/Downloads/test&quot;).toRealPath();</span><br><span class="line">// getNameCount() 返回路径中的名称元素的数量</span><br><span class="line">for(int i = 0; i &lt; p.getNameCount(); i++) &#123;</span><br><span class="line">    // 返回此路径的名称元素作为 Path对象</span><br><span class="line">    System.out.println(p.getName(i));</span><br><span class="line">&#125;</span><br><span class="line">// 测试路径是否以给定的路径结束，这里会输出 end with &#x27;.java&#x27;:false</span><br><span class="line">System.out.println(&quot;ends with &#x27;.java&#x27;: &quot; + p.endsWith(&quot;.java&quot;));</span><br><span class="line">// Path 也实现了 iterable 接口，会对路径中的名称元素进行遍历</span><br><span class="line">for(Path pp : p) &#123;</span><br><span class="line">    System.out.println(pp);</span><br><span class="line">&#125;</span><br><span class="line">// getRoot() 返回此路径的根路径作为Path对象，为null则该路径不具有根</span><br><span class="line">// startsWith() 效果和 endsWith() 相似</span><br><span class="line">// 这里会输出 Starts with C:\ true</span><br><span class="line">System.out.println(&quot;Starts with &quot; + p.getRoot() + &quot; &quot; + p.startsWith(p.getRoot()));</span><br></pre></td></tr></table></figure>

<p>有时我们还需要通过对 Path 对象增加或修改一部分来构造一个新的 path 对象，可以使用 relativize() 移除 Path 的根路径，或者使用 resolve() 添加 Path 的尾路径，注意添加的路径可以不是真实存在的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用..可以跳转到上一级路径，但必须使用normalize()方法</span><br><span class="line">// 假设当前路径为/Users/liuxuan/MyProject/mypro/spring-boot-demo/spring-boot-study/FileTest.java</span><br><span class="line">Path base = Paths.get(&quot;..&quot;, &quot;..&quot;, &quot;..&quot;).toAbsolutePath().normalize();</span><br><span class="line">System.out.println(base); ///Users/liuxuan/MyProject</span><br><span class="line">// 构造此路径和给定路径之间的相对路径</span><br><span class="line">Path p4 = base.relativize(p);</span><br><span class="line">System.out.println(p4);</span><br><span class="line">// 使用resolve构造路径</span><br><span class="line">// 此时路径为C:\Users\Bruce\Documents\GitHub\string</span><br><span class="line">Path convoluted = p.getParent().resolve(&quot;string&quot;);</span><br><span class="line">System.out.println(convoluted);</span><br></pre></td></tr></table></figure>

<p>2️⃣Files工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取文件的字节数组：</span><br><span class="line">byte[] fileBytes = Files.readAllBytes(Paths.get(&quot;/Users/liuxuan/Downloads/test/cal.sh&quot;));</span><br><span class="line">System.out.println(new String(fileBytes));</span><br></pre></td></tr></table></figure>

<p>获取文件夹中的文件夹数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String path = &quot;/Users/liuxuan/Downloads/&quot;;</span><br><span class="line">File fileDir = new File(path);</span><br><span class="line">if (!fileDir.exists() || !fileDir.isDirectory()) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String[] fileList = fileDir.list();</span><br><span class="line">int count = 0;</span><br><span class="line">for (String file : fileList) &#123;</span><br><span class="line">    if (new File(path + file).isDirectory()) &#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">File[] files = fileDir.listFiles();</span><br><span class="line">for (File file : files) &#123;</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Files实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path1 = Paths.get(&quot;/Users/liuxuan/Downloads/&quot;);</span><br><span class="line">if (!Files.exists(path1) || !Files.isDirectory(path1)) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;不是文件夹&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long dirCount = Files.list(path1).filter(Files :: isDirectory).count();</span><br><span class="line">System.out.println(dirCount);</span><br></pre></td></tr></table></figure>

<p>使用<code>Files.list(path)</code>需要注意，它返回的是<code>Stream&lt;Path&gt;</code>，如果没有关闭，并且代码频繁使用，将导致打开的文件过多而报错（每个进程可以打开的文件数量是有限制的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps -mlVv | grep javaTest</span><br><span class="line">lsof -p 进程id | wc -l</span><br></pre></td></tr></table></figure>

<p>所以要关闭流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.手动关闭</span><br><span class="line">Stream&lt;Path&gt; paths = Files.list(path);</span><br><span class="line">paths.close();</span><br><span class="line"></span><br><span class="line">2.try resource自动关闭流</span><br><span class="line">try(Stream&lt;Path&gt; paths = Files.list(path)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多该包下的用法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_handsome/article/details/109743637">https://blog.csdn.net/CSDN_handsome/article/details/109743637</a></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>看《java基础》<br>针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set.stream().map(i-&gt;String.valueOf(i)).</span><br><span class="line">括号内的i，表示流处理中的元素，也是lambda表达式的输入</span><br><span class="line">只有一句语句，省去了&#123;&#125;，省去了return</span><br><span class="line"></span><br><span class="line">使用现有的方法，比如上面的，可以变成lambda表达式的引用形式::</span><br><span class="line">.map(String::valueOf).</span><br><span class="line"></span><br><span class="line">上面的方法例如map()，内部的传参是只有一个函数式接口，</span><br><span class="line">有的方法穿参，除了一个函数式接口还有其他，所以会有其他参数。</span><br><span class="line">例如：</span><br><span class="line">方法：showSum(int x, int y, Calculate cu)</span><br><span class="line">使用：showSum(10, 20, (x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>



<h3 id="spring-expression-Spel表达式-java语言解析"><a href="#spring-expression-Spel表达式-java语言解析" class="headerlink" title="spring-expression Spel表达式 java语言解析"></a>spring-expression Spel表达式 java语言解析</h3><p>ExpressionParse接口是springframework包下的。<br>对表达式进行解析，通过字符串传入解析器，进行解析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //将一整个语句直接定义了字符串 ,其中对字符串的开始索引与结束索引使用替代变量</span><br><span class="line">    //变量前需要加#</span><br><span class="line">    String str = &quot;#var + 2&quot;;</span><br><span class="line">    //1定义一个专属的表达式解析工具</span><br><span class="line">    ExpressionParser parser = new SpelExpressionParser() ;</span><br><span class="line">    //2定义一个表达式处理类</span><br><span class="line">    Expression exp = parser.parseExpression(str);</span><br><span class="line">    //3进行最终的表达式计算，这个上下文用来传参</span><br><span class="line">    EvaluationContext context = new StandardEvaluationContext() ;</span><br><span class="line">    context.setVariable(&quot;var&quot;, 5);</span><br><span class="line">    //4通过表达式进行结果计算</span><br><span class="line">    System.out.println(exp.getValue(context, Integer.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>AtomicInteger类是系统底层保护的int类型，通过提供执行方法的控制进行值的原子操作。AtomicInteger它不能当作Integer来使用。</p>
<p>从JAVA 1.5开始，AtomicInteger 属于java.util.concurrent.atomic 包下的一个类。</p>
<p>AtomicInteger通过调用构造函数可以直接创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//初始值是 0</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(); </span><br><span class="line"> </span><br><span class="line">//初始值是 100</span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line"> </span><br><span class="line">int currentValue = atomicInteger.get();         //100</span><br><span class="line"> </span><br><span class="line">atomicInteger.set(1234);                        //当前值1234</span><br></pre></td></tr></table></figure>

<p>什么时候用？<br>1、作为多个线程同时使用的原子计数器。<br>2、在比较和交换操作中实现非阻塞算法。</p>
<p>原子计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一些以原子方式执行加法和减法操作的方法:</span><br><span class="line">addAndGet()- 以原子方式将给定值添加到当前值，并在添加后返回新值。</span><br><span class="line">getAndAdd() - 以原子方式将给定值添加到当前值并返回旧值。</span><br><span class="line">incrementAndGet()- 以原子方式将当前值递增1并在递增后返回新值。它相当于i ++操作。</span><br><span class="line">getAndIncrement() - 以原子方式递增当前值并返回旧值。它相当于++ i操作。</span><br><span class="line">decrementAndGet()- 原子地将当前值减1并在减量后返回新值。它等同于i-操作。</span><br><span class="line">getAndDecrement() - 以原子方式递减当前值并返回旧值。它相当于-i操作。</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.addAndGet(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //102</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndAdd(2));         //102</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.incrementAndGet());    //105  </span><br><span class="line">        System.out.println(atomicInteger);                      //105  </span><br><span class="line">                 </span><br><span class="line">        System.out.println(atomicInteger.getAndIncrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //106</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.decrementAndGet());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //105</span><br><span class="line">         </span><br><span class="line">        System.out.println(atomicInteger.getAndDecrement());    //105</span><br><span class="line">        System.out.println(atomicInteger);                      //104</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较和交换：<br>1、比较和交换操作将内存位置的内容与给定值进行比较，并且只有它们相同时，才将该内存位置的内容修改为给定的新值。这是作为单个原子操作完成的。<br>2、原子性保证了新值是根据最新信息计算出来的; 如果在此期间该值已被另一个线程更新，则写入将失败。<br><code>boolean compareAndSet(int expect, int update)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        //1、默认初始值</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(100);</span><br><span class="line">        //2、默认初始值和给定值，都是100，所以会更改成功</span><br><span class="line">        boolean isSuccess = atomicInteger.compareAndSet(100,110);   //current value 100</span><br><span class="line">        //3、返回true</span><br><span class="line">        System.out.println(isSuccess);      //true</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">        //4、默认初始值是110,给定值是100，所以会更改失败</span><br><span class="line">        isSuccess = atomicInteger.compareAndSet(100,120);       //current value 110</span><br><span class="line">        //5、返回false</span><br><span class="line">        System.out.println(isSuccess);      //false</span><br><span class="line">        System.out.println(atomicInteger);  //110</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/073096a729f6">https://www.jianshu.com/p/073096a729f6</a></p>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>返回Class类型的对象。只是getClass()，返回当前运行时类。object.getClass()前面带对象.getClass()返回对象的类。</p>
<p>Class常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws IllegalAccessException, InstantiationException, IOException &#123;</span><br><span class="line">  Class cl = getClass();</span><br><span class="line">  System.out.println(cl); //class org.example.javaer.ClassTest</span><br><span class="line">  String name = cl.getName(); // org.example.javaer.ClassTest</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  Object classTest = cl.newInstance(); //创建实例</span><br><span class="line">  String packName = cl.getPackage().getName();</span><br><span class="line">  System.out.println(packName); //org.example.javaer</span><br><span class="line">  ClassLoader classLoader = cl.getClassLoader(); //获取类加载器</span><br><span class="line">  System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">  //getResourceAsStream从项目下文件中获取输入流</span><br><span class="line">  //读取文件内容为String</span><br><span class="line">  InputStream in = cl.getResourceAsStream(&quot;/hi.md&quot;); //加&quot;/&quot;，/表示src/test/resources下（ClassPath根目录）</span><br><span class="line">  System.out.println(IOUtils.toString(in, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line"></span><br><span class="line">  //读取为字节数组</span><br><span class="line">  byte[] bytes = IOUtils.toByteArray(in);</span><br><span class="line">  System.out.println(bytes);</span><br><span class="line"></span><br><span class="line">  InputStream in1 = cl.getResourceAsStream(&quot;src/test/resources/hi.md&quot;); //不行，NPE</span><br><span class="line">  System.out.println(IOUtils.toString(in1, String.valueOf(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅获取各种路径"><a href="#✅获取各种路径" class="headerlink" title="✅获取各种路径"></a>✅获取各种路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() throws IOException &#123;</span><br><span class="line">    // 1.获取ClassPath根路径（类加载根路径），到src/test/resources，两种方法</span><br><span class="line">    String path1 = getClass().getResource(&quot;/&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path1);</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + getClass().getClassLoader().getResource(&quot;&quot;)); //和上面一样</span><br><span class="line"></span><br><span class="line">    // 2.获取绝对路径</span><br><span class="line">    String path2 = getClass().getResource(&quot;&quot;).toString(); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/classes/org/example/javaer/</span><br><span class="line">    System.out.println(&quot;绝对路径：&quot; + path2);</span><br><span class="line"></span><br><span class="line">    // 3.获取项目路径 两种方法</span><br><span class="line">    File dir = new File(&quot;&quot;); //参数为空</span><br><span class="line">    String path3 = dir.getCanonicalPath(); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path3);</span><br><span class="line">    String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">    System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">    String allPath = System.getProperty(&quot;java.class.path&quot;); //所有jar包的路径</span><br><span class="line">    System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">    // 再看看</span><br><span class="line">    String path5 = getClass().getResource(&quot;/&quot;).getPath(); //这样获得的前面没有file</span><br><span class="line">    System.out.println(&quot;ClassPath根路径：&quot; + path5);</span><br><span class="line">    URL url = getClass().getClassLoader().getResource(&quot;&quot;); //file:/Users/liuxuan/MyProject/JavaProject/java/web/target/test-classes/</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15057811/4080631">https://blog.51cto.com/u_15057811/4080631</a></p>
<h4 id="✅System-getProperty-方法"><a href="#✅System-getProperty-方法" class="headerlink" title="✅System.getProperty()方法"></a>✅System.getProperty()方法</h4><p>获取当前系统的版本等一些信息。<br>内部key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">String path4 = System.getProperty(&quot;user.dir&quot;); ///Users/liuxuan/MyProject/JavaProject/java/web</span><br><span class="line">System.out.println(&quot;项目路径：&quot; + path4);</span><br><span class="line">String allPath = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">System.out.println(&quot;java类路径：&quot; + allPath);</span><br><span class="line"></span><br><span class="line">Java.version</span><br><span class="line">Java 运行时环境版本</span><br><span class="line">java.vendor</span><br><span class="line">Java 运行时环境供应商</span><br><span class="line">java.vendor.url</span><br><span class="line">Java 供应商的 URL</span><br><span class="line">java.home</span><br><span class="line">Java 安装目录</span><br><span class="line">java.vm.specification.version</span><br><span class="line">Java 虚拟机规范版本</span><br><span class="line">java.vm.specification.vendor</span><br><span class="line">Java 虚拟机规范供应商</span><br><span class="line">java.vm.specification.name</span><br><span class="line">Java 虚拟机规范名称</span><br><span class="line">java.vm.version</span><br><span class="line">Java 虚拟机实现版本</span><br><span class="line">java.vm.vendor</span><br><span class="line">Java 虚拟机实现供应商</span><br><span class="line">java.vm.name</span><br><span class="line">Java 虚拟机实现名称</span><br><span class="line">java.specification.version</span><br><span class="line">Java 运行时环境规范版本</span><br><span class="line">java.specification.vendor</span><br><span class="line">Java 运行时环境规范供应商</span><br><span class="line">java.specification.name</span><br><span class="line">Java 运行时环境规范名称</span><br><span class="line">java.class.version</span><br><span class="line">Java 类格式版本号</span><br><span class="line">java.class.path</span><br><span class="line">Java 类路径</span><br><span class="line">java.library.path</span><br><span class="line">加载库时搜索的路径列表</span><br><span class="line">java.io.tmpdir</span><br><span class="line">默认的临时文件路径</span><br><span class="line">java.compiler</span><br><span class="line">要使用的 JIT 编译器的名称</span><br><span class="line">java.ext.dirs</span><br><span class="line">一个或多个扩展目录的路径</span><br><span class="line">os.name</span><br><span class="line">操作系统的名称</span><br><span class="line">os.arch</span><br><span class="line">操作系统的架构</span><br><span class="line">os.version</span><br><span class="line">操作系统的版本</span><br><span class="line">file.separator</span><br><span class="line">文件分隔符（在 UNIX 系统中是“/”）</span><br><span class="line">path.separator</span><br><span class="line">路径分隔符（在 UNIX 系统中是“:”）</span><br><span class="line">line.separator</span><br><span class="line">行分隔符（在 UNIX 系统中是“/n”）</span><br><span class="line">user.name</span><br><span class="line">用户的账户名称</span><br><span class="line">user.home</span><br><span class="line">用户的主目录</span><br><span class="line">user.dir</span><br><span class="line">用户的当前工作目录</span><br></pre></td></tr></table></figure>

<h4 id="✅类加载器"><a href="#✅类加载器" class="headerlink" title="✅类加载器"></a>✅类加载器</h4><p>用来把类装载进内存的。</p>
<p>非常不错的详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_68064743/article/details/123957150">https://blog.csdn.net/m0_68064743/article/details/123957150</a></p>
<h4 id="✅getSimpleName"><a href="#✅getSimpleName" class="headerlink" title="✅getSimpleName"></a>✅getSimpleName</h4><p>Class.getSimpleName()方法返回此Class对象表示的类或接口的简单名称，作为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String className1 = SomeTest.class.getName();</span><br><span class="line">System.out.println(className1); //com.liuxuan.study.SomeTest</span><br><span class="line">String className2 = SomeTest.class.getSimpleName();</span><br><span class="line">System.out.println(className2); //SomeTest</span><br></pre></td></tr></table></figure>

<h3 id="Class-forName方法"><a href="#Class-forName方法" class="headerlink" title="Class.forName方法"></a>Class.forName方法</h3><p>Class类的静态方法forName()<br>和上面的一样，都是返回Class类型的对象，区别在于object.getClass()用于根据对象获取Class对象；Class.forName(className)用于根据类名获取Class对象。</p>
<h4 id="✅-首先讲述Class是个什么样的对象"><a href="#✅-首先讲述Class是个什么样的对象" class="headerlink" title="✅ 首先讲述Class是个什么样的对象"></a>✅ 首先讲述Class是个什么样的对象</h4><p>1、 Class类封装了类或接口的运行时状态</p>
<p>Java程序在运行时，系统一直对所有的对象进行所谓的运行时类型标识，这些标示纪录了每个对象所属的类。<br>虚拟机通常使用运行时类型信息选择正确方法去执行，用来保存这些类型信息的类是Class类。</p>
<p>2、Class类型的对象，是加载类时自动创建的</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时，由Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。</p>
<p>3、虚拟机为每种类型管理一个独一无二的Class对象</p>
<p>每个类（型）都有一个Class对象。<br>运行程序时，Java虚拟机(JVM)首先检查所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<p>4、基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。</p>
<p>5、每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p>
<p>6、一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</p>
<h4 id="✅-结合反射使用举例"><a href="#✅-结合反射使用举例" class="headerlink" title="✅ 结合反射使用举例"></a>✅ 结合反射使用举例</h4><p>对于任何一个类，都能知道这个类所有的属性和方法；对于任何一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<p>getMethod()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。</p>
<p>getDeclaredMethod()对象表示的类或接口声明的所有方法,包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。</p>
<p>一个实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line">    private static final String defName = &quot;《程序猿植发》&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;我是静态代码块，输出: &quot; + defName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印生产日期：</span><br><span class="line">    public static String printProduceDate(String name) &#123;</span><br><span class="line">        return &quot;我是静态方法printProduceDate，输出: &quot; + name + &quot;, produce is:&quot; + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Book() &#123;</span><br><span class="line">        System.out.println(&quot;我是Book声明的构造方法！&quot;);</span><br><span class="line">        name = defName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString(String msg) &#123;</span><br><span class="line">        return name + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">    //1-将指定类加载到JVM中（ClassNotFoundException）</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Book&quot;); //加载过程会执行static静态代码块 out：我是静态代码块，输出: 《程序猿植发》</span><br><span class="line">    System.out.println(aClass);  //out:class com.junit.demo.Book</span><br><span class="line"></span><br><span class="line">    //2.1-访问静态方法：NoSuchMethodException，InvocationTargetException</span><br><span class="line">    Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">    String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);  </span><br><span class="line">    //反射静态方法 第一个参数是Class对象(也可以传入null？) 第二个参数是输入</span><br><span class="line">    System.out.println(result); //out：我是静态方法printProduceDate，输出: 《程序猿的颈椎自传》, produce is:1626682894095</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.2-初始化对象：</span><br><span class="line">    Book obj = (Book) aClass.newInstance();  //out:我是Book声明的构造方法！</span><br><span class="line">    System.out.println(&quot;得到对象后访问get方法：&quot; + obj.toString(&quot;&quot;));  //out:得到对象后访问get方法：《程序猿植发》</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    //2.3-初始化对象后访问方法：</span><br><span class="line">    Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">    String result3 = (String) method3.invoke(aClass.newInstance()/*obj*/, &quot;这本书是我的伙伴！&quot;); </span><br><span class="line">    //反射非静态方法，第一个参数是对象，第二个是输入。</span><br><span class="line">    System.out.println(result3); //out：《程序猿植发》这本书是我的伙伴！</span><br><span class="line">    System.out.println(&quot;---------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Book.class.getName()); //com.junit.demo.Book</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>☝️通过反射方式访问静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 由Class获取方法：第一个参数为方法名，第二个参数为方法的参数类型。</span><br><span class="line">Method method = aClass.getMethod(&quot;printProduceDate&quot;, String.class);</span><br><span class="line">// 引用方法：(引用实例/调用静态方法可为null，参数值/有多个用逗号隔开)，参数值要和参数类型的数量匹配！</span><br><span class="line">String result = (String) method.invoke(aClass, &quot;《程序猿的颈椎自传》&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;printProduceDate&quot;, String.class).invoke(null, &quot;《程序猿的颈椎自传》&quot;);</span><br></pre></td></tr></table></figure>

<p>✌️通过反射方式访问实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//方法一：直接转化实例化后的对象，直接调用方法</span><br><span class="line">Book book= (Book) aClass.newInstance();</span><br><span class="line">// book.setName(&#x27;xxx&#x27;); or book.getName(); or more...</span><br><span class="line"></span><br><span class="line">//方法二：使用invoke调用指定实例a的指定方法b</span><br><span class="line">Method method3 = aClass.getMethod(&quot;toString&quot;, String.class);</span><br><span class="line">//这里的book可以是已实例化的对象，或者使用 aClass.newInstance() 传入，详见简写：</span><br><span class="line">String result3 = (String) method3.invoke(book, &quot;这本书是我的伙伴！&quot;);</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">aClass.getMethod(&quot;toString&quot;, String.class).invoke(aClass.newInstance(), &quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果是类似于工具类可用于全部类访问的，可以使用一个实例化对象，而不需要每次都newInstance。</p>
<p>另外，方法一适用于需要映射的类是已知或少数时，反之需要统一按指定字符串反射调用方法的话，需使用方法二。</p>
<p>☝️通过反射方式访问私有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.junit.demo;</span><br><span class="line"></span><br><span class="line">public class Netbar &#123;</span><br><span class="line">    private Double random = Math.random();</span><br><span class="line"></span><br><span class="line">    public Double getRandom() &#123;</span><br><span class="line">        return random;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Netbar createNew() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Netbar getInstance() &#123;</span><br><span class="line">        return new Netbar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Netbar netbar = new Netbar();</span><br><span class="line">        System.out.println(&quot;Random:: &quot; + netbar.getRandom());</span><br><span class="line">        Netbar netbar2 = netbar.createNew();</span><br><span class="line">        System.out.println(&quot;Random2:: &quot; + netbar2.getRandom());</span><br><span class="line">        Netbar netbar3 = Netbar.getInstance();</span><br><span class="line">        System.out.println(&quot;Random3:: &quot; + netbar3.getRandom());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有非静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;createNew&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(aClass.newInstance()); //传入对象</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射方式访问私有静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    Class aClass = Class.forName(&quot;com.junit.demo.Netbar&quot;);</span><br><span class="line">    Method method = aClass.getDeclaredMethod(&quot;getInstance&quot;);//这里可以带参数</span><br><span class="line">    method.setAccessible(true);//对所有属性设置访问权限  当类中的成员变量为private时 必须设置此项</span><br><span class="line">    Netbar netbar = (Netbar) method.invoke(null);  //静态方法可以传入null</span><br><span class="line">    System.out.println(&quot;Random2:: &quot; + netbar.getRandom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：Java之Class.forName方法详解：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26599807/article/details/118900090">https://blog.csdn.net/qq_26599807/article/details/118900090</a></p>
<h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><p>首先，浅拷贝和深拷贝都是针对一个已有对象的操作。</p>
<p>在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象（引用数据类型）。而一般使用 『 = 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3() &#123;</span><br><span class="line">    // 1.直接</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(12345);</span><br><span class="line">    Student stu2 = stu1;</span><br><span class="line">    stu2.setNumber(54321);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2.getNumber());  //改2，1跟着也改了</span><br><span class="line">    //原因出在(stu2 = stu1) 这一句。</span><br><span class="line">    //该语句的作用是将stu1的引用赋值给stu2。其实，stu1和stu2在堆内存中指向的是同一个对象</span><br><span class="line"></span><br><span class="line">    // 2.新建一个，再set</span><br><span class="line">    Student stu3 = new Student();</span><br><span class="line">    stu3.setNumber(stu1.getNumber());</span><br><span class="line">    stu3.setNumber(111);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1.getNumber());</span><br><span class="line">    System.out.println(&quot;学生3:&quot; + stu3.getNumber());  //改2，1不会跟着也改了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。</p>
<p>所谓的浅拷贝和深拷贝，只是在拷贝对象的时候，对 类的实例对象 这种引用数据类型的不同操作而已。</p>
<p>总结来说：</p>
<p>1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p>Object 上的 clone() 方法<br>在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。<br>而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。</p>
<p>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常) 该接口为标记接口(不含任何方法)<br>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象（native为本地方法)</p>
<hr>
<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hongshi/p/16189920.html">https://www.cnblogs.com/hongshi/p/16189920.html</a></p>
<h4 id="✅浅拷贝"><a href="#✅浅拷贝" class="headerlink" title="✅浅拷贝"></a>✅浅拷贝</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    //ClassTest.Student(number=1, name=ll, teacher=ClassTest.Teacher(age=24)) hashCode:1407343478</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    //ClassTest.Student(number=2, name=oo, teacher=ClassTest.Teacher(age=24)) hashCode:1940447180</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">    //teacher的hashCode：83 83</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">    //浅拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面的Teacher对象，实际上还是指向了同一个对象，只对对它的引用进行了传递。</p>
<p>注意⚠️：String作为不可更改的类（immutable class），在new赋值的时候，就已经创建了一个新的对象；表现出来的是深拷贝（和基本数据类型一样）。</p>
<h4 id="✅深拷贝"><a href="#✅深拷贝" class="headerlink" title="✅深拷贝"></a>✅深拷贝</h4><p>两种方法：<br>1、序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。<br>2、继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。也就是让Teacher类也实现Cloneable接口，重写clone方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() &#123;</span><br><span class="line">    // 1.浅拷贝</span><br><span class="line">    Student stu1 = new Student();</span><br><span class="line">    stu1.setNumber(1);</span><br><span class="line">    stu1.setName(&quot;ll&quot;);</span><br><span class="line">    stu1.setTeacher(new Teacher(23));</span><br><span class="line">    Student stu2 = (Student)stu1.clone();</span><br><span class="line">    stu2.setNumber(2);</span><br><span class="line">    stu2.setName(&quot;oo&quot;);</span><br><span class="line">    //stu2.setTeacher(new Teacher(24)); //新建不对</span><br><span class="line">    stu2.getTeacher().setAge(24);</span><br><span class="line">    System.out.println(&quot;学生1:&quot; + stu1 + &quot; hashCode:&quot; + stu1.hashCode());</span><br><span class="line">    System.out.println(&quot;学生2:&quot; + stu2 + &quot; hashCode:&quot; + stu2.hashCode());</span><br><span class="line">    System.out.println(&quot;teacher的hashCode：&quot; + stu1.getTeacher().hashCode() + &quot; &quot; + stu2.getTeacher().hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ToString</span><br><span class="line">static class Student implements Cloneable &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    private String name;</span><br><span class="line">    private Teacher teacher;</span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setNumber(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">        this.teacher = teacher;</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher getTeacher() &#123;return teacher;&#125;</span><br><span class="line">//        //浅拷贝</span><br><span class="line">//        @Override</span><br><span class="line">//        public Object clone() &#123;</span><br><span class="line">//            try&#123;</span><br><span class="line">//                return super.clone();</span><br><span class="line">//            &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            return null;</span><br><span class="line">//        &#125;</span><br><span class="line">    //深拷贝</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Student stu = (Student)super.clone();</span><br><span class="line">            stu.setTeacher((Teacher)this.teacher.clone());</span><br><span class="line">            return stu;</span><br><span class="line"></span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Teacher implements Cloneable&#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    Teacher(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanUtils-copyProperties"><a href="#BeanUtils-copyProperties" class="headerlink" title="BeanUtils.copyProperties"></a>BeanUtils.copyProperties</h4><p><code>BeanUtils.copyProperties（source,target）</code>有两个参数，用于将事件源的数据拷贝到目标源中。BeanUtils有两个，一个是spring的，一个是apache的commons下的。用法一样，但是两者的区别在于：一个是将前者拷贝给后者，另一个是将后者拷贝给前面的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student studentOne  = new StudentOne(&quot;张三&quot;);</span><br><span class="line">Student studentTwo  = new StudentOne();  //先新建一个要拷贝出来的对象</span><br><span class="line">//BeanUtils.copyProperties是将studentOne的数据拷贝给studentTwo</span><br><span class="line">BeanUtils.copyProperties(studentOne, studentTwo);</span><br><span class="line">//spring的第一个是输入，第二个谁输出</span><br></pre></td></tr></table></figure>

<p>如果两个类不一样时，只会拷贝属性一样的内容。<br>使用场景：开发中经常遇到，把父类的属性拷贝到子类中。<br>BeanUtils是浅拷贝。浅拷贝：引用的一个内存地址)。</p>
<p>通常用于转换器Convertor，用来转换一个类的对象为另一个类的对象，重写里面的convert方法来用。</p>
<h3 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h3><h4 id="hashcode-1"><a href="#hashcode-1" class="headerlink" title="hashcode"></a>hashcode</h4><p>1、hash和hash表是什么？</p>
<blockquote>
<p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值。这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值。</p>
</blockquote>
<p>2、hashcode　</p>
<blockquote>
<p>hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。<br>每个对象都有hashcode，对象的hashcode怎么得来的呢？<br>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？<br>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。所以，hashcode是什么呢？就是在hash表中对应的位置。</p>
</blockquote>
<blockquote>
<p>这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</p>
</blockquote>
<p>3、hashcode有什么作用</p>
<blockquote>
<p>为什么hashcode不直接写物理地址呢，还要另外用一张hash表来代表对象的地址？<br>HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)<br>为什么hashcode就查找的更快，比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。<br>hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果没一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，所以比较的次数会让你觉得也挺多的，实际上，如果hash表很大，那么比较的次数就很少很少了。<br>通过对原始方法和使用hashcode方法进行对比，我们就知道了hashcode的作用，并且为什么要使用hashcode了</p>
</blockquote>
<p>4、equals方法和hashcode的关系</p>
<blockquote>
<p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等。</p>
</blockquote>
<blockquote>
<p>用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。</p>
</blockquote>
<blockquote>
<p>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同<br>2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</p>
</blockquote>
<p>5、为什么equals方法重写的话，建议也一起重写hashcode方法</p>
<blockquote>
<p>比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。</p>
</blockquote>
<p>Integer的重写方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;  // 变成比较Integer内部的final int常量的值是否相等</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hashCode方法也是用的值</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Integer.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int hashCode(int value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode是用于查找使用的，而 equals是用于比较两个对象的是否相等的。hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的.</p>
<p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致.</p>
<p>————————————————<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44364444/article/details/120054230">https://blog.csdn.net/weixin_44364444/article/details/120054230</a></p>
<h4 id="java变量地址"><a href="#java变量地址" class="headerlink" title="java变量地址"></a>java变量地址</h4><p>java的变量不能直接获取真实的地址，只能使用<code>System.out.println(obj.hashcode())</code>输出的时对象的哈希码，而非内存地址。</p>
<p>在Java中是不可能得到对象真正的内存地址的，因为Java中堆是由JVM管理的不能直接操作。只能说此时打印出的Hash码表示了该对象在JAVA虚拟机中的内存位置，Java虚拟机会根据该hash码最终在真正的的堆空间中给该对象分配一个地址.</p>
<p>要想得到变量在物理内存中的真实地存，那只有用JNI技术调用c/c++去实现，否则无能为力，因为java超不出JVM，而JVM对物理内存地址是“不可见”的，否则java中不就有了指针，而去直接操作内存了，当然这是与java语言相违背的。</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feng3702592/article/details/126722686">https://blog.csdn.net/feng3702592/article/details/126722686</a></p>
<h4 id="、equals、hashCode"><a href="#、equals、hashCode" class="headerlink" title="==、equals、hashCode"></a>==、equals、hashCode</h4><p>1、==对于普通变量是值比较，对于包装类型变量，是内存地址比较，也就是比较是不是同一个对象。</p>
<p>2、包装类型重写了equals方法，变成了值比较。</p>
<p>3、hashCode表示在hash表中的位置。equals一样，那么hashCode一定一样。（只要值是一样的，hashCode就会是相同的。）<br>原因：尽管不同的数值类型的包装类，计算hashCode的算法不一样，但是底层都是拿对应的原始数据类型的值去进行hashCode计算。<br>反过来：</p>
<p>4、同一个对象的，hashCode值一定相同，但是 hashCode相同，不一定是同一个对象，也不一定equals为true。</p>
<p>关系：同一个对象（==）最小的圈，equals为true中间圈，hashCode一样最大圈。<code>（equals要看重写了没有，不重写就是==）</code></p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">package org.example.javaer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2022-11-24 00:45</span><br><span class="line"> **/</span><br><span class="line">/**</span><br><span class="line"> *hashCode相同，不一定是同一个对象</span><br><span class="line"> *同一个对象的，hashCode值一定相同</span><br><span class="line"> *</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *普通对象的HashCode值源码解释：</span><br><span class="line"> * equals相同则hashCode一定一样</span><br><span class="line"> *If two objects are equal according to the equals(Object) method, then calling</span><br><span class="line"> *the hashCode method on each of the two objects must produce the same integer result.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *equals不一样，hashCode不一定不一样</span><br><span class="line"> * It is not required that if two objects are unequal according to the</span><br><span class="line"> *java.lang.Object.equals(java.lang.Object) method, then calling the hashCode</span><br><span class="line"> *method on each of the two objects must produce distinct integer results.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *However, the programmer should be aware that producing distinct integer results</span><br><span class="line"> *for unequal objects may improve the performance of hash tables.</span><br><span class="line"> *-------------------------------------------------------------------------------</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashCodeTest(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;--------------------普通对象-----------------------&quot;);</span><br><span class="line">        HashCodeTest test3=new HashCodeTest();</span><br><span class="line">        HashCodeTest test4=new HashCodeTest();</span><br><span class="line">        System.out.println(test3.equals(test4));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test3.hashCode() == test4.hashCode());//false</span><br><span class="line"></span><br><span class="line">        HashCodeTest test1=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        HashCodeTest test2=new HashCodeTest(&quot;我&quot;);</span><br><span class="line">        System.out.println(test1.equals(test2));//false(因为没重写还是==)</span><br><span class="line">        System.out.println(test1.hashCode() == test2.hashCode());//false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------String-----------------------&quot;);</span><br><span class="line">        String s1=&quot;abc&quot;;</span><br><span class="line">        String s2=&quot;abc&quot;;</span><br><span class="line">        System.out.println(s1.equals(s2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s1.hashCode() == s2.hashCode());//true</span><br><span class="line">        System.out.println(s1==s2); //true(是一个对象)</span><br><span class="line"></span><br><span class="line">        String s5=new String(&quot;abc&quot;);</span><br><span class="line">        String s6=new String(&quot;abc&quot;);</span><br><span class="line">        System.out.println(s5.equals(s6));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(s5.hashCode() == s6.hashCode());//true</span><br><span class="line">        System.out.println(s5==s6); //false(不是一个对象)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String s3=new String();</span><br><span class="line">        String s4=new String();</span><br><span class="line">        System.out.println(s3.hashCode());//0</span><br><span class="line">        System.out.println(s4.hashCode());//0</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 数值型原始类型对应的包装类(Byte,Short,Integer,Float,Double)，hashCode算法都是基于</span><br><span class="line">         * 对应的原始数据类型，所以只要包装类的数值相同，那么hashCode必然相同</span><br><span class="line">         *</span><br><span class="line">         * Double类关于hashCode源码说明：</span><br><span class="line">         * Double类的hashCode是根据对应的double值计算获得的。</span><br><span class="line">         *</span><br><span class="line">         * Returns a hash code for a &#123;@code double&#125; value; compatible with</span><br><span class="line">         * &#123;@code Double.hashCode()&#125;.</span><br><span class="line">         *</span><br><span class="line">         * @param value the value to hash</span><br><span class="line">         * @return a hash code value for a &#123;@code double&#125; value.</span><br><span class="line">         * @since 1.8</span><br><span class="line">         */</span><br><span class="line">        /*Double类关于hashCode源码：</span><br><span class="line">         * public static int hashCode(double value) &#123;</span><br><span class="line">            long bits = doubleToLongBits(value);</span><br><span class="line">            return (int)(bits ^ (bits &gt;&gt;&gt; 32));</span><br><span class="line">        &#125;*/</span><br><span class="line">        System.out.println(&quot;--------------------原始类型对应的包装类-----------------------&quot;);</span><br><span class="line">        Double d1=5.0;</span><br><span class="line">        Double d2=5.0;</span><br><span class="line">        System.out.println(d1.equals(d2));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d1.hashCode() == d2.hashCode());//true</span><br><span class="line">        System.out.println(d1==d2);//false (？？？为啥是false，和String不一样)</span><br><span class="line"></span><br><span class="line">        Double d3=new Double(5.0);</span><br><span class="line">        Double d4=new Double(5.0);</span><br><span class="line">        System.out.println(d3.equals(d4));//true(因为重写变值比较)</span><br><span class="line">        System.out.println(d3.hashCode() == d4.hashCode());//true</span><br><span class="line">        System.out.println(d3==d4);//false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未解：<code>Double d1=5.0; Double d2=5.0</code> 不是共用一个对象。但是<code>String s1=&quot;1&quot;; String s2=&quot;1&quot;</code>是共用。</p>
<h3 id="java异常"><a href="#java异常" class="headerlink" title="java异常"></a>java异常</h3><p>背景：代码中需要捕获到专门的异常进行特殊处理，主要是为了不影响主流程，该用try…catch，是在调用的时候catch，还是在调用方法里catch？<br>🤔如果是只想在这次调用时补货异常就在调用处使用，如果是想把方法包装好随意调用不发生异常就在方法里捕获。作用是：发生异常了不中断流程，只是打个error log之类的。如果不加，就是自动抛出throws异常了。</p>
<p>背景：里面方法的异常，外面方法能不能catch到？里面方法也catch了，外面方法还能不能catch到？<br>🤔里面方法没有catch异常的话，外面方法是能捕获到的，并且运行时异常不用在里面的方法上加throws，外面方法就能捕获到。编译时异常必须做：catch住处理或者throw + throws，或者直接throws出去，这样才能在外面方法捕获到。如果里面方法捕获了异常，但是没throw出去（运行时异常throw了不需要throws，编译时异常throw了还需要throws），外面方法就捕获不到这个异常。</p>
<p>背景：什么时候需要在方法上throws异常，一定要throws吗？<br>🤔运行时异常，可以不在方法上throws，虚拟机会自动捕获抛出去。编译时异常通常在编译时就要求throws出去异常，或者用try…catch进行异常处理（打log之类）。</p>
<p>背景：什么时候需要try..catch..throw..throws<br>🤔首先运行时异常可以不throws，如果没有try..catch，会自动throws出去，所以如果不是try..catch..对特殊异常捕获，没必要try..catch..throws。编译型异常如果是try..catch..打log了，就不用throws了。如果想抛出去，就直接throws就行。所以不需要try..catch..throw..throws。如果即想用try..catch..finally..还想throws出去，就用。</p>
<h4 id="✅java的异常体系"><a href="#✅java的异常体系" class="headerlink" title="✅java的异常体系"></a>✅java的异常体系</h4><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p><img src="/images/java%E5%BC%82%E5%B8%B8.png"></p>
<p>Error是编译时错误和系统错误，系统错误在除特殊情况下，都不需要你来关心，基本不会出现。而编译时错误，如果你使用了编译器，那么编译器会提示。</p>
<p>Exception则是可以被抛出的基本类型，我们需要主要关心的也是这个类。<br>Exception又分为RunTimeException和其他Exception。</p>
<p>RunTimeException：运行时异常，又称不受检查异常，不受检查，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1/0，空指针等。如果不处理也会被Java自己处理。</p>
<p>其他Exception，受检查异常，编译时异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种，<br>1：throw到上层，<br>2，try-catch处理。</p>
<hr>
<p>Error是java程序运行中不可预料的异常情况（正常情况下不大可能出现的情况），这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。【表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误 ，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形.应用程序不应该抛出这种类型的对象(一般是由虚拟机抛出).假如出现这种错误,除了尽力使程序安全退出外,在其他方面是无能为力的。】</p>
<p>Exception：<br>1．可以是可被控制(checked) 或不可控制的(unchecked)。<br>2．表示一个由程序员导致的错误。<br>3．应该在应用程序级被处理。<br>Error：<br>1．总是不可控制的(unchecked)。<br>2．经常用来用于表示系统错误或低层资源的错误。<br>3．如何可能的话，应该在系统级被捕捉。</p>
<hr>
<h4 id="✅常见的-Error-和-Exception："><a href="#✅常见的-Error-和-Exception：" class="headerlink" title="✅常见的 Error 和 Exception："></a>✅常见的 Error 和 Exception：</h4><p>1）运行时异常（RuntimeException）也称 【非检查型异常 UncheckedException】：</p>
<p>Nullpointer Exception：空指针异常；<br>ClassCastException：类型强制转换异常<br>IllegalArgumentException：传递非法参数异常<br>IndexOutOfBoundsException：下标越界异常<br>NumberFormatException：数字格式异常<br>ArrayIndexOutOfBoundsException: 数组越界异常<br>ArrayStoreException: 数据存储异常，操作数组时类型不一致<br>ArithmeticException： (算术异常)<br>BufferOverflowException： (缓冲区溢出异常)</p>
<p>2）非运行时异常（CheckedException）也称 【检查型异常】：</p>
<p>ClassNotFoundException：找不到指定 class 的异常<br>IOException：IO 操作异常<br>FileNotFoundException：文件不存在异常<br>SQLException：SQL语句异常<br>InterruptedException： (中断异常-调用线程睡眠时候)</p>
<p>3）错误（Error）：</p>
<p>NoClassDefFoundError：找不到 class 定义异常<br>StackOverflowError：深递归导致栈被耗尽而抛出的异常<br>OutOfMemoryError：内存溢出异常</p>
<h4 id="✅遇到的异常记录"><a href="#✅遇到的异常记录" class="headerlink" title="✅遇到的异常记录"></a>✅遇到的异常记录</h4><h4 id="ExecutionException"><a href="#ExecutionException" class="headerlink" title="ExecutionException"></a>ExecutionException</h4><p>future.get()抛出的，ExecutionException包装正在执行的线程抛出的任何异常。没明白，应该是个检查型异常。是必须要程序员处理的。</p>
<p><a target="_blank" rel="noopener" href="https://www.orcode.com/question/618888_kb0916.html">https://www.orcode.com/question/618888_kb0916.html</a><br><a target="_blank" rel="noopener" href="https://www.mianshigee.com/question/91669mas/">https://www.mianshigee.com/question/91669mas/</a></p>
<h4 id="InterruptException"><a href="#InterruptException" class="headerlink" title="InterruptException"></a>InterruptException</h4><p>future.get()会抛出，Thread.sleep也会抛出。<br>当线程正在等待、休眠或以其他方式被占用，并且线程在活动之前或活动期间被中断时抛出。 有时，方法可能希望测试当前线程是否被中断，如果是，则立即抛出此异常。<br>活动线程的执行中断行为，可以抛出这样的异常。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/kevinmeanscool/article/details/123566970">https://blog.csdn.net/kevinmeanscool/article/details/123566970</a></p>
<h4 id="java-lang-NoClassDefFoundError"><a href="#java-lang-NoClassDefFoundError" class="headerlink" title="java.lang.NoClassDefFoundError"></a>java.lang.NoClassDefFoundError</h4><p>NoClassDefFoundError可能出现的情况<br>目前有发现几种情况<br>1.一种情况就是因为静态变量加载不到原因<br>2.工程里没有将jar添加到classpath，maven项目的，需要根据项目情况排查</p>
<p>实际原因：在报错的test类所在的包里，没有引某个包，导致找不到某类。<br>首先用：<code>mvn dependency:tree</code>，查看依赖jar的关系，看一下这个类的包是哪个，引用了没。<br>发现在父pom里有这个包，但是在报错的包里没有用父pom，也没引那个包。<br>所以，在报错的包的pom里，引用那个包就解决。</p>
<h4 id="NoUniqueBeanDefinitionException"><a href="#NoUniqueBeanDefinitionException" class="headerlink" title="NoUniqueBeanDefinitionException"></a>NoUniqueBeanDefinitionException</h4><p>不唯一的bean定义异常<br>没有一个合适的bean类型（cn.cy.bean.Tool）可用，预期有一个单独的匹配的bean，但是找到了多个。</p>
<p>看看是不是一个接口有多个实现类，然后在某类中注入该接口中没有指定注入哪个。</p>
<blockquote>
<p>通常如果一个接口多个实现类，会根据条件Enum选择哪个类执行的话，加一个ServiceFacade类来根据条件选择，这个类实现Service接口和InitializingBean接口，里面定义一个map&lt;Enum, 接口Service&gt;，在使用到实现类的方法中，注入ServiceFacade就行。</p>
</blockquote>
<p>解决方法：<br>1、注入接口的地方 <code>@Autowired + @Qualifer(&quot;whichImpl&quot;)</code><br>2、注入接口的地方 <code>@Resource(name=&quot;whichImpl&quot;)</code></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46030002/article/details/125661107">https://blog.csdn.net/weixin_46030002/article/details/125661107</a></p>
<h4 id="BeanCreationException"><a href="#BeanCreationException" class="headerlink" title="BeanCreationException"></a>BeanCreationException</h4><p>Bean创建过程中抛出异常。具体有以下几种常见异常，包括上面的NoUniqueBeanDefinitionException 也是一种。</p>
<p>1.org.springframework.beans.factory.NoSuchBeanDefinitionException</p>
<p>上下文中不存在此Bean，一般原因在没有声明Bean，BeanA尝试注入BeanB，但是spring上下文中不存在BeanB。检查是否用@Component @Service @Controller @Repository 注入了bean。</p>
<p>2.org.springframework.beans.factory.NoUniqueBeanDefinitionException</p>
<p>当一个Bean有多个实现，例如BeanB1 和BeanB2都实现了同一个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BeanB1 implements IBeanB &#123; ... &#125;</span><br><span class="line">@Component</span><br><span class="line">public class BeanB2 implements IBeanB &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line">@Component</span><br><span class="line">public class BeanA &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    private IBeanB dependency;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.org.springframework.beans.BeanInstantiationException</p>
<p>Bean 实例化过程中出现异常，具体原因需要查看nested exception后面报错</p>
<p>3.1 Custom Exception<br>业务自定义抛出异常，如下抛出空指针异常</p>
<p>3.2 java.lang.InstantiationException<br>在xml配置中使用抽象类定义bean</p>
<p>3.3 java.lang.NoSuchMethodException<br>如果一个bean类没有默认的构造方法，spring在创建bean实例时.</p>
<p>4.org.springframework.beans.factory.CannotLoadBeanClassException</p>
<p>当spring加载不到bean对应的类文件时，这种异常将会被抛出。这种情况很有可能发生在当配置文件中的类路径全称找不到对应文件时。</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37578675/article/details/117075030">https://blog.csdn.net/m0_37578675/article/details/117075030</a></p>
<hr>
<h4 id="✅NoClassDefFoundError-和-ClassNotFoundException-的区别："><a href="#✅NoClassDefFoundError-和-ClassNotFoundException-的区别：" class="headerlink" title="✅NoClassDefFoundError 和 ClassNotFoundException 的区别："></a>✅NoClassDefFoundError 和 ClassNotFoundException 的区别：</h4><p>区别一：<br>NoClassDefFoundError它是Error，<br>ClassNotFoundException是Exception。</p>
<p>区别二：<br>NoClassDefFoundError是JVM运行时通过classpath加载类时，找不到对应的类而抛出的错误。<br>ClassNotFoundException是编译时异常，在编译过程中必须将ClassNotFoundException异常抛出！</p>
<p>NoClassDefFoundError发生场景如下：<br>1、类依赖的class或者jar不存在 （简单说就是maven生成运行包后被篡改）<br>2、类文件存在，但是存在不同的域中 （简单说就是引入的类不在对应的包下)<br>3、大小写问题，javac编译的时候是无视大小的，很有可能你编译出来的class文件就与想要的不一样！这个没有做验证？？？</p>
<p>ClassNotFoundException发生场景如下：<br>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>举例说明如下:<br>Class.forName(“abc”); 比如abc这个类不存项目中，代码编写时，就会提示此异常是检查性异常，比如将此异常抛出。</p>
<hr>
<h4 id="✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别："><a href="#✅运行时异常（Runtime-exception-与检查型异常（checked-exception）的区别：" class="headerlink" title="✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别："></a>✅运行时异常（Runtime exception)与检查型异常（checked exception）的区别：</h4><p>1:checked （检查型异常）也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。编译器要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，<br>另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try …catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法名的后边，eg:  方法名（） throws  IOExecption。</p>
<p>理解：检查型异常，要么：try… catch.. 打log，要么：try..catch..throw..throws（多此一举，没必要），要么只是throws。</p>
<p>2:runtime exception（运行时异常），编译器不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try …catch）,会直接throws出去，如果不想throws出去，就try catch 打log。<br>如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。  当出现这样的异常时，总是由虚拟机接管。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liangbaolong/p/12884224.html">https://www.cnblogs.com/liangbaolong/p/12884224.html</a></p>
<hr>
<h4 id="✅多异常捕获："><a href="#✅多异常捕获：" class="headerlink" title="✅多异常捕获："></a>✅多异常捕获：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; catch(NullPointerException | IOException e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    //log.error(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| 符合 可以 写多个，符合其中之一。<br>注意要把异常范围小的放在前面，范围大的放在后面。<br>⚠️注意在try内return或者break了，finally也会执行的。</p>
<h4 id="catch-Exeception-e-和catch-Throwable-e"><a href="#catch-Exeception-e-和catch-Throwable-e" class="headerlink" title="catch(Exeception e)和catch(Throwable e)"></a>catch(Exeception e)和catch(Throwable e)</h4><p>Throwable可以捕获Error和Exception两大类的异常，其中Error是比较严重不可控的异常。而Exception是可以被编程处理的异常。<br>Exception只能捕获RuntimeException和IOException。</p>
<p>回顾一下java的异常体系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Throwable: Java中所有异常和错误类的父类。只有这个类的实例（或者子类的实例）可以被虚拟机抛出或者被java的throw关键字抛出。同样，只有其或其子类可以出现在catch子句里面。</span><br><span class="line">Error: Throwable的子类，表示严重的问题发生了，而且这种错误是不可恢复的。</span><br><span class="line">Exception: Throwable的子类，应用程序应该要捕获其或其子类（RuntimeException例外），称为checked exception。比如：IOException, NoSuchMethodException...</span><br><span class="line">RuntimeException: Exception的子类，运行时异常，程序可以不捕获，称为unchecked exception。比如：NullPointException.</span><br></pre></td></tr></table></figure>

<p>❓应该catch (Throwable th) 还是 catch (Exception)?</p>
<p>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。第一种catch相当于比第二种catch多捕捉了把Error和其子类。</p>
<p>❓Error是否需要捕捉?</p>
<p>JDK中Error类的的注释里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)”来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。</p>
<p>❓Error可以catch吗？ 可以catch了后做些其他处理吗？</p>
<p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p>
<p>假设进行网络连接操作的时候，IOException 发生了，可能是网络中断，我可以再尝试几次。</p>
<p>假设OutOfMemoryError发生了，就算被捕捉了，可以有什么手段让程序正常运行下去吗？ 假设ExceptionInInitializerError发生了，类无法被正常初始化，这个是可以通过捕捉来恢复的吗？</p>
<p>👌结论：Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用</p>
<p>转自：如何处理异常? catch Exception OR catch Throwable<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/smile361/p/5521278.html">https://www.cnblogs.com/smile361/p/5521278.html</a></p>
<p>举一个用<code>catch (Throwable e)</code>的例子：<br>目的是确保异常被打印，一个无线递归，导致的StackOverflowError</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Throwable_demo &#123;</span><br><span class="line">    static void generate_throwable() &#123;</span><br><span class="line">        generate_throwable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //此种情形下我们要catch Throwable, 以确保异常被打印...</span><br><span class="line">        try &#123;</span><br><span class="line">            final int[] times = &#123; 0 &#125;;</span><br><span class="line">            Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        ++times[0];</span><br><span class="line">                        System.out.println(times[0]);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(10);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread1.start();</span><br><span class="line">            generate_throwable();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            //若catch的是Exception：</span><br><span class="line">            //因finally中的exit指令，在打印异常前程序就会终止。</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;end.&quot;);</span><br><span class="line">            //如果不exit: 因 thread1 未停止，程序不会终止。</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅项目中的自定义异常"><a href="#✅项目中的自定义异常" class="headerlink" title="✅项目中的自定义异常"></a>✅项目中的自定义异常</h4><p>继承RuntimeException扩展一个新的异常作为整个类库的异常基类。<br>里面定义异常编码啥的。</p>
<p>如果需要根据异常进行不同的处理，建议给自定义异常增加一个ERROR_CODE字段，这样无论在服务器还是客户端都可以根据不同的ERROR_CODE进行对应的处理。但是出现这种情况的时候，应该需要考虑一下设计思路了，一般来讲根据异常来决定业务流程不是一个好的设计方案。</p>
<h4 id="✅e-getMeasage-和e-toString"><a href="#✅e-getMeasage-和e-toString" class="headerlink" title="✅e.getMeasage()和e.toString()"></a>✅e.getMeasage()和e.toString()</h4><p>e.getMeasage()返回异常的简短描述信息，是一个字符串。<br>e.toString()返回异常的详细信息，包括异常类型和异常消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">空指针：</span><br><span class="line">message:null</span><br><span class="line">toString:java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList线程安全问题"><a href="#ArrayList线程安全问题" class="headerlink" title="ArrayList线程安全问题"></a>ArrayList线程安全问题</h3><p>ArrayList 是线程不安全的集合类，当多线程环境下，并发对同一个ArrayList执行add，可能会丢数据。如果多线程又是add，又是输出list，会发生并发错误。</p>
<p>⚠️为什么说可能呢，因为有时候add得太快，就没出问题。</p>
<blockquote>
<p>ConcurrentModificationException: 并发修改异常<br>    使用迭代器循环，在循环中用ArrayList的add/remove方法会出现该异常。原因及解决方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013168615/article/details/116570591">https://blog.csdn.net/u013168615/article/details/116570591</a></p>
</blockquote>
<hr>
<p>多线程对List进行add又遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test4() throws InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 1; i &lt;= 30; i++)&#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(0, 8));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread.sleep(60 * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常：Exception in thread “Thread-0” java.util.ConcurrentModificationException</p>
<h4 id="✅ArrayList为什么线程不安全"><a href="#✅ArrayList为什么线程不安全" class="headerlink" title="✅ArrayList为什么线程不安全"></a>✅ArrayList为什么线程不安全</h4><p>多线程对ArrayList进行add有可能会造成数据丢失。也有可能会造成数组越界。</p>
<blockquote>
<p>线程安全：指当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染等意外情况。</p>
<p>线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染等意外情况。</p>
</blockquote>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line"> implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 列表元素集合数组如果新建ArrayList对象时没有指定大小，那么会将 </span><br><span class="line">    * EMPTY_ELEMENTDATA赋值给elementData，</span><br><span class="line">    * 并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY </span><br><span class="line">    */</span><br><span class="line">    transient Object[] elementData; </span><br><span class="line">    // 列表大小，elementData中存储的元素个数</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的实现主要就是：<br>1️⃣用了一个 Object 的数组，用来保存所有的元素；<br>2️⃣一个 size 变量用来保存当前数组中已经添加了多少元素。</p>
<p>ensureCapacityInternal() 的作用就是如果将当前的新元素加到列表后面，判断列表的 elementData 数组的大小是否满足。如果 size + 1 的这个需求长度大于 elementData 这个数组的长度，那么就要对这个数组进行扩容。由此看到 add 元素时，实际有两个大的步骤：<br>1️⃣判断 elementData 数组 capacity 容量是否满足需求，是否需要扩容。<br>2️⃣在 elementData 对应位置上设置值。<br><code>这样就出现了第一个导致线程不安全的隐患，在多个线程进行 add 操作时可能会导致 elementData 数组越界。</code></p>
<hr>
<p>为什么会数组越界ArrayIndexOutOfBoundsException？</p>
<p>ArrayList 默认数组大小为 10。假设现在已经添加进去 9 个元素了，size = 9。</p>
<p>1、线程 A 执行完 add 方法中的 ensureCapacityInternal(size+1) 挂起了。<br>2、线程 B 开始执行，校验数组容量发现不需要扩容。于是把 “b” 放在了下标为 9 的位置，且 size 自增 1。此时 size = 10。<br>3、线程 A 接着执行，尝试把 “a” 放在下标为 10 的位置，因为 size = 10。但因为数组还没有扩容，最大的下标才为 9，所以会抛出数组越界异常ArrayIndexOutOfBoundsException。</p>
<hr>
<p>为什么会数据丢失？</p>
<p>ArrayList线程不安全，当一条线程执行list.add()的时候会出现被另一条线程的值覆盖，比如线程A对list进行add，携带的size是n，同时线程B也进行add操作，携带的size也是n，所以ArrayList没有达到扩容的条件，A的值应该放在ArrayList的第n位，但是B的值也将放在第n位，覆盖了A的值，导致数据丢失。</p>
<p>源码：<br>第二步 elementData[size++] = e 设置值的操作同样会导致线程不安全。从这里可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：<br>elementData[size] = e;<br>size = size + 1;</p>
<p>ArrayList 为什么线程不安全：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChineseSoftware/article/details/117047757">https://blog.csdn.net/ChineseSoftware/article/details/117047757</a></p>
<hr>
<p>ArrayList的所有方法都没有加Lock，也没有加synchronized，因此在并发操作下，扩容函数grow()会存在问题。</p>
<p>举个简单的例子：<br>elementData数组刚刚添加了最后一个元素，也就是刚好满员了<br>这时2个线程同时又调用了add，那么就必须要执行grow进行扩容<br>第1个线程调用完grow()，然后也调用了elementData[size++] = e，把新元素添加上去<br>第2个线程又调用一次grow()，整个elementData数组就乱掉了。</p>
<h4 id="✅多线程情况下该用什么："><a href="#✅多线程情况下该用什么：" class="headerlink" title="✅多线程情况下该用什么："></a>✅多线程情况下该用什么：</h4><p>1、使用 Vector 初始化 list 对象，效率低<br><code>List&lt;String&gt; list = new Vector&lt;&gt;();</code><br>Vector.add使用了synchronized加锁<br>转换成ArrayList：<br><code>List&lt;String&gt; newList = new ArrayList&lt;String&gt;(vector);</code></p>
<p>2、使用 Collections.synchronizedList<br><code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code><br><code>List&lt;String&gt; list = Collections.synchronizedList(Lists.newArrayList());</code><br>add方法同样加了 synchronized 锁。</p>
<p>3、使用 CopyOnWriteArrayList<br><code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></p>
<p>写时复制，即向一个容器添加元素的时候，不直接向当前容器添加，而是将当前容器进行复制，然后向新容器进行添加操作，最后将原容器的引用指向新的容器。</p>
<p>这样的好处是允许并发的读而不需要加锁（因为容器内元素未发生变化），提升效率，仅写时上锁，读和写再不同的容器中，体现了读写分离的思想 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原文：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fhblikesky/p/13692641.html">https://www.cnblogs.com/fhblikesky/p/13692641.html</a></p>
<h4 id="✅list的ConcurrentModificationException问题"><a href="#✅list的ConcurrentModificationException问题" class="headerlink" title="✅list的ConcurrentModificationException问题"></a>✅list的ConcurrentModificationException问题</h4><p>除了多线程修改ArrayList的操作会造成该问题之外，在迭代器中用list.add或list.remove去添加删除list元素，也会造成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = myList.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Iterator it = myList.iterator(); it.hasNext();) &#123;</span><br><span class="line">    String value = it.next();</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (String value : myList) &#123;</span><br><span class="line">    System. out.println( &quot;List Value:&quot; + value);</span><br><span class="line">        if (value.equals( &quot;3&quot;)) &#123;</span><br><span class="line">            myList.remove(value);  // error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>原因看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;= elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出</li>
<li>lastRet：表示上一个访问的元素的索引</li>
<li>expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。</li>
<li>modCount: 是在 ArrayList 中赋值的，并且初始值为 0，在 add 和 remove 的时候（修改元素的时候）会增加 1.</li>
</ul>
<p>hasNext方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasNext 方法，在方法中的 size 是 ArrayList 中的变量，这个 ConcurrentModificationException 异常存在的原因之一就在这个方法体现出来了，在多线程的情况下，如果使用迭代器遍历时，ArrayList数组元素变少导致 cursor &gt; size，然后数组越界。在正常情况下当 cursor == size代表已经到数组尽头了.</p>
<p>next 方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    int i = cursor;</span><br><span class="line">    if (i &gt;= size)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">    if (i &gt;= elementData.length)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    cursor = i + 1;</span><br><span class="line">    return (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next 方法中先是判断了 modCount 是否等于 expectedModCount，不相等则抛出 并发修改异常，否则取到游标，然后判断游标是否大于数组长度或者元素个数。最后游标加一，然后返回数的同时使 lastRet 等于 i。</p>
<p>remove方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0)</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList.this.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 remove 掉元素的时候更新下自己的 expectedModCount。注意的是remove后 lastRet 会变成 -1，也就是不能连续 remove 两次，因为在 next 中检查了 lastRet 的值不能小于 0。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">if (modCount != expectedModCount)</span><br><span class="line">throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当modCount != expectedModCount时，执行next()就会抛出ConcurrentModificationException<br>而什么时候会造成modCount != expectedModCount呢？<br>ArrayList.add()和remove()方法，每执行一次都会modCount++，但不改变expectedModCount的值。expectedModCount的值是在构建迭代的时候初始为expectedModCount=modCount的。<br>在构建迭代器之后，再使用ArrayList.add()方法就造成了modCount != expectedModCount<br>构建迭代器后，用迭代器来add和remove就没有问题。因为它会在改变modCount的值之后，又把值赋给了expectedModCount，从而保证modCount=expectedModCount</p>
<hr>
<p>解决方法：用迭代器的remove方法<br>多线程情况下，iterator是线程私有，也即是说expectedModCount是每个线程私有。使用Vector也不行。<br>所以：<br>在使用iterator迭代的时候使用synchronized或者Lock进行同步。不推荐，因为增删造成的同步锁可能会阻塞遍历操作。<br>使用并发容器CopyOnWriteArrayList或者ConcurrentHashMap代替ArrayList和Vector。CopyOnWriteArrayList不能使用Iterator.remove()进行删</p>
<p>ConcurrentModificationException异常原因和解决方法：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44613591/article/details/114108920">https://blog.csdn.net/qq_44613591/article/details/114108920</a></p>
<p>Java 遍历List ConcurrentModificationException 异常解析：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30051139/article/details/54019515">https://blog.csdn.net/qq_30051139/article/details/54019515</a></p>
<h4 id="总结多线程下ArrayList的几个问题"><a href="#总结多线程下ArrayList的几个问题" class="headerlink" title="总结多线程下ArrayList的几个问题"></a>总结多线程下ArrayList的几个问题</h4><p>1.多线程add可能会丢数据，也可能数组越界，但不会并发错误<br>2.多线程add又打印ArrayList，会并发错误，应为System.out方法里用了迭代器。<br>3.用迭代器遍历中又用ArrayList的add和remove方法，会并发错误。</p>
<p>实验：对partition后的某个subList进行add的话，会牵一发而动全身，因为每个subList是多大已经规定好，对前面的subList进行add，add的元素会跑到下一个subList，以此类推。原来的list也会改变。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList进行add，会并发错误。<br>🤔为什么单纯ArrayList多线程add不会并发错误，这里就会。<br>这里使用的是AbstractList的add方法，其中用到ArrayList的size方法会检查modCount。但是ArrayList的add方法用的是ArrayList的add方法。</p>
<p>实验：对ArrayList分partition：<code>List&lt;List&lt;A&gt;&gt; partion = Lists.partition(list, 2);</code>，循环将各个subList传入不同的线程，并且在线程中对subList只是打印，在主线程里再add，会并发错误。原因：打印List也会用到迭代器。<br>如果是在线程里循环遍历打印单个元素，不会有错误。并且会实时反映增加的元素。</p>
<h3 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h3><p>1、泛型与Object的区别</p>
<p>方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object doSomething(Object obj) &#123;....&#125;</span><br><span class="line">​</span><br><span class="line">public &lt;T&gt; T doSomething(T t) &#123;....&#125;</span><br></pre></td></tr></table></figure>

<p>无论是T还是 obj，你都只能调用Object类型的参数和返回值。</p>
<p>但是，如果是使用了泛型的类，和普通的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;Foo&gt; my = new MyClass&lt;Foo&gt;();</span><br><span class="line">Foo foo = new Foo();</span><br><span class="line"></span><br><span class="line">泛型：</span><br><span class="line">Foo newFoo = my.doSomething(foo);</span><br><span class="line"></span><br><span class="line">Object:</span><br><span class="line">Foo newFoo = (Foo) my.doSomething(foo);</span><br></pre></td></tr></table></figure>

<p>因此，使用泛型的好处：</p>
<p>1.不需要做强制类型转换</p>
<p>2.编译时更安全。如果使用Object类的话，你没法保证返回的类型一定是Foo，也许是其它类型。这时你就会在运行时得到一个类型转换异常（ClassCastException）</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SDDDDDSA/article/details/120733398">https://blog.csdn.net/SDDDDDSA/article/details/120733398</a></p>
<p>2、泛型<code>&lt;T&gt; T</code> 与 T 的区别</p>
<p>方法返回前的<code>&lt;T&gt; </code>是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.jt.test;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @Description</span><br><span class="line"> * 有的方法返回值为 &lt;T&gt; T ，有的方法返回值为 T ,区别在那里 ？</span><br><span class="line"> **/</span><br><span class="line">public class Request&lt;E&gt; &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public &lt;T&gt; T getObject(Class&lt;T&gt; tClass) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        T t = tClass.newInstance();</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 方法返回前的 &lt;T&gt; 是告诉编译器，当前方法的值传入类型可以和类初始化的泛型类型不同，</span><br><span class="line">     * 也是就是该方法的泛型类可以自定义，不需要跟类初始化的泛型类相同</span><br><span class="line">     *</span><br><span class="line">     * 参数 T</span><br><span class="line">     *  第一个 表示是泛型</span><br><span class="line">     *  第二个 表示是返回是T类型的数据</span><br><span class="line">     *  第三个 表示限制参数类型为T</span><br><span class="line">     * @param data</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private &lt;T&gt; T getListFirst(List&lt;T&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 这个只能传T类型的数据</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private E getListFirst2(List&lt;E&gt; data) &#123;</span><br><span class="line">        if (data == null || data.size() == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return data.get(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; data2 = new ArrayList&lt;&gt;();</span><br><span class="line">        // 入参由List&lt;T&gt;的T 决定，因为返回值为&lt;T&gt; T ,所以入参不受 Request&lt;T&gt; 影响</span><br><span class="line">        Integer a = new Request&lt;String&gt;().getListFirst(data);</span><br><span class="line"> </span><br><span class="line">        // 编译出错，入参由Request&lt;T&gt; T的决定，受Request&lt;T&gt;影响</span><br><span class="line">        //new Request&lt;String&gt;().getListFirst2(data);</span><br><span class="line"> </span><br><span class="line">        // 没什么区别</span><br><span class="line">        String aa = new Request&lt;String&gt;().getListFirst(data2);</span><br><span class="line">        String bb = new Request&lt;String&gt;().getListFirst2(data2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianzhitu/article/details/107962657">https://blog.csdn.net/qianzhitu/article/details/107962657</a></p>
<p>3、泛型通配符</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>常用的 T，E，K，V，？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<p>？表示不确定的 java 类型<br>T (type) 表示具体的一个java类型<br>K V (key value) 分别代表java键值中的Key Value<br>E (element) 代表Element</p>
<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/minkeyto/article/details/116205607">https://blog.csdn.net/minkeyto/article/details/116205607</a></p>
<p>学长教学妹java泛型：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67401499/article/details/125401501">https://blog.csdn.net/m0_67401499/article/details/125401501</a></p>
<h3 id="java可变参数"><a href="#java可变参数" class="headerlink" title="java可变参数"></a>java可变参数</h3><p>java可变参数是指在调用方法时传入不定长度的参数，本质上是基于数组实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">//在定义方法时，在最后一个形参上加&quot;…&quot;就表示该形参可以接受多个参数值，多个参数值被当做数组传入。</span><br><span class="line">public static void element(Integer... args)&#123; &#125;</span><br><span class="line">//参数为数组</span><br><span class="line">public static void element(Integer[] args)&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//参数为可变参数</span><br><span class="line">public static void element(Integer... args) &#123;</span><br><span class="line">    for (int arg : args) &#123;</span><br><span class="line">        System.out.print(arg + &quot;  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //都可以</span><br><span class="line">    element(1,2,3);</span><br><span class="line">    int[] array=&#123;1,2,3&#125;;</span><br><span class="line">    element(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️可变参数只能做为函数的最后一个参数，前面有没有其他参数都可以，一个函数最多只能有一个可变参数。</p>
<p>可变参数在编译为字节码后，在方法签名中是以数组形态出现的，如果两个方法签名编译后的是一致的话，是不能编译通过的，不可以作为方法的重载。</p>
<p>可变参数作为参数的方法可以传入数组类型的数据或者直接传入多个数据，但是数组作为参数的方法只能传入数组类型的数据。</p>
<p>反射时，可变参数的注意事项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void element(Integer... args)&#123;</span><br><span class="line">        System.out.println(args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] arrry=&#123;1,2,3&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //反射是运行时获取的，在运行时看来，可变参数和数组上是一致的。因而方法的签名为([java/lang/Integer;)V</span><br><span class="line">            //Method对象的方法声明为Object invoke (Object obj,Object.. args)</span><br><span class="line">            //args虽然是一个可变长度的参数，但是args的长度受限于该方法对象代表的真实方法的参数列表长度,</span><br><span class="line">            //从运行时签名来看，([java/lang/Integer;)V实际上是一个形参，即Integer[] args,因此invoke (Object obj,Object.. args)中可变参数args的实际参数长度只能为1。</span><br><span class="line">            Method method = Demo5.class.getMethod(&quot;element&quot;, Integer[].class);</span><br><span class="line">            //array的长度为3，不符合</span><br><span class="line">            method.invoke(null,arrry);</span><br><span class="line">            //将Integer[]转为Object[]，长度还是为3，不符合</span><br><span class="line">            method.invoke(null,(Object[])arrry);</span><br><span class="line">            //将整个Integer[]转为一个Object，长度为1，符合</span><br><span class="line">            method.invoke(null,(Object)arrry);</span><br><span class="line">            //Object[]的长度为1，符合，和上面相同</span><br><span class="line">            method.invoke(null,new Object[]&#123;arrry&#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43413307/article/details/125485292">https://blog.csdn.net/weixin_43413307/article/details/125485292</a></p>
<h3 id="类中的布尔类型get方法注意"><a href="#类中的布尔类型get方法注意" class="headerlink" title="类中的布尔类型get方法注意"></a>类中的布尔类型get方法注意</h3><p>@Getter自动生成getter方法，但是：<br>1.Boolean类型,生成的get方法是get开头的(建议使用这个).<br>2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).</p>
<p>用到布尔值的属性时,最好统一使用大写的包装类Boolean.<br>如果用小写的booean基本类型,最好重写get方法,保证是getXxxx的格式即可.<br>*如果这个对象涉及到反射,反射一般会默认调取对象的get方法,对于这个is的情况,是走不通的.</p>
<h3 id="java的native方法"><a href="#java的native方法" class="headerlink" title="java的native方法"></a>java的native方法</h3><p>什么是native方法？<br>一个Native Method是一个java调用非java代码的接口。Native Method的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<p>使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。 这些函数的实现体在DLL中，JDK的源代码中并不包含，你应该是看不到的。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p>
<p>例如：<br>Thread.sleep(1000); 还有 Thread.start0() 都是native方法。<br>在JDK 源码 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法</p>
<p>native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。<br>java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.native方法是java与其他语言协作的时候使用的，底层实现不是java(c,c++)</span><br><span class="line">2.native并不是java实现的，所以直接调用就好，不需要管他底层实现</span><br><span class="line">3.native方法实际上是java用于调用底层操作系统的方法,java只能调用，不能查看和修改</span><br><span class="line">4.java是跨平台语言，自然而然会失去对底层的控制，于是想要调用底层方法，就必须使用native方法间接调用底层操作系统的方法(c,c++实现)</span><br><span class="line">5.随着java的不断发展，native方法越来越少</span><br><span class="line">6.native是一个关键字，其修饰的方法只说明不实现</span><br><span class="line">7.native方法加载到 本地栈中</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https://blog.csdn.net/TheWayForDream/article/details/122202601</span><br></pre></td></tr></table></figure>

<p>JNI：Java Native Interface：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28001771/answer/2049534464">https://www.zhihu.com/question/28001771/answer/2049534464</a><br>native用法：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/195760.html">https://www.jb51.net/article/195760.html</a></p>
<h3 id="printStackTrace-方法"><a href="#printStackTrace-方法" class="headerlink" title="printStackTrace()方法"></a>printStackTrace()方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">… &#125; catch(Exception e) &#123;</span><br><span class="line">e.printStackTrace() ; &#125;</span><br></pre></td></tr></table></figure>

<p>try语句中出现异常时，系统会自动将catch括号中的Exception e 初始化。</p>
<p>printStackTrace()：在命令行打印异常信息在程序中出错的位置及原因。<br>System.out.println(e)：打印异常</p>
<p>不建议使用printStackTrace()的原因：<br>e.printStackTrace() 语句要产生的字符串记录的是堆栈信息，太长太多，内存会被填满。</p>
<p>短时间内大量请求访问此接口 -&gt; 代码本身有问题，很多情况下抛异常  -&gt; e.printStackTrace() 来打印异常到控制台 -&gt; 产生错误堆栈字符串到字符串池内存空间 -&gt; 此内存空间一下子被占满了 -&gt; 开始在此内存空间产出字符串的线程未完成，就没空间了 -&gt;  大量线程产出字符串产出到一半，等在这儿（等有内存了继续搞）-&gt; 相互等待，等内存，锁死了，整个应用挂掉了。</p>
<p>为什么不建议printStackTrace：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kzadmxz/article/details/89914896">https://blog.csdn.net/kzadmxz/article/details/89914896</a></p>
<p>建议：logger.error(“***”,  e);</p>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><p>✅1.使用Math方法</p>
<p>java本身的，不需要导入包，Math.random()随机生成一个double类型[0，1)，如果想生成1~100的随机数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = (int)(Math.random()*100)+1;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println((int)0.01); //0</span><br></pre></td></tr></table></figure>

<p>✅2.使用Random方法生成随机数</p>
<p>Random类是java.until下的一个根据随机算法的起源数字进行一些变化，从而得到随机数字的方法。</p>
<p>随机算法的起源数字被成为种子数（seed）。</p>
<p>虽然Random类产生的数字是随机的，但在相同种子数（seed）下的相同次数产生的随机数是相同的（伪随机）。</p>
<p>Random中共有两种构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、public Random（）</span><br><span class="line">此构造方法是以系统自身的时间为种子数来构造Random对象。</span><br><span class="line"></span><br><span class="line">2、public Random（long seed）</span><br><span class="line">此构造方法可以自己来选定具体的种子来构造Random对象。</span><br></pre></td></tr></table></figure>

<p>常用方法：都可以加参数表示范围，范围是左闭右开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">random.nextInt()	返回值为整数,范围是int类型范围</span><br><span class="line">random.nextLong()	返回值为长整型，范围是long类型的范围</span><br><span class="line">random.nextFloat()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextDouble()	返回值为小数，范围是[0,0.1]</span><br><span class="line">random.nextBoolean（）	返回值为boolean值，true和false概率相同</span><br><span class="line">radom.nextGaussian()	返回值为呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random r = new Random();//以系统自身时间为种子数</span><br><span class="line">int i = r.nextInt();</span><br><span class="line">System.out.println(&quot;i&quot;+i);</span><br><span class="line">Scanner sc  =new Scanner(System.in);</span><br><span class="line">int j = sc.nextInt();</span><br><span class="line">Random r2 = new Random(j);//自定义种子数</span><br><span class="line">Random r3 = new Random(j);//这里是为了验证上方的注意事项：Random类是伪随机，相同种子数相同次数产生的随机数相同</span><br><span class="line">int num  = r2.nextInt(1000);</span><br><span class="line">int num2 = r3.nextInt(1000);</span><br><span class="line">System.out.println(&quot;num&quot;+num);</span><br><span class="line">System.out.println(&quot;num2&quot;+num2);</span><br></pre></td></tr></table></figure>

<p>✅3.使用SecureRandom生成随机数</p>
<p>java.util.Random的实例不是加密安全的，要是知道setSeed值(即时间戳)，很明显能把随机数给猜出来。所以不建议使用Random。SecureRandom来获取加密安全的伪随机数生成器，以供对安全敏感的应用程序使用。</p>
<p>在安全应用场景，随机数应该使用安全的随机数。密码学意义上的安全随机数，要求必须保证其不可预测性。</p>
<p>密码学安全的伪随机数产生器：JDK的java.security.SecureRandom</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom random = new SecureRandom();</span><br><span class="line">String returnValue = &quot;&quot;;</span><br><span class="line">int randomInt = 0;</span><br><span class="line">int range = 9;</span><br><span class="line">for(int i=0; i&lt;5; i++ )&#123;</span><br><span class="line">    randomInt = random.nextInt(range+1);</span><br><span class="line">    returnValue = returnValue + randomInt;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">secureRandom.setSeed(System.currentTimeMillis()); //使用系统时间作为种子</span><br><span class="line">如果同一毫秒连续调用，则得到的随机数则是相同的。</span><br><span class="line">不要自己指定种子。应当使用系统随机源。采用无参构造方法实例化</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSecureRandom() throws NoSuchAlgorithmException &#123;</span><br><span class="line">    //指定算法名称</span><br><span class="line">    SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0 ; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-------------------&quot;);</span><br><span class="line">    secureRandom = new SecureRandom();</span><br><span class="line">    secureRandom.setSeed(10000L);</span><br><span class="line">    for(int i = 0; i &lt; 10 ; i ++) &#123;</span><br><span class="line">        System.out.println(secureRandom.nextInt(1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getInstance方法"><a href="#getInstance方法" class="headerlink" title="getInstance方法"></a>getInstance方法</h3><p>两个使用场景：</p>
<p>✅1.抽象类</p>
<p>抽象类是无法直接new出来的，所以想要通过实例化的话只能通过getInstance()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class GetInstanceTest &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Person p = Person.getInstance(&quot;Limbo&quot;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public Person(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract public void eat();</span><br><span class="line">    public static  PersonImpl getInstance(String title) &#123;</span><br><span class="line">        return new PersonImpl(title);</span><br><span class="line">    &#125;</span><br><span class="line">    //必须static：</span><br><span class="line">    static class PersonImpl extends Person</span><br><span class="line">    &#123;</span><br><span class="line">        public PersonImpl(String title) &#123;</span><br><span class="line">            super(title);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void eat()</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Eat!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅2.单例设计模式</p>
<p>一般在单例模式下使用.getInstance()创建对象.<br>单例模式：一个类有且只有一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Singleton s = Singleton.getInstance();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    private String content;</span><br><span class="line">    //在自己内部定义自己的一个实例</span><br><span class="line">    private static Singleton SINGLETON = null;</span><br><span class="line">    //private 只能在自己内部供自己去访问</span><br><span class="line">    private Singleton(String title, String content) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    //此静态方法供外部直接访问</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (SINGLETON == null)</span><br><span class="line">            SINGLETON = new Singleton(&quot;Kobe&quot;, &quot;MVP&quot;);</span><br><span class="line">        return SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.title + &quot; - &quot; + this.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getInsance()t:在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。</p>
<p>(1)对象使用之前通过getinstance得到，而不需要自己定义，用完之后不需要delete；</p>
<p>(2)new 一定要生成一个新对象，分配内存；getInstance() 则不一定要再次创建，它可以把一个已存在的引用给你使用，这在效能上优于new；</p>
<p>(3) new创建后只能当次使用，而getInstance()可以跨栈区域使用，或者远程跨区域使用。所以getInstance()通常是static静态实例方法。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/baxianhua/p/9341953.html">https://www.cnblogs.com/baxianhua/p/9341953.html</a></p>
<h3 id="lang3下的Pair"><a href="#lang3下的Pair" class="headerlink" title="lang3下的Pair"></a>lang3下的Pair</h3><p>org.apache.commons.lang3.tuple.Pair</p>
<p>Pair 用于存储左右元素对，Pair&lt;Left, Right&gt;。主要有两个子类，ImmutablePair 和 MutablePair。</p>
<p>Pair 实现了 java.util.Map.Entry，因此 left 和 right 也可以视作 key-value。不同于Map，Pair只能存一组键值对。</p>
<p>of 方法 以 static 调用的形式创建一个 Pair 实例. 默认创建的是 ImmutablePair。left, right值final 修饰， 值第一次被设置后不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; pair = Pair.of(1, &quot;1&quot;);</span><br><span class="line">System.out.println(pair.getLeft());</span><br><span class="line">System.out.println(pair.getKey());</span><br><span class="line">System.out.println(pair.getRight());</span><br><span class="line">System.out.println(pair.getValue());</span><br><span class="line">pair.setValue(&quot;2&quot;); //java.lang.UnsupportedOperationException</span><br></pre></td></tr></table></figure>

<p>org.apache.commons.lang3.tuple.MutablePair<br>继承了 Pair，left 和 right 值可变。</p>
<p>Pair与Map：<br>1.共通点: Pair 和 Map 都是以 key, value 进行存储。<br>2.不同点:<br>Pair 通过 getKey(), getValue() 获取 key 和 value，没有增加键值对的操作。<br>Map 是通过 get(key) 获取 key 对应的 value，通过 values() 获取所有的value，而且还可以通过 put 增加键值对。<br>Pair 保存的是一对 key-value，而 Map 可以保存多对 key-value。</p>
<p>⚠️Pair的一个使用场景：VO中用到的小数据结构，不想再构造一个pojo了，有两组键值对的数据，比如Point，只有x和y。就可以用<code>List&lt;Pair&lt;String, Double&gt;&gt;</code> 表示。<br>⚠️但是Pair不能被json解析。</p>
<h3 id="几种排序算法"><a href="#几种排序算法" class="headerlink" title="几种排序算法"></a>几种排序算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-交换排序</span><br><span class="line"> -冒泡排序</span><br><span class="line"> -快速排序</span><br><span class="line">-插入排序</span><br><span class="line"> -直接插入排序</span><br><span class="line"> -希尔排序</span><br><span class="line">-选择排序</span><br><span class="line"> -简单选择排序</span><br><span class="line"> -堆排序</span><br><span class="line">-归并排序</span><br><span class="line">-基数排序</span><br></pre></td></tr></table></figure>

<h4 id="✅冒泡排序"><a href="#✅冒泡排序" class="headerlink" title="✅冒泡排序"></a>✅冒泡排序</h4><p>1.从第一个元素开始，比较相邻的两个元素。如果第一个比第二个大，则进行交换,此时最后的元素应是最大的数。<br>2.对剩余元素重复以上步骤，直到没有任何一对元素需要比较为止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSortOpt(int[] arr) &#123;</span><br><span class="line">    if(arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr.length &lt; 2) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序优化：<br>假如待排序数组是 2、1、3、4、5 这样的情况，按照上述代码实现，第一次循环即可得出正确结果。但循环并不会停止，而是继续执行，直到结束为止。显然，之后的循环遍历是没有必要的。</p>
<p>为了解决这个问题，我们可以设置一个标志位，用来表示当前次循环是否有交换，如果没有，则说明当前数组已经完全排序，直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static int bubbleSortOpt2(int[] arr) &#123;</span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (flag == 1) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序再优化：<br>比如 3、4、2、1、6、7、8 这个数组，第一次循环后，变为 3、2、1、4、6、7、8 的顺序，我们发现，1 之后的 4 、6、7、8 已经有序了，第二次循环就没必要对后面这段再遍历比较。<br>记录最后发生交换的地点，就是我们要找的分界点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static int bubbleSortOpt3(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    if (arr == null) &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125; else if (arr.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int len = arr.length - 1;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        // 记录最后一次交换位置</span><br><span class="line">        int lastChange = 0;</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                // 每交换一次更新一次</span><br><span class="line">                lastChange = j;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有发生交换，排序已经完成</span><br><span class="line">        if (lastChange == 0) &#123;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">        len = lastChange;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅快速排序"><a href="#✅快速排序" class="headerlink" title="✅快速排序"></a>✅快速排序</h4><p>快速排序的思想很简单，先找一个基准数，先把待排序的数组根据基准数拆成左右两个区间，左边都比中间的基准数小，右边都比基准数大。接着左右两边各自再做同样的操作，完成后再拆分再继续，一直到各区间只有一个数为止。<br>算法的实现需要用到递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line"></span><br><span class="line">    if(start &lt; end) &#123;</span><br><span class="line">        // 把数组中的首位数字作为基准数</span><br><span class="line">        int pivot = arr[start];</span><br><span class="line">        // 记录需要排序的下标</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end;</span><br><span class="line">        // 循环找到比基准数大的数和比基准数小的数</span><br><span class="line">        while(low &lt; high) &#123;</span><br><span class="line">            // 右边的数字比基准数大</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用右边的数替换左边的数</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            // 左边的数字比基准数小</span><br><span class="line">            while(low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用左边的数替换右边的数</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把标准值赋给下标重合的位置</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        // 处理所有小的数字</span><br><span class="line">        quickSort(arr, start, low);</span><br><span class="line">        // 处理所有大的数字</span><br><span class="line">        quickSort(arr, low + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Java 实现的八种常用排序算法:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_handsome/article/details/109055036">https://blog.csdn.net/CSDN_handsome/article/details/109055036</a></p>
<p>想实现一个根据对象某属性首尾相接的排序，用Comparator自定义排序没行得通，所以：先弄一个end的Set，然后便利start，找到第一个对象，然后造一个start-对象的Map，然后用end找对象，一个一个找到。</p>
<h3 id="java链式编程"><a href="#java链式编程" class="headerlink" title="java链式编程"></a>java链式编程</h3><p>链式编程的原理是返回一个this对象，也就是返回对象本身，从而达到链式效果。</p>
<p>链式编程，中间操作的返回值都是自己，每个操作的输出是体现在自己对象的改变中的，类似于<code>Stream&lt;T&gt;</code></p>
<p>链式编程的案例：</p>
<p>1、StringBuilder 和 StringBuffer中的append()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder buffer = new StringBuilder();</span><br><span class="line">buffer.append(&quot;你&quot;).append(&quot;好&quot;).append(&quot;!&quot;);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">@Override</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、String 进行字符串操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String string = String.valueOf(&quot;123&quot;).concat(&quot;,4567890&quot;).replace(&#x27;,&#x27;, &#x27;!&#x27;).substring(2, 8);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">返回的是对象本身，所以可以使用链式编程</span><br><span class="line">public static String valueOf(Object obj) &#123;</span><br><span class="line">    return (obj == null) ? &quot;null&quot; : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String concat(String str) &#123;</span><br><span class="line">     // 省略...</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、 Stream 流式计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    // 相同元素去重</span><br><span class="line">    .distinct()</span><br><span class="line">    // 升序排序</span><br><span class="line">    .sorted((c1, c2) -&gt; c1.compareTo(c2))</span><br><span class="line">    // 遍历</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">方法返回的是对象本身，所以可以使用链式编程</span><br><span class="line">Stream&lt;T&gt; distinct();</span><br><span class="line">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span><br></pre></td></tr></table></figure>

<p>自己做一个链式编程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.setAge(10).setName(&quot;11&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ToString</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Integer age;</span><br><span class="line"></span><br><span class="line">        public Person setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        public Person setAge(Integer age) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="java数组、字符串、list的最大长度"><a href="#java数组、字符串、list的最大长度" class="headerlink" title="java数组、字符串、list的最大长度"></a>java数组、字符串、list的最大长度</h3><p>✅数组的最大长度：<br>数组的length属性是int类型，占4个字节，最大值为Integer.MAX_VALUE= 2^31-1【21亿多】<br>注意：这是理论上的最大长度，堆内存不一定能开辟那么大的存储空间来存储该数组。</p>
<p>✅字符串的最大长度：<br>运行时：<br>String、StringBuilder、StringBuffer底层都是基于字符数组char[ ]的，该数组的最大长度也为Integer.MAX_VALUE，所以一个字符串最大21亿多个字符【每个字符在java8中占1个字节】，即占2^32-2个字节，即差2个字节达到4GB。<br>2^10字节=1KB，2^20=1MB，2^30=1GB</p>
<p>编译时：<br>java源码通过javac编译后生成的字节码文件中，静态常量池中字符串常量的长度最多为65535，因为JVM为了解决历史上的一个BUG，所以强制要求编译时字符串的最大长度为65534。</p>
<p>✅ArrayList和LinkedList的最大长度<br>ArrayList底层是数组，最大值为Integer.MAX_VALUE= 231-1【21亿多】<br>LinkedList底层是链表，理论是无上限长度。</p>
<h3 id="Java元组Tuple"><a href="#Java元组Tuple" class="headerlink" title="Java元组Tuple"></a>Java元组Tuple</h3><p>Java中的Tuple是一种数据结构，可存放多个元素，每个元素的数据类型可不同。Tuple与List集合类似，但是不同的是，List集合只能存储一种数据类型，而Tuple可存储多种数据类型。<br>可能你会说，Object类型的List实际也是可以存储多种类型的啊？但是在创建List的时候，需要指定元素数据类型，也就是只能指定为Object类型，获取的元素类型就是Object，如有需要则要进行强转。而Tuple在创建的时候，则可以直接指定多个元素数据类型。</p>
<p>元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。关系数据库中的 一条记录就是一个元组， 一个表就是一个关系， 纪录组成表， 元组生成关系， 这就是关系数据库的核心理念。</p>
<p>元组的使用就是通过泛型定义一个类，然后去保存多个类型属性。所以可以认为元组完全是基于泛型的。返回的所有类型属性外包一层对象然后返回这个对象，其实就是作为元组的实现定义。</p>
<p>元组不同于List，List存储相同的数据类型，虽然也可以存储不同的数据类型，那就不符合泛型了。</p>
<p>元组不同于数组，数组种存储的相同的数据类型。</p>
<p>元组不同于map，map类型是键值对存在的，而元组中的值，值之间没有关系。</p>
<p>元组的值可以是不同数据类型，值与值之间没有关系。</p>
<p>理解：元祖相当于定义一个VO，里面有不同的属性类型，可以包装不同类型。和list区别是，十元祖就可以放10个不同类型的数据。元祖的优点其实还是可以防止代码的冗余，不用写更多的方法，可以通过一个返回多个我想要的类型属性。上面的Pair就是实现这么一个功能，也是元祖。</p>
<hr>
<p>依赖Jar包：javatuples</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javatuples&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javatuples&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>jar包中的结构很简单，其中的类主要是tuple基础类、扩展的一元组、二元组…十元组，以及键值对元组；接口的作用是提供【获取创建各元组时传入参数值】的方法。</p>
<p>其中三元祖的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package org.javatuples;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">import org.javatuples.valueintf.IValue0;</span><br><span class="line">import org.javatuples.valueintf.IValue1;</span><br><span class="line">import org.javatuples.valueintf.IValue2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A tuple of three elements.</span><br><span class="line"> * &lt;/p&gt; </span><br><span class="line"> * </span><br><span class="line"> * @since 1.0</span><br><span class="line"> * </span><br><span class="line"> * @author Daniel Fern&amp;aacute;ndez</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public final class Triplet&lt;A,B,C&gt; </span><br><span class="line">        extends Tuple</span><br><span class="line">        implements IValue0&lt;A&gt;,</span><br><span class="line">                    IValue1&lt;B&gt;,</span><br><span class="line">                    IValue2&lt;C&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -1877265551599483740L;</span><br><span class="line"></span><br><span class="line">    private static final int SIZE = 3;</span><br><span class="line"></span><br><span class="line">    private final A val0;</span><br><span class="line">    private final B val1;</span><br><span class="line">    private final C val2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;A,B,C&gt; Triplet&lt;A,B,C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return new Triplet&lt;A,B,C&gt;(value0,value1,value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般调用静态方法with，传入元组数据，创建一个元组。可以自定义一个工具类，提供公共方法，根据传入的参数个数，返回不同的元组对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.liuxuan.study;</span><br><span class="line"></span><br><span class="line">import com.liuxuan.repository.domain.Student;</span><br><span class="line">import org.javatuples.Pair;</span><br><span class="line">import org.javatuples.Triplet;</span><br><span class="line">import org.javatuples.Unit;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: liuxuan</span><br><span class="line"> * @date: 2023-02-06 22:32</span><br><span class="line"> **/</span><br><span class="line">public class TupleUtils&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 单元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A&gt; Unit&lt;A&gt; with(final A value0) &#123;</span><br><span class="line">        return Unit.with(value0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 双元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B&gt; Pair&lt;A, B&gt; with(final A value0, final B value1) &#123;</span><br><span class="line">        return Pair.with(value0, value1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 三元素元祖</span><br><span class="line">     */</span><br><span class="line">    public static &lt;A, B, C&gt; Triplet&lt;A, B, C&gt; with(final A value0, final B value1, final C value2) &#123;</span><br><span class="line">        return Triplet.with(value0, value1, value2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Triplet&lt;Integer, String, String&gt;&gt; roleList = new ArrayList&lt;Triplet&lt;Integer, String, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        Triplet&lt;Integer, String, String&gt; studentTriplet = TupleUtils.with(11, &quot;sid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; teacherTriplet = TupleUtils.with(22, &quot;tid&quot;, &quot;graduate&quot;);</span><br><span class="line">        Triplet&lt;Integer, String, String&gt; programmerTriplet = TupleUtils.with(33, &quot;id&quot;, &quot;graduate&quot;);</span><br><span class="line"></span><br><span class="line">        roleList.add(studentTriplet);</span><br><span class="line">        roleList.add(teacherTriplet);</span><br><span class="line">        roleList.add(programmerTriplet);</span><br><span class="line"></span><br><span class="line">        for (Triplet&lt;Integer, String, String&gt; triplet : roleList) &#123;</span><br><span class="line">            System.out.println(triplet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TupleUtils中提供了with的重载方法，调用时根据传入的参数值个数，返回对应的元组对象。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35006663/article/details/100301416">https://blog.csdn.net/qq_35006663/article/details/100301416</a></p>
<hr>
<p>org.apache.commons.lang3.tuple 中的元祖</p>
<p>用于处理一对键值的对象pair类似于Map.entry，commons lang3增加了可以处理3个值的Triple基类，此包下定义了<code>Pair&lt;L,R&gt;</code>抽象基类，及MutablePair,MutableTriple,ImmutablePair,ImmutableTriple子类。一个线程非安全，另一个线程安全。</p>
<p>接口：<br>1.<code>Pair</code>：封装一对键值对。<br>实现类：可变：<code>MutablePair&lt;L,R&gt;</code>，不可变：<code>ImmutablePair</code><br>2.<code>Triple</code>：封装3个值的类<br>实现类：<code>ImmutableTriple</code>; <code>MuttableTriple&lt;L,M,R&gt;</code></p>
<h3 id="Preconditions-checkArgument校验字段"><a href="#Preconditions-checkArgument校验字段" class="headerlink" title="Preconditions.checkArgument校验字段"></a>Preconditions.checkArgument校验字段</h3><p>guava中的静态方法，用来确认参数是不是符合要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;31.0.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String param = &quot;&quot;;</span><br><span class="line">//旧式写法</span><br><span class="line">if (StringUtils.isEmpty(param)) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;param字段不能为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//新式写法：期望这个字段不能为空</span><br><span class="line">Preconditions.checkArgument(StringUtils.isNotEmpty(param), &quot;param字段不能为空&quot;);</span><br></pre></td></tr></table></figure>

<p>新式的校验是：要求我们对某个字段的要求是什么，当逻辑未命中要求时，则抛出异常。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>drainTo()方法：<br>ArrayBlockingQueue是有界的阻塞队列，该队列内部使用数组支持的元素存储。<br>drainTo()方法用于将所有元素传输到集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 10;</span><br><span class="line">ArrayBlockingQueue queue = new ArrayBlockingQueue(capacity);</span><br><span class="line">queue.add(11);</span><br><span class="line">queue.add(22);</span><br><span class="line">queue.add(33);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[11, 22, 33]</span><br><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">queue.drainTo(list);</span><br><span class="line">System.out.println(&quot;queue = &quot; + queue); //[]</span><br><span class="line">System.out.println(&quot;collection = &quot; + list); //[11, 22, 33]</span><br></pre></td></tr></table></figure>

<h3 id="java获取本地ip"><a href="#java获取本地ip" class="headerlink" title="java获取本地ip"></a>java获取本地ip</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String localIP = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">System.out.println(localIP);</span><br></pre></td></tr></table></figure>

<h3 id="guava中的ImmutableList"><a href="#guava中的ImmutableList" class="headerlink" title="guava中的ImmutableList"></a>guava中的ImmutableList</h3><p>ImmutableList是一个不可变、线程安全的列表集合，它只会获取传入对象的一个副本，而不会影响到原来的变量或者对象。</p>
<p>ImmutableList创建不可变对象有两种方法，一种是使用静态of方法，另外一种是使用静态内部类Builder。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">静态内部类构建方法 :</span><br><span class="line">ImmutableList&lt;Integer&gt; list = ImmutableList .&lt;Integer&gt;builder()</span><br><span class="line">                        .add(12)</span><br><span class="line">                        .add(23)</span><br><span class="line">                        .add(34)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">静态方法提供了多个参数的of静态方法:</span><br><span class="line">ImmutableList&lt;String&gt; list3 = ImmutableList .&lt;String&gt;of(&quot;12&quot;,&quot;23&quot;);</span><br><span class="line"></span><br><span class="line">复制数组中的元素到ImmutableList中:</span><br><span class="line"> List&lt;String&gt; list4 = new ArrayList&lt;String&gt;();</span><br><span class="line">list4.add(&quot;1&quot;);</span><br><span class="line">list4.add(&quot;2&quot;);</span><br><span class="line">list4.add(&quot;3&quot;);</span><br><span class="line">//copy数组list4的一个副本</span><br><span class="line">List&lt;String&gt; list5 = ImmutableList .&lt;String&gt;copyOf(list4);</span><br></pre></td></tr></table></figure>

<h3 id="System-getProperty"><a href="#System-getProperty" class="headerlink" title="System.getProperty()"></a>System.getProperty()</h3><p>获取系统属性，即在java虚拟机启动时定义的环境变量的值，第一个参数是属性名称，第二个参数是属性的默认值。</p>
<p><code>String s = System.getProperty(&quot;line.separator&quot;)</code> 获取系统空格。</p>
<p>System.getProperty() 是获取系统的相关属性，包括文件编码、操作系统名称、区域、用户名等，此属性一般是由 JVM 自动获取，不能设置。这个必须接收一个 String 类型的参数，并且返回一个 String 类型的值。如果想要获取所有的系统的相关属性值可以使用 System.getProperties() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">java.runtime.name-------Java(TM) SE Runtime Environment</span><br><span class="line">sun.boot.library.path-------C:\Program Files\Java\jdk1.8.0_60\jre\bin</span><br><span class="line">java.vm.version-------25.60-b23</span><br><span class="line">java.vm.vendor-------Oracle Corporation</span><br><span class="line">java.vendor.url-------http://java.oracle.com/</span><br><span class="line">path.separator-------;</span><br><span class="line">java.vm.name-------Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">file.encoding.pkg-------sun.io</span><br><span class="line">user.country-------CN</span><br><span class="line">user.script-------</span><br><span class="line">sun.java.launcher-------SUN_STANDARD</span><br><span class="line">sun.os.patch.level-------</span><br><span class="line">java.vm.specification.name-------Java Virtual Machine Specification</span><br><span class="line">user.dir-------F:\siwei\dayunmotor-tbox\dayunmotor-forward-hbase</span><br><span class="line">java.runtime.version-------1.8.0_60-b27</span><br><span class="line">java.awt.graphicsenv-------sun.awt.Win32GraphicsEnvironment</span><br><span class="line">java.endorsed.dirs-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\endorsed</span><br><span class="line">os.arch-------amd64</span><br><span class="line">java.io.tmpdir-------C:\Users\yesway\AppData\Local\Temp\</span><br><span class="line">line.separator-------</span><br><span class="line"></span><br><span class="line">java.vm.specification.vendor-------Oracle Corporation</span><br><span class="line">user.variant-------</span><br><span class="line">os.name-------Windows 10</span><br><span class="line">sun.jnu.encoding-------GBK</span><br><span class="line">java.library.path-------C:\Program Files\Java\jdk1.8.0_60\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\ProgramData\Oracle\Java\javapath;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;D:\Program Files\Git\cmd;C:\Users\yesway\AppData\Local\Microsoft\WindowsApps;;.</span><br><span class="line">java.specification.name-------Java Platform API Specification</span><br><span class="line">java.class.version-------52.0</span><br><span class="line">sun.management.compiler-------HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version-------10.0</span><br><span class="line">user.home-------C:\Users\yesway</span><br><span class="line">user.timezone-------</span><br><span class="line">java.awt.printerjob-------sun.awt.windows.WPrinterJob</span><br><span class="line">file.encoding-------UTF-8</span><br><span class="line">java.specification.version-------1.8</span><br><span class="line">java.class.path-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\rt.jar;F:\siwei\dayunmotor-tbox\dayunmotor-forward-hbase\target\classes;D:\dayunMaven\org\springframework\boot\spring-boot-starter\2.4.0\spring-boot-starter-2.4.0.jar;D:\dayunMaven\org\springframework\boot\spring-boot\2.4.0\spring-boot-2.4.0.jar;D:\dayunMaven\org\springframework\spring-context\5.3.1\spring-context-5.3.1.jar;D:\dayunMaven\org\springframework\boot\spring-boot-autoconfigure\2.4.0\spring-boot-autoconfigure-2.4.0.jar;D:\dayunMaven\jakarta\annotation\jakarta.annotation-api\1.3.5\jakarta.annotation-api-1.3.5.jar;D:\dayunMaven\org\springframework\spring-core\5.3.1\spring-core-5.3.1.jar;D:\dayunMaven\org\springframework\spring-jcl\5.3.1\spring-jcl-5.3.1.jar;D:\dayunMaven\org\yaml\snakeyaml\1.27\snakeyaml-1.27.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-aop\2.4.0\spring-boot-starter-aop-2.4.0.jar;D:\dayunMaven\org\springframework\spring-aop\5.3.1\spring-aop-5.3.1.jar;D:\dayunMaven\org\springframework\spring-beans\5.3.1\spring-beans-5.3.1.jar;D:\dayunMaven\org\aspectj\aspectjweaver\1.9.6\aspectjweaver-1.9.6.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-amqp\2.4.0\spring-boot-starter-amqp-2.4.0.jar;D:\dayunMaven\org\springframework\spring-messaging\5.3.1\spring-messaging-5.3.1.jar;D:\dayunMaven\org\springframework\amqp\spring-rabbit\2.3.1\spring-rabbit-2.3.1.jar;D:\dayunMaven\org\springframework\amqp\spring-amqp\2.3.1\spring-amqp-2.3.1.jar;D:\dayunMaven\org\springframework\retry\spring-retry\1.3.0\spring-retry-1.3.0.jar;D:\dayunMaven\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;D:\dayunMaven\com\rabbitmq\amqp-client\5.9.0\amqp-client-5.9.0.jar;D:\dayunMaven\org\springframework\spring-tx\5.3.1\spring-tx-5.3.1.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-log4j2\2.4.0\spring-boot-starter-log4j2-2.4.0.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-slf4j-impl\2.13.3\log4j-slf4j-impl-2.13.3.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-jul\2.13.3\log4j-jul-2.13.3.jar;D:\dayunMaven\org\slf4j\jul-to-slf4j\1.7.30\jul-to-slf4j-1.7.30.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-web\2.4.0\spring-boot-starter-web-2.4.0.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-json\2.4.0\spring-boot-starter-json-2.4.0.jar;D:\dayunMaven\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.11.3\jackson-datatype-jdk8-2.11.3.jar;D:\dayunMaven\com\fasterxml\jackson\module\jackson-module-parameter-names\2.11.3\jackson-module-parameter-names-2.11.3.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-tomcat\2.4.0\spring-boot-starter-tomcat-2.4.0.jar;D:\dayunMaven\org\apache\tomcat\embed\tomcat-embed-core\9.0.39\tomcat-embed-core-9.0.39.jar;D:\dayunMaven\org\glassfish\jakarta.el\3.0.3\jakarta.el-3.0.3.jar;D:\dayunMaven\org\apache\tomcat\embed\tomcat-embed-websocket\9.0.39\tomcat-embed-websocket-9.0.39.jar;D:\dayunMaven\org\springframework\spring-web\5.3.1\spring-web-5.3.1.jar;D:\dayunMaven\org\springframework\spring-webmvc\5.3.1\spring-webmvc-5.3.1.jar;D:\dayunMaven\org\springframework\spring-expression\5.3.1\spring-expression-5.3.1.jar;D:\dayunMaven\net\minidev\json-smart\2.3\json-smart-2.3.jar;D:\dayunMaven\net\minidev\accessors-smart\1.2\accessors-smart-1.2.jar;D:\dayunMaven\org\ow2\asm\asm\5.0.4\asm-5.0.4.jar;D:\dayunMaven\org\springframework\boot\spring-boot-starter-data-redis\2.4.0\spring-boot-starter-data-redis-2.4.0.jar;D:\dayunMaven\org\springframework\data\spring-data-redis\2.4.1\spring-data-redis-2.4.1.jar;D:\dayunMaven\org\springframework\data\spring-data-keyvalue\2.4.1\spring-data-keyvalue-2.4.1.jar;D:\dayunMaven\org\springframework\data\spring-data-commons\2.4.1\spring-data-commons-2.4.1.jar;D:\dayunMaven\org\springframework\spring-oxm\5.3.1\spring-oxm-5.3.1.jar;D:\dayunMaven\org\springframework\spring-context-support\5.3.1\spring-context-support-5.3.1.jar;D:\dayunMaven\io\lettuce\lettuce-core\6.0.1.RELEASE\lettuce-core-6.0.1.RELEASE.jar;D:\dayunMaven\io\netty\netty-common\4.1.53.Final\netty-common-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-handler\4.1.53.Final\netty-handler-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-resolver\4.1.53.Final\netty-resolver-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-buffer\4.1.53.Final\netty-buffer-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-codec\4.1.53.Final\netty-codec-4.1.53.Final.jar;D:\dayunMaven\io\netty\netty-transport\4.1.53.Final\netty-transport-4.1.53.Final.jar;D:\dayunMaven\io\projectreactor\reactor-core\3.3.11.RELEASE\reactor-core-3.3.11.RELEASE.jar;D:\dayunMaven\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;D:\dayunMaven\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;D:\dayunMaven\org\apache\commons\commons-pool2\2.8.0\commons-pool2-2.8.0.jar;D:\dayunMaven\org\projectlombok\lombok\1.18.8\lombok-1.18.8.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-core\2.11.2\log4j-core-2.11.2.jar;D:\dayunMaven\org\apache\logging\log4j\log4j-api\2.11.2\log4j-api-2.11.2.jar;D:\dayunMaven\org\slf4j\slf4j-api\1.7.5\slf4j-api-1.7.5.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-annotations\2.9.0\jackson-annotations-2.9.0.jar;D:\dayunMaven\com\alibaba\fastjson\1.2.47\fastjson-1.2.47.jar;D:\dayunMaven\org\apache\hadoop\hadoop-client\3.0.0\hadoop-client-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-hdfs-client\3.0.0\hadoop-hdfs-client-3.0.0.jar;D:\dayunMaven\com\squareup\okhttp\okhttp\2.4.0\okhttp-2.4.0.jar;D:\dayunMaven\com\squareup\okio\okio\1.4.0\okio-1.4.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-api\3.0.0\hadoop-yarn-api-3.0.0.jar;D:\dayunMaven\javax\xml\bind\jaxb-api\2.2.11\jaxb-api-2.2.11.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-client\3.0.0\hadoop-yarn-client-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-core\3.0.0\hadoop-mapreduce-client-core-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-yarn-common\3.0.0\hadoop-yarn-common-3.0.0.jar;D:\dayunMaven\org\eclipse\jetty\jetty-util\9.3.19.v20170502\jetty-util-9.3.19.v20170502.jar;D:\dayunMaven\com\sun\jersey\jersey-client\1.19\jersey-client-1.19.jar;D:\dayunMaven\com\fasterxml\jackson\module\jackson-module-jaxb-annotations\2.7.8\jackson-module-jaxb-annotations-2.7.8.jar;D:\dayunMaven\com\fasterxml\jackson\jaxrs\jackson-jaxrs-json-provider\2.7.8\jackson-jaxrs-json-provider-2.7.8.jar;D:\dayunMaven\com\fasterxml\jackson\jaxrs\jackson-jaxrs-base\2.7.8\jackson-jaxrs-base-2.7.8.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-jobclient\3.0.0\hadoop-mapreduce-client-jobclient-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-mapreduce-client-common\3.0.0\hadoop-mapreduce-client-common-3.0.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-annotations\3.0.0\hadoop-annotations-3.0.0.jar;D:\dayunMaven\org\apache\hbase\hbase-shaded-client\2.1.0\hbase-shaded-client-2.1.0.jar;D:\dayunMaven\com\github\stephenc\findbugs\findbugs-annotations\1.3.9-1\findbugs-annotations-1.3.9-1.jar;D:\dayunMaven\org\apache\htrace\htrace-core4\4.2.0-incubating\htrace-core4-4.2.0-incubating.jar;D:\dayunMaven\commons-logging\commons-logging\1.2\commons-logging-1.2.jar;D:\dayunMaven\org\apache\htrace\htrace-core\3.1.0-incubating\htrace-core-3.1.0-incubating.jar;D:\dayunMaven\log4j\log4j\1.2.17\log4j-1.2.17.jar;D:\dayunMaven\org\apache\yetus\audience-annotations\0.5.0\audience-annotations-0.5.0.jar;D:\dayunMaven\junit\junit\4.12\junit-4.12.jar;D:\dayunMaven\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;D:\dayunMaven\org\apache\hadoop\hadoop-common\3.0.0\hadoop-common-3.0.0.jar;D:\dayunMaven\com\google\guava\guava\11.0.2\guava-11.0.2.jar;D:\dayunMaven\commons-cli\commons-cli\1.2\commons-cli-1.2.jar;D:\dayunMaven\org\apache\commons\commons-math3\3.1.1\commons-math3-3.1.1.jar;D:\dayunMaven\org\apache\httpcomponents\httpclient\4.5.2\httpclient-4.5.2.jar;D:\dayunMaven\org\apache\httpcomponents\httpcore\4.4.4\httpcore-4.4.4.jar;D:\dayunMaven\commons-codec\commons-codec\1.4\commons-codec-1.4.jar;D:\dayunMaven\commons-io\commons-io\2.4\commons-io-2.4.jar;D:\dayunMaven\commons-net\commons-net\3.1\commons-net-3.1.jar;D:\dayunMaven\commons-collections\commons-collections\3.2.2\commons-collections-3.2.2.jar;D:\dayunMaven\javax\servlet\javax.servlet-api\3.1.0\javax.servlet-api-3.1.0.jar;D:\dayunMaven\javax\servlet\jsp\jsp-api\2.1\jsp-api-2.1.jar;D:\dayunMaven\com\sun\jersey\jersey-core\1.19\jersey-core-1.19.jar;D:\dayunMaven\javax\ws\rs\jsr311-api\1.1.1\jsr311-api-1.1.1.jar;D:\dayunMaven\com\sun\jersey\jersey-servlet\1.19\jersey-servlet-1.19.jar;D:\dayunMaven\com\sun\jersey\jersey-json\1.19\jersey-json-1.19.jar;D:\dayunMaven\org\codehaus\jettison\jettison\1.1\jettison-1.1.jar;D:\dayunMaven\com\sun\xml\bind\jaxb-impl\2.2.3-1\jaxb-impl-2.2.3-1.jar;D:\dayunMaven\org\codehaus\jackson\jackson-core-asl\1.9.2\jackson-core-asl-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-mapper-asl\1.9.2\jackson-mapper-asl-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-jaxrs\1.9.2\jackson-jaxrs-1.9.2.jar;D:\dayunMaven\org\codehaus\jackson\jackson-xc\1.9.2\jackson-xc-1.9.2.jar;D:\dayunMaven\com\sun\jersey\jersey-server\1.19\jersey-server-1.19.jar;D:\dayunMaven\commons-beanutils\commons-beanutils\1.9.3\commons-beanutils-1.9.3.jar;D:\dayunMaven\org\apache\commons\commons-configuration2\2.1.1\commons-configuration2-2.1.1.jar;D:\dayunMaven\org\apache\commons\commons-lang3\3.4\commons-lang3-3.4.jar;D:\dayunMaven\org\slf4j\slf4j-log4j12\1.7.25\slf4j-log4j12-1.7.25.jar;D:\dayunMaven\org\apache\avro\avro\1.7.7\avro-1.7.7.jar;D:\dayunMaven\com\thoughtworks\paranamer\paranamer\2.3\paranamer-2.3.jar;D:\dayunMaven\org\xerial\snappy\snappy-java\1.0.5\snappy-java-1.0.5.jar;D:\dayunMaven\com\google\re2j\re2j\1.1\re2j-1.1.jar;D:\dayunMaven\com\google\protobuf\protobuf-java\2.5.0\protobuf-java-2.5.0.jar;D:\dayunMaven\org\apache\hadoop\hadoop-auth\3.0.0\hadoop-auth-3.0.0.jar;D:\dayunMaven\com\nimbusds\nimbus-jose-jwt\4.41.1\nimbus-jose-jwt-4.41.1.jar;D:\dayunMaven\com\github\stephenc\jcip\jcip-annotations\1.0-1\jcip-annotations-1.0-1.jar;D:\dayunMaven\org\apache\curator\curator-framework\2.12.0\curator-framework-2.12.0.jar;D:\dayunMaven\com\jcraft\jsch\0.1.54\jsch-0.1.54.jar;D:\dayunMaven\org\apache\curator\curator-client\2.12.0\curator-client-2.12.0.jar;D:\dayunMaven\org\apache\curator\curator-recipes\2.12.0\curator-recipes-2.12.0.jar;D:\dayunMaven\com\google\code\findbugs\jsr305\3.0.0\jsr305-3.0.0.jar;D:\dayunMaven\org\apache\zookeeper\zookeeper\3.4.9\zookeeper-3.4.9.jar;D:\dayunMaven\jline\jline\0.9.94\jline-0.9.94.jar;D:\dayunMaven\io\netty\netty\3.10.5.Final\netty-3.10.5.Final.jar;D:\dayunMaven\org\apache\commons\commons-compress\1.4.1\commons-compress-1.4.1.jar;D:\dayunMaven\org\tukaani\xz\1.0\xz-1.0.jar;D:\dayunMaven\org\apache\kerby\kerb-simplekdc\1.0.1\kerb-simplekdc-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-client\1.0.1\kerb-client-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-config\1.0.1\kerby-config-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-core\1.0.1\kerb-core-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-pkix\1.0.1\kerby-pkix-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-asn1\1.0.1\kerby-asn1-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-util\1.0.1\kerby-util-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-common\1.0.1\kerb-common-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-crypto\1.0.1\kerb-crypto-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-util\1.0.1\kerb-util-1.0.1.jar;D:\dayunMaven\org\apache\kerby\token-provider\1.0.1\token-provider-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-admin\1.0.1\kerb-admin-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-server\1.0.1\kerb-server-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerb-identity\1.0.1\kerb-identity-1.0.1.jar;D:\dayunMaven\org\apache\kerby\kerby-xdr\1.0.1\kerby-xdr-1.0.1.jar;D:\dayunMaven\org\codehaus\woodstox\stax2-api\3.1.4\stax2-api-3.1.4.jar;D:\dayunMaven\com\fasterxml\woodstox\woodstox-core\5.0.3\woodstox-core-5.0.3.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-databind\2.9.6\jackson-databind-2.9.6.jar;D:\dayunMaven\com\fasterxml\jackson\core\jackson-core\2.9.6\jackson-core-2.9.6.jar;D:\dayunMaven\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.9.6\jackson-datatype-jsr310-2.9.6.jar;D:\dayunMaven\com\google\code\gson\gson\2.6.2\gson-2.6.2.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.4\lib\idea_rt.jar</span><br><span class="line">user.name-------yesway</span><br><span class="line">java.vm.specification.version-------1.8</span><br><span class="line">sun.java.command-------com.dayunmotor.forward.hbase.ForwardHbaseApplication</span><br><span class="line">java.home-------C:\Program Files\Java\jdk1.8.0_60\jre</span><br><span class="line">sun.arch.data.model-------64</span><br><span class="line">user.language-------zh</span><br><span class="line">java.specification.vendor-------Oracle Corporation</span><br><span class="line">awt.toolkit-------sun.awt.windows.WToolkit</span><br><span class="line">java.vm.info-------mixed mode</span><br><span class="line">java.version-------1.8.0_60</span><br><span class="line">java.ext.dirs-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">sun.boot.class.path-------C:\Program Files\Java\jdk1.8.0_60\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_60\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_60\jre\classes</span><br><span class="line">java.vendor-------Oracle Corporation</span><br><span class="line">file.separator-------\</span><br><span class="line">java.vendor.url.bug-------http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding-------UnicodeLittle</span><br><span class="line">sun.cpu.endian-------little</span><br><span class="line">sun.desktop-------windows</span><br><span class="line">sun.cpu.isalist-------amd64</span><br></pre></td></tr></table></figure>


<h3 id="用反射获取Java对象中所有的属性名称和属性值"><a href="#用反射获取Java对象中所有的属性名称和属性值" class="headerlink" title="用反射获取Java对象中所有的属性名称和属性值"></a>用反射获取Java对象中所有的属性名称和属性值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException &#123;</span><br><span class="line">        Person person = new Person(&quot;zhangsan&quot;, 30, &quot;男&quot;);</span><br><span class="line">        StringBuilder sbName = new StringBuilder();</span><br><span class="line">        StringBuilder sbValue = new StringBuilder();</span><br><span class="line">        String[] fieldNames = getFiledName(person);</span><br><span class="line"></span><br><span class="line">        for(int j=0 ; j&lt;fieldNames.length ; j++)&#123; //遍历所有属性</span><br><span class="line">            String name = fieldNames[j]; //获取属性的名字</span><br><span class="line">            Object value = getFieldValueByName(name, person);</span><br><span class="line">            sbName.append(name);</span><br><span class="line">            sbValue.append(value);</span><br><span class="line">            if(j != fieldNames.length - 1) &#123;</span><br><span class="line">                sbName.append(&quot;/&quot;);</span><br><span class="line">                sbValue.append(&quot;/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;attribute name:&quot;+sbName.toString());</span><br><span class="line">        System.out.println(&quot;attribute value:&quot;+sbValue.toString());</span><br><span class="line">        // 根据Method获取类名</span><br><span class="line">        Method method = person.getClass().getMethod(&quot;printName&quot;, new Class[] &#123;&#125;);</span><br><span class="line">        String className = method.getDeclaringClass().getName(); //类名</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        System.out.println(&quot;full name:&quot; + className + &quot;.&quot; + methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取属性名数组</span><br><span class="line">     * */</span><br><span class="line">    private static String[] getFiledName(Object o)&#123;</span><br><span class="line">        Field[] fields=o.getClass().getDeclaredFields();</span><br><span class="line">        String[] fieldNames=new String[fields.length];</span><br><span class="line">        for(int i=0;i&lt;fields.length;i++)&#123;</span><br><span class="line">            // System.out.println(fields[i].getType());</span><br><span class="line">            fieldNames[i]=fields[i].getName();</span><br><span class="line">        &#125;</span><br><span class="line">        return fieldNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据属性名获取属性值</span><br><span class="line">     **/</span><br><span class="line">    private static Object getFieldValueByName(String fieldName, Object o) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String firstLetter = fieldName.substring(0, 1).toUpperCase();</span><br><span class="line">            String getter = &quot;get&quot; + firstLetter + fieldName.substring(1);</span><br><span class="line">            Method method = o.getClass().getMethod(getter, new Class[] &#123;&#125;);</span><br><span class="line">            Object value = method.invoke(o, new Object[] &#123;&#125;);</span><br><span class="line">            return value;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">        private String gender;</span><br><span class="line"></span><br><span class="line">        public Person(String n,int a,String g) &#123;</span><br><span class="line">            name = n;</span><br><span class="line">            age = a;</span><br><span class="line">            gender = g;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getAge() &#123;</span><br><span class="line">            return age;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getGender() &#123;</span><br><span class="line">            return gender;</span><br><span class="line">        &#125;</span><br><span class="line">        public void printName() &#123;</span><br><span class="line">            System.out.println(&quot;name is &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiadongqing/p/16298207.html">https://www.cnblogs.com/xiadongqing/p/16298207.html</a></p>
<p>关于反射的概念：<br>Java中的反射是通过反射API来实现的。Java反射API主要包括以下几个重要的类和接口：<br>1、Class 类：表示一个类或接口，在运行时JVM中每个类都有一个对应的Class对象。<br>2、Constructor类：表示一个类的构造方法。<br>3、Method 类：表示一个类的方法。<br>4、Field 类：表示一个类的成员变量（字段）。</p>
<p>反射实现的核心是 Class 类，一个类在编译后会生成对应的 class文件，这个文件中包含了类的结构信息，包括字段、方法、构造函数等信息。在运行时，JVM会读取这个 文件并将其加载到内存中。当需要使用一个类时，JVM会通过类的全限定名来找到对应的 class 文件，并将其加载到内存中。在加载后，JVM 会为每个类创建一个对应的 Class对象，该对象包含了类的所有结构信息。</p>
<p>通过 Class 对象可以获取类的所有结构信息，包括构造函数、方法、字段等。可以通过 Constructor、Method 和Field 等类来表示类的构造函数、方法和字段，通过这些类可以获取和调用类的构造函数数、方法和字段。</p>
<p>反射的实现主要依靠JVM 中的类加载机制和 Class对象，通过 class 对象可以获取类的所有结构信息，通过这些信息可以实现对类的动态操作。在运行时，通过反射可以动态地创建对象、调用方法、访问字段等，从而实现了比较灵活的编程方式。</p>
<p>反射是指在程序运行时动态获取对象信息的能力。它可以让程序在运行时通过对象的引用来获取对象的类型信息、属性、方法等，而不需要在编译时进行硬编码。具体实现反射的方式是通过反射APl来获取对象的类信息，包括类名、父类、接口、方法、属性等，然后通过反射API提供的方法来操作这些信息。在Java中，反射API主要包括 Class 类、Constructor类、Field类和Method类等。通过这些类，可以实现动态创建对象、调用方法、获取属性等操作。</p>
<p>反射是一种强大的编程技术，但也需要谨慎使用，因为它会增加代码的复杂度和运行时开销。</p>
<h3 id="java中的StopWatch"><a href="#java中的StopWatch" class="headerlink" title="java中的StopWatch"></a>java中的StopWatch</h3><p>StopWatch不在java标准包中的，可以在以下两个程序包中找到StopWatch工具类</p>
<p>org.apache.commons.lang3.time<br>Apache Commons Lang提供了一些Java标准库中没有提供的类与方法，尤其是在String操作方法，基础数值方法，对象引用，并发行，创建及序列化，系统属性等方面提供了强大的功能</p>
<p>org.springframework.util<br>spring框架为现代java企业级应用提供了一个简洁并且富有表达能力的可以运行在任何部署平台的编程与设置模型</p>
<p>看一下spring中的怎么用，可以优雅地打印出多个任务的详细耗时情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StopWatchTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        StopWatch sw = new StopWatch(&quot;模板测试&quot;);</span><br><span class="line"></span><br><span class="line">        sw.start(&quot;任务1&quot;);</span><br><span class="line">        Thread.sleep(1000 * 1);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        sw.start(&quot;任务2&quot;);</span><br><span class="line">        Thread.sleep(1000 * 2);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        sw.start(&quot;任务3&quot;);</span><br><span class="line">        Thread.sleep(1000 * 3);</span><br><span class="line">        sw.stop();</span><br><span class="line"></span><br><span class="line">        //打印各子任务耗时比例</span><br><span class="line">        System.out.println(sw.prettyPrint());</span><br><span class="line">        System.out.println(&quot;所有任务总耗时：&quot; + sw.getTotalTimeMillis() + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qfzhaohan/article/details/121379893">https://blog.csdn.net/qfzhaohan/article/details/121379893</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jade liu"
      src="/images/head.gif">
  <p class="site-author-name" itemprop="name">Jade liu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jadeliuliu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jadeliuliu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jadeliu1998@163.com" title="E-Mail → mailto:jadeliu1998@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/jadeliu1998" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;jadeliu1998" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5823044646" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5823044646" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jade liu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
